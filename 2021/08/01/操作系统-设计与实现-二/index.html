<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统-设计与实现-二 | H4wk1ns's blog</title><meta name="keywords" content="手写,操作系统"><meta name="author" content="H4wk1ns"><meta name="copyright" content="H4wk1ns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言  这一章没有新的内容，仅仅是实现课程中的L0实验 L0直接运行在硬件上的小游戏实验背景  传统上，操作系统被认为就是”写汇编”、”跟底层打交道”。但实际上，操作系统和硬件之间的关系被夸大了。操作系统实际上不过就是一个直接运行在计算机上的(高级语言)程序而已，只是会在适当的时候调用操作系统提供的机制。  因此，在初始化完成后设置好一个没有标准库的C程序运行环境，其中包含栈区、静态数据、堆区;代">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-设计与实现-二">
<meta property="og:url" content="https://jiaweihawk.github.io/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/index.html">
<meta property="og:site_name" content="H4wk1ns&#39;s blog">
<meta property="og:description" content="前言  这一章没有新的内容，仅仅是实现课程中的L0实验 L0直接运行在硬件上的小游戏实验背景  传统上，操作系统被认为就是”写汇编”、”跟底层打交道”。但实际上，操作系统和硬件之间的关系被夸大了。操作系统实际上不过就是一个直接运行在计算机上的(高级语言)程序而已，只是会在适当的时候调用操作系统提供的机制。  因此，在初始化完成后设置好一个没有标准库的C程序运行环境，其中包含栈区、静态数据、堆区;代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiaweihawk.github.io/img/background.jpg">
<meta property="article:published_time" content="2021-08-01T13:23:36.000Z">
<meta property="article:modified_time" content="2024-10-16T15:08:39.134Z">
<meta property="article:author" content="H4wk1ns">
<meta property="article:tag" content="手写">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiaweihawk.github.io/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jiaweihawk.github.io/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-设计与实现-二',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-16 23:08:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/profile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">H4wk1ns's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-设计与实现-二</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-01T13:23:36.000Z" title="发表于 2021-08-01 21:23:36">2021-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-16T15:08:39.134Z" title="更新于 2024-10-16 23:08:39">2024-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%89%8B%E5%86%99/">手写</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-设计与实现-二"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这一章没有新的内容，仅仅是实现课程中的L0实验</p>
<h1 id="L0直接运行在硬件上的小游戏"><a href="#L0直接运行在硬件上的小游戏" class="headerlink" title="L0直接运行在硬件上的小游戏"></a>L0直接运行在硬件上的小游戏</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  传统上，操作系统被认为就是”写汇编”、”跟底层打交道”。但实际上，操作系统和硬件之间的关系被夸大了。操作系统实际上不过就是一个直接运行在计算机上的(高级语言)程序而已，只是会在适当的时候调用操作系统提供的<strong>机制</strong>。<br>  因此，在初始化完成后设置好一个没有标准库的<strong>C</strong>程序运行环境，其中包含栈区、静态数据、堆区;代码从<code>main</code>函数开始执行，并允许我们在程序运行过程中直接、独占式地访问操作系统中的物理设备(例如显示器、计时器)和响应中断，即可实现当下主流的操作系统</p>
<h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote>
<p>实验要求1:实现AbstractMachine中klib中缺失的函数</p>
<blockquote>
<p><strong>AbstractMachine</strong>的项目中包含一个基础运行库的框架klib，其中包含了方便你编写<em>bare-metal</em>程序的系列库函数，例如<code>assert</code>、<code>printf</code>和<code>memcpy</code>等。<br>尽可能实现有能力实现的代码</p>
</blockquote>
<p>实验要求2:实现可移植的、直接运行在计算机硬件上的小游戏</p>
<blockquote>
<p>你需要编写一个直接运行在<strong>AbstractMachine</strong>上(仅仅是用IOE拓展，不使用其他硬件机制如中断/异常/虚拟存储/多处理器)的小游戏;满足:</p>
<ol>
<li>有肉眼可辨认的图形输出</li>
<li>能使用键盘与游戏交互</li>
<li>游戏使用的内存(代码、静态数据总和不超过1MiB、堆区_heap使用不超过1MiB)，因此不必考虑复杂的图形;</li>
<li>按ESC键后调用<code>_halt()</code>退出;除此之外游戏程序永不调用<code>_halt()</code>结束，Game Over后按键重新开始</li>
</ol>
<p>只要程序不崩溃，哪怕只有几个像素点在屏幕上乱动也可以。虽然不限制实现什么游戏，但仍需要在移植性/通用性上对代码做出一定的保证:</p>
<ul>
<li>兼容很简单的处理器:即小游戏运行中只调用<strong>TRM</strong>和<strong>IOE</strong> API，而不使用其他API</li>
<li>你的游戏应当是可以在多个硬件体系之间移植的，考虑兼容以下情况:<ul>
<li>适配不同的屏幕大小。不同的体系结构中，屏幕大小可能是320x200、640x480、800x600等，你的游戏最好都能在所有分辨率下都获得不错的体验;</li>
<li>同minilabs一样，你的程序可能运行在32/64-bit平台，因此你应当使用<code>intptr_t</code>或<code>uintptr_t</code>来保存指针数值;</li>
<li>兼容大/小端，因此禁止把不同大小的指针类型强制转换</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><p>  根据前面的描述，整个实验由两个小实验构成—实现<strong>klib</strong>库函数;实现小游戏。这里给出这两个小实验需要注意的细节</p>
<h3 id="实现库函数"><a href="#实现库函数" class="headerlink" title="实现库函数"></a>实现库函数</h3><p>  实际上，实现库函数是普通的<strong>C</strong>语言练习题;但需要注意的是，编写可移植代码时，尽量使用<strong>C</strong>标准提供的机制，而非做一些对硬件的假设</p>
<h3 id="访问I-O设备"><a href="#访问I-O设备" class="headerlink" title="访问I/O设备"></a>访问I/O设备</h3><p>  没有库函数的C语言程序类似于状态机，仅仅可以完成纯粹的”计算”。我们可以通过<strong>TRM</strong>和<strong>IOE</strong>的API，与外界的I/O设备进行交互，从而完成相关的操作。</p>
<h3 id="实现游戏"><a href="#实现游戏" class="headerlink" title="实现游戏"></a>实现游戏</h3><p>  <strong>AbstractMachine</strong>中附带的<strong>AMGame</strong>使用了一种框架，这里再提供一个不同的框架，来实现游戏，如下所示<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">next_frame = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (uptime() &lt; next_frame) ; <span class="comment">// 等待一帧的到来</span></span><br><span class="line">  <span class="keyword">while</span> ((key = readkey()) != _KEY_NONE) &#123;</span><br><span class="line">    kbd_event(key);         <span class="comment">// 处理键盘事件</span></span><br><span class="line">  &#125;</span><br><span class="line">  game_progress();          <span class="comment">// 处理一帧游戏逻辑，更新物体的位置等</span></span><br><span class="line">  screen_update();          <span class="comment">// 重新绘制屏幕</span></span><br><span class="line">  next_frame += <span class="number">1000</span> / FPS; <span class="comment">// 计算下一帧的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  其使用<strong>轮询(polling)</strong>等待下一帧时刻的到来;等到帧时刻到来，就读取键盘按键并处理;然后模拟这一帧中游戏发生的事情即可。</p>
<h3 id="小游戏和操作系统"><a href="#小游戏和操作系统" class="headerlink" title="小游戏和操作系统"></a>小游戏和操作系统</h3><p>  实际上，游戏和操作系统的工作原理有很多相像的地方，正如前面介绍的，简化的游戏的<strong>主循环</strong>如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 在每一个时间片，例如每 16.7ms (60 fps)</span></span><br><span class="line">  wait_for_frame();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做完这一个时间片内需要完成的工作</span></span><br><span class="line">  <span class="type">int</span> scanlines = <span class="number">262</span>;</span><br><span class="line">  <span class="keyword">while</span> (scanlines-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ppu_cycle();      <span class="comment">// 更新游戏图像</span></span><br><span class="line">    psg_detect_key(); <span class="comment">// 读取按键，更新游戏逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  而如果在程序的<strong>主循环</strong>中，不再是一次执行一帧，而是”每一帧”都执行另一个程序，程序执行完后返回主循环，则可以抽象为批处理系统的流程<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 等待键盘输入需要运行的命令</span></span><br><span class="line">  Job *job = wait_for_job();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并执行命令</span></span><br><span class="line">  load(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  有了上面的分析，可以简单的<strong>剧透</strong>一下<strong>批处理</strong>系统的工作流程</p>
<ol>
<li>批处理系统执行的命令由键盘输入，因此<code>wait_for_job()</code>就是从键盘读取按键，并解析成命令，与游戏读取按键类似</li>
<li>执行的命令(job)是保存在磁盘上的ELF格式的二进制文件，则使用硬件提供的I/O指令，将存储设备中二进制文件加载到内存中，然后在通过跳转，将控制权交给job;等job结束后函数返回，重新回到批处理系统，从而完成一个简易的操作系统，其<code>load()</code>部分的简化代码如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy_from_disk(elf32, <span class="number">4096</span>, <span class="number">0</span>); <span class="comment">// 从磁盘读取 ELF 文件头</span></span><br><span class="line"><span class="keyword">if</span> (elf-&gt;e_machine == EM_386) &#123;  <span class="comment">// x86 (32-bit)</span></span><br><span class="line">  load_elf32(elf32); <span class="comment">// 从磁盘加载二进制文件到 ELF 文件描述的位置</span></span><br><span class="line">  ((<span class="type">void</span>(*)())(<span class="type">uint32_t</span>)elf32-&gt;e_entry)(); <span class="comment">// 跳转到加载的代码执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  在之前从github上拉取下来的实验目录下，切换到master分支，继续拉取<strong>L0</strong>实验的代码即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy L0</span><br></pre></td></tr></table></figure></p>
<p>  本次实验可能还需要运行在qemu实验环境下，因此还需要安装qemu实验环境，执行如下命令<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S qemu qemu-extra-arch</span><br></pre></td></tr></table></figure></p>
<p>  最后，编译时还可能需要一些额外的库<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S gcc-multilib slib</span><br></pre></td></tr></table></figure></p>
<p>  最后，由于是在manjaro中进行实验，需要设置一些额外的软链接，使程序正常运行<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/x86_64-pc-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-gcc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/ld /usr/bin/x86_64-linux-gnu-ld</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/objcopy /usr/bin/x86_64-linux-gnu-objcopy</span><br></pre></td></tr></table></figure></p>
<h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a target="_blank" rel="noopener" href="https://gitee.com/jiaweihawk/nju-os/tree/7cde800afe2d8067e0b8f97a1c44fbc304743d67">实验实现</a></p>
<h3 id="实现AbstractMachine中klib的缺失函数"><a href="#实现AbstractMachine中klib的缺失函数" class="headerlink" title="实现AbstractMachine中klib的缺失函数"></a>实现AbstractMachine中klib的缺失函数</h3><p>  即这里需要实现一些常用的C语言函数，这里会实现部分功能(类似malloc等，由于还未建立虚拟内存机制，则当下无法实现</p>
<h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h4><ol>
<li><code>void *memset(void *s, int c, size_t n)</code><br>根据<code>man 3 memset</code>说明，其将s指向的地址的前n个字节，设置为字节c，因此我们只需要将s当作<code>unsigned char *</code>类型的指针即可，然后依次赋值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">		((<span class="type">unsigned</span> <span class="type">char</span>*)s)[i] = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>void *memcpy(void *dst, const void *src, size_t n)</code><br>和1.是类似的思路，将其当作<code>unsigned char*</code>类型进行遍历赋值即可<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">		((<span class="type">unsigned</span> <span class="type">char</span>*)dst)[i] = ((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)src)[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>void *memmove(void *dst, const void *src, size_t n)</code><br>其和2的作用是一样的，但是该方法<code>src</code>和<code>dst</code>可能重合。因此先复制到中间变量，然后在复制到目标地址中。其实相当于调用两次<code>memcpy</code>即可<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="comment">//首先申请相关大小的堆空间</span></span><br><span class="line">	<span class="type">void</span> *temp = <span class="built_in">malloc</span>(n);</span><br><span class="line">	assert(temp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(temp, src, n);</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, temp, n);</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>int memcmp(const void *s1, const void *s2, size_t n)</code><br>根据<code>man 3 memcpy</code>可知，<code>memcpy</code>将<code>s1</code>和<code>s2</code>当作<code>unsigned char</code>类型，而其返回结果是<code>s1</code>和<code>s2</code>第一个不相等的字符相减的结果。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s1)[i] &lt; ((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s2)[i]) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s1)[i] &gt; ((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s2)[i]) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>size_t strlen(const char *s)</code><br>即遍历直到第一个为0的字符为止<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(s[len++]) &#123;;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>char *strcat(char *dst, const char *src)</code><br>根据<code>man 3 strcat</code>可知，其将<code>src</code>指向的字符串拼接到<code>dst</code>后面，并且可以默认<code>dst</code>留有足够的空间(即<code>dst</code>剩余空间足够容纳<code>src</code>指向的字符串，及末尾的’\x00’)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> dstLen = <span class="number">0</span>, srcLen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(dst[dstLen++]) &#123;; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(src[srcLen]) &#123;</span><br><span class="line">		dst[dstLen++] = src[srcLen++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst[dstLen] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>char *strcpy(char *dst, const char *src)</code><br>即其复制的时候，以<code>src</code>的’\x00’结束，并且’\x00’字符也会被复制<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(src[len]) &#123;</span><br><span class="line">		dst[len] = src[len];</span><br><span class="line">		++len;</span><br><span class="line">	&#125;</span><br><span class="line">	dst[len] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>char *strncpy(char *dst, const char *src, size_t n)</code><br>和7.的思路是一致的，但是其确保每次都写入n个字节——当<code>src</code>个数不足n个时，以’\x00’进行拓展;当个数超过n个时，则进行截断。注意的是，如果<code>src</code>的第一个’\x00’的在第n个之后，则复制的时候，不会复制’\x00’<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(src[len] &amp;&amp; len &lt; n) &#123;</span><br><span class="line">		dst[len] = src[len];</span><br><span class="line">		++len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(len &lt; n) &#123; dst[len++] = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>int strcmp(const char *s1, const char *s2)</code><br>思路和<code>memcmp</code>完全一样，但需要注意以下如果s1字符串和s2字符串长度和每一位字符都相等，其需要进行中止<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;s1[i] || s2[i]; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i] &lt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s1[i] &gt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>int strncmp(const char *s1, const char *s2, size_t n)</code><br>其和9.的思路也是完全一样的，除了额外添加的中止条件:长度小于等于n<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; (s1[i] || s2[i]); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i] &lt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s1[i] &gt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="程序编译和链接"><a href="#程序编译和链接" class="headerlink" title="程序编译和链接"></a>程序编译和链接</h4><p>  最后，我们可以使用上述这些标准库，实现一个简单的测试样例，首先在文件系统下任意路径下创建一个测试文件夹，并创建一个测试文件.c和对应的Makefile文件，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Hello, world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME := test</span><br><span class="line">SRCS := test.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(AM_HOME)</span>/Makefile</span><br></pre></td></tr></table></figure>
<p>  然后需要进行编译,文件中已经设置好了<strong>AM_HOME</strong>环境变量为真实的<strong>am</strong>文件夹路径，则执行make命令即可，如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=x86_64-qemu run</span><br></pre></td></tr></table></figure></p>
<h3 id="实现可移植的、直接运行在计算机硬件上的小游戏"><a href="#实现可移植的、直接运行在计算机硬件上的小游戏" class="headerlink" title="实现可移植的、直接运行在计算机硬件上的小游戏"></a>实现可移植的、直接运行在计算机硬件上的小游戏</h3><h4 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h4><p>  实际上在<strong>amgame</strong>文件夹下，已经有比较完善的程序框架了，因此我们只需要在这个基础上进行补全即可。<br>  而对于小游戏，我之前在coursera学习了一门很有意思的课<strong>Build a Modern Computer from First Principles: Nand to Tetris</strong>, 在这门课上有一个很有意思的游戏——“Square Dance”，准备实现这个游戏<br>  这个游戏实现起来并不是很难，只需要在屏幕上根据相关参数显示正方形即可，其相关的参数包括正方形的大小和正方形的位置。<br>  因此我们使用如下信息记录正方形的参数</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SQUARE</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y, edge, side;</span><br><span class="line">&#125; Square;</span><br></pre></td></tr></table></figure>
<p>  其中<code>x</code>、<code>y</code>分别表示正方形左顶点在显示器上的坐标，而<code>edge</code>则表示正方形的边长, <code>side</code>表示正方形的单位长度在显示器上的像素点个数</p>
<p>  下面则实现在显示器上画出该图形，模板已经给了一个画直线的代码，然后进行简单包装即可(即增量的画出正方形变化的像素即可)，这里需要特别注意，避免一次画大量数据，导致爆栈。</p>
<p>  其次，则是对于正方形的操作，其支持位移和形变，即上移’↑’、下移’↓’、左移’←’和右移’→’的位移变化，以及放大’+’和缩小’-‘的形状变化。这里需要注意的是，其位移变化不能让正方形超出边界，其形状变化同样也不可以让正方形过大或过小。<br>  最终的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;game.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SQUARE</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y, edge, side;</span><br><span class="line">&#125; Square;</span><br><span class="line">Square square;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免爆栈，所以一次只画一个单元的图像</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_draw_line</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">int</span> row = x, row_end = x + w;</span><br><span class="line">	<span class="keyword">while</span>(row &lt; row_end) &#123;</span><br><span class="line">		<span class="type">int</span> col = y, col_end = y + h;</span><br><span class="line">		<span class="keyword">while</span>(col &lt; col_end) &#123;</span><br><span class="line">			draw_line(row, col, square.side, square.side, color);</span><br><span class="line">			col += square.side;</span><br><span class="line">		&#125;</span><br><span class="line">		row += square.side;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查左边碰壁;原始最右侧画成黑色，新的最左侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_left</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(square.x - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x + edge - 1, y)起点的宽度为1，高度为edge的黑线</span></span><br><span class="line">		safe_draw_line((square.x + square.edge - <span class="number">1</span>) * square.side, square.y * square.side, square.side, square.edge * square.side, BLACK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x - 1, y)起点的宽度为1，高度为edge的白线</span></span><br><span class="line">		safe_draw_line((square.x - <span class="number">1</span>) * square.side, square.y * square.side, square.side, square.edge * square.side, WHITE);</span><br><span class="line"></span><br><span class="line">		--square.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查右边碰壁;原始最左侧画成黑色，新的最右侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_right</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>((square.x + square.edge) * square.side &lt; w) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y)起点的宽度为1，高度为edge的黑线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, square.y * square.side, square.side, square.edge * square.side, BLACK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x + edge, y)起点的宽度为1，高度为edge的白线</span></span><br><span class="line">		safe_draw_line((square.x + square.edge) * square.side, square.y * square.side, square.side, square.edge * square.side, WHITE);</span><br><span class="line"></span><br><span class="line">		++square.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查上边碰壁;原始最下侧画成黑色，新的最上侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_up</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(square.y - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y + edge - 1)起点的宽度为edge，高度为1的黑线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, (square.y + square.edge - <span class="number">1</span>) * square.side, square.edge * square.side, square.side, BLACK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y - 1)起点的宽度为edge，高度为1的白线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, (square.y - <span class="number">1</span>) * square.side, square.edge * square.side, square.side, WHITE);</span><br><span class="line"></span><br><span class="line">		--square.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查下边碰壁;原始最上侧画成黑色，新的最下侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_down</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>((square.y + square.edge) * square.side &lt; h) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y)起点的宽度为edge，高度为1的黑线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, square.y * square.side, square.edge * square.side, square.side, BLACK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y + edge)起点的宽度为edge，高度为1的白线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, (square.y + square.edge) * square.side, square.edge * square.side, square.side, WHITE);</span><br><span class="line"></span><br><span class="line">		++square.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查边长不能小于1;将最下方和最右方的边画成黑色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">figure_small</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(square.edge - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y + square.edge - 1)起点的宽度为edge，高度为1的黑线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, (square.y + square.edge - <span class="number">1</span>) * square.side, square.edge * square.side, square.side, BLACK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x + square.edge - 1, y)起点的宽度为1， 高度为edge - 1的黑线</span></span><br><span class="line">		safe_draw_line((square.x + square.edge - <span class="number">1</span>) * square.side, square.y * square.side, square.side, (square.edge - <span class="number">1</span>) * square.side, BLACK);</span><br><span class="line"></span><br><span class="line">		--square.edge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查增加的边长不能越界;将新的下方和最右方的边画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">figure_big</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>((square.x + square.edge) * square.side &lt; w &amp;&amp; (square.y + square.edge) * square.side &lt; h) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x, y + edge)起点的宽度为edge + 1，高度为1的白线</span></span><br><span class="line">		safe_draw_line(square.x * square.side, (square.y + square.edge) * square.side, (square.edge + <span class="number">1</span>) * square.side, square.side, WHITE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(x + square.edge, y)起点的宽度为1， 高度为edge的白线</span></span><br><span class="line">		safe_draw_line((square.x + square.edge) * square.side, square.y * square.side, square.side, square.edge * square.side, WHITE);</span><br><span class="line"></span><br><span class="line">		++square.edge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">square_init</span><span class="params">()</span> &#123;</span><br><span class="line">	square.x = square.y = <span class="number">0</span>;</span><br><span class="line">	square.edge = <span class="number">1</span>;</span><br><span class="line">	square.side = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//画一条宽度为edge， 高度为edge的线即可</span></span><br><span class="line">	safe_draw_line(square.x * square.side, square.y * square.side, square.edge * square.side, square.edge * square.side, WHITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operating system is a C program!</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  ioe_init();</span><br><span class="line">  gpu_init();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;mainargs = \&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(args); <span class="comment">// make run mainargs=xxx</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化方块</span></span><br><span class="line">  square_init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Press any key to see its key code...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key = print_key();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//方便肉眼观察</span></span><br><span class="line">    <span class="type">int</span> delta = <span class="number">262</span>;</span><br><span class="line">    <span class="keyword">while</span>(delta--) &#123;;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;W&quot;</span>)) &#123; move_up(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;S&quot;</span>)) &#123; move_down(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;A&quot;</span>)) &#123; move_left(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;D&quot;</span>)) &#123; move_right(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;J&quot;</span>)) &#123; figure_big(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;K&quot;</span>)) &#123; figure_small(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;ESCAPE&quot;</span>)) &#123; halt(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="游戏编译和链接"><a href="#游戏编译和链接" class="headerlink" title="游戏编译和链接"></a>游戏编译和链接</h4><p>  最后，我们在<strong>amgame</strong>路径下，执行如下命令，进行游戏的编译和运行<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=x86_64-qemu run</span><br></pre></td></tr></table></figure></p>
<p>  游戏的运行结果如下所示<br>  <img src="游戏截图.PNG" alt="游戏截图"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">H4wk1ns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiaweihawk.github.io/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/">https://jiaweihawk.github.io/2021/08/01/操作系统-设计与实现-二/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiaweihawk.github.io" target="_blank">H4wk1ns's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%86%99/">手写</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-设计与实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%89/"><img class="next-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-设计与实现-三</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/01/操作系统-设计与实现-七/" title="操作系统-设计与实现-七"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">操作系统-设计与实现-七</div></div></a></div><div><a href="/2021/08/06/操作系统-设计与实现-三/" title="操作系统-设计与实现-三"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-06</div><div class="title">操作系统-设计与实现-三</div></div></a></div><div><a href="/2021/12/15/操作系统-设计与实现-九/" title="操作系统-设计与实现-九"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">操作系统-设计与实现-九</div></div></a></div><div><a href="/2021/09/07/操作系统-设计与实现-五/" title="操作系统-设计与实现-五"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-07</div><div class="title">操作系统-设计与实现-五</div></div></a></div><div><a href="/2021/12/05/操作系统-设计与实现-八/" title="操作系统-设计与实现-八"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">操作系统-设计与实现-八</div></div></a></div><div><a href="/2021/10/04/操作系统-设计与实现-六/" title="操作系统-设计与实现-六"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-04</div><div class="title">操作系统-设计与实现-六</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/profile.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">H4wk1ns</div><div class="author-info__description">coder && ctfer</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jiaweihawk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/static/cv/cv_zh.pdf" target="_blank" title="个人简历"><i class="fa-solid fa-file-pdf"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#L0%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F"><span class="toc-number">2.</span> <span class="toc-text">L0直接运行在硬件上的小游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">实验背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">实验描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%8D%97"><span class="toc-number">2.3.</span> <span class="toc-text">实验指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">实现库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEI-O%E8%AE%BE%E5%A4%87"><span class="toc-number">2.3.2.</span> <span class="toc-text">访问I&#x2F;O设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">实现游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.4.</span> <span class="toc-text">小游戏和操作系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">2.4.</span> <span class="toc-text">实验环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">实验实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0AbstractMachine%E4%B8%ADklib%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">实现AbstractMachine中klib的缺失函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">程序编译和链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E3%80%81%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">实现可移植的、直接运行在计算机硬件上的小游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">游戏实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">游戏编译和链接</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/23/virtio%E7%AE%80%E4%BB%8B/" title="virtio简介">virtio简介</a><time datetime="2024-08-23T15:05:52.000Z" title="发表于 2024-08-23 23:05:52">2024-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a><time datetime="2024-08-04T04:33:06.000Z" title="发表于 2024-08-04 12:33:06">2024-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/" title="qemu设备模型">qemu设备模型</a><time datetime="2024-07-31T15:38:12.000Z" title="发表于 2024-07-31 23:38:12">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="qemu内存模型">qemu内存模型</a><time datetime="2024-07-20T01:37:13.000Z" title="发表于 2024-07-20 09:37:13">2024-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/14/%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A0%88/" title="网卡与网络栈">网卡与网络栈</a><time datetime="2024-04-14T10:24:48.000Z" title="发表于 2024-04-14 18:24:48">2024-04-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By H4wk1ns</div><div class="footer_custom_text">come to hack me!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>