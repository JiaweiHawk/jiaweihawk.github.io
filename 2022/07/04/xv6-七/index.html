<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>xv6-七 | H4wk1ns's blog</title><meta name="keywords" content="内核,手写"><meta name="author" content="H4wk1ns"><meta name="copyright" content="H4wk1ns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言这篇博客研究xv6的进程调度机制的实现 多进程现代操作系统基本都支持并行多进程(多CPU多进程)，而要实现该功能，需要解决如下问题  如何切换进程？虽然实现思路不是很难，但是实现细节比较复杂。 如何对用户进程透明？即用户进程应该对于进程切换无感——进程切换前和进程切换后，进程的上下文不应有任何改变 如何找到当前CPU执行的进程的描述符？进程可能被切换到任何CPU上，则CPU应当可以高效的找到当">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6-七">
<meta property="og:url" content="https://jiaweihawk.github.io/2022/07/04/xv6-%E4%B8%83/index.html">
<meta property="og:site_name" content="H4wk1ns&#39;s blog">
<meta property="og:description" content="前言这篇博客研究xv6的进程调度机制的实现 多进程现代操作系统基本都支持并行多进程(多CPU多进程)，而要实现该功能，需要解决如下问题  如何切换进程？虽然实现思路不是很难，但是实现细节比较复杂。 如何对用户进程透明？即用户进程应该对于进程切换无感——进程切换前和进程切换后，进程的上下文不应有任何改变 如何找到当前CPU执行的进程的描述符？进程可能被切换到任何CPU上，则CPU应当可以高效的找到当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiaweihawk.github.io/img/background.jpg">
<meta property="article:published_time" content="2022-07-04T14:22:43.000Z">
<meta property="article:modified_time" content="2024-10-16T15:08:39.099Z">
<meta property="article:author" content="H4wk1ns">
<meta property="article:tag" content="内核">
<meta property="article:tag" content="手写">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiaweihawk.github.io/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jiaweihawk.github.io/2022/07/04/xv6-%E4%B8%83/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xv6-七',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-16 23:08:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/profile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">H4wk1ns's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">xv6-七</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-04T14:22:43.000Z" title="发表于 2022-07-04 22:22:43">2022-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-16T15:08:39.099Z" title="更新于 2024-10-16 23:08:39">2024-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%89%8B%E5%86%99/">手写</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="xv6-七"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>进程调度</strong>机制的实现</p>
<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>现代操作系统基本都支持并行多进程(多CPU多进程)，而要实现该功能，需要解决如下问题</p>
<ol>
<li>如何切换进程？<br>虽然实现思路不是很难，但是实现细节比较复杂。</li>
<li>如何对用户进程透明？<br>即用户进程应该对于进程切换无感——进程切换前和进程切换后，进程的上下文不应有任何改变</li>
<li>如何找到当前CPU执行的进程的描述符？<br>进程可能被切换到任何CPU上，则CPU应当可以高效的找到当前执行的进程的描述符信息，从而在<strong>S-mode</strong>时更改当前进程的状态信息</li>
</ol>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p><strong>xv6</strong>的进程切换的基本流程如下图所示<br><img src="进程切换.png" alt="xv6进程切换示意图"></p>
<p>可以看到，<strong>xv6</strong>实现进程切换的方式非常标准——首先从<strong>U-mode</strong>陷入到<strong>S-mode</strong>(系统调用或中断)，再从对应的<strong>S-mode</strong>切换到CPU切换进程(每个CPU在操作系统初始化时的执行流)。</p>
<p>接着就是上述步骤的反向操作，即切换到调度出的待切换进程的<strong>S-mode</strong>，然后从<strong>S-mode</strong>返回到<strong>U-mode</strong>，最终完成进程切换</p>
<p>进程调度时，进程首先<strong>陷入</strong>到<strong>S-mode</strong>，根据前面<a href="/2022/05/21/xv6-%E4%BA%8C/" title="xv6-二">xv6-二</a>可知，<strong>U-mode</strong>的上下文会保存在<strong>S-mode</strong>的内核栈中；当进程切换结束时，会从<strong>S-mode</strong>返回到<strong>U-mode</strong>，内核从进程的内核栈中恢复<strong>U-mode</strong>的上下文，从而还原到切换前的<strong>U-mode</strong>状态。这样的机制保证了对用户进程的透明</p>
<p>而进程切换最关键的代码则是<strong>swtch</strong>(kernel/swtch.S:8)，其将当前进程的<strong>S-mode</strong>的上下文保存，并载入调度选中的进程的<strong>S-mode</strong>的上下文并执行。这里需要注意的几个点是</p>
<ul>
<li><strong>S-mode</strong>共享一个地址空间，所以无需更换页表，即可访问相关的虚拟地址资源</li>
<li>每一个进程的地址描述符(<strong>struct proc</strong>(kernel/proc.h:86)或<strong>struct cpu</strong>(kernel/proc.h:22))中包含<strong>struct context</strong>(kernel/proc.h:2)，用来保存被切换时进程<strong>S-mode</strong>的上下文信息</li>
<li>进程切换时，并不会保存或载入<strong>pc</strong>寄存器。其通过保存和载入<strong>ra</strong>寄存器，在进程从<strong>swtch</strong>返回时实现CPU执行流的切换</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>正如上一节分析的，每次进程调度时，都涉及到<strong>CPU切换进程</strong>。实际上，<strong>CPU切换进程</strong>就是每个CPU在操作系统初始化时的执行流抽象的进程，其在<strong>_entry</strong>(kernel/entry.S:5)中构建进程的<strong>S-mode</strong>栈；其在<strong>main</strong>(kernel/main.c:44)中循环执行<strong>scheduler()</strong>，用来调度并切换进程。由于其特殊性质——每个CPU一个<strong>CPU切换进程</strong>，并且基本上仅仅用来调度进程，因此其不需要完整的进程描述符来表示，使用<strong>struct cpu</strong>(kernel/proc.h:22)的部分字段即可。</p>
<p>而一般的进程调度调用栈如下图所示<br><img src="进程调度调用栈.png" alt="进程调度调用栈"></p>
<p>可以看到，从一个进程切换到另一个进程过程中，一共调用了两次<strong>swtch</strong>(kernel/swtch.S:8)。第一次调用为<code>swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context)</code>，即切换到<strong>CPU切换进程</strong>；第二次调用为<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context)</code>，即从<strong>CPU切换进程</strong>切换到调度出的进程上下文。整体的逻辑还是非常清晰的。</p>
<p>其调度策略也很简单，循环遍历进程描述符数组，直到找到一个可被调度的进程即可</p>
<h2 id="struct-cpu"><a href="#struct-cpu" class="headerlink" title="struct cpu"></a>struct cpu</h2><p>为了记录CPU独占的数据(如当前执行的进程描述符、CPU切换进程)，<strong>xv6</strong>使用<strong>struct cpu</strong>(kernel/proc.h:22)来管理。</p>
<p>其中，在<strong>S-mode</strong>地址空间中，包含元素为<strong>struct cpu</strong>的数组<strong>cpus</strong>(kernel/proc.c:9)，其包含了当前所有CPU的描述符。每个CPU可以以各自的<strong>hartid</strong>作为下标，访问对应的描述符。</p>
<p>这里需要注意的是，每个CPU的<strong>hartid</strong>只能在<strong>M-mode</strong>中访问。在<strong>S-mode</strong>中，xv6保证CPU对应的<strong>hartid</strong>会保存在其<strong>tp</strong>(thread pointer)中，可以通过<strong>mycpu</strong>(kernel/proc.c:59)来获取当前CPU对应的描述符。但是其应该在关闭中断时调用——否则在执行一般时可能发生进程调度，从而返回错误的结果</p>
<h1 id="wake-sleep"><a href="#wake-sleep" class="headerlink" title="wake()/sleep()"></a>wake()/sleep()</h1><p>类似于<strong>acquiresleep()/releasesleep()</strong>，操作系统提供了这一组函数，用于进程等待事件发生以及事件发生时唤醒等待进程。其实现如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体思路非常简单，<strong>sleep()</strong>即将当前进程的状态设置为<strong>SLEEPING</strong>，并释放传入的锁即可;<strong>wake()</strong>即将所有包含等待事件的进程状态设置为<strong>RUNNABLE</strong>即可</p>
<p>这里需要特别说明一下，在调用<strong>sleep()</strong>和<strong>wake()</strong>前，需要获取相应的<strong>自旋锁</strong>，避免部分等待进程会遗漏<strong>wake()</strong>。即当某一进程正在唤醒阻塞进程时，可能新的进程会准备阻塞，<br><img src="sleep_wake.png" alt="sleep()/wake()bug"></p>
<h1 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab Multithreading"></a>Lab Multithreading</h1><p>本次<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/thread.html">lab</a>用来加深对于<strong>xv6</strong>的<strong>多进程</strong>机制理解</p>
<h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote>
<p>Your job is to come up with a plan to create threads and save/restore registers to switch between threads, and implement that plan. When you’re done, <strong>make grade</strong> should say that your solution passes the <strong>uthread</strong> test.</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>实际上，用户态进程切换和操作系统的进程切换非常相似，但是更简单——因为这里的用户态进程不并行(这里的用户态下的多进程不会同时在两个CPU下执行)。</p>
<p>其进程切换就是将当前CPU的上下文保存到当前用户态进程的<strong>context</strong>中；载入被选中的用户态进程的<strong>context</strong>即可。</p>
<p>为了方便管理，直接将用户态进程的进程栈的底部当做该进程的<strong>context</strong>存储位置即可</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，在创建用户态进程时，提前设置好用户态进程的<strong>context</strong>，从而确保该进程在第一次被载入时，可以正常的执行回调函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread.c</span></span><br><span class="line"><span class="comment">// Saved registers for user context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * set the thread context&#x27;s stack and ret address</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">c</span> =</span> (<span class="keyword">struct</span> context*)t-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  c-&gt;ra = (uint64)func;</span><br><span class="line">  c-&gt;sp = (uint64)(t-&gt;<span class="built_in">stack</span> + STACK_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，则是当进行用户态的多进程调度时，完成进程的<strong>context</strong>的保存和恢复即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch thread context</span></span><br><span class="line">    thread_switch((<span class="keyword">struct</span> context*)t-&gt;<span class="built_in">stack</span>,</span><br><span class="line">                  (<span class="keyword">struct</span> context*)current_thread-&gt;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/uthread_switch.S</span></span><br><span class="line">	.text</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment">	 * thread_switch(struct context *old, struct context *new);</span></span><br><span class="line"><span class="comment">     * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">    sd ra, <span class="number">0</span>(a0)</span><br><span class="line">    sd sp, <span class="number">8</span>(a0)</span><br><span class="line">    sd s0, <span class="number">16</span>(a0)</span><br><span class="line">    sd s1, <span class="number">24</span>(a0)</span><br><span class="line">    sd s2, <span class="number">32</span>(a0)</span><br><span class="line">    sd s3, <span class="number">40</span>(a0)</span><br><span class="line">    sd s4, <span class="number">48</span>(a0)</span><br><span class="line">    sd s5, <span class="number">56</span>(a0)</span><br><span class="line">    sd s6, <span class="number">64</span>(a0)</span><br><span class="line">    sd s7, <span class="number">72</span>(a0)</span><br><span class="line">    sd s8, <span class="number">80</span>(a0)</span><br><span class="line">    sd s9, <span class="number">88</span>(a0)</span><br><span class="line">    sd s10, <span class="number">96</span>(a0)</span><br><span class="line">    sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, <span class="number">0</span>(a1)</span><br><span class="line">    ld sp, <span class="number">8</span>(a1)</span><br><span class="line">    ld s0, <span class="number">16</span>(a1)</span><br><span class="line">    ld s1, <span class="number">24</span>(a1)</span><br><span class="line">    ld s2, <span class="number">32</span>(a1)</span><br><span class="line">    ld s3, <span class="number">40</span>(a1)</span><br><span class="line">    ld s4, <span class="number">48</span>(a1)</span><br><span class="line">    ld s5, <span class="number">56</span>(a1)</span><br><span class="line">    ld s6, <span class="number">64</span>(a1)</span><br><span class="line">    ld s7, <span class="number">72</span>(a1)</span><br><span class="line">    ld s8, <span class="number">80</span>(a1)</span><br><span class="line">    ld s9, <span class="number">88</span>(a1)</span><br><span class="line">    ld s10, <span class="number">96</span>(a1)</span><br><span class="line">    ld s11, <span class="number">104</span>(a1)</span><br><span class="line">	ret    <span class="comment">/* return to ra */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;uthread&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="uthread实验结果.png" alt="uthread实验结果"></p>
<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote>
<p>insert lock and unlock statements in <strong>put</strong> and <strong>get</strong> in <strong>notxv6/ph.c</strong> so that the number of keys missing is always 0 with two threads. The relevant pthread calls are:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure>
<p>You’re done when <strong>make grade</strong> says that your code passes the <strong>ph_safe</strong> test, which requires zero missing keys with two threads.</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>当多个进程同时在哈希表中插入时，则由于条件竞争，会导致部分插入的键-值对丢失——最简单的例子，假如两个进程同时插入一个键相同但值不同的键-值对，当他们同时执行到<strong>insert</strong>函数时，必然会有一个进程覆盖掉另一个进程的插入。</p>
<p>那么解决办法很简单，就是在可能产生条件竞争的操作上上锁就行。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>由于<strong>put</strong>函数可能同时读、写同一个键-值对，则在该函数中上锁即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notxv6/ph.c</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> locks[NBUCKET];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;uthread&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="using-threads.png" alt="Using threads"></p>
<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><blockquote>
<p>Your goal is to achieve the desired barrier behavior. In addition to the lock primitives that you have seen in the ph assignment, you will need the following new pthread primitives; look <a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">here</a> and <a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">here</a> for details.</p>
<p>pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up<br>pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</p>
<p>Make sure your solution passes make grade’s barrier test. </p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>即每次调用<strong>barrier</strong>函数时，阻塞当前进程，直到被阻塞进程的个数等于用户态多进程个数为止，由最后一个进入的进程唤醒所有进程即可。</p>
<p>这里特别需要注意的是<strong>pthread_cond_wait</strong>函数对于<strong>mutex</strong>参数的操作——在进入前，<strong>mutex</strong>需要已经被获取，然后在标记用户态进程被阻塞后释放，并直到被唤醒后再次获取锁</p>
<p>一轮<strong>barrier</strong>的进程同步情况如图所示<br><img src="barrier_sync.png" alt="一轮barrier的同步"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>即按照前面的分析，首先获取<strong>mutex</strong>互斥锁，然后根据当前阻塞在<strong>barrier</strong>的进程个数，睡眠或唤醒，并在最后释放掉<strong>mutex</strong>互斥锁即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notxv6/barrier.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * if ++bstate.nthread != nthread, there still some</span></span><br><span class="line"><span class="comment">   * thread has not reached the barrier, so this</span></span><br><span class="line"><span class="comment">   * thread should wait</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * if old_nthread == nthread, thread is the last</span></span><br><span class="line"><span class="comment">   * to reach the barrier, it should wake other</span></span><br><span class="line"><span class="comment">   * thread</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(++bstate.nthread == nthread) &#123;</span><br><span class="line"></span><br><span class="line">    ++bstate.round;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,</span><br><span class="line">                      &amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;barrier&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="barrier.png" alt="Barrier"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">H4wk1ns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiaweihawk.github.io/2022/07/04/xv6-%E4%B8%83/">https://jiaweihawk.github.io/2022/07/04/xv6-七/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiaweihawk.github.io" target="_blank">H4wk1ns's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E6%A0%B8/">内核</a><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%86%99/">手写</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/14/xv6-%E5%85%AD/"><img class="prev-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">xv6-六</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/13/xv6-%E5%85%AB/"><img class="next-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">xv6-八</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/26/xv6-三/" title="xv6-三"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-26</div><div class="title">xv6-三</div></div></a></div><div><a href="/2022/09/02/xv6-九/" title="xv6-九"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">xv6-九</div></div></a></div><div><a href="/2022/05/21/xv6-二/" title="xv6-二"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-21</div><div class="title">xv6-二</div></div></a></div><div><a href="/2022/06/11/xv6-五/" title="xv6-五"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">xv6-五</div></div></a></div><div><a href="/2022/07/13/xv6-八/" title="xv6-八"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-13</div><div class="title">xv6-八</div></div></a></div><div><a href="/2022/06/14/xv6-六/" title="xv6-六"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-14</div><div class="title">xv6-六</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/profile.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">H4wk1ns</div><div class="author-info__description">coder && ctfer</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jiaweihawk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/static/cv/cv_zh.pdf" target="_blank" title="个人简历"><i class="fa-solid fa-file-pdf"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">进程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-cpu"><span class="toc-number">2.3.</span> <span class="toc-text">struct cpu</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wake-sleep"><span class="toc-number">3.</span> <span class="toc-text">wake()&#x2F;sleep()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab-Multithreading"><span class="toc-number">4.</span> <span class="toc-text">Lab Multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Uthread-switching-between-threads"><span class="toc-number">4.1.</span> <span class="toc-text">Uthread: switching between threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">4.1.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">4.1.4.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using-threads"><span class="toc-number">4.2.</span> <span class="toc-text">Using threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.2.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C-1"><span class="toc-number">4.2.4.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Barrier"><span class="toc-number">4.3.</span> <span class="toc-text">Barrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C-2"><span class="toc-number">4.3.4.</span> <span class="toc-text">结果</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/23/virtio%E7%AE%80%E4%BB%8B/" title="virtio简介">virtio简介</a><time datetime="2024-08-23T15:05:52.000Z" title="发表于 2024-08-23 23:05:52">2024-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a><time datetime="2024-08-04T04:33:06.000Z" title="发表于 2024-08-04 12:33:06">2024-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/" title="qemu设备模型">qemu设备模型</a><time datetime="2024-07-31T15:38:12.000Z" title="发表于 2024-07-31 23:38:12">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="qemu内存模型">qemu内存模型</a><time datetime="2024-07-20T01:37:13.000Z" title="发表于 2024-07-20 09:37:13">2024-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/14/%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A0%88/" title="网卡与网络栈">网卡与网络栈</a><time datetime="2024-04-14T10:24:48.000Z" title="发表于 2024-04-14 18:24:48">2024-04-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By H4wk1ns</div><div class="footer_custom_text">come to hack me!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>