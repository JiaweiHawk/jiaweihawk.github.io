<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>xv6-九 | H4wk1ns's blog</title><meta name="keywords" content="内核,手写"><meta name="author" content="H4wk1ns"><meta name="copyright" content="H4wk1ns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言这篇博客研究xv6的文件系统机制 文件系统总览文件系统是用来管理持久型数据的子系统。由于其需要解决很多问题，所以其抽象层次非常复杂，如下所示 另一方面，文件系统也被称为on-disk data structure，其需要在磁盘中以一定的数据结构进行组织，从而可以让操作系统高效的将文件系统导出到磁盘或从磁盘导入到内存中，如下所示 Disk Layer设计Disk Layer用于抽象对磁盘的读写一">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6-九">
<meta property="og:url" content="https://jiaweihawk.github.io/2022/09/02/xv6-%E4%B9%9D/index.html">
<meta property="og:site_name" content="H4wk1ns&#39;s blog">
<meta property="og:description" content="前言这篇博客研究xv6的文件系统机制 文件系统总览文件系统是用来管理持久型数据的子系统。由于其需要解决很多问题，所以其抽象层次非常复杂，如下所示 另一方面，文件系统也被称为on-disk data structure，其需要在磁盘中以一定的数据结构进行组织，从而可以让操作系统高效的将文件系统导出到磁盘或从磁盘导入到内存中，如下所示 Disk Layer设计Disk Layer用于抽象对磁盘的读写一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiaweihawk.github.io/img/background.jpg">
<meta property="article:published_time" content="2022-09-02T01:59:45.000Z">
<meta property="article:modified_time" content="2024-10-16T15:08:39.104Z">
<meta property="article:author" content="H4wk1ns">
<meta property="article:tag" content="内核">
<meta property="article:tag" content="手写">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiaweihawk.github.io/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jiaweihawk.github.io/2022/09/02/xv6-%E4%B9%9D/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xv6-九',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-16 23:08:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/profile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">H4wk1ns's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">xv6-九</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-02T01:59:45.000Z" title="发表于 2022-09-02 09:59:45">2022-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-16T15:08:39.104Z" title="更新于 2024-10-16 23:08:39">2024-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%89%8B%E5%86%99/">手写</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="xv6-九"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>文件系统</strong>机制</p>
<h1 id="文件系统总览"><a href="#文件系统总览" class="headerlink" title="文件系统总览"></a>文件系统总览</h1><p>文件系统是用来管理<strong>持久型</strong>数据的子系统。<br>由于其需要解决很多问题，所以其抽象层次非常复杂，如下所示<br><img src="fs.png" alt="文件系统抽象层次"></p>
<p>另一方面，文件系统也被称为<strong>on-disk data structure</strong>，其需要在磁盘中以一定的数据结构进行组织，从而可以让操作系统高效的将文件系统<strong>导出到</strong>磁盘或从<strong>磁盘</strong>导入到内存中，如下所示<br><img src="disk.png" alt="磁盘数据布局"></p>
<h2 id="Disk-Layer"><a href="#Disk-Layer" class="headerlink" title="Disk Layer"></a>Disk Layer</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><strong>Disk Layer</strong>用于抽象对磁盘的读写<br>一般情况下，操作系统通过对磁盘的端口寄存器进行读写，从而完成对磁盘状态的控制和数据的读写。这也就是驱动</p>
<p>由于现实中有各种各样的磁盘，从而需要各种各样的驱动程序。为了隐藏这些实现细节，则通过<strong>Disk Layer</strong>将其抽象成统一的接口，即名称相同的函数指针<br>在驱动初始化时，将这些指针覆盖为驱动自己的函数。之后调用这些统一的接口，则相当于直接调用这些驱动的函数，从而将不同的驱动实现统一为了相同的接口</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于目前<strong>xv6</strong>仅仅涉及到<strong>QEMU</strong>的<strong>virtio disk</strong>设备，因此其仅仅实现了位于<strong>kernel/virtio_disk.c</strong>的该设备的驱动函数<strong>virtio_disk_rw()</strong>，并将其当做<strong>Disk Layer</strong>的接口</p>
<p>即当<strong>xv6</strong>需要读、写磁盘时，其会调用<strong>virtio_disk_rw()</strong>函数完成</p>
<h2 id="Buffer-Cache-Layer"><a href="#Buffer-Cache-Layer" class="headerlink" title="Buffer Cache Layer"></a>Buffer Cache Layer</h2><h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><p>由于磁盘读、写速度相比较内存访问慢很多，因此操作系统会缓存频繁访问的磁盘的<strong>block</strong>，从而避免每次重新从磁盘中缓慢的读取数据</p>
<p>而为了保证正确性，操作系统需要确保任何时候，操作系统中任何磁盘的<strong>block</strong>有至多一个<strong>cache</strong>；任何一个<strong>block</strong>的<strong>cache</strong>同时被至多一个进程访问。这些可以通过<a href="/2022/07/13/xv6-%E5%85%AB/" title="xv6-八">xv6-八</a>介绍的<strong>锁机制</strong>实现</p>
<p>一般情况下，操作系统中使用<strong>固定数量</strong>的<strong>buffer</strong>来缓存磁盘的<strong>block</strong>。当操作系统访问不在<strong>cache</strong>中的<strong>block</strong>时，其可能需要覆盖掉其他的<strong>buffer</strong>。为了尽可能减少读取磁盘的次数，每次选择覆盖掉<strong>Least Recently Used</strong>的<strong>buffer</strong>进行覆盖，因为一般<strong>Least Recently Used</strong>的<strong>buffer</strong>，也是最不可能再被重复使用的<strong>buffer</strong></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>xv6</strong>使用位于<strong>kernel/buf.h</strong>的<strong>struct buf</strong>结构体表示每一个<strong>buffer</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 1024  <span class="comment">// block size</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/buf.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>xv6</strong>使用位于<strong>kernel/bio.c</strong>的<strong>bcache</strong>结构，抽象整个<strong>Buffer Cache Layer</strong>, 如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></p>
<p>其中，<strong>xv6</strong>将<strong>Buffer Cache Layer</strong>中所有<strong>buffer</strong>通过静态数组的形式定义，并通过<strong>buffer</strong>的<strong>prev</strong>字段和<strong>next</strong>字段组织成双向链表。其中<strong>bcache.head</strong>的<strong>next</strong>方向是<strong>Less Recently Used</strong>的<strong>buffer</strong>(即<strong>bcache.head.next</strong>是<strong>Most Recently Used</strong>)；而<strong>prev</strong>恰恰相反，是<strong>More Recently Used</strong>(即<strong>bcache.head.prev</strong>是<strong>Least Recently Used</strong>)</p>
<h4 id="bget"><a href="#bget" class="headerlink" title="bget()"></a>bget()</h4><p><strong>Buffer Cache Layer</strong>中最重要的两个函数就是位于<strong>kernel/bio.c</strong>的<strong>bget()</strong>和<strong>brelse()</strong></p>
<p>其中，<strong>bget()</strong>，顾名思义，会从<strong>Buffer Cache Layer</strong>中申请一个指定设备的指定<strong>block</strong>的<strong>buffer</strong>。这里有几点需要特别注意</p>
<ol>
<li>当前待缓存的<strong>block</strong>，可能已经在<strong>Buffer Cache Layer</strong>中被缓存；或者在被释放的某个<strong>buffer</strong>，其仍然保留该<strong>block</strong>的缓存数据，未被清除。为了尽可能减少磁盘读取次数，则优先返回这些<strong>buffer</strong>，并使用其上的数据即可。由于当前访问的<strong>block</strong>，往往之前也会被访问，则基于<strong>Least Recently Used</strong>算法，从<strong>bcache.head.next</strong>(即<strong>Most Recently Used</strong>)，沿着<strong>next</strong>方向(即<strong>Less Recently Used</strong>)遍历即可</li>
<li>当申请到<strong>buffer</strong>后，再返回前需要获取锁，从而确保任何时候任何<strong>buffer</strong>，仅会被至多一个进程操作。如果有多个进程操作，可能会出现一个进程写；另一个进程读的情况，从而导致数据不一致</li>
</ol>
<h4 id="brelse"><a href="#brelse" class="headerlink" title="brelse()"></a>brelse()</h4><p><strong>brelse()</strong>，当<strong>xv6</strong>使用完<strong>buffer</strong>后，则<strong>xv6</strong>需要调用此函数释放<strong>buffer</strong></p>
<p>为了实现减少磁盘的读、写，这里释放<strong>buffer</strong>时，需要注意如下几点：</p>
<ol>
<li>释放<strong>buffer</strong>时，仅仅释放获取的<strong>lock</strong>和<strong>计数引用</strong>，其余诸如设备号、块号和块内容等不能清除，因为后续可能会快被重新使用</li>
<li>考虑到当前访问的块，很可能马上被继续访问，则将当前<strong>buffer</strong>移动到<strong>bcache.head.next</strong>位置(即<strong>Most Recently Used</strong>)，从而方便<strong>bget()</strong>复用这些数据</li>
</ol>
<h4 id="bread-bwrite"><a href="#bread-bwrite" class="headerlink" title="bread()/bwrite()"></a>bread()/bwrite()</h4><p>这里的逻辑很简单，通过<strong>Device Layer</strong>的<strong>virtio_disk_rw()</strong>，即可将磁盘的数据读入<strong>buffer</strong>；或将<strong>buffer</strong>中的数据写到磁盘中即可</p>
<p>需要注意的是，为了确保任何时候任何<strong>buffer</strong>被至多一个进程访问，其需要在上锁的情况下调用<strong>virtio_disk_rw()</strong></p>
<h2 id="Logging-Layer"><a href="#Logging-Layer" class="headerlink" title="Logging Layer"></a>Logging Layer</h2><h3 id="设计-2"><a href="#设计-2" class="headerlink" title="设计"></a>设计</h3><p><strong>Logging Layer</strong>用于文件系统的<strong>Crash Recovery</strong></p>
<p>在文件系统进行一系列的磁盘写入工作时，崩溃(如突然断电等)的发生会导致磁盘数据的不一致。操作系统往往会通过<strong>Logging Layer</strong>来解决这类问题</p>
<p>在正式进行磁盘的写入工作前，操作系统现将计划要写入的数据以<strong>log</strong>的形式写入磁盘中。当所有的<strong>log</strong>都成功写入后，再向磁盘中写入一个特殊的<strong>commit</strong>记录，表示当前<strong>log</strong>成功写入。之后开始正式的磁盘写入工作，当操作系统完成所有的磁盘写入工作后，操作系统会清除掉瓷盘中的<strong>log</strong>，表示本次写入的完成</p>
<p>通过<strong>Logging Layer</strong>，即使发生<strong>Crash</strong>，在每次操作系统重启时，也能恢复文件系统的一致性。更具体地说，如果重启后，磁盘中存在特殊的<strong>commit</strong>，则根据保存的<strong>log</strong>，重新执行磁盘的<strong>写入</strong>工作。对于其余的情况，则操作系统认为要么写入工作还没开始，要么已经成功完成，并不会导致磁盘的非一致性错误，则无需处理</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h4><p><strong>xv6</strong>使用位于<strong>kernel/buf.c</strong>的<strong>struct log</strong>来描述<strong>Logging Layer</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The log is a physical re-do log containing disk blocks.</span></span><br><span class="line"><span class="comment">// The on-disk log format:</span></span><br><span class="line"><span class="comment">//   header block, containing block #s for block A, B, C, ...</span></span><br><span class="line"><span class="comment">//   block A</span></span><br><span class="line"><span class="comment">//   block B</span></span><br><span class="line"><span class="comment">//   block C</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// Log appends are synchronous.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要特别注意的是，由于文件系统需要在内存或磁盘上导出或加载。因此文件系统的<strong>on-disk</strong>结构和<strong>in-memory</strong>结构有极大的关联性，但是往往也有较大的不一致。因为<strong>in-memory</strong>结构除了需要包含<strong>on-disk</strong>的数据，还需要包含一些运算所需要的数据结构，诸如<strong>spinlock</strong>等的结构会出现在<strong>in-memory</strong>结构，而不会出现在<strong>on-disk</strong>结构中</p>
<h4 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h4><p>在<strong>xv6</strong>的<strong>Logging Layer</strong>中，<strong>log</strong>的典型用法如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure></p>
<p>顾名思义，位于<strong>kernel/log.c</strong>的<strong>begin_op()</strong>函数表示写磁盘的<strong>准备操作</strong></p>
<p><strong>begin_op()</strong>需要在<strong>Logging Layer</strong>中申请<strong>log</strong>空间。为此，其需要获取相关的自旋锁，从而互斥的判断相关字段即可</p>
<p>这里需要特别说明的是，<strong>begin_op()</strong>和<strong>end_op()</strong>之间因当包含完整的<strong>写操作</strong>，即仅仅执行这些操作，仍然能保持磁盘数据的一致性。如果一次要写入的数据特别多，则应该拆分成诸如<strong>kernel/file.c</strong>的<strong>filewrite()</strong>的多个<strong>“原子”写操作</strong></p>
<h4 id="log-write"><a href="#log-write" class="headerlink" title="log_write()"></a>log_write()</h4><p>位于<strong>kenel/log.c</strong>的<strong>log_write()</strong>函数，将在正式执行<strong>写磁盘</strong>操作前，将要更新的<strong>block</strong>序号，写入到相关的<strong>in-memory</strong>的<strong>log</strong>数据中</p>
<p>这里需要特别注意的是，<strong>log_write()</strong>需要调用<strong>bpin()</strong>，增加相关<strong>block</strong>序号的<strong>buffer</strong>的引用计数，从而避免其被后续<strong>brelse()</strong>释放<strong>buffer()</strong>，导致更新内容丢失</p>
<h4 id="end-op"><a href="#end-op" class="headerlink" title="end_op()"></a>end_op()</h4><p>顾名思义，位于<strong>kernel/log.c</strong>的<strong>end_op()</strong>函数表示完成<strong>log</strong>的写入，将正式开始<strong>写磁盘</strong>操作</p>
<p>而<strong>写磁盘</strong>操作也分为以下几部分</p>
<ol>
<li>将此次<strong>写磁盘</strong>涉及的<strong>block</strong>数据(<strong>buffer</strong>中的更新数据)写入到磁盘的<strong>log</strong>部分</li>
<li>将当前的<strong>in-memory</strong>的<strong>log</strong>对象(主要是<strong>log header</strong>数据)写入到<strong>on-disk</strong>的<strong>log</strong>对象中。这也是前面提到的特殊的<strong>commit</strong>内容</li>
<li>将此次<strong>写磁盘</strong>涉及的<strong>block</strong>数据(<strong>buffer</strong>中的更新数据)写入到磁盘的<strong>data</strong>部分</li>
<li>清空<strong>in-memory</strong>的<strong>log header</strong>，并将其写入到<strong>on-disk</strong>的<strong>log</strong>对象，彻底完成一次<strong>写磁盘</strong>操作</li>
</ol>
<h2 id="Inode-Layer"><a href="#Inode-Layer" class="headerlink" title="Inode Layer"></a>Inode Layer</h2><h3 id="设计-3"><a href="#设计-3" class="headerlink" title="设计"></a>设计</h3><p><strong>Inode Layer</strong>用来抽象文件系统中的<strong>文件项</strong></p>
<p>正如前面所说的，文件系统的部分抽象层，往往包括<strong>in-memory</strong>表示和<strong>on-disk</strong>表示，而且<strong>in-memory</strong>表示往往比<strong>on-disk</strong>表示多了一些操作所需要的必须的数据结构,<strong>Inode Layer</strong>也不例外。对于<strong>on-disk</strong>的<strong>inode</strong>，其是描述一个文件或目录的大小和<strong>data block</strong>信息的数据结构；对于<strong>in-memory</strong>的<strong>inode</strong>，其就是<strong>on-disk</strong>的<strong>inode</strong>的拷贝，并且附带前面所说的内核所需要的必要结构信息</p>
<p>这里需要特别说明，为了减少磁盘读、写从而提高性能，操作系统会缓存<strong>inode</strong>，类似于<strong>Buffer Cache Layer</strong>——即释放<strong>inode</strong>时，仅仅减少该结构的引用计数，直到引用计数为0才最终释放<strong>inode</strong></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><h4 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h4><p><strong>xv6</strong>使用位于<strong>kernel/fs.h</strong>的<strong>struct dinode</strong>描述<strong>on-disk</strong>的<strong>inode</strong>；使用位于<strong>kernel/file.h</strong>的<strong>struct inode</strong>描述<strong>in-memory</strong>的<strong>inode</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里在特别分析一下<strong>inode</strong>如何表示<strong>文件/目录项</strong>，如下图所示<br><img src="inode.png" alt="inode示意图">。其数据在<strong>addrss1-address12</strong>和<strong>indirect</strong>所指向的<strong>data block</strong>中，但是存储的都是<strong>block</strong>块号，需要在具体的转换为<strong>block</strong>中数据才行</p>
<p>而<strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>icache</strong>结构描述<strong>inode</strong>缓冲，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; icache;</span><br></pre></td></tr></table></figure></p>
<h4 id="iget"><a href="#iget" class="headerlink" title="iget()"></a>iget()</h4><p>在<strong>xv6</strong>中，<strong>Inode Layer</strong>的经典用法如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip = iget(dev, inum)</span><br><span class="line">ilock(ip)</span><br><span class="line">... example and modify ip-&gt;XXX ...</span><br><span class="line">iunlock(ip)</span><br><span class="line">iput(ip)</span><br></pre></td></tr></table></figure></p>
<p><strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>iget()</strong>函数，在<strong>inode</strong>缓冲中分配对应的<strong>inode</strong></p>
<p>根据前面的分析，如果该<strong>inode</strong>已经被缓存，则添加<strong>引用计数ref</strong>即可；否则找到可以覆盖的<strong>inode</strong>缓冲，并初始化即可</p>
<p>需要特别注意的是，在<strong>iget()</strong>函数中并不会实际载入磁盘中的数据，仅仅初始化<strong>in-memory</strong>的<strong>inode</strong>中必要的数据结构而已</p>
<h4 id="ilock"><a href="#ilock" class="headerlink" title="ilock()"></a>ilock()</h4><p><strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>ilock()</strong>函数，从而方便进程互斥的访问<strong>inode</strong>。一般当进程需要上锁时，则表明需要读、写资源，也就是进程会访问或更改<strong>inode</strong>数据，因此这里会将<strong>inode</strong>的<strong>on-disk</strong>数据加载到内存中，方便后续的操作</p>
<p>需要说明的是，这里仅仅加载<strong>inode</strong>的<strong>控制信息</strong>和部分<strong>数据信息</strong>，<strong>inode</strong>的所有数据信息都会通过<strong>bmap()</strong>函数，获取数据对应的<strong>block</strong>号，在使用<strong>bget()</strong>进行访问即可</p>
<h4 id="iput"><a href="#iput" class="headerlink" title="iput()"></a>iput()</h4><p><strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>iput()</strong>函数，释放<strong>inode</strong>，即减少<strong>inode</strong>的引用计数即可</p>
<p>需要特别注意的是，当<strong>inode</strong>的引用计数为0时，则表明此时对于<strong>inode</strong>表示的文件或目录操作结束，此时应当判断一下该文件是否应该被删除，即判断<strong>nlink</strong>字段是否为0，从而完成相关的删除操作即可</p>
<h2 id="Directory-Layer"><a href="#Directory-Layer" class="headerlink" title="Directory Layer"></a>Directory Layer</h2><h3 id="设计-4"><a href="#设计-4" class="headerlink" title="设计"></a>设计</h3><p><strong>Directory Layer</strong>是用来抽象文件系统中的目录</p>
<p>实际上，目录就是一种特殊的文件——其内容就是一系列的<strong>目录项</strong>序列</p>
<p>一般来说，每一个<strong>目录项</strong>包含目录项的名称和目录项指向的文件<strong>inode</strong>的<strong>block</strong>块号，从而可以很好的抽象目录</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>正如前面分析的，<strong>目录</strong>是一种<strong>特殊</strong>的<strong>文件</strong>，所以<strong>xv6</strong>也使用位于<strong>kernel/fs.h</strong>的<strong>struct dinode</strong>和位于<strong>kernel/file.h</strong>的<strong>struct inode</strong>进行描述</p>
<p>但由于<strong>目录</strong>中的数据内容都是<strong>目录项</strong>，<strong>xv6</strong>使用位于<strong>kernel/fs.h</strong>的<strong>struct dirent</strong>描述<strong>目录项</strong></p>
<h4 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup()"></a>dirlookup()</h4><p><strong>Directory Layer</strong>中最重要的，即在<strong>目录</strong>中找到对应的<strong>目录项</strong>。<strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>dirlookup()</strong>来实现该功能</p>
<p>其逻辑也很简单，也就是以<strong>目录项</strong>的格式，依次遍历当前<strong>目录</strong>数据即可</p>
<h2 id="Pathname-Layer"><a href="#Pathname-Layer" class="headerlink" title="Pathname Layer"></a>Pathname Layer</h2><h3 id="设计-5"><a href="#设计-5" class="headerlink" title="设计"></a>设计</h3><p><strong>Pathname Layer</strong>用来将<strong>human-friendly</strong>的路径，转换为<strong>Machine-friendly</strong>的<strong>Inode Layer</strong>的<strong>Inode</strong></p>
<p>在直白一些，就是将<strong>树状</strong>文件系统，转换为<strong>on-disk</strong>文件系统。操作系统通过迭代查找<strong>目录</strong>，从而将<strong>路径信息</strong>转换为对应的<strong>inode</strong>，方便后续操作</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h4 id="namex"><a href="#namex" class="headerlink" title="namex()"></a>namex()</h4><p>正如前面分析的，<strong>Pathname Layer</strong>主要就是通过迭代目录，从而转化为对应文件的<strong>inode</strong></p>
<p><strong>xv6</strong>通过<strong>namex()</strong>，非常精巧的实现了该要求。其<strong>namex()</strong>函数的定义就非常巧妙，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure></p>
<p>即如果要查找父目录，则<strong>namex()</strong>返回父目录的<strong>inode</strong>，而<strong>name</strong>则被设置为剩余的路径元素信息，方便后续的文件查找；如果要查找的是该文件，则<strong>namex()</strong>直接返回该文件的<strong>inode</strong>，而<strong>name</strong>则被设置为<strong>NULL</strong></p>
<p>这个<strong>API</strong>极大的拓展了<strong>Pathname Layer</strong>的灵活性，其实现也非常巧妙，特别是<strong>skipelem()</strong>的实现，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the next path element from path into name.</span></span><br><span class="line"><span class="comment">// Return a pointer to the element following the copied one.</span></span><br><span class="line"><span class="comment">// The returned path has no leading slashes,</span></span><br><span class="line"><span class="comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one.</span></span><br><span class="line"><span class="comment">// If no name to remove, return 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*</span><br><span class="line"><span class="title function_">skipelem</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  s = path;</span><br><span class="line">  <span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="number">0</span>)</span><br><span class="line">    path++;</span><br><span class="line">  len = path - s;</span><br><span class="line">  <span class="keyword">if</span>(len &gt;= DIRSIZ)</span><br><span class="line">    memmove(name, s, DIRSIZ);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    memmove(name, s, len);</span><br><span class="line">    name[len] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即<strong>skipelem()</strong>在迭代路径时，提供了一次迭代所需要的充足信息，所以实现的逻辑非常清晰和优雅，值得好好学习!</p>
<h2 id="File-Descriptor-Layer"><a href="#File-Descriptor-Layer" class="headerlink" title="File Descriptor Layer"></a>File Descriptor Layer</h2><h3 id="设计-6"><a href="#设计-6" class="headerlink" title="设计"></a>设计</h3><p><strong>File Descriptor Layer</strong>用来将操作系统的各种资源(例如<strong>pipes</strong>、<strong>devies</strong>等)抽象为统一的系统接口——<strong>File Descriptor</strong></p>
<p>操作系统一般会给每个进程一个独立的打开文件表，其中每一个都是资源(例如<strong>inode</strong>、<strong>device</strong>等)的包装。而这些打开文件表的表项，都被操作系统全局的文件表维护</p>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><strong>xv6</strong>使用位于<strong>kernel/file.h</strong>的<strong>struct file</strong>描述<strong>File Descriptor</strong>接口，使用位于<strong>kernel/proc.h</strong>的<strong>proc-&gt;ofile</strong>描述进程的打开文件，使用位于<strong>kernel/file.c</strong>的<strong>ftable</strong>描述操作系统中所有的打开文件，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/file.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure></p>
<h1 id="Lab-file-system"><a href="#Lab-file-system" class="headerlink" title="Lab file system"></a>Lab file system</h1><p>本次<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/fs.html">lab</a>用来加深对于<strong>xv6</strong>的<strong>文件系统</strong>机制的理解</p>
<h2 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote>
<p>Modify <strong>bmap()</strong> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <strong>ip-&gt;addrs[]</strong> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <strong>bigfile</strong> writes 65803 blocks and <strong>usertests</strong> runs successfully: </p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果要添加<strong>inode</strong>的<strong>doubly-indirect block</strong>的支持，则参考下图，更改所有涉及<strong>inode</strong>的<strong>data block</strong>的数据结构和操作即可<br><img src="inode.png" alt="inode示意图"></p>
<p>总的来说，涉及到<strong>inode</strong>的<strong>data block</strong>细节的，只有<strong>on-disk</strong>的<strong>struct dinode</strong>结构和<strong>in-memory</strong>的<strong>struct inode</strong>，相关的宏以及获取<strong>data block</strong>块号的<strong>bmap()</strong>和清空<strong>data block</strong>的<strong>itrunc()</strong></p>
<h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><p>首先，我们将<strong>inode</strong>的<strong>data block</strong>布局，更改为<strong>11</strong>个<strong>direct block</strong>、<strong>1</strong>个<strong>indirect block</strong>和<strong>1</strong>个<strong>doubly indirect block</strong>，即更改<strong>struct dinode</strong>和<strong>struct inode</strong>的<strong>arrays</strong>字段，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT     11                                <span class="comment">//Number of direct data block</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDE       1                                 <span class="comment">//Number of indirect data entries</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBPIND      (BSIZE / sizeof(uint))            <span class="comment">//Number of data block per indirect entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT   (NINDE * NBPIND)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDINDE      1                                 <span class="comment">//Number of doubly indirect data enties</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDEPDIND  (BSIZE / sizeof(uint))            <span class="comment">//Number of indirect data entries per doubly indirect entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBPDIND     (NINDEPDIND * NBPIND)             <span class="comment">//Number of data block per doubly indirect entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDINDIRECT  (NDINDE * NBPDIND)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE     (NDIRECT + NINDIRECT + NDINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+NINDE+NDINDE];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+NINDE+NDINDE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其次来重构<strong>bmap()</strong>函数，其思路非常简单——由于<strong>inode</strong>的<strong>data block</strong>按照<strong>direct block</strong>、<strong>indirect block</strong>和<strong>doubly indirect block</strong>顺序排列，可以简单理解为将一维数组的下标解析为三维数组的坐标</p>
<p>对于<strong>direct block</strong>，其<strong>arrays</strong>数组中存储的就是<strong>data block</strong>的块号，则直接返回即可；对于<strong>indirect block</strong>，其<strong>arrays</strong>数组中存储的是<strong>direct block</strong>的块号，还需要再载入<strong>direct block</strong>块这一个步骤；类似的，对于<strong>doubly indirect block</strong>，其<strong>arrays</strong>数组中存储的时<strong>indirect block</strong>块号，还需要再载入<strong>indirect block</strong>、接着载入<strong>direct block</strong>块两个步骤，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+bn/NBPIND]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+bn/NBPIND] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">    bn %= NBPIND;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load doubly indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+NINDE+bn/NBPDIND]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+NINDE+bn/NBPDIND] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    bn %= NBPDIND;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn/NBPIND]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn/NBPIND] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    bn %= NBPIND;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后则是重构<strong>itrunc()</strong>，其依次遍历<strong>inode</strong>的<strong>direct block</strong>、<strong>indirect block</strong>和<strong>doubly indirect block</strong>，将这些<strong>block</strong>和这些block包含的<strong>data block</strong>通过<strong>bfree()</strong>释放掉即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp1</span>, *<span class="title">bp2</span>;</span></span><br><span class="line">  uint *a1, *a2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free direct data blocks</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free indirect data blocks</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINDE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+i]) &#123;</span><br><span class="line">      bp1 = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+i]);</span><br><span class="line">      a1 = (uint*)bp1-&gt;data;</span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NBPIND; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a1[j])</span><br><span class="line">          bfree(ip-&gt;dev, a1[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      brelse(bp1);</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+i]);</span><br><span class="line">      ip-&gt;addrs[NDIRECT+i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free doubly indirect data blocks</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDINDE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+NINDE+i]) &#123;</span><br><span class="line">      bp1 = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+NINDE+i]);</span><br><span class="line">      a1 = (uint*)bp1-&gt;data;</span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDEPDIND; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a1[j]) &#123;</span><br><span class="line">          bp2 = bread(ip-&gt;dev, a1[j]);</span><br><span class="line">          a2 = (uint*)bp2-&gt;data;</span><br><span class="line">          <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; NBPIND; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a2[k])</span><br><span class="line">              bfree(ip-&gt;dev, a2[k]);</span><br><span class="line">          &#125;</span><br><span class="line">          brelse(bp2);</span><br><span class="line">          bfree(ip-&gt;dev, a1[j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      brelse(bp1);</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+NINDE+i]);</span><br><span class="line">      ip-&gt;addrs[NDIRECT+NINDE+i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;bigfile&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="bigfile实验结果.png" alt="bigfile实验结果"></p>
<h2 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote>
<p>You will implement the <strong>symlink(char <em>target, char </em>path)</strong> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding).<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ symlinktest</span><br><span class="line">Start: <span class="built_in">test</span> symlinks</span><br><span class="line"><span class="built_in">test</span> symlinks: ok</span><br><span class="line">Start: <span class="built_in">test</span> concurrent symlinks</span><br><span class="line"><span class="built_in">test</span> concurrent symlinks: ok</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于文件系统在解析<strong>符号链接</strong>文件时，会采用和其他文件类型完全不同的方式，因此可以添加新的文件类型即可</p>
<p>而为了完成<strong>符号链接</strong>功能，则重构系统调用中涉及文件系统的部分，添加<strong>符号链接</strong>类型的功能支持即可</p>
<h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><p>首先，在<strong>xv6</strong>中添加<strong>symlink</strong>系统调用，即添加相关的系统调用号和系统调用声明，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_symlink 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">[SYS_symlink] sys_symlink,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;symlink&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>其次则是实现系统调用<strong>symlink()</strong>，即完成必要的检查后，创建相关的<strong>符号链接</strong>类型的文件即可。其中根据要求，<strong>符号链接</strong>类型的文件内容是传入的路径字符串即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a symbol file pointing to the given path</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], linkpath[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, linkpath, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>((ip = create(linkpath, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the target to the inode</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) != MAXPATH)</span><br><span class="line">    panic(<span class="string">&quot;symlink: writei&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面则是添加<strong>符号链接</strong>的操作。实际上，<strong>符号链接</strong>的作用，就是路径替换，即解析该<strong>符号链接</strong>时，相当于解析其替换的文件。在具体一些，在<strong>xv6</strong>中，即解析其替换的文件的<strong>inode</strong>。因此，可以通过更改<strong>open</strong>系统调用，返回其实际指向的文件的<strong>inode</strong>即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode, iterate;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ilock(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deal with symlink file</span></span><br><span class="line">    <span class="keyword">if</span>((omode &amp; O_NOFOLLOW) == <span class="number">0</span>) &#123;</span><br><span class="line">      iterate = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">        <span class="keyword">if</span>((readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH)) != MAXPATH || iterate++ &gt;= MAXITER) &#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;symlink&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="symlink实验结果.png" alt="symlink实验结果"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">H4wk1ns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiaweihawk.github.io/2022/09/02/xv6-%E4%B9%9D/">https://jiaweihawk.github.io/2022/09/02/xv6-九/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiaweihawk.github.io" target="_blank">H4wk1ns's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E6%A0%B8/">内核</a><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%86%99/">手写</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/26/LinuxFoundation-mentorship/"><img class="prev-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LinuxFoundation mentorship</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/11/%E5%88%86%E5%8C%BA-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分区-文件系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/04/xv6-七/" title="xv6-七"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-04</div><div class="title">xv6-七</div></div></a></div><div><a href="/2022/05/26/xv6-三/" title="xv6-三"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-26</div><div class="title">xv6-三</div></div></a></div><div><a href="/2022/05/21/xv6-二/" title="xv6-二"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-21</div><div class="title">xv6-二</div></div></a></div><div><a href="/2022/06/11/xv6-五/" title="xv6-五"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">xv6-五</div></div></a></div><div><a href="/2022/07/13/xv6-八/" title="xv6-八"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-13</div><div class="title">xv6-八</div></div></a></div><div><a href="/2022/06/14/xv6-六/" title="xv6-六"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-14</div><div class="title">xv6-六</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/profile.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">H4wk1ns</div><div class="author-info__description">coder && ctfer</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jiaweihawk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/static/cv/cv_zh.pdf" target="_blank" title="个人简历"><i class="fa-solid fa-file-pdf"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88"><span class="toc-number">2.</span> <span class="toc-text">文件系统总览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Disk-Layer"><span class="toc-number">2.1.</span> <span class="toc-text">Disk Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer-Cache-Layer"><span class="toc-number">2.2.</span> <span class="toc-text">Buffer Cache Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bget"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">bget()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#brelse"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">brelse()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bread-bwrite"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">bread()&#x2F;bwrite()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logging-Layer"><span class="toc-number">2.3.</span> <span class="toc-text">Logging Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#begin-op"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">begin_op()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log-write"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">log_write()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#end-op"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">end_op()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inode-Layer"><span class="toc-number">2.4.</span> <span class="toc-text">Inode Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-2"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iget"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">iget()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ilock"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">ilock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iput"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">iput()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Directory-Layer"><span class="toc-number">2.5.</span> <span class="toc-text">Directory Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dirlookup"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">dirlookup()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pathname-Layer"><span class="toc-number">2.6.</span> <span class="toc-text">Pathname Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#namex"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">namex()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-Descriptor-Layer"><span class="toc-number">2.7.</span> <span class="toc-text">File Descriptor Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-6"><span class="toc-number">2.7.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">2.7.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab-file-system"><span class="toc-number">3.</span> <span class="toc-text">Lab file system</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Large-files"><span class="toc-number">3.1.</span> <span class="toc-text">Large files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">3.1.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">3.1.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">3.1.4.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbolic-links"><span class="toc-number">3.2.</span> <span class="toc-text">Symbolic links</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">3.2.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">结果</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/23/virtio%E7%AE%80%E4%BB%8B/" title="virtio简介">virtio简介</a><time datetime="2024-08-23T15:05:52.000Z" title="发表于 2024-08-23 23:05:52">2024-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a><time datetime="2024-08-04T04:33:06.000Z" title="发表于 2024-08-04 12:33:06">2024-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/" title="qemu设备模型">qemu设备模型</a><time datetime="2024-07-31T15:38:12.000Z" title="发表于 2024-07-31 23:38:12">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="qemu内存模型">qemu内存模型</a><time datetime="2024-07-20T01:37:13.000Z" title="发表于 2024-07-20 09:37:13">2024-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/14/%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A0%88/" title="网卡与网络栈">网卡与网络栈</a><time datetime="2024-04-14T10:24:48.000Z" title="发表于 2024-04-14 18:24:48">2024-04-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By H4wk1ns</div><div class="footer_custom_text">come to hack me!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>