<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>qemu的PCI设备 | H4wk1ns's blog</title><meta name="keywords" content="qemu,虚拟化"><meta name="author" content="H4wk1ns"><meta name="copyright" content="H4wk1ns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言PCI(Peripheral Component Interconnect)是一种连接电脑主板和外部设备的总线标准，其从1992年提出之后就逐渐取代了其他各种总线，被各种处理器所支持，在x86硬件体系结构中几乎所有设备都以各种形式连接到PCI设备树上。因为，想要更好的了解Qemu设备模拟的细节就需要从PCI入手。 PCI基础PCI总线结构下图是一个经典的PCI总线架构图 可以看到，PCI总线由">
<meta property="og:type" content="article">
<meta property="og:title" content="qemu的PCI设备">
<meta property="og:url" content="https://jiaweihawk.github.io/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/index.html">
<meta property="og:site_name" content="H4wk1ns&#39;s blog">
<meta property="og:description" content="前言PCI(Peripheral Component Interconnect)是一种连接电脑主板和外部设备的总线标准，其从1992年提出之后就逐渐取代了其他各种总线，被各种处理器所支持，在x86硬件体系结构中几乎所有设备都以各种形式连接到PCI设备树上。因为，想要更好的了解Qemu设备模拟的细节就需要从PCI入手。 PCI基础PCI总线结构下图是一个经典的PCI总线架构图 可以看到，PCI总线由">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiaweihawk.github.io/img/background.jpg">
<meta property="article:published_time" content="2024-08-04T04:33:06.000Z">
<meta property="article:modified_time" content="2024-10-16T15:08:39.066Z">
<meta property="article:author" content="H4wk1ns">
<meta property="article:tag" content="qemu">
<meta property="article:tag" content="虚拟化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiaweihawk.github.io/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jiaweihawk.github.io/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'qemu的PCI设备',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-16 23:08:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/profile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">H4wk1ns's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">qemu的PCI设备</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-04T04:33:06.000Z" title="发表于 2024-08-04 12:33:06">2024-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-16T15:08:39.066Z" title="更新于 2024-10-16 23:08:39">2024-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="qemu的PCI设备"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PCI(Peripheral Component Interconnect)是一种连接电脑主板和外部设备的总线标准，其从1992年提出之后就逐渐取代了其他各种总线，被各种处理器所支持，在x86硬件体系结构中几乎所有设备都以各种形式连接到PCI设备树上。因为，想要更好的了解Qemu设备模拟的细节就需要从PCI入手。</p>
<h1 id="PCI基础"><a href="#PCI基础" class="headerlink" title="PCI基础"></a>PCI基础</h1><h2 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h2><p>下图是一个经典的PCI总线架构图<br><img src="pci总线架构.png" alt="PCI总线架构图"></p>
<p>可以看到，PCI总线由三个基本组件构成</p>
<ul>
<li>PCI设备(PCI device)<br>  符合<a target="_blank" rel="noopener" href="https://members.pcisig.com/wg/PCI-SIG/document/download/8237">PCI总线标准</a>(这里额外说明一下，PCI标准文档只允许PCI-SIG成员访问，可以尝试用公司邮箱登录访问)的设备就称为PCI设备，其能按照PCI总线标准进行交互。</li>
<li>PCI总线(PCI bus)<br>  用以连接多个PCI设备/PCI桥的通信干道</li>
<li>PCI桥(PCI bridge)<br>  总线之间的链接枢纽，可以连接CPU与PCI总线、PCI主总线与PCI次总线等</li>
</ul>
<h2 id="PCI设备编号"><a href="#PCI设备编号" class="headerlink" title="PCI设备编号"></a>PCI设备编号</h2><p>每个PCI设备在系统中的位置由总线编号(Bus Number)、设备编号(Device Number)和功能编号(Function Number)唯一确定</p>
<h2 id="PCI配置空间"><a href="#PCI配置空间" class="headerlink" title="PCI配置空间"></a>PCI配置空间</h2><p>每个PCI设备都有单独的存储空间，被称为PCI配置空间。</p>
<p>操作系统可以通过<strong>pio</strong>命令，通过访问<strong>CONFIG_ADDRESS(0xcf8)</strong>和<strong>CONFIG_DATA(0xcfc)</strong>寄存器来与PCI配置空间进行交互。这两个寄存器都是32bit，其中<strong>CONFIG_ADDRESS</strong>寄存器格式如下所示<br><img src="CONFIG_ADDRESS寄存器格式.png" alt="CONFIG_ADDRESS寄存器格式"></p>
<ul>
<li>bit31是<strong>CONFIG_DATA</strong>寄存器的使能位</li>
<li>bit30~24为保留位</li>
<li>bit23~16为总线编号</li>
<li>bit15~11为设备编号</li>
<li>bit10~8为功能编号</li>
<li>bit7~2为配置空间中32bit寄存器编号</li>
<li>bit1-0为只读0</li>
</ul>
<p>而<strong>CONFIG_DATA</strong>寄存器中的值是<strong>CONFIG_ADDRESS</strong>寄存器中指定配置空间内指定寄存器的数值。因此，操作系统与PCI设备配置空间的交互方式为</p>
<ul>
<li>向<strong>CONFIG_ADDRESS</strong>寄存器中写入要读/写的位置</li>
<li>从<strong>CONFIG_DATA</strong>寄存器中读/写数据</li>
</ul>
<p>PCI配置空间有多种格式，其中所有PCI设备的配置空间都有如下的Type 00格式头<br><img src="PCI设备配置空间头.png" alt="PCI设备配置空间头"></p>
<p>这里着重说明一下配置空间头的<strong>BAR(Base Address Register)</strong>寄存器，其用来定义该PCI设备占用的地址空间信息，格式如下所示<br><img src="BAR格式.png" alt="BAR格式"></p>
<p>操作系统与配置空间头的交互方式为</p>
<ul>
<li>操作系统向<strong>BAR</strong>写入<strong>所有bit都为1</strong>的值</li>
<li>操作系统读取<strong>BAR</strong>值，并将其翻转并加一，得到的即为该<strong>BAR</strong>所需要的地址空间大小</li>
<li>操作系统从对应地址空间中分配该大小的空间，并将空间地址写入<strong>BAR</strong>，完成<strong>BAR</strong>的设置</li>
</ul>
<h1 id="Qemu模拟"><a href="#Qemu模拟" class="headerlink" title="Qemu模拟"></a>Qemu模拟</h1><p>根据<a href="#PCI总线结构">PCI总线结构</a>中的介绍，一个经典的PCI总线包含PCI设备、PCI桥和PCI总线等三部分，则Qemu对这些部分都有相应的模拟。</p>
<h2 id="PCI桥"><a href="#PCI桥" class="headerlink" title="PCI桥"></a>PCI桥</h2><p>实际上，PCI桥也分多种类型，包括PCI-Host桥和PCI-PCI桥等。这里主要介绍PCI-Host桥，即连接CPU与PCI总线。</p>
<p>Qemu使用<strong>PCIHost</strong>对其进行模拟，其<strong>TypeInfo</strong>变量<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L257"><strong>pci_host_type_info</strong></a>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_host_type_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_HOST_BRIDGE,</span><br><span class="line">    .parent = TYPE_SYS_BUS_DEVICE,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIHostBridgeClass),</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIHostState),</span><br><span class="line">    .class_init = pci_host_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_host.h#L53"><strong>struct PCIHostBridgeClass</strong></a>和<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_host.h#L39"><strong>struct PCIHostState</strong></a>来表征<strong>PCIHost</strong></p>
<h4 id="struct-PCIHostBridgeClass"><a href="#struct-PCIHostBridgeClass" class="headerlink" title="struct PCIHostBridgeClass"></a>struct PCIHostBridgeClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIHostBridgeClass</span> &#123;</span></span><br><span class="line">    SysBusDeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *(*root_bus_path)(PCIHostState *, PCIBus *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="struct-PCIHostState"><a href="#struct-PCIHostState" class="headerlink" title="struct PCIHostState"></a>struct PCIHostState</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIHostState</span> &#123;</span></span><br><span class="line">    SysBusDevice busdev;</span><br><span class="line"></span><br><span class="line">    MemoryRegion conf_mem;</span><br><span class="line">    MemoryRegion data_mem;</span><br><span class="line">    MemoryRegion mmcfg;</span><br><span class="line">    <span class="type">uint32_t</span> config_reg;</span><br><span class="line">    <span class="type">bool</span> mig_enabled;</span><br><span class="line">    PCIBus *bus;</span><br><span class="line">    <span class="type">bool</span> bypass_iommu;</span><br><span class="line"></span><br><span class="line">    QLIST_ENTRY(PCIHostState) next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<strong>conf_mem</strong>字段是前面<a href="#PCI配置空间">PCI配置空间</a>中<strong>CONFIG_ADDRESS</strong>地址空间的<strong>MemoryRegion</strong>，<strong>config_reg</strong>是该地址空间的数据。<strong>data_mem</strong>字段是<strong>CONFIG_DATA</strong>地址空间的<strong>MemoryRegion</strong>，而该地址空间是<strong>CONFIG_ADDRESS</strong>指定的设备的配置空间寄存器，自然应当在指定PCI设备的数据结构中而不在这里存储。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>由于<strong>PCIHost</strong>仅仅是一个接口类，没有具体内容，这里用<strong>I440FX-PCIHost</strong>进行分析，其<strong>TypeInfo</strong>变量<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L397"><strong>i440fx_pcihost_info</strong></a>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo i440fx_pcihost_info = &#123;</span><br><span class="line">    .name          = TYPE_I440FX_PCI_HOST_BRIDGE,</span><br><span class="line">    .parent        = TYPE_PCI_HOST_BRIDGE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(I440FXState),</span><br><span class="line">    .instance_init = i440fx_pcihost_initfn,</span><br><span class="line">    .class_init    = i440fx_pcihost_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h4><p>Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L368"><strong>i440fx_pcihost_class_init()</strong></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i440fx_pcihost_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    hc-&gt;root_bus_path = i440fx_pcihost_root_bus_path;</span><br><span class="line">    dc-&gt;realize = i440fx_pcihost_realize;</span><br><span class="line">    dc-&gt;fw_name = <span class="string">&quot;pci&quot;</span>;</span><br><span class="line">    device_class_set_props(dc, i440fx_props);</span><br><span class="line">    <span class="comment">/* Reason: needs to be wired up by pc_init1 */</span></span><br><span class="line">    dc-&gt;user_creatable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE_START, <span class="string">&quot;uint32&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole_start,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE_END, <span class="string">&quot;uint32&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole_end,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE64_START, <span class="string">&quot;uint64&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole64_start,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    object_class_property_add(klass, PCI_HOST_PROP_PCI_HOLE64_END, <span class="string">&quot;uint64&quot;</span>,</span><br><span class="line">                              i440fx_pcihost_get_pci_hole64_end,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要设置了<strong>realize</strong>函数指针为<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L249"><strong>i440fx_pcihost_realize()</strong></a></p>
<h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci-host/i440fx.c#L368"><strong>i440fx_pcihost_initfn()</strong></a>初始化对象<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i440fx_pcihost_initfn</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    I440FXState *s = I440FX_PCI_HOST_BRIDGE(obj);</span><br><span class="line">    PCIHostState *phb = PCI_HOST_BRIDGE(obj);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;phb-&gt;conf_mem, obj, &amp;pci_host_conf_le_ops, phb,</span><br><span class="line">                          <span class="string">&quot;pci-conf-idx&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    memory_region_init_io(&amp;phb-&gt;data_mem, obj, &amp;pci_host_data_le_ops, phb,</span><br><span class="line">                          <span class="string">&quot;pci-conf-data&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_RAM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;ram_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_PCI_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;pci_address_space,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_SYSTEM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;system_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, PCI_HOST_PROP_IO_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;io_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，其使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L202"><strong>pci_host_conf_le_ops</strong></a>和<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L214"><strong>pci_host_data_le_ops</strong></a>初始化了<strong>PCIHost</strong>的<strong>conf_mem</strong>字段和<strong>data_mem</strong>字段，这些回调函数的内容如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> MemoryRegionOps pci_host_conf_be_ops = &#123;</span><br><span class="line">    .read = pci_host_config_read,</span><br><span class="line">    .write = pci_host_config_write,</span><br><span class="line">    .endianness = DEVICE_BIG_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> MemoryRegionOps pci_host_data_le_ops = &#123;</span><br><span class="line">    .read = pci_host_data_read,</span><br><span class="line">    .write = pci_host_data_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_config_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    PCI_DPRINTF(<span class="string">&quot;%s addr &quot;</span> HWADDR_FMT_plx <span class="string">&quot; len %d val %&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                __func__, addr, len, val);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="number">0</span> || len != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;config_reg = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">pci_host_config_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                     <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> val = s-&gt;config_reg;</span><br><span class="line"></span><br><span class="line">    PCI_DPRINTF(<span class="string">&quot;%s addr &quot;</span> HWADDR_FMT_plx <span class="string">&quot; len %d val %&quot;</span>PRIx32<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                __func__, addr, len, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_data_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;config_reg &amp; (<span class="number">1u</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">        pci_data_write(s-&gt;bus, s-&gt;config_reg | (addr &amp; <span class="number">3</span>), val, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">pci_host_data_read</span><span class="params">(<span class="type">void</span> *opaque,</span></span><br><span class="line"><span class="params">                                   hwaddr addr, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;config_reg &amp; (<span class="number">1U</span> &lt;&lt; <span class="number">31</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pci_data_read(s-&gt;bus, s-&gt;config_reg | (addr &amp; <span class="number">3</span>), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_data_write</span><span class="params">(PCIBus *s, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);</span><br><span class="line">    <span class="type">uint32_t</span> config_addr = addr &amp; (PCI_CONFIG_SPACE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pci_dev) &#123;</span><br><span class="line">        trace_pci_cfg_write(<span class="string">&quot;empty&quot;</span>, extract32(addr, <span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">                            extract32(addr, <span class="number">11</span>, <span class="number">5</span>), extract32(addr, <span class="number">8</span>, <span class="number">3</span>),</span><br><span class="line">                            config_addr, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_host_config_write_common(pci_dev, config_addr, PCI_CONFIG_SPACE_SIZE,</span><br><span class="line">                                 val, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pci_data_read</span><span class="params">(PCIBus *s, <span class="type">uint32_t</span> addr, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);</span><br><span class="line">    <span class="type">uint32_t</span> config_addr = addr &amp; (PCI_CONFIG_SPACE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pci_dev) &#123;</span><br><span class="line">        trace_pci_cfg_read(<span class="string">&quot;empty&quot;</span>, extract32(addr, <span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">                           extract32(addr, <span class="number">11</span>, <span class="number">5</span>), extract32(addr, <span class="number">8</span>, <span class="number">3</span>),</span><br><span class="line">                           config_addr, ~<span class="number">0x0</span>);</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pci_host_config_read_common(pci_dev, config_addr,</span><br><span class="line">                                       PCI_CONFIG_SPACE_SIZE, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，这里就是Qemu模拟的前面<a href="#PCI配置空间">PCI配置空间</a>中<strong>CONFIG_ADDRESS</strong>和<strong>CONFIG_DATA</strong>的逻辑。但这里未将<strong>MemoryRegion</strong>绑定到对应的地址空间，那只能是在实例化的时候绑定的</p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  i440fx_pcihost_realize (dev=0x5555573de800, errp=0x7fffffffd420) at ../../qemu/hw/pci-host/i440fx.c:250</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e9c4f4 in device_set_realized (obj=0x5555573de800, value=true, errp=0x7fffffffd530) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea7cfb in property_set_bool (obj=0x5555573de800, v=0x5555573dfd30, name=0x5555562f9dd1 &quot;realized&quot;, opaque=0x5555570f4510, errp=0x7fffffffd530) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea5891 in object_property_set (obj=0x5555573de800, name=0x5555562f9dd1 &quot;realized&quot;, v=0x5555573dfd30, errp=0x7fffffffd530) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#4  0x0000555555eaa4ca in object_property_set_qobject (obj=0x5555573de800, name=0x5555562f9dd1 &quot;realized&quot;, value=0x5555573dfa50, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea5c4a in object_property_set_bool (obj=0x5555573de800, name=0x5555562f9dd1 &quot;realized&quot;, value=true, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e9bc0e in qdev_realize (dev=0x5555573de800, bus=0x555557360240, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e9bc47 in qdev_realize_and_unref (dev=0x5555573de800, bus=0x555557360240, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/hw/core/qdev.c:299</span></span><br><span class="line"><span class="comment">//#8  0x0000555555966b7a in sysbus_realize_and_unref (dev=0x5555573de800, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/hw/core/sysbus.c:261</span></span><br><span class="line"><span class="comment">//#9  0x0000555555cb292b in pc_init1 (machine=0x555557357800, pci_type=0x5555562ab7db &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:212</span></span><br><span class="line"><span class="comment">//#10 0x0000555555cb35e3 in pc_init_v9_0 (machine=0x555557357800) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment">//#11 0x000055555595f8be in machine_run_board_init (machine=0x555557357800, mem_path=0x0, errp=0x7fffffffd810) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bdbc78 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bdbf87 in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb48) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb48) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb48) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb48, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb38) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#18 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i440fx_pcihost_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ERRP_GUARD();</span><br><span class="line">    I440FXState *s = I440FX_PCI_HOST_BRIDGE(dev);</span><br><span class="line">    PCIHostState *phb = PCI_HOST_BRIDGE(dev);</span><br><span class="line">    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);</span><br><span class="line">    PCIBus *b;</span><br><span class="line">    PCIDevice *d;</span><br><span class="line">    PCII440FXState *f;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(s-&gt;io_memory, <span class="number">0xcf8</span>, &amp;phb-&gt;conf_mem);</span><br><span class="line">    sysbus_init_ioports(sbd, <span class="number">0xcf8</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(s-&gt;io_memory, <span class="number">0xcfc</span>, &amp;phb-&gt;data_mem);</span><br><span class="line">    sysbus_init_ioports(sbd, <span class="number">0xcfc</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register i440fx 0xcf8 port as coalesced pio */</span></span><br><span class="line">    memory_region_set_flush_coalesced(&amp;phb-&gt;data_mem);</span><br><span class="line">    memory_region_add_coalescing(&amp;phb-&gt;conf_mem, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    b = pci_root_bus_new(dev, <span class="literal">NULL</span>, s-&gt;pci_address_space,</span><br><span class="line">                         s-&gt;io_memory, <span class="number">0</span>, TYPE_PCI_BUS);</span><br><span class="line">    phb-&gt;bus = b;</span><br><span class="line"></span><br><span class="line">    d = pci_create_simple(b, <span class="number">0</span>, s-&gt;pci_type);</span><br><span class="line">    f = I440FX_PCI_DEVICE(d);</span><br><span class="line"></span><br><span class="line">    range_set_bounds(&amp;s-&gt;pci_hole, s-&gt;below_4g_mem_size,</span><br><span class="line">                     IO_APIC_DEFAULT_ADDRESS - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup pci memory mapping */</span></span><br><span class="line">    pc_pci_as_mapping_init(s-&gt;system_memory, s-&gt;pci_address_space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if *disabled* show SMRAM to all CPUs */</span></span><br><span class="line">    memory_region_init_alias(&amp;f-&gt;smram_region, OBJECT(d), <span class="string">&quot;smram-region&quot;</span>,</span><br><span class="line">                             s-&gt;pci_address_space, SMRAM_C_BASE, SMRAM_C_SIZE);</span><br><span class="line">    memory_region_add_subregion_overlap(s-&gt;system_memory, SMRAM_C_BASE,</span><br><span class="line">                                        &amp;f-&gt;smram_region, <span class="number">1</span>);</span><br><span class="line">    memory_region_set_enabled(&amp;f-&gt;smram_region, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* smram, as seen by SMM CPUs */</span></span><br><span class="line">    memory_region_init(&amp;f-&gt;smram, OBJECT(d), <span class="string">&quot;smram&quot;</span>, <span class="number">4</span> * GiB);</span><br><span class="line">    memory_region_set_enabled(&amp;f-&gt;smram, <span class="literal">true</span>);</span><br><span class="line">    memory_region_init_alias(&amp;f-&gt;low_smram, OBJECT(d), <span class="string">&quot;smram-low&quot;</span>,</span><br><span class="line">                             s-&gt;ram_memory, SMRAM_C_BASE, SMRAM_C_SIZE);</span><br><span class="line">    memory_region_set_enabled(&amp;f-&gt;low_smram, <span class="literal">true</span>);</span><br><span class="line">    memory_region_add_subregion(&amp;f-&gt;smram, SMRAM_C_BASE, &amp;f-&gt;low_smram);</span><br><span class="line">    object_property_add_const_link(qdev_get_machine(), <span class="string">&quot;smram&quot;</span>,</span><br><span class="line">                                   OBJECT(&amp;f-&gt;smram));</span><br><span class="line"></span><br><span class="line">    init_pam(&amp;f-&gt;pam_regions[<span class="number">0</span>], OBJECT(d), s-&gt;ram_memory, s-&gt;system_memory,</span><br><span class="line">             s-&gt;pci_address_space, PAM_BIOS_BASE, PAM_BIOS_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(f-&gt;pam_regions) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        init_pam(&amp;f-&gt;pam_regions[i + <span class="number">1</span>], OBJECT(d), s-&gt;ram_memory,</span><br><span class="line">                 s-&gt;system_memory, s-&gt;pci_address_space,</span><br><span class="line">                 PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE, PAM_EXPAN_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ram_addr_t</span> ram_size = s-&gt;below_4g_mem_size + s-&gt;above_4g_mem_size;</span><br><span class="line">    ram_size = ram_size / <span class="number">8</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (ram_size &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        ram_size = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d-&gt;config[I440FX_COREBOOT_RAM_SIZE] = ram_size;</span><br><span class="line"></span><br><span class="line">    i440fx_update_memory_mappings(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，确实如前面<a href="#对象初始化">对象初始化</a>中分析的，是在实例化中绑定的<strong>MemoryRegion</strong></p>
<h2 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h2><p>根据前面<a href="#PCI设备编号">PCI设备编号</a>可知，由总线编号、设备编号和功能编号可唯一确定一个PCI设备，则PCI总线需要模拟该功能，即通过这些信息能唯一定位一个PCI设备</p>
<p>Qemu中表示PCI总线的<strong>TypeInfo</strong>变量<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L219"><strong>struct pci_bus_info</strong></a>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_bus_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_BUS,</span><br><span class="line">    .parent = TYPE_BUS,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIBus),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIBusClass),</span><br><span class="line">    .class_init = pci_bus_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_bus.h#L13"><strong>struct PCIBusClass</strong></a>和<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci_bus.h#L33"><strong>struct PCIBus</strong></a>来表征PCI总线</p>
<h4 id="struct-PCIBusClass"><a href="#struct-PCIBusClass" class="headerlink" title="struct PCIBusClass"></a>struct PCIBusClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PCI Bus datastructures.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not access the following members directly;</span></span><br><span class="line"><span class="comment"> * use accessor functions in pci.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIBusClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    BusClass parent_class;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*bus_num)(PCIBus *bus);</span><br><span class="line">    <span class="type">uint16_t</span> (*numa_node)(PCIBus *bus);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其主要包含一些成员变量的访问函数</p>
<h4 id="struct-PCIBus"><a href="#struct-PCIBus" class="headerlink" title="struct PCIBus"></a>struct PCIBus</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIBus</span> &#123;</span></span><br><span class="line">    BusState qbus;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PCIBusFlags</span> <span class="title">flags</span>;</span></span><br><span class="line">    <span class="type">const</span> PCIIOMMUOps *iommu_ops;</span><br><span class="line">    <span class="type">void</span> *iommu_opaque;</span><br><span class="line">    <span class="type">uint8_t</span> devfn_min;</span><br><span class="line">    <span class="type">uint32_t</span> slot_reserved_mask;</span><br><span class="line">    pci_set_irq_fn set_irq;</span><br><span class="line">    pci_map_irq_fn map_irq;</span><br><span class="line">    pci_route_irq_fn route_intx_to_irq;</span><br><span class="line">    <span class="type">void</span> *irq_opaque;</span><br><span class="line">    PCIDevice *devices[PCI_SLOT_MAX * PCI_FUNC_MAX];</span><br><span class="line">    PCIDevice *parent_dev;</span><br><span class="line">    MemoryRegion *address_space_mem;</span><br><span class="line">    MemoryRegion *address_space_io;</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, PCIBus) child; <span class="comment">/* this will be replaced by qdev later */</span></span><br><span class="line">    QLIST_ENTRY(PCIBus) sibling;<span class="comment">/* this will be replaced by qdev later */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The bus IRQ state is the logical OR of the connected devices.</span></span><br><span class="line"><span class="comment">       Keep a count of the number of devices with raised IRQs.  */</span></span><br><span class="line">    <span class="type">int</span> nirq;</span><br><span class="line">    <span class="type">int</span> *irq_count;</span><br><span class="line"></span><br><span class="line">    Notifier machine_done;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其除了保存挂载的设备<strong>devices</strong>外，还记录了子总线<strong>child</strong></p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>根据<a href="#PCI总线">pci总线</a>中的<strong>pci_bus_info</strong>可知，PCI总线只有<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L201"><strong>pci_bus_class_init()</strong></a>来进行对象初始化。</p>
<h4 id="对象初始化-1"><a href="#对象初始化-1" class="headerlink" title="对象初始化"></a>对象初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_bus_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    BusClass *k = BUS_CLASS(klass);</span><br><span class="line">    PCIBusClass *pbc = PCI_BUS_CLASS(klass);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;print_dev = pcibus_dev_print;</span><br><span class="line">    k-&gt;get_dev_path = pcibus_get_dev_path;</span><br><span class="line">    k-&gt;get_fw_dev_path = pcibus_get_fw_dev_path;</span><br><span class="line">    k-&gt;realize = pci_bus_realize;</span><br><span class="line">    k-&gt;unrealize = pci_bus_unrealize;</span><br><span class="line"></span><br><span class="line">    rc-&gt;phases.hold = pcibus_reset_hold;</span><br><span class="line"></span><br><span class="line">    pbc-&gt;bus_num = pcibus_num;</span><br><span class="line">    pbc-&gt;numa_node = pcibus_numa_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其主要初始化了相关的函数指针，而这些函数指针会用于定位PCI设备，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PCI address</span></span><br><span class="line"><span class="comment"> * bit 16 - 24: bus number</span></span><br><span class="line"><span class="comment"> * bit  8 - 15: devfun number</span></span><br><span class="line"><span class="comment"> * bit  0 -  7: offset in configuration space of a given pci device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the helper function to get a PCIDevice* for a given pci address */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> PCIDevice *<span class="title function_">pci_dev_find_by_addr</span><span class="params">(PCIBus *bus, <span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> bus_num = addr &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="type">uint8_t</span> devfn = addr &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pci_find_device(bus, bus_num, devfn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCIDevice *<span class="title function_">pci_find_device</span><span class="params">(PCIBus *bus, <span class="type">int</span> bus_num, <span class="type">uint8_t</span> devfn)</span></span><br><span class="line">&#123;</span><br><span class="line">    bus = pci_find_bus_nr(bus, bus_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bus-&gt;devices[devfn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCIBus *<span class="title function_">pci_find_bus_nr</span><span class="params">(PCIBus *bus, <span class="type">int</span> bus_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIBus *sec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pci_bus_num(bus) == bus_num) &#123;</span><br><span class="line">        <span class="keyword">return</span> bus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consider all bus numbers in range for the host pci bridge. */</span></span><br><span class="line">    <span class="keyword">if</span> (!pci_bus_is_root(bus) &amp;&amp;</span><br><span class="line">        !pci_secondary_bus_in_range(bus-&gt;parent_dev, bus_num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try child bus */</span></span><br><span class="line">    <span class="keyword">for</span> (; bus; bus = sec) &#123;</span><br><span class="line">        QLIST_FOREACH(sec, &amp;bus-&gt;child, sibling) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pci_bus_num(sec) == bus_num) &#123;</span><br><span class="line">                <span class="keyword">return</span> sec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* PXB buses assumed to be children of bus 0 */</span></span><br><span class="line">            <span class="keyword">if</span> (pci_bus_is_root(sec)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pci_root_bus_in_range(sec, bus_num)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pci_secondary_bus_in_range(sec-&gt;parent_dev, bus_num)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_bus_num</span><span class="params">(PCIBus *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PCI_BUS_GET_CLASS(s)-&gt;bus_num(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>这里就以<strong>e1000</strong>为例，通过分析其代码来学习Qemu对于PCI设备的模拟逻辑</p>
<p>根据<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1763"><strong>e1000_register_types()</strong></a>的逻辑，其<strong>struct TypeInfo</strong>如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo device_type_info = &#123;</span><br><span class="line">    .name = TYPE_DEVICE,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(DeviceState),</span><br><span class="line">    .instance_init = device_initfn,</span><br><span class="line">    .instance_post_init = device_post_init,</span><br><span class="line">    .instance_finalize = device_finalize,</span><br><span class="line">    .class_base_init = device_class_base_init,</span><br><span class="line">    .class_init = device_class_init,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(DeviceClass),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; TYPE_VMSTATE_IF &#125;,</span><br><span class="line">        &#123; TYPE_RESETTABLE_INTERFACE &#125;,</span><br><span class="line">        &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_device_type_info = &#123;</span><br><span class="line">    .name = TYPE_PCI_DEVICE,</span><br><span class="line">    .parent = TYPE_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(PCIDevice),</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(PCIDeviceClass),</span><br><span class="line">    .class_init = pci_device_class_init,</span><br><span class="line">    .class_base_init = pci_device_class_base_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo e1000_base_info = &#123;</span><br><span class="line">    .name          = TYPE_E1000_BASE,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(E1000State),</span><br><span class="line">    .instance_init = e1000_instance_init,</span><br><span class="line">    .class_size    = <span class="keyword">sizeof</span>(E1000BaseClass),</span><br><span class="line">    .abstract      = <span class="literal">true</span>,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo = &#123;</span><br><span class="line">    .name          = <span class="string">&quot;e1000&quot;</span>,</span><br><span class="line">    .parent        = TYPE_E1000_BASE,</span><br><span class="line">    .class_data    = &amp;e1000_devices[<span class="number">0</span>],</span><br><span class="line">    .class_init    = e1000_class_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>可以看到，虽然<strong>e1000</strong>的Typeinfo信息很少，没有指明对应的类和对象的数据结构。但<strong>QOM</strong>会在初始化类时将父类的相关信息填充到当前的<strong>TypeImpl</strong>中，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">type_class_get_size</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;class_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ti-&gt;class_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type_has_parent(ti)) &#123;</span><br><span class="line">        <span class="keyword">return</span> type_class_get_size(type_get_parent(ti));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(ObjectClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">type_initialize</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    ti-&gt;class_size = type_class_get_size(ti);</span><br><span class="line">    ...</span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span> =</span> g_malloc0(ti-&gt;class_size);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，实际上<strong>e1000</strong>就是在使用<strong>e1000_base_info</strong>中说明的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L80"><strong>E1000State</strong></a>和<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L146"><strong>E1000BaseClass</strong></a>来表征<strong>e1000</strong>，如下的gdb结果也证实了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pwndbg&gt; bt</span></span><br><span class="line"><span class="comment">//#0  e1000_instance_init (obj=0x7ffff587d010) at ../../qemu/hw/net/e1000.c:1723</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea30e0 in object_init_with_type (obj=0x7ffff587d010, ti=0x55555709bc20) at ../../qemu/qom/object.c:429</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea30c2 in object_init_with_type (obj=0x7ffff587d010, ti=0x55555709be00) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea36a6 in object_initialize_with_type (obj=0x7ffff587d010, size=208592, type=0x55555709be00) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea3e75 in object_new_with_type (type=0x55555709be00) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea3eb1 in object_new_with_class (klass=0x5555572bc2d0) at ../../qemu/qom/object.c:799</span></span><br><span class="line"><span class="comment">//#6  0x0000555555c3d234 in qemu_get_nic_models (device_type=0x55555623a47a &quot;pci-device&quot;) at ../../qemu/net/net.c:968</span></span><br><span class="line"><span class="comment">//#7  0x0000555555c3db78 in qemu_create_nic_bus_devices (bus=0x5555574157d0, parent_type=0x55555623a47a &quot;pci-device&quot;, default_model=0x5555562ab765 &quot;e1000&quot;, alias=0x55555623b21d &quot;virtio&quot;, alias_target=0x55555623b20e &quot;virtio-net-pci&quot;) at ../../qemu/net/net.c:1188</span></span><br><span class="line"><span class="comment">//#8  0x0000555555a9a0da in pci_init_nic_devices (bus=0x5555574157d0, default_model=0x5555562ab765 &quot;e1000&quot;) at ../../qemu/hw/pci/pci.c:1861</span></span><br><span class="line"><span class="comment">//#9  0x0000555555cd3d69 in pc_nic_init (pcmc=0x5555572bb030, isa_bus=0x555557163a00, pci_bus=0x5555574157d0) at ../../qemu/hw/i386/pc.c:1283</span></span><br><span class="line"><span class="comment">//#10 0x0000555555cb2ed4 in pc_init1 (machine=0x555557357800, pci_type=0x5555562ab7db &quot;i440FX&quot;) at ../../qemu/hw/i386/pc_piix.c:323</span></span><br><span class="line"><span class="comment">//#11 0x0000555555cb35e3 in pc_init_v9_0 (machine=0x555557357800) at ../../qemu/hw/i386/pc_piix.c:523</span></span><br><span class="line"><span class="comment">//#12 0x000055555595f8be in machine_run_board_init (machine=0x555557357800, mem_path=0x0, errp=0x7fffffffd820) at ../../qemu/hw/core/machine.c:1547</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bdbc78 in qemu_init_board () at ../../qemu/system/vl.c:2613</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bdbf87 in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2705</span></span><br><span class="line"><span class="comment">//#15 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#16 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#19 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="comment">//pwndbg&gt; p *ti</span></span><br><span class="line"><span class="comment">//$8 = &#123;</span></span><br><span class="line"><span class="comment">//  name = 0x55555709bf80 &quot;e1000&quot;,</span></span><br><span class="line"><span class="comment">//  class_size = 240,</span></span><br><span class="line"><span class="comment">//  instance_size = 208592,</span></span><br><span class="line"><span class="comment">//  instance_align = 0,</span></span><br><span class="line"><span class="comment">//  class_init = 0x555555a0fa01 &lt;e1000_class_init&gt;,</span></span><br><span class="line"><span class="comment">//  class_base_init = 0x0,</span></span><br><span class="line"><span class="comment">//  class_data = 0x555556dfa700 &lt;e1000_devices&gt;,</span></span><br><span class="line"><span class="comment">//  instance_init = 0x0,</span></span><br><span class="line"><span class="comment">//  instance_post_init = 0x0,</span></span><br><span class="line"><span class="comment">//  instance_finalize = 0x0,</span></span><br><span class="line"><span class="comment">//  abstract = false,</span></span><br><span class="line"><span class="comment">//  parent = 0x55555709bfa0 &quot;e1000-base&quot;,</span></span><br><span class="line"><span class="comment">//  parent_type = 0x55555709bc20,</span></span><br><span class="line"><span class="comment">//  class = 0x5555572bc2d0,</span></span><br><span class="line"><span class="comment">//  num_interfaces = 0,</span></span><br><span class="line"><span class="comment">//  interfaces = &#123;&#123;</span></span><br><span class="line"><span class="comment">//      typename = 0x0</span></span><br><span class="line"><span class="comment">//    &#125; &lt;repeats 32 times&gt;&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//pwndbg&gt; p sizeof(E1000State)</span></span><br><span class="line"><span class="comment">//$9 = 208592</span></span><br><span class="line"><span class="comment">//pwndbg&gt; p sizeof(E1000BaseClass)</span></span><br><span class="line"><span class="comment">//$10 = 240</span></span><br></pre></td></tr></table></figure></p>
<h4 id="E1000BaseClass"><a href="#E1000BaseClass" class="headerlink" title="E1000BaseClass"></a>E1000BaseClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct DeviceClass - The base class for all devices.</span></span><br><span class="line"><span class="comment"> * @props: Properties accessing state fields.</span></span><br><span class="line"><span class="comment"> * @realize: Callback function invoked when the #DeviceState:realized</span></span><br><span class="line"><span class="comment"> * property is changed to %true.</span></span><br><span class="line"><span class="comment"> * @unrealize: Callback function invoked when the #DeviceState:realized</span></span><br><span class="line"><span class="comment"> * property is changed to %false.</span></span><br><span class="line"><span class="comment"> * @hotpluggable: indicates if #DeviceClass is hotpluggable, available</span></span><br><span class="line"><span class="comment"> * as readonly &quot;hotpluggable&quot; property of #DeviceState instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @categories: device categories device belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DECLARE_BITMAP(categories, DEVICE_CATEGORY_MAX);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fw_name: name used to identify device to firmware interfaces</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fw_name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @desc: human readable description of device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @props_: properties associated with device, should only be</span></span><br><span class="line"><span class="comment">     * assigned by using device_class_set_props(). The underscore</span></span><br><span class="line"><span class="comment">     * ensures a compile-time error if someone attempts to assign</span></span><br><span class="line"><span class="comment">     * dc-&gt;props directly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Property *props_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @user_creatable: Can user instantiate with -device / device_add?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All devices should support instantiation with device_add, and</span></span><br><span class="line"><span class="comment">     * this flag should not exist.  But we&#x27;re not there, yet.  Some</span></span><br><span class="line"><span class="comment">     * devices fail to instantiate with cryptic error messages.</span></span><br><span class="line"><span class="comment">     * Others instantiate, but don&#x27;t work.  Exposing users to such</span></span><br><span class="line"><span class="comment">     * behavior would be cruel; clearing this flag will protect them.</span></span><br><span class="line"><span class="comment">     * It should never be cleared without a comment explaining why it</span></span><br><span class="line"><span class="comment">     * is cleared.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * TODO remove once we&#x27;re there</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> user_creatable;</span><br><span class="line">    <span class="type">bool</span> hotpluggable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* callbacks */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: deprecated device reset method pointer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Modern code should use the ResettableClass interface to</span></span><br><span class="line"><span class="comment">     * implement a multi-phase reset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> remove once every reset callback is unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DeviceReset reset;</span><br><span class="line">    DeviceRealize realize;</span><br><span class="line">    DeviceUnrealize unrealize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @vmsd: device state serialisation description for</span></span><br><span class="line"><span class="comment">     * migration/save/restore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> VMStateDescription *vmsd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @bus_type: bus type</span></span><br><span class="line"><span class="comment">     * private: to qdev / bus.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *bus_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*realize)(PCIDevice *dev, Error **errp);</span><br><span class="line">    PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vendor_id;</span><br><span class="line">    <span class="type">uint16_t</span> device_id;</span><br><span class="line">    <span class="type">uint8_t</span> revision;</span><br><span class="line">    <span class="type">uint16_t</span> class_id;</span><br><span class="line">    <span class="type">uint16_t</span> subsystem_vendor_id;       <span class="comment">/* only for header type = 0 */</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_id;              <span class="comment">/* only for header type = 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *romfile;                <span class="comment">/* rom bar */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E1000BaseClass</span> &#123;</span></span><br><span class="line">    PCIDeviceClass parent_class;</span><br><span class="line">    <span class="type">uint16_t</span> phy_id2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里除了父类外，没有太多与<strong>PCI设备</strong>相关的内容。</p>
<h4 id="E1000State"><a href="#E1000State" class="headerlink" title="E1000State"></a>E1000State</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct DeviceState - common device state, accessed with qdev helpers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure should not be accessed directly.  We declare it here</span></span><br><span class="line"><span class="comment"> * so that it can be embedded in individual device state structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @id: global device id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @canonical_path: canonical path of realized device in the QOM tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *canonical_path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @realized: has device been realized?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> realized;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @pending_deleted_event: track pending deletion events during unplug</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> pending_deleted_event;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @pending_deleted_expires_ms: optional timeout for deletion events</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int64_t</span> pending_deleted_expires_ms;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @opts: QDict of options for the device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QDict *opts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @hotplugged: was device added after PHASE_MACHINE_READY?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> hotplugged;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @allow_unplug_during_migration: can device be unplugged during migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> allow_unplug_during_migration;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @parent_bus: bus this device belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusState *parent_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @gpios: QLIST of named GPIOs the device provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NamedGPIOListHead gpios;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @clocks: QLIST of named clocks the device provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NamedClockListHead clocks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @child_bus: QLIST of child buses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusStateHead child_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @num_child_bus: number of @child_bus entries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> num_child_bus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @instance_id_alias: device alias for handling legacy migration setups</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> instance_id_alias;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @alias_required_for_version: indicates @instance_id_alias is</span></span><br><span class="line"><span class="comment">     * needed for migration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> alias_required_for_version;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @reset: ResettableState for the device; handled by Resettable interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResettableState reset;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @unplug_blockers: list of reasons to block unplugging of device</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GSList *unplug_blockers;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @mem_reentrancy_guard: Is the device currently in mmio/pio/dma?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Used to prevent re-entrancy confusing things.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MemReentrancyGuard mem_reentrancy_guard;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    <span class="type">bool</span> partially_hotplugged;</span><br><span class="line">    <span class="type">bool</span> has_power;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI config space */</span></span><br><span class="line">    <span class="type">uint8_t</span> *config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Used to enable config checks on load. Note that writable bits are</span></span><br><span class="line"><span class="comment">     * never checked even if set in cmask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> *cmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to implement R/W bytes */</span></span><br><span class="line">    <span class="type">uint8_t</span> *wmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to implement RW1C(Write 1 to Clear) bytes */</span></span><br><span class="line">    <span class="type">uint8_t</span> *w1cmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to allocate config space for capabilities. */</span></span><br><span class="line">    <span class="type">uint8_t</span> *used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following fields are read only */</span></span><br><span class="line">    <span class="type">int32_t</span> devfn;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cached device to fetch requester ID from, to avoid the PCI tree</span></span><br><span class="line"><span class="comment">     * walking every time we invoke PCI request (e.g., MSI). For</span></span><br><span class="line"><span class="comment">     * conventional PCI root complex, this field is meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PCIReqIDCache requester_id_cache;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    PCIIORegion io_regions[PCI_NUM_REGIONS];</span><br><span class="line">    AddressSpace bus_master_as;</span><br><span class="line">    MemoryRegion bus_master_container_region;</span><br><span class="line">    MemoryRegion bus_master_enable_region;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do not access the following fields */</span></span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Legacy PCI VGA regions */</span></span><br><span class="line">    MemoryRegion *vga_regions[QEMU_PCI_VGA_NUM_REGIONS];</span><br><span class="line">    <span class="type">bool</span> has_vga;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current IRQ levels.  Used internally by the generic PCI code.  */</span></span><br><span class="line">    <span class="type">uint8_t</span> irq_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Capability bits */</span></span><br><span class="line">    <span class="type">uint32_t</span> cap_present;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Offset of MSI-X capability in config space */</span></span><br><span class="line">    <span class="type">uint8_t</span> msix_cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSI-X entries */</span></span><br><span class="line">    <span class="type">int</span> msix_entries_nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Space to store MSIX table &amp; pending bit array */</span></span><br><span class="line">    <span class="type">uint8_t</span> *msix_table;</span><br><span class="line">    <span class="type">uint8_t</span> *msix_pba;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* May be used by INTx or MSI during interrupt notification */</span></span><br><span class="line">    <span class="type">void</span> *irq_opaque;</span><br><span class="line"></span><br><span class="line">    MSITriggerFunc *msi_trigger;</span><br><span class="line">    MSIPrepareMessageFunc *msi_prepare_message;</span><br><span class="line">    MSIxPrepareMessageFunc *msix_prepare_message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MemoryRegion container for msix exclusive BAR setup */</span></span><br><span class="line">    MemoryRegion msix_exclusive_bar;</span><br><span class="line">    <span class="comment">/* Memory Regions for MSIX table and pending bit entries. */</span></span><br><span class="line">    MemoryRegion msix_table_mmio;</span><br><span class="line">    MemoryRegion msix_pba_mmio;</span><br><span class="line">    <span class="comment">/* Reference-count for entries actually in use by driver. */</span></span><br><span class="line">    <span class="type">unsigned</span> *msix_entry_used;</span><br><span class="line">    <span class="comment">/* MSIX function mask set or MSIX disabled */</span></span><br><span class="line">    <span class="type">bool</span> msix_function_masked;</span><br><span class="line">    <span class="comment">/* Version id needed for VMState */</span></span><br><span class="line">    <span class="type">int32_t</span> version_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Offset of MSI capability in config space */</span></span><br><span class="line">    <span class="type">uint8_t</span> msi_cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI Express */</span></span><br><span class="line">    PCIExpressDevice <span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SHPC */</span></span><br><span class="line">    SHPCDevice *shpc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Location of option rom */</span></span><br><span class="line">    <span class="type">char</span> *romfile;</span><br><span class="line">    <span class="type">uint32_t</span> romsize;</span><br><span class="line">    <span class="type">bool</span> has_rom;</span><br><span class="line">    MemoryRegion rom;</span><br><span class="line">    <span class="type">uint32_t</span> rom_bar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* INTx routing notifier */</span></span><br><span class="line">    PCIINTxRoutingNotifier intx_routing_notifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSI-X notifiers */</span></span><br><span class="line">    MSIVectorUseNotifier msix_vector_use_notifier;</span><br><span class="line">    MSIVectorReleaseNotifier msix_vector_release_notifier;</span><br><span class="line">    MSIVectorPollNotifier msix_vector_poll_notifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ID of standby device in net_failover pair */</span></span><br><span class="line">    <span class="type">char</span> *failover_pair_id;</span><br><span class="line">    <span class="type">uint32_t</span> acpi_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HW models:</span></span><br><span class="line"><span class="comment"> *  E1000_DEV_ID_82540EM works with Windows, Linux, and OS X &lt;= 10.8</span></span><br><span class="line"><span class="comment"> *  E1000_DEV_ID_82544GC_COPPER appears to work; not well tested</span></span><br><span class="line"><span class="comment"> *  E1000_DEV_ID_82545EM_COPPER works with Linux and OS X &gt;= 10.6</span></span><br><span class="line"><span class="comment"> *  Others never tested</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E1000State_st</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion io;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mac_reg[<span class="number">0x8000</span>];</span><br><span class="line">    <span class="type">uint16_t</span> phy_reg[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">uint16_t</span> eeprom_data[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> rxbuf_size;</span><br><span class="line">    <span class="type">uint32_t</span> rxbuf_min_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e1000_tx</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> header[<span class="number">256</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> vlan_header[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">/* Fields vlan and data must not be reordered or separated. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> vlan[<span class="number">4</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">0x10000</span>];</span><br><span class="line">        <span class="type">uint16_t</span> size;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> vlan_needed;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sum_needed;</span><br><span class="line">        <span class="type">bool</span> cptse;</span><br><span class="line">        e1000x_txd_props props;</span><br><span class="line">        e1000x_txd_props tso_props;</span><br><span class="line">        <span class="type">uint16_t</span> tso_frames;</span><br><span class="line">        <span class="type">bool</span> busy;</span><br><span class="line">    &#125; tx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> val_in;    <span class="comment">/* shifted in from guest driver */</span></span><br><span class="line">        <span class="type">uint16_t</span> bitnum_in;</span><br><span class="line">        <span class="type">uint16_t</span> bitnum_out;</span><br><span class="line">        <span class="type">uint16_t</span> reading;</span><br><span class="line">        <span class="type">uint32_t</span> old_eecd;</span><br><span class="line">    &#125; eecd_state;</span><br><span class="line"></span><br><span class="line">    QEMUTimer *autoneg_timer;</span><br><span class="line"></span><br><span class="line">    QEMUTimer *mit_timer;      <span class="comment">/* Mitigation timer. */</span></span><br><span class="line">    <span class="type">bool</span> mit_timer_on;         <span class="comment">/* Mitigation timer is running. */</span></span><br><span class="line">    <span class="type">bool</span> mit_irq_level;        <span class="comment">/* Tracks interrupt pin level. */</span></span><br><span class="line">    <span class="type">uint32_t</span> mit_ide;          <span class="comment">/* Tracks E1000_TXD_CMD_IDE bit. */</span></span><br><span class="line"></span><br><span class="line">    QEMUTimer *flush_queue_timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compatibility flags for migration to/from qemu 1.3.0 and older */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_MAC_BIT 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_TSO_BIT 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_VET_BIT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_MAC (1 &lt;&lt; E1000_FLAG_MAC_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_TSO (1 &lt;&lt; E1000_FLAG_TSO_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_FLAG_VET (1 &lt;&lt; E1000_FLAG_VET_BIT)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> compat_flags;</span><br><span class="line">    <span class="type">bool</span> received_tx_tso;</span><br><span class="line">    <span class="type">bool</span> use_tso_for_migration;</span><br><span class="line">    e1000x_txd_props mig_props;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其<strong>mmio</strong>和<strong>io</strong>的MemoryRegion就是前面<a href="#PCI配置空间">pci配置空间</a>中的<strong>BAR</strong>，其<strong>parent_obj</strong>中的<strong>config</strong>则是前面<a href="#PCI配置空间">pci配置空间</a>的配置头</p>
<h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><h4 id="类初始化-1"><a href="#类初始化-1" class="headerlink" title="类初始化"></a>类初始化</h4><p><strong>e1000</strong>使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1698"><strong>e1000_class_init()</strong></a>初始化类<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  e1000_class_init (klass=0x555557242140, data=0x555556dfa710 &lt;e1000_devices+16&gt;) at ../../qemu/hw/net/e1000.c:1700</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea306a in type_initialize (ti=0x55555709bfc0) at ../../qemu/qom/object.c:418</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea4a1d in object_class_foreach_tramp (key=0x55555709c140, value=0x55555709bfc0, opaque=0x7fffffffd7a0) at ../../qemu/qom/object.c:1133</span></span><br><span class="line"><span class="comment">//#3  0x00007ffff7b6c6b8 in g_hash_table_foreach () at /lib/x86_64-linux-gnu/libglib-2.0.so.0</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea4b0d in object_class_foreach (fn=0x555555ea4c98 &lt;object_class_get_list_tramp&gt;, implements_type=0x555556279512 &quot;machine&quot;, include_abstract=false, opaque=0x7fffffffd7f0) at ../../qemu/qom/object.c:1155</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea4d26 in object_class_get_list (implements_type=0x555556279512 &quot;machine&quot;, include_abstract=false) at ../../qemu/qom/object.c:1212</span></span><br><span class="line"><span class="comment">//#6  0x0000555555bd9434 in select_machine (qdict=0x5555570ebce0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1661</span></span><br><span class="line"><span class="comment">//#7  0x0000555555bda5fd in qemu_create_machine (qdict=0x5555570ebce0) at ../../qemu/system/vl.c:2101</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bde7b1 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3664</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#10 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#11 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#12 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    ResettableClass *rc = RESETTABLE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">    E1000BaseClass *e = E1000_CLASS(klass);</span><br><span class="line">    <span class="type">const</span> E1000Info *info = data;</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_e1000_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span> = pci_e1000_uninit;</span><br><span class="line">    k-&gt;romfile = <span class="string">&quot;efi-e1000.rom&quot;</span>;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_INTEL;</span><br><span class="line">    k-&gt;device_id = info-&gt;device_id;</span><br><span class="line">    k-&gt;revision = info-&gt;revision;</span><br><span class="line">    e-&gt;phy_id2 = info-&gt;phy_id2;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_NETWORK_ETHERNET;</span><br><span class="line">    rc-&gt;phases.hold = e1000_reset_hold;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_NETWORK, dc-&gt;categories);</span><br><span class="line">    dc-&gt;desc = <span class="string">&quot;Intel Gigabit Ethernet&quot;</span>;</span><br><span class="line">    dc-&gt;vmsd = &amp;vmstate_e1000;</span><br><span class="line">    device_class_set_props(dc, e1000_properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，其在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/qom/object.c#L1148"><strong>object_class_foreach()</strong></a>初始化所有注册的类时，初始化了<strong>PCIDeviceClass</strong>父类相关字段，并设置了实例化函数指针。</p>
<h4 id="对象初始化-2"><a href="#对象初始化-2" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>根据前面<a href="#数据结构-2">数据结构</a>，虽然<strong>e1000</strong>的<strong>struct TypeInfo</strong>并未设置对象初始化函数，但<strong>QOM</strong>会使用其父类的对象初始化函数<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1721">e1000_instance_init()</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  e1000_instance_init (obj=0x5555580d01f0) at ../../qemu/hw/net/e1000.c:1723</span></span><br><span class="line"><span class="comment">//#1  0x0000555555ea30e0 in object_init_with_type (obj=0x5555580d01f0, ti=0x55555709bc20) at ../../qemu/qom/object.c:429</span></span><br><span class="line"><span class="comment">//#2  0x0000555555ea30c2 in object_init_with_type (obj=0x5555580d01f0, ti=0x55555709be00) at ../../qemu/qom/object.c:425</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea36a6 in object_initialize_with_type (obj=0x5555580d01f0, size=208592, type=0x55555709be00) at ../../qemu/qom/object.c:571</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea3e75 in object_new_with_type (type=0x55555709be00) at ../../qemu/qom/object.c:791</span></span><br><span class="line"><span class="comment">//#5  0x0000555555ea3ee1 in object_new (typename=0x5555580c2180 &quot;e1000&quot;) at ../../qemu/qom/object.c:806</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e9b710 in qdev_new (name=0x5555580c2180 &quot;e1000&quot;) at ../../qemu/hw/core/qdev.c:166</span></span><br><span class="line"><span class="comment">//#7  0x0000555555bcdd84 in qdev_device_add_from_qdict (opts=0x5555580c2500, from_json=false, errp=0x7fffffffd710) at ../../qemu/system/qdev-monitor.c:681</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bcdf99 in qdev_device_add (opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#9  0x0000555555bd80a7 in device_init_func (opaque=0x0, opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#10 0x00005555560be1e2 in qemu_opts_foreach (list=0x555556f4bec0 &lt;qemu_device_opts&gt;, func=0x555555bd807c &lt;device_init_func&gt;, opaque=0x0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#11 0x0000555555bdbd46 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bdbf8c in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#15 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#17 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    E1000State *n = E1000(obj);</span><br><span class="line">    device_add_bootindex_property(obj, &amp;n-&gt;conf.bootindex,</span><br><span class="line">                                  <span class="string">&quot;bootindex&quot;</span>, <span class="string">&quot;/ethernet-phy@0&quot;</span>,</span><br><span class="line">                                  DEVICE(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其在解析Qemu参数时初始化<strong>e1000</strong>对象，其中没有过多的<strong>PCI设备</strong>相关的信息，这些被放到了实例化中进行</p>
<h3 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h3><p>根据前面<a href="#类初始化-1">类初始化</a>内容，Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1637">pci_e1000_realize()</a>函数来实例化<strong>e1000</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_e1000_realize (pci_dev=0x5555580d01f0, errp=0x7fffffffd420) at ../../qemu/hw/net/e1000.c:1639</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a9a921 in pci_qdev_realize (qdev=0x5555580d01f0, errp=0x7fffffffd4a0) at ../../qemu/hw/pci/pci.c:2093</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e9c4f4 in device_set_realized (obj=0x5555580d01f0, value=true, errp=0x7fffffffd710) at ../../qemu/hw/core/qdev.c:510</span></span><br><span class="line"><span class="comment">//#3  0x0000555555ea7cfb in property_set_bool (obj=0x5555580d01f0, v=0x5555580c5590, name=0x5555562f9dd1 &quot;realized&quot;, opaque=0x5555570f4510, errp=0x7fffffffd710) at ../../qemu/qom/object.c:2358</span></span><br><span class="line"><span class="comment">//#4  0x0000555555ea5891 in object_property_set (obj=0x5555580d01f0, name=0x5555562f9dd1 &quot;realized&quot;, v=0x5555580c5590, errp=0x7fffffffd710) at ../../qemu/qom/object.c:1472</span></span><br><span class="line"><span class="comment">//#5  0x0000555555eaa4ca in object_property_set_qobject (obj=0x5555580d01f0, name=0x5555562f9dd1 &quot;realized&quot;, value=0x5555580c35d0, errp=0x7fffffffd710) at ../../qemu/qom/qom-qobject.c:28</span></span><br><span class="line"><span class="comment">//#6  0x0000555555ea5c4a in object_property_set_bool (obj=0x5555580d01f0, name=0x5555562f9dd1 &quot;realized&quot;, value=true, errp=0x7fffffffd710) at ../../qemu/qom/object.c:1541</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e9bc0e in qdev_realize (dev=0x5555580d01f0, bus=0x5555574157d0, errp=0x7fffffffd710) at ../../qemu/hw/core/qdev.c:292</span></span><br><span class="line"><span class="comment">//#8  0x0000555555bcdee9 in qdev_device_add_from_qdict (opts=0x5555580c2500, from_json=false, errp=0x7fffffffd710) at ../../qemu/system/qdev-monitor.c:718</span></span><br><span class="line"><span class="comment">//#9  0x0000555555bcdf99 in qdev_device_add (opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/qdev-monitor.c:737</span></span><br><span class="line"><span class="comment">//#10 0x0000555555bd80a7 in device_init_func (opaque=0x0, opts=0x5555570ef1c0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:1200</span></span><br><span class="line"><span class="comment">//#11 0x00005555560be1e2 in qemu_opts_foreach (list=0x555556f4bec0 &lt;qemu_device_opts&gt;, func=0x555555bd807c &lt;device_init_func&gt;, opaque=0x0, errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/util/qemu-option.c:1135</span></span><br><span class="line"><span class="comment">//#12 0x0000555555bdbd46 in qemu_create_cli_devices () at ../../qemu/system/vl.c:2637</span></span><br><span class="line"><span class="comment">//#13 0x0000555555bdbf8c in qmp_x_exit_preconfig (errp=0x555557061f60 &lt;error_fatal&gt;) at ../../qemu/system/vl.c:2706</span></span><br><span class="line"><span class="comment">//#14 0x0000555555bde944 in qemu_init (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/vl.c:3739</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e96f93 in main (argc=35, argv=0x7fffffffdb58) at ../../qemu/system/main.c:47</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7829d90 in __libc_start_call_main (main=main@entry=0x555555e96f6f &lt;main&gt;, argc=argc@entry=35, argv=argv@entry=0x7fffffffdb58) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7829e40 in __libc_start_main_impl (main=0x555555e96f6f &lt;main&gt;, argc=35, argv=0x7fffffffdb58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdb48) at ../csu/libc-start.c:392</span></span><br><span class="line"><span class="comment">//#18 0x000055555586cc95 in _start ()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_e1000_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev = DEVICE(pci_dev);</span><br><span class="line">    E1000State *d = E1000(pci_dev);</span><br><span class="line">    <span class="type">uint8_t</span> *pci_conf;</span><br><span class="line">    <span class="type">uint8_t</span> *macaddr;</span><br><span class="line"></span><br><span class="line">    pci_dev-&gt;config_write = e1000_write_config;</span><br><span class="line"></span><br><span class="line">    pci_conf = pci_dev-&gt;config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> RST# value should be 0, PCI spec 6.2.4 */</span></span><br><span class="line">    pci_conf[PCI_CACHE_LINE_SIZE] = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    pci_conf[PCI_INTERRUPT_PIN] = <span class="number">1</span>; <span class="comment">/* interrupt pin A */</span></span><br><span class="line"></span><br><span class="line">    e1000_mmio_setup(d);</span><br><span class="line"></span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io);</span><br><span class="line"></span><br><span class="line">    qemu_macaddr_default_if_unset(&amp;d-&gt;conf.macaddr);</span><br><span class="line">    macaddr = d-&gt;conf.macaddr.a;</span><br><span class="line"></span><br><span class="line">    e1000x_core_prepare_eeprom(d-&gt;eeprom_data,</span><br><span class="line">                               e1000_eeprom_template,</span><br><span class="line">                               <span class="keyword">sizeof</span>(e1000_eeprom_template),</span><br><span class="line">                               PCI_DEVICE_GET_CLASS(pci_dev)-&gt;device_id,</span><br><span class="line">                               macaddr);</span><br><span class="line"></span><br><span class="line">    d-&gt;nic = qemu_new_nic(&amp;net_e1000_info, &amp;d-&gt;conf,</span><br><span class="line">                          object_get_typename(OBJECT(d)), dev-&gt;id,</span><br><span class="line">                          &amp;dev-&gt;mem_reentrancy_guard, d);</span><br><span class="line"></span><br><span class="line">    qemu_format_nic_info_str(qemu_get_queue(d-&gt;nic), macaddr);</span><br><span class="line"></span><br><span class="line">    d-&gt;autoneg_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, e1000_autoneg_timer, d);</span><br><span class="line">    d-&gt;mit_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, e1000_mit_timer, d);</span><br><span class="line">    d-&gt;flush_queue_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL,</span><br><span class="line">                                        e1000_flush_queue_timer, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_qdev_realize</span><span class="params">(DeviceState *qdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = (PCIDevice *)qdev;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    pci_dev = do_pci_register_device(pci_dev,</span><br><span class="line">                                     object_get_typename(OBJECT(qdev)),</span><br><span class="line">                                     pci_dev-&gt;devfn, errp);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pc-&gt;realize) &#123;</span><br><span class="line">        pc-&gt;realize(pci_dev, &amp;local_err);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">qdev_realize</span><span class="params">(DeviceState *dev, BusState *bus, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(!dev-&gt;realized &amp;&amp; !dev-&gt;parent_bus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!qdev_set_parent_bus(dev, bus, errp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(!DEVICE_GET_CLASS(dev)-&gt;bus_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_property_set_bool(OBJECT(dev), <span class="string">&quot;realized&quot;</span>, <span class="literal">true</span>, errp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeviceState *<span class="title function_">qdev_device_add_from_qdict</span><span class="params">(<span class="type">const</span> QDict *opts,</span></span><br><span class="line"><span class="params">                                        <span class="type">bool</span> from_json, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *driver, *path;</span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    DeviceState *dev = <span class="literal">NULL</span>;</span><br><span class="line">    BusState *bus = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    driver = qdict_get_try_str(opts, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!driver) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find driver */</span></span><br><span class="line">    dc = qdev_get_device_class(&amp;driver, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find bus */</span></span><br><span class="line">    path = qdict_get_try_str(opts, <span class="string">&quot;bus&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find(path, errp);</span><br><span class="line">        <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!object_dynamic_cast(OBJECT(bus), dc-&gt;bus_type)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Device &#x27;%s&#x27; can&#x27;t go on %s bus&quot;</span>,</span><br><span class="line">                       driver, object_get_typename(OBJECT(bus)));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dc-&gt;bus_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find_recursive(sysbus_get_default(), <span class="literal">NULL</span>, dc-&gt;bus_type);</span><br><span class="line">        <span class="keyword">if</span> (!bus || qbus_is_full(bus)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;No &#x27;%s&#x27; bus found for device &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                       dc-&gt;bus_type, driver);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* create device */</span></span><br><span class="line">    dev = qdev_new(driver);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qdev_realize(dev, bus, errp)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在初始化<strong>e1000</strong>对象后，其又被迅速实例化。根据<a href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/" title="qemu设备模型">qemu设备模型</a>中类初始化可知，<strong>DeviceClass</strong>类在实例化时会调用类初始化设置的<strong>realized</strong>属性的setter方法<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L470"><strong>device_set_realized()</strong></a>，并在该方法中调用类的<strong>realize</strong>函数指针，即<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1637">pci_e1000_realize()</a>函数</p>
<p>其中，在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L280"><strong>qdev_realize()</strong></a>和<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/core/qdev.c#L280"><strong>do_pci_register_device()</strong></a>中完成了<strong>PCI设备</strong>的编号，从而可以让前面介绍的<a href="#对象初始化-1">PCI桥</a>根据PCI设备编号定位<strong>PCI设备</strong></p>
<p>除此之外，<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1637">pci_e1000_realize()</a>还初始化了其<strong>PCI设置空间</strong>，包括<strong>配置空间头</strong>(<strong>config</strong>字段)、<strong>mmio bar</strong>和<strong>pio bar</strong>。但需要注意的是，这里仅仅是初始化了<strong>bar</strong>的相关数据结构，但并没有映射到设备的地址空间，<strong>guest</strong>此时是看不到<strong>bar</strong>对应的地址空间，即从<strong>AddressSpace</strong>是找到不到该<strong>MemoryRegion</strong>的，需要后续<strong>guest</strong>配置完<strong>PCI设置空间</strong>后才会完成映射。具体来说，其通过<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L1301"><strong>pci_register_bar()</strong></a>，向<strong>PCIDevice</strong>的<strong>io_regions</strong>字段注册了<strong>BAR</strong>的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/include/hw/pci/pci.h#L143"><strong>struct PCIIORegion</strong></a>的数据结构，但并未将这部分地址空间的<strong>MemoryRegion</strong>映射到对应的<strong>AddressSpace</strong>上，其会推迟到<strong>guest</strong>完成设备的<strong>PCI设置空间</strong>的配置后在进行映射，所以此时Qemu在处理<strong>guest</strong>对这部分地址空间的请求时并不会分派到上述的<strong>MemoryRegion</strong>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pci_register_bar</span><span class="params">(PCIDevice *pci_dev, <span class="type">int</span> region_num,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span> type, MemoryRegion *memory)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIIORegion *r;</span><br><span class="line">    <span class="type">uint32_t</span> addr; <span class="comment">/* offset in pci config space */</span></span><br><span class="line">    <span class="type">uint64_t</span> wmask;</span><br><span class="line">    <span class="type">pcibus_t</span> size = memory_region_size(memory);</span><br><span class="line">    <span class="type">uint8_t</span> hdr_type;</span><br><span class="line">    ...</span><br><span class="line">    r = &amp;pci_dev-&gt;io_regions[region_num];</span><br><span class="line">    r-&gt;addr = PCI_BAR_UNMAPPED;</span><br><span class="line">    r-&gt;size = size;</span><br><span class="line">    r-&gt;type = type;</span><br><span class="line">    r-&gt;memory = memory;</span><br><span class="line">    r-&gt;address_space = type &amp; PCI_BASE_ADDRESS_SPACE_IO</span><br><span class="line">                        ? pci_get_bus(pci_dev)-&gt;address_space_io</span><br><span class="line">                        : pci_get_bus(pci_dev)-&gt;address_space_mem;</span><br><span class="line"></span><br><span class="line">    wmask = ~(size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (region_num == PCI_ROM_SLOT) &#123;</span><br><span class="line">        <span class="comment">/* ROM enable bit is writable */</span></span><br><span class="line">        wmask |= PCI_ROM_ADDRESS_ENABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = pci_bar(pci_dev, region_num);</span><br><span class="line">    pci_set_long(pci_dev-&gt;config + addr, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;type &amp; PCI_BASE_ADDRESS_SPACE_IO) &amp;&amp;</span><br><span class="line">        r-&gt;type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) &#123;</span><br><span class="line">        pci_set_quad(pci_dev-&gt;wmask + addr, wmask);</span><br><span class="line">        pci_set_quad(pci_dev-&gt;cmask + addr, ~<span class="number">0ULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pci_set_long(pci_dev-&gt;wmask + addr, wmask &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">        pci_set_long(pci_dev-&gt;cmask + addr, <span class="number">0xffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="PCI配置"><a href="#PCI配置" class="headerlink" title="PCI配置"></a>PCI配置</h3><p>此刻Qemu已经准备好<strong>e1000</strong>模拟设备的所有数据信息，可以模拟<strong>e1000</strong>设备与<strong>guest</strong>进行交互，首先就是<strong>e1000</strong>设备的<strong>PCI设置空间</strong>的配置</p>
<h4 id="指定设备"><a href="#指定设备" class="headerlink" title="指定设备"></a>指定设备</h4><p>根据前面<a href="#PCI配置空间">PCI配置空间</a>和<a href="#对象初始化">PCIHost对象初始化</a>可知，Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L158"><strong>pci_host_config_write()</strong></a>来模拟Qemu对<strong>CONFIG_ADDRESS</strong>寄存器的写操作，从而指定后续<strong>PCI配置</strong>的<strong>PCI设备</strong>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_host_config_write (opaque=0x5555573de7c0, addr=0, val=2147489796, len=4) at ../../qemu/hw/pci/pci_host.c:161</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573deaf0, addr=0, value=0x7ffff6954598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff6954598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573deaf0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573deaf0, addr=0, data=2147489796, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\004\030&quot;, len=4, mr_addr=0, l=0x7ffff6954680, mr=0x5555573deaf0) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee828b430, addr=3320, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573deaf0) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e2b982 in flatview_write (fv=0x7ffee828b430, addr=3320, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3320, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3320, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e85476 in kvm_handle_io (port=3320, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#12 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa760) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#13 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#14 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_config_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    PCI_DPRINTF(<span class="string">&quot;%s addr &quot;</span> HWADDR_FMT_plx <span class="string">&quot; len %d val %&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                __func__, addr, len, val);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="number">0</span> || len != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;config_reg = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，<strong>guest</strong>产生了IO事件，Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/accel/kvm/kvm-all.c#L2624"><strong>kvm_handle_io()</strong></a>进行模拟。其在<strong>address_space_io</strong>找到前面<a href="#实例化">i440fx_pcihost实例化</a>时映射的<strong>MemoryRegion</strong>，并执行其<strong>write</strong>回调函数即<strong>pci_host_config_write()</strong>即可。</p>
<p>而对应的<strong>guest</strong>则是调用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.9-rc2/source/arch/x86/include/asm/shared/io.h#L32"><strong>outl()</strong></a>向<strong>0xcf8</strong>写入对应的地址，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  0xffffffff81eaefc5 in pci_conf1_read (seg=&lt;optimized out&gt;, bus=&lt;optimized out&gt;, devfn=24, reg=4, len=2, value=0xffffc90000013bcc) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/direct.c:33</span></span><br><span class="line"><span class="comment">//#1  0xffffffff81574518 in pci_bus_read_config_word (bus=&lt;optimized out&gt;, devfn=&lt;optimized out&gt;, pos=pos@entry=4, value=value@entry=0xffffc90000013bee) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/access.c:67</span></span><br><span class="line"><span class="comment">//#2  0xffffffff81574932 in pci_read_config_word (dev=dev@entry=0xffff888100863000, where=where@entry=4, val=val@entry=0xffffc90000013bee) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/access.c:562</span></span><br><span class="line"><span class="comment">//#3  0xffffffff81588055 in pci_enable_resources (dev=dev@entry=0xffff888100863000, mask=67) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/setup-res.c:490</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81eb31ad in pcibios_enable_device (dev=0xffff888100863000, mask=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/common.c:695</span></span><br><span class="line"><span class="comment">//#5  0xffffffff815812d3 in do_pci_enable_device (bars=67, dev=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2022</span></span><br><span class="line"><span class="comment">//#6  do_pci_enable_device (dev=0xffff888100863000, bars=67) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2007</span></span><br><span class="line"><span class="comment">//#7  0xffffffff81582c67 in pci_enable_device_flags (dev=dev@entry=0xffff888100863000, flags=flags@entry=768) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2107</span></span><br><span class="line"><span class="comment">//#8  0xffffffff81582cde in pci_enable_device (dev=dev@entry=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:2154</span></span><br><span class="line"><span class="comment">//#9  0xffffffff8199c7c2 in e1000_probe (pdev=0xffff888100863000, ent=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:940</span></span><br><span class="line"><span class="comment">//#10 0xffffffff81584ba2 in local_pci_probe (_ddi=_ddi@entry=0xffffc90000013d30) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:324</span></span><br><span class="line"><span class="comment">//#11 0xffffffff81585add in pci_call_probe (id=&lt;optimized out&gt;, dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:392</span></span><br><span class="line"><span class="comment">//#12 __pci_device_probe (pci_dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:417</span></span><br><span class="line"><span class="comment">//#13 pci_device_probe (dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:451</span></span><br><span class="line"><span class="comment">//#14 0xffffffff818bd81c in call_driver_probe (drv=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:578</span></span><br><span class="line"><span class="comment">//#15 really_probe (dev=dev@entry=0xffff8881008630c0, drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:656</span></span><br><span class="line"><span class="comment">//#16 0xffffffff818bda8e in __driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:798</span></span><br><span class="line"><span class="comment">//#17 0xffffffff818bdb69 in driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:828</span></span><br><span class="line"><span class="comment">//#18 0xffffffff818bdde5 in __driver_attach (data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1214</span></span><br><span class="line"><span class="comment">//#19 __driver_attach (dev=0xffff8881008630c0, data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1154</span></span><br><span class="line"><span class="comment">//#20 0xffffffff818bb5b7 in bus_for_each_dev (bus=&lt;optimized out&gt;, start=start@entry=0x0 &lt;fixed_percpu_data&gt;, data=data@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, fn=fn@entry=0xffffffff818bdd60 &lt;__driver_attach&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:368</span></span><br><span class="line"><span class="comment">//#21 0xffffffff818bd1f9 in driver_attach (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1231</span></span><br><span class="line"><span class="comment">//#22 0xffffffff818bc997 in bus_add_driver (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:673</span></span><br><span class="line"><span class="comment">//#23 0xffffffff818bef8b in driver_register (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/driver.c:246</span></span><br><span class="line"><span class="comment">//#24 0xffffffff8158447c in __pci_register_driver (drv=drv@entry=0xffffffff82bfe7a0 &lt;e1000_driver&gt;, owner=owner@entry=0x0 &lt;fixed_percpu_data&gt;, mod_name=mod_name@entry=0xffffffff827051f5 &quot;e1000&quot;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:1450</span></span><br><span class="line"><span class="comment">//#25 0xffffffff832a4c31 in e1000_init_module () at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:227</span></span><br><span class="line"><span class="comment">//#26 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff832a4bf0 &lt;e1000_init_module&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#27 0xffffffff832481d7 in do_initcall_level (command_line=0xffff888100333140 &quot;rdinit&quot;, level=6) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#28 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#29 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#30 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#31 0xffffffff81ee5285 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#32 0xffffffff8103be2f in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81ee5270 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#33 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#34 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILDIO(bwl, bw, type)						\</span></span><br><span class="line"><span class="meta">static __always_inline void __out##bwl(type value, u16 port)		\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	asm volatile(<span class="string">&quot;out&quot;</span> #bwl <span class="string">&quot; %&quot;</span> #bw <span class="string">&quot;0, %w1&quot;</span>			\</span></span><br><span class="line"><span class="meta">		     : : <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;Nd&quot;</span>(port));			\</span></span><br><span class="line"><span class="meta">&#125;									\</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line">BUILDIO(l,  , u32)</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outl __outl</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_conf1_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seg, <span class="type">unsigned</span> <span class="type">int</span> bus,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">int</span> devfn, <span class="type">int</span> reg, <span class="type">int</span> len, u32 *value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (seg || (bus &gt; <span class="number">255</span>) || (devfn &gt; <span class="number">255</span>) || (reg &gt; <span class="number">4095</span>)) &#123;</span><br><span class="line">		*value = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	outl(PCI_CONF1_ADDRESS(bus, devfn, reg), <span class="number">0xCF8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (len) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		*value = inb(<span class="number">0xCFC</span> + (reg &amp; <span class="number">3</span>));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		*value = inw(<span class="number">0xCFC</span> + (reg &amp; <span class="number">2</span>));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		*value = inl(<span class="number">0xCFC</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，<strong>guest</strong>在访问<strong>PCI</strong>设备配置空间时，首先获取<strong>pci_config_lock</strong>锁，首先通过<code>outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8)</code>设定<strong>CONFIG_ADDRESS</strong>，指定访问的PCI设备。然后在访问<strong>CONFIG_DATA</strong>寄存器访问数据即可。</p>
<h4 id="访问配置空间"><a href="#访问配置空间" class="headerlink" title="访问配置空间"></a>访问配置空间</h4><p>在指定完<strong>CONFIG_ADDRESS</strong>寄存器后，即可通过<strong>pio</strong>访问指定的<strong>PCI设备</strong>的配置空间了。根据前面<a href="#PCI配置空间">PCI配置空间</a>和<a href="#对象初始化">PCIHost对象初始化</a>可知，Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L191"><strong>pci_host_data_read()</strong></a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L182"><strong>pci_host_data_write()</strong></a>来模拟Qemu对<strong>CONFIG_DATA</strong>寄存器的访问操作，如下是一个写操作的例子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_host_data_write (opaque=0x5555573de7c0, addr=0, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:187</span></span><br><span class="line"><span class="comment">//#1  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573dec00, addr=0, value=0x7ffff6954598, size=2, shift=0, mask=65535, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#2  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff6954598, size=2, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573dec00, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#3  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573dec00, addr=0, data=263, op=MO_16, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\a\001&quot;, len=2, mr_addr=0, l=0x7ffff6954680, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee828cfd0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=2, mr_addr=0, l=2, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e2b982 in flatview_write (fv=0x7ffee828cfd0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=2, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#12 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa760) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#13 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#14 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_host_data_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                                <span class="type">uint64_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;config_reg &amp; (<span class="number">1u</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">        pci_data_write(s-&gt;bus, s-&gt;config_reg | (addr &amp; <span class="number">3</span>), val, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后其会<code>s-&gt;config_reg</code>的值，按照前面<a href="#对象初始化-1">PCI总线</a>介绍的定位到<strong>PCI设备</strong>，并调用<strong>e1000</strong>之前<a href="#实例化-1">实例化</a>时设置的<strong>config_write</strong>字段<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/net/e1000.c#L1624"><strong>e1000_write_config</strong></a>设置其<strong>配置空间</strong>即可(否则调用<strong>do_pci_register_device</strong>设置的函数指针即可)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  e1000_write_config (pci_dev=0x5555580b0870, address=4, val=263, len=2) at ../../qemu/hw/net/e1000.c:1627</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a9e85a in pci_host_config_write_common (pci_dev=0x5555580b0870, addr=4, limit=256, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9eaa6 in pci_data_write (s=0x555557415420, addr=2147489796, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#3  0x0000555555a9ec7b in pci_host_data_write (opaque=0x5555573de7c0, addr=0, val=263, len=2) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#4  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573dec00, addr=0, value=0x7ffff6954598, size=2, shift=0, mask=65535, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff6954598, size=2, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573dec00, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573dec00, addr=0, data=263, op=MO_16, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\a\001&quot;, len=2, mr_addr=0, l=0x7ffff6954680, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee828cfd0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=2, mr_addr=0, l=2, mr=0x5555573dec00) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b982 in flatview_write (fv=0x7ffee828cfd0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=2, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=2, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#15 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa760) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#16 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_data_write</span><span class="params">(PCIBus *s, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);</span><br><span class="line">    <span class="type">uint32_t</span> config_addr = addr &amp; (PCI_CONFIG_SPACE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pci_dev) &#123;</span><br><span class="line">        trace_pci_cfg_write(<span class="string">&quot;empty&quot;</span>, extract32(addr, <span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">                            extract32(addr, <span class="number">11</span>, <span class="number">5</span>), extract32(addr, <span class="number">8</span>, <span class="number">3</span>),</span><br><span class="line">                            config_addr, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_host_config_write_common(pci_dev, config_addr, PCI_CONFIG_SPACE_SIZE,</span><br><span class="line">                                 val, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_host_config_write_common</span><span class="params">(PCIDevice *pci_dev, <span class="type">uint32_t</span> addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint32_t</span> limit, <span class="type">uint32_t</span> val, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_adjust_config_limit(pci_get_bus(pci_dev), &amp;limit);</span><br><span class="line">    <span class="keyword">if</span> (limit &lt;= addr) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(len &lt;= <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* non-zero functions are only exposed when function 0 is present,</span></span><br><span class="line"><span class="comment">     * allowing direct removal of unexposed functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((pci_dev-&gt;qdev.hotplugged &amp;&amp; !pci_get_function_0(pci_dev)) ||</span><br><span class="line">        !pci_dev-&gt;has_power || is_pci_dev_ejected(pci_dev)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_pci_cfg_write(pci_dev-&gt;name, pci_dev_bus_num(pci_dev),</span><br><span class="line">                        PCI_SLOT(pci_dev-&gt;devfn),</span><br><span class="line">                        PCI_FUNC(pci_dev-&gt;devfn), addr, val);</span><br><span class="line">    pci_dev-&gt;config_write(pci_dev, addr, val, MIN(len, limit - addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而对应的<strong>guest</strong>则是调用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.9-rc2/source/arch/x86/include/asm/shared/io.h#L32"><strong>outl()</strong></a>向<strong>0xcf8</strong>写入对应的地址，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  0xffffffff81eaf11f in pci_conf1_write (seg=&lt;optimized out&gt;, bus=&lt;optimized out&gt;, devfn=24, reg=&lt;optimized out&gt;, len=2, value=263) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/direct.c:69</span></span><br><span class="line"><span class="comment">//#1  0xffffffff81582aea in __pci_set_master (enable=true, dev=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:4200</span></span><br><span class="line"><span class="comment">//#2  pci_set_master (dev=dev@entry=0xffff888100863000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci.c:4253</span></span><br><span class="line"><span class="comment">//#3  0xffffffff8199c810 in e1000_probe (pdev=0xffff888100863000, ent=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:952</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81584ba2 in local_pci_probe (_ddi=_ddi@entry=0xffffc90000013d30) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:324</span></span><br><span class="line"><span class="comment">//#5  0xffffffff81585add in pci_call_probe (id=&lt;optimized out&gt;, dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:392</span></span><br><span class="line"><span class="comment">//#6  __pci_device_probe (pci_dev=0xffff888100863000, drv=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:417</span></span><br><span class="line"><span class="comment">//#7  pci_device_probe (dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:451</span></span><br><span class="line"><span class="comment">//#8  0xffffffff818bd81c in call_driver_probe (drv=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:578</span></span><br><span class="line"><span class="comment">//#9  really_probe (dev=dev@entry=0xffff8881008630c0, drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:656</span></span><br><span class="line"><span class="comment">//#10 0xffffffff818bda8e in __driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:798</span></span><br><span class="line"><span class="comment">//#11 0xffffffff818bdb69 in driver_probe_device (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=dev@entry=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:828</span></span><br><span class="line"><span class="comment">//#12 0xffffffff818bdde5 in __driver_attach (data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, dev=0xffff8881008630c0) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1214</span></span><br><span class="line"><span class="comment">//#13 __driver_attach (dev=0xffff8881008630c0, data=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1154</span></span><br><span class="line"><span class="comment">//#14 0xffffffff818bb5b7 in bus_for_each_dev (bus=&lt;optimized out&gt;, start=start@entry=0x0 &lt;fixed_percpu_data&gt;, data=data@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;, fn=fn@entry=0xffffffff818bdd60 &lt;__driver_attach&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:368</span></span><br><span class="line"><span class="comment">//#15 0xffffffff818bd1f9 in driver_attach (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/dd.c:1231</span></span><br><span class="line"><span class="comment">//#16 0xffffffff818bc997 in bus_add_driver (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/bus.c:673</span></span><br><span class="line"><span class="comment">//#17 0xffffffff818bef8b in driver_register (drv=drv@entry=0xffffffff82bfe808 &lt;e1000_driver+104&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/driver.c:246</span></span><br><span class="line"><span class="comment">//#18 0xffffffff8158447c in __pci_register_driver (drv=drv@entry=0xffffffff82bfe7a0 &lt;e1000_driver&gt;, owner=owner@entry=0x0 &lt;fixed_percpu_data&gt;, mod_name=mod_name@entry=0xffffffff827051f5 &quot;e1000&quot;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/pci-driver.c:1450</span></span><br><span class="line"><span class="comment">//#19 0xffffffff832a4c31 in e1000_init_module () at /home/hawk/Desktop/mqemu/kernel/drivers/net/ethernet/intel/e1000/e1000_main.c:227</span></span><br><span class="line"><span class="comment">//#20 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff832a4bf0 &lt;e1000_init_module&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#21 0xffffffff832481d7 in do_initcall_level (command_line=0xffff888100333140 &quot;rdinit&quot;, level=6) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#22 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#23 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#24 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#25 0xffffffff81ee5285 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#26 0xffffffff8103be2f in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81ee5270 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#27 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#28 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILDIO(bwl, bw, type)						\</span></span><br><span class="line"><span class="meta">static __always_inline void __out##bwl(type value, u16 port)		\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	asm volatile(<span class="string">&quot;out&quot;</span> #bwl <span class="string">&quot; %&quot;</span> #bw <span class="string">&quot;0, %w1&quot;</span>			\</span></span><br><span class="line"><span class="meta">		     : : <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;Nd&quot;</span>(port));			\</span></span><br><span class="line"><span class="meta">&#125;									\</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line">BUILDIO(w, w, u16)</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outw __outw</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_conf1_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seg, <span class="type">unsigned</span> <span class="type">int</span> bus,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">int</span> devfn, <span class="type">int</span> reg, <span class="type">int</span> len, u32 value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (seg || (bus &gt; <span class="number">255</span>) || (devfn &gt; <span class="number">255</span>) || (reg &gt; <span class="number">4095</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	outl(PCI_CONF1_ADDRESS(bus, devfn, reg), <span class="number">0xCF8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (len) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		outb((u8)value, <span class="number">0xCFC</span> + (reg &amp; <span class="number">3</span>));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		outw((u16)value, <span class="number">0xCFC</span> + (reg &amp; <span class="number">2</span>));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		outl((u32)value, <span class="number">0xCFC</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，类似前面<a href="#指定设备">指定设备</a>，在指定访问的PCI设备后，即可通过<strong>in/out</strong>访问<strong>CONFIG_DATA</strong>寄存器访问数据。</p>
<h4 id="设置BAR"><a href="#设置BAR" class="headerlink" title="设置BAR"></a>设置BAR</h4><p>参考前面<a href="#PCI配置空间">BAR</a>相关内容，操作系统需要通过与<strong>BAR</strong>交互完成<strong>BAR</strong>的配置，从而将Qemu中<strong>BAR</strong>的<strong>MemoryRegion</strong>映射到<strong>AddressSpace</strong>中</p>
<p>首先，<strong>guest</strong>使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.9-rc2/source/drivers/pci/probe.c#L176"><strong>__pci_read_base()</strong></a>读取<strong>PCI设备</strong>的<strong>BAR</strong>内容，获取<strong>BAR</strong>空间的大小等信息，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  __pci_read_base (dev=dev@entry=0xffff8881008e1000, type=type@entry=pci_bar_unknown, res=res@entry=0xffff8881008e13a0, pos=pos@entry=16) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:178</span></span><br><span class="line"><span class="comment">//#1  0xffffffff815779e2 in pci_read_bases (rom=&lt;optimized out&gt;, howmany=&lt;optimized out&gt;, dev=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:335</span></span><br><span class="line"><span class="comment">//#2  pci_read_bases (dev=0xffff8881008e1000, howmany=6, rom=48) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:321</span></span><br><span class="line"><span class="comment">//#3  0xffffffff815781e4 in pci_setup_device (dev=dev@entry=0xffff8881008e1000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:1963</span></span><br><span class="line"><span class="comment">//#4  0xffffffff81578d6a in pci_scan_device (devfn=24, bus=0xffff888100826000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2434</span></span><br><span class="line"><span class="comment">//#5  pci_scan_single_device (devfn=24, bus=0xffff888100826000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2591</span></span><br><span class="line"><span class="comment">//#6  pci_scan_single_device (bus=0xffff888100826000, devfn=24) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2581</span></span><br><span class="line"><span class="comment">//#7  0xffffffff81578e33 in pci_scan_slot (bus=bus@entry=0xffff888100826000, devfn=devfn@entry=24) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2678</span></span><br><span class="line"><span class="comment">//#8  0xffffffff8157a490 in pci_scan_child_bus_extend (bus=bus@entry=0xffff888100826000, available_buses=available_buses@entry=0) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:2897</span></span><br><span class="line"><span class="comment">//#9  0xffffffff8157a68b in pci_scan_child_bus (bus=bus@entry=0xffff888100826000) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:3011</span></span><br><span class="line"><span class="comment">//#10 0xffffffff815bf969 in acpi_pci_root_create (root=root@entry=0xffff888100372700, ops=ops@entry=0xffffffff82c71720 &lt;acpi_pci_root_ops&gt;, info=info@entry=0xffff8881003773c0, sysdata=sysdata@entry=0xffff8881003773f8) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/pci_root.c:1066</span></span><br><span class="line"><span class="comment">//#11 0xffffffff81eb1285 in pci_acpi_scan_root (root=root@entry=0xffff888100372700) at /home/hawk/Desktop/mqemu/kernel/arch/x86/pci/acpi.c:455</span></span><br><span class="line"><span class="comment">//#12 0xffffffff815bf3f4 in acpi_pci_root_add (device=0xffff88810080a000, not_used=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/pci_root.c:733</span></span><br><span class="line"><span class="comment">//#13 0xffffffff815b4149 in acpi_scan_attach_handler (device=0xffff88810080a000) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2235</span></span><br><span class="line"><span class="comment">//#14 acpi_bus_attach (device=0xffff88810080a000, first_pass=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2282</span></span><br><span class="line"><span class="comment">//#15 0xffffffff818b50c7 in device_for_each_child (parent=parent@entry=0xffff888100809a68, data=data@entry=0xffffc90000013cd8, fn=fn@entry=0xffffffff815b2330 &lt;acpi_dev_for_one_check&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/core.c:4049</span></span><br><span class="line"><span class="comment">//#16 0xffffffff815b2147 in acpi_dev_for_each_child (adev=adev@entry=0xffff888100809800, fn=fn@entry=0xffffffff815b4010 &lt;acpi_bus_attach&gt;, data=data@entry=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/bus.c:1138</span></span><br><span class="line"><span class="comment">//#17 0xffffffff815b408f in acpi_bus_attach (device=0xffff888100809800, first_pass=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2302</span></span><br><span class="line"><span class="comment">//#18 0xffffffff818b50c7 in device_for_each_child (parent=parent@entry=0xffff888100809268, data=data@entry=0xffffc90000013d70, fn=fn@entry=0xffffffff815b2330 &lt;acpi_dev_for_one_check&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/base/core.c:4049</span></span><br><span class="line"><span class="comment">//#19 0xffffffff815b2147 in acpi_dev_for_each_child (adev=adev@entry=0xffff888100809000, fn=fn@entry=0xffffffff815b4010 &lt;acpi_bus_attach&gt;, data=data@entry=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/bus.c:1138</span></span><br><span class="line"><span class="comment">//#20 0xffffffff815b408f in acpi_bus_attach (device=0xffff888100809000, first_pass=first_pass@entry=0x1 &lt;fixed_percpu_data+1&gt;) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2302</span></span><br><span class="line"><span class="comment">//#21 0xffffffff815b68a7 in acpi_bus_scan (handle=handle@entry=0xffffffffffffffff) at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2583</span></span><br><span class="line"><span class="comment">//#22 0xffffffff832962e4 in acpi_scan_init () at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/scan.c:2718</span></span><br><span class="line"><span class="comment">//#23 0xffffffff83295d3c in acpi_init () at /home/hawk/Desktop/mqemu/kernel/drivers/acpi/bus.c:1443</span></span><br><span class="line"><span class="comment">//#24 0xffffffff81001a63 in do_one_initcall (fn=0xffffffff83295b40 &lt;acpi_init&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1238</span></span><br><span class="line"><span class="comment">//#25 0xffffffff832481d7 in do_initcall_level (command_line=0xffff888100127c00 &quot;rdinit&quot;, level=4) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1300</span></span><br><span class="line"><span class="comment">//#26 do_initcalls () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1316</span></span><br><span class="line"><span class="comment">//#27 do_basic_setup () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1335</span></span><br><span class="line"><span class="comment">//#28 kernel_init_freeable () at /home/hawk/Desktop/mqemu/kernel/init/main.c:1548</span></span><br><span class="line"><span class="comment">//#29 0xffffffff81ee5285 in kernel_init (unused=&lt;optimized out&gt;) at /home/hawk/Desktop/mqemu/kernel/init/main.c:1437</span></span><br><span class="line"><span class="comment">//#30 0xffffffff8103be2f in ret_from_fork (prev=&lt;optimized out&gt;, regs=0xffffc90000013f58, fn=0xffffffff81ee5270 &lt;kernel_init&gt;, fn_arg=0x0 &lt;fixed_percpu_data&gt;) at /home/hawk/Desktop/mqemu/kernel/arch/x86/kernel/process.c:147</span></span><br><span class="line"><span class="comment">//#31 0xffffffff8100244a in ret_from_fork_asm () at /home/hawk/Desktop/mqemu/kernel/arch/x86/entry/entry_64.S:243</span></span><br><span class="line"><span class="comment">//#32 0x0000000000000000 in ?? ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __pci_read_base - Read a PCI BAR</span></span><br><span class="line"><span class="comment"> * @dev: the PCI device</span></span><br><span class="line"><span class="comment"> * @type: type of the BAR</span></span><br><span class="line"><span class="comment"> * @res: resource buffer to be filled in</span></span><br><span class="line"><span class="comment"> * @pos: BAR position in the config space</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 1 if the BAR is 64-bit, or 0 if 32-bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __pci_read_base(<span class="keyword">struct</span> pci_dev *dev, <span class="keyword">enum</span> pci_bar_type type,</span><br><span class="line">		    <span class="keyword">struct</span> resource *res, <span class="type">unsigned</span> <span class="type">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">	u32 l = <span class="number">0</span>, sz = <span class="number">0</span>, mask;</span><br><span class="line">	u64 l64, sz64, mask64;</span><br><span class="line">	u16 orig_cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_bus_region</span> <span class="title">region</span>, <span class="title">inverted_region</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *res_name = pci_resource_name(dev, res - dev-&gt;resource);</span><br><span class="line"></span><br><span class="line">	mask = type ? PCI_ROM_ADDRESS_MASK : ~<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">	pci_read_config_dword(dev, pos, &amp;l);</span><br><span class="line">	pci_write_config_dword(dev, pos, l | mask);</span><br><span class="line">	pci_read_config_dword(dev, pos, &amp;sz);</span><br><span class="line">	pci_write_config_dword(dev, pos, l);</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (type == pci_bar_unknown) &#123;</span><br><span class="line">		res-&gt;flags = decode_bar(dev, l);</span><br><span class="line">		res-&gt;flags |= IORESOURCE_SIZEALIGN;</span><br><span class="line">		<span class="keyword">if</span> (res-&gt;flags &amp; IORESOURCE_IO) &#123;</span><br><span class="line">			l64 = l &amp; PCI_BASE_ADDRESS_IO_MASK;</span><br><span class="line">			sz64 = sz &amp; PCI_BASE_ADDRESS_IO_MASK;</span><br><span class="line">			mask64 = PCI_BASE_ADDRESS_IO_MASK &amp; (u32)IO_SPACE_LIMIT;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l64 = l &amp; PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">			sz64 = sz &amp; PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">			mask64 = (u32)PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (l &amp; PCI_ROM_ADDRESS_ENABLE)</span><br><span class="line">			res-&gt;flags |= IORESOURCE_ROM_ENABLE;</span><br><span class="line">		l64 = l &amp; PCI_ROM_ADDRESS_MASK;</span><br><span class="line">		sz64 = sz &amp; PCI_ROM_ADDRESS_MASK;</span><br><span class="line">		mask64 = PCI_ROM_ADDRESS_MASK;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	sz64 = pci_size(l64, sz64, mask64);</span><br><span class="line">	<span class="keyword">if</span> (!sz64) &#123;</span><br><span class="line">		pci_info(dev, FW_BUG <span class="string">&quot;%s: invalid; can&#x27;t size\n&quot;</span>, res_name);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	region.start = l64;</span><br><span class="line">	region.end = l64 + sz64 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span><br><span class="line">	pcibios_resource_to_bus(dev-&gt;bus, &amp;inverted_region, res);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If &quot;A&quot; is a BAR value (a bus address), &quot;bus_to_resource(A)&quot; is</span></span><br><span class="line"><span class="comment">	 * the corresponding resource address (the physical address used by</span></span><br><span class="line"><span class="comment">	 * the CPU.  Converting that resource address back to a bus address</span></span><br><span class="line"><span class="comment">	 * should yield the original BAR value:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *     resource_to_bus(bus_to_resource(A)) == A</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If it doesn&#x27;t, CPU accesses to &quot;bus_to_resource(A)&quot; will not</span></span><br><span class="line"><span class="comment">	 * be claimed by the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (inverted_region.start != region.start) &#123;</span><br><span class="line">		res-&gt;flags |= IORESOURCE_UNSET;</span><br><span class="line">		res-&gt;start = <span class="number">0</span>;</span><br><span class="line">		res-&gt;end = region.end - region.start;</span><br><span class="line">		pci_info(dev, <span class="string">&quot;%s: initial BAR value %#010llx invalid\n&quot;</span>,</span><br><span class="line">			 res_name, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)region.start);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，<strong>guest</strong>首先保存当前<strong>BAR</strong>的值，然后将<strong>BAR</strong>所有bit设为1。此时在读取<strong>BAR</strong>的值并将结果保存在<code>sz</code>字段中，最后恢复<strong>BAR</strong>的值。根据<a target="_blank" rel="noopener" href="https://members.pcisig.com/wg/PCI-SIG/document/download/8237"><strong>PCI Local Bus Specification Revision 3.0</strong></a>的<strong>6.2.5.1. Address Maps</strong>章节可知，此时通过<code>sz</code>字段即可获取<strong>BAR</strong>空间的大小，如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; frame </span><br><span class="line"><span class="comment">#0  __pci_read_base (dev=dev@entry=0xffff8881008e1000, type=type@entry=pci_bar_unknown, res=res@entry=0xffff8881008e13a0, pos=pos@entry=16) at /home/hawk/Desktop/mqemu/kernel/drivers/pci/probe.c:201</span></span><br><span class="line">201		pci_write_config_dword(dev, pos, l);</span><br><span class="line">pwndbg&gt; p/x (~sz) + 1</span><br><span class="line"><span class="variable">$10</span> = 0x20000</span><br></pre></td></tr></table></figure></p>
<p>而根据前面<a href="#对象初始化">PCI桥</a>的内容，Qemu使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L182"><strong>pci_host_data_write()</strong></a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci_host.c#L191"><strong>pci_host_data_read()</strong></a>来模拟PCI配置空间的访问，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_default_write_config (d=0x5555580d01f0, addr=16, val_in=4294967295, l=4) at ../../qemu/hw/pci/pci.c:1594</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a0f779 in e1000_write_config (pci_dev=0x5555580d01f0, address=16, val=4294967295, len=4) at ../../qemu/hw/net/e1000.c:1629</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9e85a in pci_host_config_write_common (pci_dev=0x5555580d01f0, addr=16, limit=256, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#3  0x0000555555a9eaa6 in pci_data_write (s=0x5555574157d0, addr=2147489808, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#4  0x0000555555a9ec7b in pci_host_data_write (opaque=0x5555573de800, addr=0, val=4294967295, len=4) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573dec40, addr=0, value=0x7ffff67ff598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff67ff598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573dec40, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573dec40, addr=0, data=4294967295, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;\377\377\377\377&quot;, len=4, mr_addr=0, l=0x7ffff67ff680, mr=0x5555573dec40) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee8041af0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573dec40) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2b982 in flatview_write (fv=0x7ffee8041af0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#16 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa7a0) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pci_default_read_config</span><span class="params">(PCIDevice *d,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> address, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(address + len &lt;= pci_config_size(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pci_is_express_downstream_port(d) &amp;&amp;</span><br><span class="line">        ranges_overlap(address, len, d-&gt;<span class="built_in">exp</span>.exp_cap + PCI_EXP_LNKSTA, <span class="number">2</span>)) &#123;</span><br><span class="line">        pcie_sync_bridge_lnk(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;val, d-&gt;config + address, len);</span><br><span class="line">    <span class="keyword">return</span> le32_to_cpu(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, was_irq_disabled = pci_irq_disabled(d);</span><br><span class="line">    <span class="type">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    assert(addr + l &lt;= pci_config_size(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; val &gt;&gt;= <span class="number">8</span>, ++i) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> wmask = d-&gt;wmask[addr + i];</span><br><span class="line">        <span class="type">uint8_t</span> w1cmask = d-&gt;w1cmask[addr + i];</span><br><span class="line">        assert(!(wmask &amp; w1cmask));</span><br><span class="line">        d-&gt;config[addr + i] = (d-&gt;config[addr + i] &amp; ~wmask) | (val &amp; wmask);</span><br><span class="line">        d-&gt;config[addr + i] &amp;= ~(val &amp; w1cmask); <span class="comment">/* W1C: Write 1 to Clear */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, <span class="number">24</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS, <span class="number">4</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, <span class="number">4</span>) ||</span><br><span class="line">        range_covers_byte(addr, l, PCI_COMMAND))</span><br><span class="line">        pci_update_mappings(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_COMMAND, <span class="number">2</span>)) &#123;</span><br><span class="line">        pci_update_irq_disabled(d, was_irq_disabled);</span><br><span class="line">        memory_region_set_enabled(&amp;d-&gt;bus_master_enable_region,</span><br><span class="line">                                  (pci_get_word(d-&gt;config + PCI_COMMAND)</span><br><span class="line">                                   &amp; PCI_COMMAND_MASTER) &amp;&amp; d-&gt;has_power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msi_write_config(d, addr, val_in, l);</span><br><span class="line">    msix_write_config(d, addr, val_in, l);</span><br><span class="line">    pcie_sriov_config_write(d, addr, val_in, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，Qemu则模拟<strong>BAR</strong>读取时并没有特别的操作，就是将<strong>BAR</strong>数据直接复制出来。因此将<strong>BAR</strong>所有bit置1后读取<strong>BAR</strong>空间大小的交互只能是在写入时实现。这里是通过<strong>wmask</strong>字段实现的，在<strong>PCI设备</strong>实例化时，<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L1301"><strong>pci_register_bar()</strong></a>同时会设置<strong>wmask</strong>字段为<code>~(size-1)</code>，其确保<code>d-&gt;config[addr + i]</code>的低位始终为0来实现交互的模拟，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, was_irq_disabled = pci_irq_disabled(d);</span><br><span class="line">    <span class="type">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    assert(addr + l &lt;= pci_config_size(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; val &gt;&gt;= <span class="number">8</span>, ++i) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> wmask = d-&gt;wmask[addr + i];</span><br><span class="line">        <span class="type">uint8_t</span> w1cmask = d-&gt;w1cmask[addr + i];</span><br><span class="line">        assert(!(wmask &amp; w1cmask));</span><br><span class="line">        d-&gt;config[addr + i] = (d-&gt;config[addr + i] &amp; ~wmask) | (val &amp; wmask);</span><br><span class="line">        d-&gt;config[addr + i] &amp;= ~(val &amp; w1cmask); <span class="comment">/* W1C: Write 1 to Clear */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_register_bar</span><span class="params">(PCIDevice *pci_dev, <span class="type">int</span> region_num,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span> type, MemoryRegion *memory)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">pcibus_t</span> size = memory_region_size(memory);</span><br><span class="line">    ...</span><br><span class="line">    wmask = ~(size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (region_num == PCI_ROM_SLOT) &#123;</span><br><span class="line">        <span class="comment">/* ROM enable bit is writable */</span></span><br><span class="line">        wmask |= PCI_ROM_ADDRESS_ENABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = pci_bar(pci_dev, region_num);</span><br><span class="line">    pci_set_long(pci_dev-&gt;config + addr, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;type &amp; PCI_BASE_ADDRESS_SPACE_IO) &amp;&amp;</span><br><span class="line">        r-&gt;type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) &#123;</span><br><span class="line">        pci_set_quad(pci_dev-&gt;wmask + addr, wmask);</span><br><span class="line">        pci_set_quad(pci_dev-&gt;cmask + addr, ~<span class="number">0ULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pci_set_long(pci_dev-&gt;wmask + addr, wmask &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">        pci_set_long(pci_dev-&gt;cmask + addr, <span class="number">0xffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，<strong>guest</strong>只需要向<strong>BAR</strong>中写入为<strong>BAR</strong>分配的地址空间(是在bios中进行设置而非kernel)，即可完成最终的<strong>BAR</strong>设置，<strong>guest</strong>会使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/qemu/v9.0.0-rc2/source/hw/pci/pci.c#L1514"><strong>pci_update_mappings()</strong></a>将<strong>BAR</strong>对应的<strong>MemoryRegion</strong>映射入对应的<strong>AddressSpace</strong>中，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#0  pci_default_write_config (d=0x5555581030f0, addr=16, val_in=4273733632, l=4) at ../../qemu/hw/pci/pci.c:1594</span></span><br><span class="line"><span class="comment">//#1  0x0000555555a0f779 in e1000_write_config (pci_dev=0x5555581030f0, address=16, val=4273733632, len=4) at ../../qemu/hw/net/e1000.c:1629</span></span><br><span class="line"><span class="comment">//#2  0x0000555555a9e85a in pci_host_config_write_common (pci_dev=0x5555581030f0, addr=16, limit=256, val=4273733632, len=4) at ../../qemu/hw/pci/pci_host.c:96</span></span><br><span class="line"><span class="comment">//#3  0x0000555555a9eaa6 in pci_data_write (s=0x5555574288b0, addr=2147489808, val=4273733632, len=4) at ../../qemu/hw/pci/pci_host.c:138</span></span><br><span class="line"><span class="comment">//#4  0x0000555555a9ec7b in pci_host_data_write (opaque=0x5555573f2390, addr=0, val=4273733632, len=4) at ../../qemu/hw/pci/pci_host.c:188</span></span><br><span class="line"><span class="comment">//#5  0x0000555555e19a00 in memory_region_write_accessor (mr=0x5555573f27d0, addr=0, value=0x7ffff67ff598, size=4, shift=0, mask=4294967295, attrs=...) at ../../qemu/system/memory.c:497</span></span><br><span class="line"><span class="comment">//#6  0x0000555555e19d39 in access_with_adjusted_size (addr=0, value=0x7ffff67ff598, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555e19906 &lt;memory_region_write_accessor&gt;, mr=0x5555573f27d0, attrs=...) at ../../qemu/system/memory.c:573</span></span><br><span class="line"><span class="comment">//#7  0x0000555555e1d053 in memory_region_dispatch_write (mr=0x5555573f27d0, addr=0, data=4273733632, op=MO_32, attrs=...) at ../../qemu/system/memory.c:1521</span></span><br><span class="line"><span class="comment">//#8  0x0000555555e2b7a0 in flatview_write_continue_step (attrs=..., buf=0x7ffff7f8a000 &quot;&quot;, len=4, mr_addr=0, l=0x7ffff67ff680, mr=0x5555573f27d0) at ../../qemu/system/physmem.c:2713</span></span><br><span class="line"><span class="comment">//#9  0x0000555555e2b870 in flatview_write_continue (fv=0x7ffee8041af0, addr=3324, attrs=..., ptr=0x7ffff7f8a000, len=4, mr_addr=0, l=4, mr=0x5555573f27d0) at ../../qemu/system/physmem.c:2743</span></span><br><span class="line"><span class="comment">//#10 0x0000555555e2b982 in flatview_write (fv=0x7ffee8041af0, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2774</span></span><br><span class="line"><span class="comment">//#11 0x0000555555e2bdd0 in address_space_write (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4) at ../../qemu/system/physmem.c:2894</span></span><br><span class="line"><span class="comment">//#12 0x0000555555e2be4c in address_space_rw (as=0x55555704dc80 &lt;address_space_io&gt;, addr=3324, attrs=..., buf=0x7ffff7f8a000, len=4, is_write=true) at ../../qemu/system/physmem.c:2904</span></span><br><span class="line"><span class="comment">//#13 0x0000555555e85476 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7f8a000, direction=1, size=4, count=1) at ../../qemu/accel/kvm/kvm-all.c:2631</span></span><br><span class="line"><span class="comment">//#14 0x0000555555e85de6 in kvm_cpu_exec (cpu=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-all.c:2903</span></span><br><span class="line"><span class="comment">//#15 0x0000555555e88eb8 in kvm_vcpu_thread_fn (arg=0x5555573a0db0) at ../../qemu/accel/kvm/kvm-accel-ops.c:50</span></span><br><span class="line"><span class="comment">//#16 0x00005555560b2687 in qemu_thread_start (args=0x5555573aa8c0) at ../../qemu/util/qemu-thread-posix.c:541</span></span><br><span class="line"><span class="comment">//#17 0x00007ffff7894ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="comment">//#18 0x00007ffff7926850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val_in, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, was_irq_disabled = pci_irq_disabled(d);</span><br><span class="line">    <span class="type">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    assert(addr + l &lt;= pci_config_size(d));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, <span class="number">24</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS, <span class="number">4</span>) ||</span><br><span class="line">        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, <span class="number">4</span>) ||</span><br><span class="line">        range_covers_byte(addr, l, PCI_COMMAND))</span><br><span class="line">        pci_update_mappings(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranges_overlap(addr, l, PCI_COMMAND, <span class="number">2</span>)) &#123;</span><br><span class="line">        pci_update_irq_disabled(d, was_irq_disabled);</span><br><span class="line">        memory_region_set_enabled(&amp;d-&gt;bus_master_enable_region,</span><br><span class="line">                                  (pci_get_word(d-&gt;config + PCI_COMMAND)</span><br><span class="line">                                   &amp; PCI_COMMAND_MASTER) &amp;&amp; d-&gt;has_power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msi_write_config(d, addr, val_in, l);</span><br><span class="line">    msix_write_config(d, addr, val_in, l);</span><br><span class="line">    pcie_sriov_config_write(d, addr, val_in, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_update_mappings</span><span class="params">(PCIDevice *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIIORegion *r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pcibus_t</span> new_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; PCI_NUM_REGIONS; i++) &#123;</span><br><span class="line">        r = &amp;d-&gt;io_regions[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* this region isn&#x27;t registered */</span></span><br><span class="line">        <span class="keyword">if</span> (!r-&gt;size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        new_addr = pci_bar_address(d, i, r-&gt;type, r-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!d-&gt;has_power) &#123;</span><br><span class="line">            new_addr = PCI_BAR_UNMAPPED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This bar isn&#x27;t changed */</span></span><br><span class="line">        <span class="keyword">if</span> (new_addr == r-&gt;addr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* now do the real mapping */</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;addr != PCI_BAR_UNMAPPED) &#123;</span><br><span class="line">            trace_pci_update_mappings_del(d-&gt;name, pci_dev_bus_num(d),</span><br><span class="line">                                          PCI_SLOT(d-&gt;devfn),</span><br><span class="line">                                          PCI_FUNC(d-&gt;devfn),</span><br><span class="line">                                          i, r-&gt;addr, r-&gt;size);</span><br><span class="line">            memory_region_del_subregion(r-&gt;address_space, r-&gt;memory);</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;addr = new_addr;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;addr != PCI_BAR_UNMAPPED) &#123;</span><br><span class="line">            trace_pci_update_mappings_add(d-&gt;name, pci_dev_bus_num(d),</span><br><span class="line">                                          PCI_SLOT(d-&gt;devfn),</span><br><span class="line">                                          PCI_FUNC(d-&gt;devfn),</span><br><span class="line">                                          i, r-&gt;addr, r-&gt;size);</span><br><span class="line">            memory_region_add_subregion_overlap(r-&gt;address_space,</span><br><span class="line">                                                r-&gt;addr, r-&gt;memory, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_update_vga(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.owalle.com/2021/12/09/qemu-pci/">用QEMU来体会PCI/PCIE设备 </a></li>
<li><a target="_blank" rel="noopener" href="https://members.pcisig.com/wg/PCI-SIG/document/download/8237">PCI Local Bus Specification Revision 3.0</a></li>
<li><a target="_blank" rel="noopener" href="https://airbus-seclab.github.io/qemu_blog/pci.html">A deep dive into QEMU: PCI host bridge controller</a></li>
<li><a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/">【HARDWARE.0x00】PCI 设备简易食用手册</a></li>
<li><a target="_blank" rel="noopener" href="https://shaocheng.li/posts/2017/11/27/">x86 计算机的 PCI 总线结构</a></li>
<li><a target="_blank" rel="noopener" href="https://66ring.github.io/2021/09/10/universe/qemu/qemu_bus_simulate/">QEMU总线模拟 </a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GiantVM/doc/blob/master/pci.md">PCI设备的创建与初始化</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vertor11/article/details/135942748">QEMU - e1000全虚拟化前端与TAP/TUN后端流程简析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013253075/article/details/119485466">【精讲】PCIe基础篇——BAR配置过程</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">H4wk1ns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiaweihawk.github.io/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/">https://jiaweihawk.github.io/2024/08/04/qemu的PCI设备/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiaweihawk.github.io" target="_blank">H4wk1ns's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/qemu/">qemu</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"><img class="prev-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">qemu设备模型</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/virtio%E7%AE%80%E4%BB%8B/"><img class="next-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">virtio简介</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/08/qemu基本知识/" title="qemu基本知识"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">qemu基本知识</div></div></a></div><div><a href="/2024/07/20/qemu内存模型/" title="qemu内存模型"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="title">qemu内存模型</div></div></a></div><div><a href="/2024/07/31/qemu设备模型/" title="qemu设备模型"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">qemu设备模型</div></div></a></div><div><a href="/2024/08/23/virtio简介/" title="virtio简介"><img class="cover" src="/img/background.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-23</div><div class="title">virtio简介</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/profile.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">H4wk1ns</div><div class="author-info__description">coder && ctfer</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jiaweihawk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/static/cv/cv_zh.pdf" target="_blank" title="个人简历"><i class="fa-solid fa-file-pdf"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PCI%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">PCI基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PCI%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">PCI总线结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCI%E8%AE%BE%E5%A4%87%E7%BC%96%E5%8F%B7"><span class="toc-number">2.2.</span> <span class="toc-text">PCI设备编号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCI%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">PCI配置空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qemu%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.</span> <span class="toc-text">Qemu模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PCI%E6%A1%A5"><span class="toc-number">3.1.</span> <span class="toc-text">PCI桥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-PCIHostBridgeClass"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">struct PCIHostBridgeClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-PCIHostState"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">struct PCIHostState</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">类初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">对象初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">实例化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCI%E6%80%BB%E7%BA%BF"><span class="toc-number">3.2.</span> <span class="toc-text">PCI总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-PCIBusClass"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">struct PCIBusClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-PCIBus"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">struct PCIBus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">对象初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCI%E8%AE%BE%E5%A4%87"><span class="toc-number">3.3.</span> <span class="toc-text">PCI设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#E1000BaseClass"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">E1000BaseClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E1000State"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">E1000State</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">类初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">对象初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCI%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.4.</span> <span class="toc-text">PCI配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%AE%BE%E5%A4%87"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">指定设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">访问配置空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEBAR"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">设置BAR</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/23/virtio%E7%AE%80%E4%BB%8B/" title="virtio简介">virtio简介</a><time datetime="2024-08-23T15:05:52.000Z" title="发表于 2024-08-23 23:05:52">2024-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/04/qemu%E7%9A%84PCI%E8%AE%BE%E5%A4%87/" title="qemu的PCI设备">qemu的PCI设备</a><time datetime="2024-08-04T04:33:06.000Z" title="发表于 2024-08-04 12:33:06">2024-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/qemu%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/" title="qemu设备模型">qemu设备模型</a><time datetime="2024-07-31T15:38:12.000Z" title="发表于 2024-07-31 23:38:12">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/20/qemu%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="qemu内存模型">qemu内存模型</a><time datetime="2024-07-20T01:37:13.000Z" title="发表于 2024-07-20 09:37:13">2024-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/14/%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A0%88/" title="网卡与网络栈">网卡与网络栈</a><time datetime="2024-04-14T10:24:48.000Z" title="发表于 2024-04-14 18:24:48">2024-04-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By H4wk1ns</div><div class="footer_custom_text">come to hack me!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>