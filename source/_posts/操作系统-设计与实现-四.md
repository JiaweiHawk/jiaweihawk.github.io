---
title: 操作系统-设计与实现-四
date: 2021-08-10 09:21:41
tags: ['手写','操作系统']
categories: ['手写']
---


# 前言

  jyy老师太强了。这一章介绍一下并发控制中互斥相关的内容，并实现课程中的L1实验

# 互斥

  实现共享内存上的互斥，并不是一个非常简单的事情:
  1. 系统不能**同时**读/写共享内存(除了原子指令)，即`load`时不能写，只能单纯的读;而写的时候，无法进行读(即使类似于`addq $1, [sum]`这种指令，其也是分为读值、计算和写值三部分)。从而当一个线程完成状态读取和状态设置时，其实这两者之间可能状态已经发生了变化(另一个线程完成了状态读取和状态设置)
  2. 系统可能**乱序**执行指令。可能有些精妙的算法可以规避1.中的问题，例如**Peterson算法**。但是现代操作系统可能的指令乱序执行(即可能在读之前完成写)，也会导致互斥的失败


  可以看到，单纯的从软件上实现共享内存的互斥是非常困难的一件事情，因此这就往往需要硬件上进行协调配合!
  硬件可以通过诸如锁总线的方式，原子的实现**load-exec-store**指令，从而为我们实现共享内存上的互斥提供了有效的解决方法。
  这些原子指令，完美的解决了上面的两个难点，因此很容易就实现共享内存的互斥。这些方案往往简洁，且很好理解，如下面基于**xchg**的自选锁实现的共享内存的互斥。

  ```c
int locked = 0;

void lock() {
	while(xchg(&locked, 1));
}

void unlock() {
	xchg(&locked, 0);
}
```

  可以看到，由于**xchg**是原子的，因此任何时候，永远只可能有一个线程，在执行**lock**或**unlock**中的**xchg**指令，而只要有线程成功获取了锁(**xchg**返回的值为0)，则其同时会将`locked`的值设置为1，直到其归还锁之前，不会再有其他人获取锁。因此其简洁的实现了共享内存的互斥


# L1物理内存管理(pmm)

## 实验背景

  从这次实验开始，我们将真正的开始实现一个操作系统。
  在实现操作系统内核时，经常会需要为操作系统中新增的对象分配存储空间。在这些对象不再使用时，有需要将这些对象的内存进行回收。例如在前面的**M2**中调用`co_start`分配协程结构体资源;调用`co_wait`回收上述分配的资源。
  当然，对于迷你自制的操作系统来说，每种类型的资源都进行手工分配和释放是完全可行的。但是实现内存的自动分配和释放，可以简化操作系统内核中很多部分的代码，是十分值得的。
  在本次实验中，需要亲自体验平常使用的**malloc**/**free**应该如何实现。在多处理器系统中，各个处理器上的代码会并发地申请或释放内存，这会给内存分配和释放带来额外的挑战——一方面，希望不同处理器可以并行、高效地申请内存，少量甚至不会出现同时申请而产生一个处理器等待另一个处理器的情况;另一方面，不希望**malloc**/**free**仅仅通过简单粗暴使用一把互斥锁来保护，从而降低了内存管理的效率


## 实验描述

> <u>实验要求1:实现多处理器安全的内存分配和回收</u>
>> 类似于**malloc**/**free**，在bare-metal上实现内存分配/回收的函数:
>> ```c
static void *kalloc(size_t size) {
	//内存分配
}

static void *kfree(void *ptr) {
	//内存释放
}
```
> 在AbstractMachine启动后，$[heap.start, heap.end]$都是可用的物理内存(堆区)，`kalloc`返回的内存必须位于这个区间中。具体来说这个实验中你需要实现一个数据结构，维护一个不相交区间的集合(堆区)
> $$H = \{[\mathcal{l}_{0},\mathcal{r}_{0}),[\mathcal{l}_{1},\mathcal{r}_{1}),....,[\mathcal{l}_{n},\mathcal{r}_{n})\}$$
> 初始时，堆区为空。假设当前堆区为$H$，$heap.start = L，heap.end = R$
> - `kalloc(s)分配s字节的内存$[\mathcal{l}, \mathcal{r})$满足
>     分配发生在堆区中$$(L \le \mathcal{l} < \mathcal{r} \le R)$$
>     分配的内存不与已分配内存重叠($$\forall[\mathcal{l}_{i}, \mathcal{r}_{i}) \in H. [\mathcal{l}, \mathcal{r}) \cap [\mathcal{l}_{i}, \mathcal{r}_{i}) = \emptyset $$)
>   得到新的堆区
>   $$ H^{'} = H \cup \{[\mathcal{l}, \mathcal{r})\}$$
>   并返回新分配区间的左端点$\mathcal{l}$
> - `kfree($\mathcal{l}$)删除一个已有区间$[\mathcal{l}, \mathcal{r}) \in H$，得到新的堆区
>    $$H^{'} = H \setminus \{[\mathcal{l}, \mathcal{r})\}$$
>   当$\mathcal{l}$不是$H$中任何一个区间左端点时，产生**undefined behavior**
>
> 除了上面的抽象描述，还有一些作为**计算机系统软件基础设施**的要求:
> - 对于大小为$s$的内存分配请求，返回的内存地址必须对齐到$2^{i}$，其中$i$是最小的满足$2^{i} \ge s$。例如，分配17字节内存返回的地址必须是32的整数倍
> - 在分配算法不能找到足够的内存继续分配时，返回`NULL(0)`
>   - 受分配算法的局限，可能系统中仍然有空闲的内存，但形成了碎片的内存，或者单纯是分配算法不能找到这些内存而导致失败，这是允许的。
> - 由于这些API仅仅在自制的操作系统内核中使用，可以直接拒绝超过16MB的内存分配
> - 不必初始化返回的内存，当然，对返回的内存赋上初始值是个不错的主意
> - 最重要的要求在于**允许多处理器并行地调用`kalloc`/`kfree`**:
>   - 不同的处理器可能同时执行`kalloc`分配大小不同的内存
>   - 不同的处理器可能同时执行`kfree`释放内存
>   - 在一个处理器分配的内存，可能在另一个处理器上释放
>   - 在`kalloc`/`kfree`实现正确的前提下，尽可能使不同处理器上的内存分配能够并行
>
> <u>实验要求2:实现AbstractMachine中缺失的函数</u>
>> 在L0中，已经提出了这个实验要求。从现在开始，正式建议实现klib里缺失的函数——没有`printf`、`sprintf`等函数，根本就是在使用汇编语言写操作系统


## 实验指南

### 代码组织与运行

  实验框架代码由三个目录组成:

  ```
.
+--framework	->	框架代码;	可以在本地修改
|	+--kernel.h
|	+--main.c
+--include	->	头文件;	可以自由修改/创建文件
|	+--common.h
+--Makefile
+--src		->	源文件; 可以自由修改/创建文件
    +--os.c
    +--pmm.c
```

  可以使用前面提到的技巧(即执行`make -nB  | sed "s/^/\n/g" | sed "s/ /\n\t/g"`，观察并了解整个系统镜像的生成过程:
  1. 首先，其编译相关的源文件,生成目标文件，样例如下所示
  ```bash
x86_64-linux-gnu-gcc
        -std=gnu11
        -O2
        -MMD
        -Wall
        -Werror
        -ggdb
        -Iinclude/
        -Iframework/
        -I/home/hawk/Desktop/nju/kernel/include
        -I/home/hawk/Desktop/nju/kernel/../abstract-machine/am/include/
        -I/home/hawk/Desktop/nju/kernel/../abstract-machine/klib/include/
        -D__ISA__=\"x86_64\"
        -D__ISA_X86_64__
        -D__ARCH__=x86_64-qemu
        -D__ARCH_X86_64_QEMU
        -D__PLATFORM__=qemu
        -D__PLATFORM_QEMU
        -DARCH_H=\"arch/x86_64-qemu.h\"
        -fno-asynchronous-unwind-tables
        -fno-builtin
        -fno-stack-protector
        -Wno-main
        -m64
        -fPIC
        -mno-sse
        -c
        -o
        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/framework/main.o
        /home/hawk/Desktop/nju/kernel/framework/main.c
```
  2. 链接生成ELF文件，命令如下
  ```bash
x86_64-linux-gnu-ld
        -melf_x86_64
        -N
        -Ttext-segment=0x00100000
        -o
        /home/hawk/Desktop/nju/kernel/build/kernel-x86_64-qemu.elf
        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/framework/main.o
        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/./src/pmm.o
        /home/hawk/Desktop/nju/kernel/build/x86_64-qemu/./src/os.o
        /home/hawk/Desktop/nju/kernel/../abstract-machine/am/build/am-x86_64-qemu.a
        /home/hawk/Desktop/nju/kernel/../abstract-machine/klib/build/klib-x86_64-qemu.a
```
  3. 最后，生成可以运行的磁盘镜像文件，其命令如下所示
  ```bash
(
        cat
        /home/hawk/Desktop/nju/kernel/../abstract-machine/am/src/x86/qemu/boot/bootblock.o;
        head
        -c
        1024
        /dev/zero;
        cat
        /home/hawk/Desktop/nju/kernel/build/kernel-x86_64-qemu.elf
        )
        >
        /home/hawk/Desktop/nju/kernel/build/kernel-x86_64-qemu
```

  如果想要运行的话，和之前L0的实验是类似的，使用make即可执行，指令如下所示
  ```bash
make run ARCH=x86_64-qemu
```

  如果要启动多个处理器，则传递`smp`环境变量即可，执行如下命令即可启动4各处理器
  ```bash
make run ARCH=x86_64-qemu smp = 4
```

### 框架代码导读
