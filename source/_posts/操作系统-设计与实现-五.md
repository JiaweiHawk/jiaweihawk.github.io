---
title: 操作系统-设计与实现-五
date: 2021-09-07 10:47:00
tags: ["手写","操作系统"]
categories: ["手写"]
---


# 前言

  这几节课加深了对于操作系统的某些方面的了解，下面简单介绍一下进程抽象的相关问题，并实现课程中的M3实验


# 进程抽象
## fork系统调用

  之前我们一直将进程当作一个**状态机**。那么如果我们想要创建一个新的进程，也就是创建一个新的**状态机**即可。
  在Linux中，操作系统提供了**fork**系统调用，其会将当前的进程，即当前的状态机(包括内存和寄存器)，完整的复制一份，从而创建了新的进程。
  具体的，可以根据**man 2 fork**，查看接口信息，如下所示
  ```c
#include <unistd.h>

/*
On success, the PID of the child process is returned in the parent,  and  0  is
returned  in  the  child.   On  failure, -1 is returned in the parent, no child
process is created, and errno is set to indicate the error.
*/

pid_t fork(void);
```

### fork bomb

  自然的，我们可以想到，操作系统管理进程是需要资源的。那么理论上，我们只要不停地创建进程，系统最后会因为资源耗尽而崩溃。
  基于这个原理，有一个经典的命令——**fork bomb**，其会以指数级别的增长速度创建进程，从而使进程崩溃。
  **fork bomb**的经典命令格式如下所示
  ```bash
:(){:|:&};:
```

  可以看到，这个命令有点**tricky**，我们简单的分析一下该命令。
  首先，在bash中，`:`可以作为标识符，也就是其可以作为一个符号，那我们将其更换为一个更美观的标识符**fork**，转换后的命令如下
  ```bash
fork(){fork|fork&};fork
```

  此时可以大致看出来，这就是定义了一个函数，然后在进行调用即可。**bash**中的分号表示一个换行，这里我们在美化一下命令，添加适当的空白和换行，如下所示
  ```bash
fork() {
	fork | fork &
}
fork
```

  可以看到，其以二的幂的增长速度创建进程，从而很快导致系统崩溃


### fork中的缓冲问题

  实际上，虽然前面介绍**fork**的时候，只是简单的以**将当前的状态机(包括内存和寄存器)复制一份**介绍，但是中间有非常繁杂的细节，例如缓冲问题。
  首先简单的分析一份代码，如下所示
  ```c
#include <stdio.h>
#include <unistd.h>

int main() {
	for(int i = 0; i < 2; ++i) {
		fork();
		printf("hawk\n");
	}
}
```

  这份代码分析起来并不是很复杂，我们只要根据状态机理论，画一个状态图即可，如下所示
  ![fork状态图1](fork状态图1.PNG)

  可以看到，从理论上进行分析，最后该程序应该会执行6次**printf**，那么程序总共会在终端上输出6行**hawk**。但是我们进行如下测试，会得到匪夷所思的结果
  ```bash
[hawk@manjaro Desktop]$ ./fork-printf 
hawk
hawk
hawk
hawk
hawk
hawk
[hawk@manjaro Desktop]$ ./fork-printf | wc -l
8
```

  如果直接输出，程序确实是预期的结果;但如果我们将输出重定向，则其反而会输出8行**hawk**，与预期不同
  实际上，这就是缓冲导致的问题——正常情况下，glibc是行缓冲:即遇到'\n'，就将缓冲区输出到标准输出上;而当我们使用管道后，管道还会使用自己的缓冲区，可以通过**ulimit -a | grep "pipe size"**查看缓冲区大小。
  结合这个问题，实际上可以很好进行分析——即在复制状态机的状态时，其会将内存和寄存器等一并进行复制，而缓冲区也是存在于内存中的，自然也会一并复制过来，从而导致这个问题。具体的我们仍然可以结合状态图进行分析。
  ![fork状态图2](fork状态图2.PNG)

  可以看到，如果考虑到缓冲的话，其确实会输出8行**hawk**。
  为了确认我们的猜想，执行如下命令进行验证
  ```bash
[hawk@manjaro Desktop]$ (stdbuf -o0 ./fork-printf) | wc -l
6
```

## execve系统调用

  当我们想要创建一个新线程，我们可能需要其执行其他的命令。此时，仅仅用**fork**系统调用是不够的，还需要用**execve**系统调用，将当前的状态机状态重置成另一个程序的初始状态。
  类似于**fork**，我们可以通过**man 2 execve**查看该系统调用的接口信息，如下所示
  ```c
#include <unistd.h>


/*       
       execve() executes the program referred to by pathname.  This causes the program
       that is currently being run by the calling process to be replaced  with  a  new
       program,  with  newly  initialized stack, heap, and (initialized and uninitial‐
       ized) data segments.
*/
int execve(const char *pathname, char *const argv[], char *const envp[]);


/*
       pathname must be either a binary executable, or a script starting with  a  line
       of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       

       argv  is  an array of pointers to strings passed to the new program as its com‐
       mand-line arguments.  By convention, the first of these strings (i.e., argv[0])
       should  contain the filename associated with the file being executed.  The argv
       array must be terminated by  a  NULL  pointer.   (Thus,  in  the  new  program,
       argv[argc] will be NULL.)



       envp  is an array of pointers to strings, conventionally of the form key=value,
       which are passed as the environment of the new program.  The envp array must be
       terminated by a NULL pointer.
*/
```

## \_exit系统调用

  理论上，当我们有了**fork**、**execve**系统调用后，我们就可以自由的执行任意程序了。虽然如此，但我们还需要一个系统调用，用来中止当前的状态机(状态机自身只能不停的跳转到下一个状态)。
  Linux为此提供了**\_exit()**系统调用，用来立即销毁当前进程，或者说是状态机。同样的，可以通过**man 2 \_exit**查看该系统调用的接口信息，如下所示
  ```c
#include <unistd.h>

/*
_exit()  terminates  the calling process "immediately".  Any open file descrip‐
       tors belonging to the process are closed.  Any children of the process are  in‐
       herited  by  init(1)  (or by the nearest "subreaper" process as defined through
       the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process's  par‐
       ent is sent a SIGCHLD signal.
*/
noreturn void _exit(int status);


/*

C library/kernel differences
       In  glibc  up  to  version 2.3, the _exit() wrapper function invoked the kernel
       system call of the same name.  Since glibc 2.3, the  wrapper  function  invokes
       exit_group(2), in order to terminate all of the threads in a process.

       The  raw  _exit()  system  call terminates only the calling thread, and actions
       such as reparenting child processes or sending SIGCHLD to  the  parent  process
       are performed only if this is the last thread in the thread group.
*/
```

# M3系统调用Profiler(sperf)

## 实验背景

  **程序就是一个状态机**，而操作系统上的程序又通过**系统调用**和操作系统交互。
  虽然如此，如果不看看实际程序执行的系统调用，对操作系统的理解仍然是很片面的。

  所幸操作系统提供了足够的工具来查看——即追踪工具**trace**。**trace**工具是系统编程时非常常用的问题诊断工具。根据调试理论，**trace**在一定程度上反映了程序执行的流程，因此可以帮助你缩小bug所在的范围;此外，**trace**中额外的信息还能帮助诊断性能等问题。

  如果我们对**trace**进行一定的分析，就可以将其结果更优美的进行展示。在本次实验中，可以借助**strace**实现一个程序的**性能诊断**工具，其可以通过分析**trace**的输出，从而分析系统调用的性能信息


## 实验描述

> 实现命令行工具*sperf*:
> $$sperf \quad \underline{COMMAND} \quad \underline{[ARG]} \quad ...$$
> 其会在系统中执行**COMMAND**命令(如果**COMMAND**是以/开头的绝对路径，则直接执行;否则在**PATH**环境变量中搜索到第一个存在且可执行的文件)，并为**COMMAND**传入ARG参数，然后统计命令执行的系统调用所占用时间，最后在屏幕上显示出耗时最多的若干个系统调用的时间
> 一些假设和约定:
> - 输出的形式不限。对于较短时间运行的程序，可以一次性打印出耗时最多的几个系统调用;对于耗时较长的程序，需要定期(如每秒)打印出系统调用的耗时信息;
> - 假设**COMMAND**是单进程、单线程的，无需处理多进程和多线程的情况
> - 必须使用**execve**系统调用，而非**glibc**对于**execve**的包装(如**execl**、**execlp**、**execle**、**execv**、**execvp**或**execvpe**)


## 实验指南

  在该实验中，其大体上可以分为三个部分
  1. 创建子进程，在子进程中启动**strace**(通过**fork**/**execve**系统调用)
  2. 在父进程中捕获**strace**的输出(通过**pipe**系统调用)
  3. 解析捕获的**strace**输出，并把系统调用的时间信息统计显示


### 显示系统调用序列

  在该实验中，我们只需要通过**strace**，就可以方便的查看整个程序从**头**开始的按顺序的一系列的系统调用
  因此，本质上，该实验就是解析**strace**的输出


### 显示系统调用的时间(strace)

  根据实验要求，我们不仅需要分析程序的系统调用的序列，还需要统计每一个系统调用的时间占比。而这也就是要求**strace**输出中也应该包含每一次系统调用所消耗的时间。
  通过`man strace`可以很轻易的查到如下的信息
  ```plaintext
--syscall-times[=precision]
                   Show the time spent in system calls.  This records the time difference between the
                   beginning  and  the  end of each system call.  precision can be one of s (for sec‐
                   onds), ms (milliseconds), us (microseconds), or ns (nanoseconds), and allows  set‐
                   ting the precision of time value being printed.  Default is us (microseconds).
```

  因此，我们在调用**strace**时，添加相关的参数即可
  ~~实际上在man中可以直接找到输出系统调用及其时间百分比的参数，即`strace -cU time-percent`, 但是有点作弊~~


### spert:设计

  类似于前面的M1实验——其将**pstree**分解成多个更简单的子部分进行解决;这里也将**sperf**分解成几个更为简单的部件进行解决。
  1. 解析出**COMMAND**和**ARG**——就是**main**的相关参数
  2. 使用**fork**创建一个新的进程:
  	1. 子进程使用`execve`调用`strace COMMAND ARG ...`，启动一份**strace**
	- 在`execve`成功返回以后，子进程已经不再受控制了。`strace`会不断输出系统调用的trace，直到程序结束。当然，COMMAND命令不结束，`strace`也不会结束
	2. 父进程想办法不断读取`strace`的输出，直到**strace**程序结束
	- 能读取到输出，就可以解析出每个系统调用的时间，从而把统计信息打印到屏幕上


### 使用execve创建子进程

  实验中已经明确要求了，必须使用`execve`执行程序，因此我们需要通过`man 2 execve`详细了解一下该函数的信息，其内容如下所示
  ```c
       #include <unistd.h>

       int execve(const char *pathname, char *const argv[],
                  char *const envp[]);
```

  这里可能会有几个问题:
  1. **pathname**是相对于进程的当前目录(**current working directory**)而言的，或者是一个绝对路径。如果错误的传入可执行文件路径，则**execve**无法正确执行
  2. 传入正确的**argv**。在课件中实际上有一个非常优美的写法
  3. 传入正确的**envp**。部分程序的运行依赖于正确的环境变量，否则可能导致程序的异常


### 连接父子进程的输入

  使用`pipe`系统调用，可以创建一个管道，通过`man 2 pipe`查看该系统调用的详细信息，如下所示
  ```c
#include <unistd.h>

int pipe(int pipefd[2]);

/*
       pipe()  creates  a  pipe, a unidirectional data channel that can be used for interprocess communication.  The array pipefd is used to return two file descriptors referring to the ends of the
       pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel  until  it  is  read
       from the read end of the pipe.  For further details, see pipe(7).


       On success, zero is returned.  On error, -1 is returned, errno is set appropriately, and pipefd is left unchanged.
       On Linux (and other systems), pipe() does not modify pipefd on failure.  A requirement standardizing this behavior was added in POSIX.1-2016.  The Linux-specific pipe2() system call likewise
       does not modify pipefd on failure.
*/
```

  `man`手册中也给出了相关的使用样例，如下所示
  ```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int
main(int argc, char *argv[])
{
    int pipefd[2];
    pid_t cpid;
    char buf;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    cpid = fork();
    if (cpid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (cpid == 0) {    /* Child reads from pipe */
        close(pipefd[1]);          /* Close unused write end */

        while (read(pipefd[0], &buf, 1) > 0)
            write(STDOUT_FILENO, &buf, 1);

        write(STDOUT_FILENO, "\n", 1);
        close(pipefd[0]);
        _exit(EXIT_SUCCESS);

    } else {            /* Parent writes argv[1] to pipe */
        close(pipefd[0]);          /* Close unused read end */
        write(pipefd[1], argv[1], strlen(argv[1]));
        close(pipefd[1]);          /* Reader will see EOF */
        wait(NULL);                /* Wait for child */
        exit(EXIT_SUCCESS);
    }
}
```


  可以看到，使用**pipefd**，和使用普通的文件描述符没有什么区别——只不过**pipefd**指定了`pipefd[0]`只能读;`pipefd[1]`只能写

  实验指南中还额外指明了，可能需要**dup2**系统调用进行文件描述符的腾挪，这里同样通过`man 2 dup2`，查看该系统调用的相关信息
  ```c
#include <unistd.h>

int dup(int oldfd);
/*

       The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.

       After  a successful return, the old and new file descriptors may be used interchangeably.  They refer to the same open file description (see open(2)) and thus share file offset and file sta‐
       tus flags; for example, if the file offset is modified by using lseek(2) on one of the file descriptors, the offset is also changed for the other.

       The two file descriptors do not share file descriptor flags (the close-on-exec flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.
*/


int dup2(int oldfd, int newfd);
/*
       The dup2() system call performs the same task as dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd.  If  the  file
       descriptor newfd was previously open, it is silently closed before being reused.

       The  steps  of closing and reusing the file descriptor newfd are performed atomically.  This is important, because trying to implement equivalent functionality using close(2) and dup() would
       be subject to race conditions, whereby newfd might be reused between the two steps.  Such reuse could happen because the main program is interrupted by a signal handler that allocates a file
       descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.

       *  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.
*/
```

  实际上，也就是用来重定向文件描述符的系统调用


### 解析strace的输出

  实际上，**strace**的输出类似于一行c函数的调用，因此解析**strace**的输出，也就相当于一个**字符串处理**类型的问题。
  因此最方便的办法自然是通过正则表达式进行解析，可以通过`man 3 regex`查看相关的文档信息
  ```c
#include <sys/types.h>
#include <regex.h>

int regcomp(regex_t *preg, const char *regex, int cflags);
/*
       regcomp() is used to compile a regular expression into a form that is suitable for subsequent regexec() searches.
       regcomp() is supplied with preg, a pointer to a pattern buffer storage area; regex, a pointer to the null-terminated string and cflags, flags used to determine the type of compilation.
       All regular expression searching must be done via a compiled pattern buffer, thus regexec() must always be supplied with the address of a regcomp() initialized pattern buffer.
       cflags may be the bitwise-or of zero or more:
*/


int regexec(const regex_t *preg, const char *string, size_t nmatch,
            regmatch_t pmatch[], int eflags);
/*
       regexec()  is  used  to match a null-terminated string against the precompiled pattern buffer, preg.  nmatch and pmatch are used to provide information regarding the location of any matches.
       eflags may be the bitwise-or of one or both of REG_NOTBOL and REG_NOTEOL which cause changes in matching behavior.
*/


size_t regerror(int errcode, const regex_t *preg, char *errbuf,
                size_t errbuf_size);
/*
       regerror() is used to turn the error codes that can be returned by both regcomp() and regexec() into error message strings.
       regerror() is passed the error code, errcode, the pattern buffer, preg, a pointer to a character string buffer, errbuf, and the size of the string buffer, errbuf_size.  It returns  the  size
       of  the errbuf required to contain the null-terminated error message string.  If both errbuf and errbuf_size are nonzero, errbuf is filled in with the first errbuf_size - 1 characters of the
       error message and a terminating null byte ('\0').
*/



void regfree(regex_t *preg);
/*
       Supplying regfree() with a precompiled pattern buffer, preg will free the memory allocated to the pattern buffer by the compiling process, regcomp().
*/
```

  可以看到，首先需要进行正则表达式的预编译，然后再执行匹配过程，最后释放掉预编译所占用的空间。具体的细节可以查看手册了解


  当然，在解析strace的输出时，会遇到一些小麻烦，如下所示
  1. **strace**默认会将**trace**输出到**stderr**中。但如果**strace**追踪的程序同样输出到**stderr**，则会对解析**strace**的输出产生一些麻烦
  2. 即使解决了上面的问题(例如将程序的**stderr**重定向到**/dev/null**丢弃)，程序输出的字符串同样可能对解析产生麻烦，如下所示
  ```bash
$ strace -T echo -n '", 1) = 100 <99999.9>' > /dev/null
ioctl(1, TCGETS, 0x7fff80723570)        = -1 ENOTTY <0.000100>
write(1, "\", 1) = 100 <99999.9>", 21)  = 21 <0.000149>
close(1)                                = 0 <0.000126>
```


### 图形化展示


  最后，当我们获取了每个系统调用所花的总时间后，就可以使用[ANSI Escape Code](https://notes.burke.libbey.me/ansi-escape-codes/)，打印出一张图形化界面——只需要每个一段时间使用ANSI Escape Code清一下屏幕即可


  额外说明一下，实际上，在学会使用**Escape Code**之后，就打开了一扇新的大门，只需要两个额外的API，既可以实现任何有趣的东西
  1. 准确的定时器;
  2. 能够即刻捕获终端按键的API

## 实验环境

  直接按照实验手册上的说明，从github上继续拉取**M3**实验即可
  ```bash
git pull origin M3
```


## 实验实现

  下面是个人的思路及其实现，[实验实现](nju.tar.gz)

### 解析sperf、COMMAND、ARG和环境变量

  为了获取有效的**sperf**路径信息，则我们需要依次实验**PATH**环境变量，找到其有效路径。通过查阅手册`man 3 getenv`可知，可以通过**getenv**函数获取环境变量，如下所示
  ```c
#include <stdlib.h>

char *getenv(const char *name);
/*
The getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string.
*/
```
  Linux中PATH变量通过**:**进行分割，因此我们只需要根据**:**切割获取的环境变量，并依次遍历这些路径，则可以找到**sperf**文件所在的路径

  对于COMMAND，根据实验手册可知，其是第一个参数，即`argv[1]`即COMMAND。实际上其并不需要进行解析——因为我们会调用`execve(/path/to/sperf, sperf_args, sperf_env)`，实际上**sperf_args[1]**的值就是COMMAND。那么只要我们传递正确的**sperf_env**，则执行execve的时候，其会自动进行解析


  对于ARG，实际上就是`argv[2:]`,其中**argv[0] == sperf**,**argv[1] == COMMAND**，也不需要进行太多的解析

  最后则是环境变量，实际上根据手册`man 7 environ`可知，其是操作系统直接定义好的变量，如下所示
  ```c
extern char **environ;
/*
The variable environ points to an array of pointers to strings called the "environment".  The last pointer in this array has the value NULL.  (This variable must be declared in the user pro‐
       gram, but is declared in the header file <unistd.h> if the _GNU_SOURCE feature test macro is defined.)
*/
```
  因此，我们不需要更多的解析，直接使用即可


  最后，解析sperf、COMMAND、ARG和环境变量部分的代码如下所示
  ```c
```

### 图形化展示

  有时，"面向终端编程"并不是十分的直观，并且十分枯燥。因此可以通过使用[ANSI Escape Code](https://notes.burke.libbey.me/ansi-escape-codes/)，设置字符的颜色和坐标，从而通过在字符终端里绘制系统调用图的方式展示系统调用的耗时(系统调用所花时间与所占面积成正比)，直观地展示系统调用信息
