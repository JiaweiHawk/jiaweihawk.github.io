---
title: 操作系统-设计与实现-五
date: 2021-09-07 10:47:00
tags: ["手写","操作系统"]
categories: ["手写"]
---


# 前言

  这几节课加深了对于操作系统的某些方面的了解，下面简单介绍一下进程抽象的相关问题，并实现课程中的M3实验


# 进程抽象
## fork系统调用

  之前我们一直将进程当作一个**状态机**。那么如果我们想要创建一个新的进程，也就是创建一个新的**状态机**即可。
  在Linux中，操作系统提供了**fork**系统调用，其会将当前的进程，即当前的状态机(包括内存和寄存器)，完整的复制一份，从而创建了新的进程。
  具体的，可以根据**man 2 fork**，查看接口信息，如下所示
  ```c
#include <unistd.h>

/*
On success, the PID of the child process is returned in the parent,  and  0  is
returned  in  the  child.   On  failure, -1 is returned in the parent, no child
process is created, and errno is set to indicate the error.
*/

pid_t fork(void);
```

### fork bomb

  自然的，我们可以想到，操作系统管理进程是需要资源的。那么理论上，我们只要不停地创建进程，系统最后会因为资源耗尽而崩溃。
  基于这个原理，有一个经典的命令——**fork bomb**，其会以指数级别的增长速度创建进程，从而使进程崩溃。
  **fork bomb**的经典命令格式如下所示
  ```bash
:(){:|:&};:
```

  可以看到，这个命令有点**tricky**，我们简单的分析一下该命令。
  首先，在bash中，`:`可以作为标识符，也就是其可以作为一个符号，那我们将其更换为一个更美观的标识符**fork**，转换后的命令如下
  ```bash
fork(){fork|fork&};fork
```

  此时可以大致看出来，这就是定义了一个函数，然后在进行调用即可。**bash**中的分号表示一个换行，这里我们在美化一下命令，添加适当的空白和换行，如下所示
  ```bash
fork() {
	fork | fork &
}
fork
```

  可以看到，其以二的幂的增长速度创建进程，从而很快导致系统崩溃


### fork中的缓冲问题

  实际上，虽然前面介绍**fork**的时候，只是简单的以**将当前的状态机(包括内存和寄存器)复制一份**介绍，但是中间有非常繁杂的细节，例如缓冲问题。
  首先简单的分析一份代码，如下所示
  ```c
#include <stdio.h>
#include <unistd.h>

int main() {
	for(int i = 0; i < 2; ++i) {
		fork();
		printf("hawk\n");
	}
}
```

  这份代码分析起来并不是很复杂，我们只要根据状态机理论，画一个状态图即可，如下所示
  ```plaintext
pid0___(fork)___pid0___(printf)___(fork)___pid0___(printf)
         |                           |_____pid2___(printf)
         |______pid1___(printf)___(fork)___pid1___(printf)
	                             |_____pid3___(printf)
```

  可以看到，从理论上进行分析，最后该程序应该会执行6次**printf**，那么程序总共会在终端上输出6行**hawk**。但是我们进行如下测试，会得到匪夷所思的结果
  ```bash
[hawk@manjaro Desktop]$ ./fork-printf 
hawk
hawk
hawk
hawk
hawk
hawk
[hawk@manjaro Desktop]$ ./fork-printf | wc -l
8
```

  如果直接输出，程序确实是预期的结果;但如果我们将输出重定向，则其反而会输出8行**hawk**，与预期不同
  实际上，这就是缓冲导致的问题——正常情况下，glibc是行缓冲:即遇到'\n'，就将缓冲区输出到标准输出上;而当我们使用管道后，管道还会使用自己的缓冲区，可以通过**ulimit -a | grep "pipe size"**查看缓冲区大小。
  结合这个问题，实际上可以很好进行分析——即在复制状态机的状态时，其会将内存和寄存器等一并进行复制，而缓冲区也是存在于内存中的，自然也会一并复制过来，从而导致这个问题。具体的我们仍然可以结合状态图进行分析。
  ```plaintext
pid0___(fork)___pid0___(printf)___(buf:"hawk\n")___(fork)___pid0___(printf)___(buf:"hawk\nhawk\n")
         |                                            |_____pid2___(printf)___(buf:"hawk\nhawk\n")
         |______pid1___(printf)___(buf:"hawk\n")___(fork)___pid1___(printf)___(buf:"hawk\nhawk\n")
	                                              |_____pid3___(printf)___(buf:"hawk\nhawk\n")
```

  可以看到，如果考虑到缓冲的话，其确实会输出8行**hawk**。
  为了确认我们的猜想，执行如下命令进行验证
  ```bash
[hawk@manjaro Desktop]$ (stdbuf -o0 ./fork-printf) | wc -l
6
```

## execve系统调用

  当我们想要创建一个新线程，我们可能需要其执行其他的命令。此时，仅仅用**fork**系统调用是不够的，还需要用**execve**系统调用，将当前的状态机状态重置成另一个程序的初始状态。
  类似于**fork**，我们可以通过**man 2 execve**查看该系统调用的接口信息，如下所示
  ```c
#include <unistd.h>


/*       
       execve() executes the program referred to by pathname.  This causes the program
       that is currently being run by the calling process to be replaced  with  a  new
       program,  with  newly  initialized stack, heap, and (initialized and uninitial‐
       ized) data segments.
*/
int execve(const char *pathname, char *const argv[], char *const envp[]);


/*
       pathname must be either a binary executable, or a script starting with  a  line
       of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       

       argv  is  an array of pointers to strings passed to the new program as its com‐
       mand-line arguments.  By convention, the first of these strings (i.e., argv[0])
       should  contain the filename associated with the file being executed.  The argv
       array must be terminated by  a  NULL  pointer.   (Thus,  in  the  new  program,
       argv[argc] will be NULL.)



       envp  is an array of pointers to strings, conventionally of the form key=value,
       which are passed as the environment of the new program.  The envp array must be
       terminated by a NULL pointer.
*/
```

## \_exit系统调用

  理论上，当我们有了**fork**、**execve**系统调用后，我们就可以自由的执行任意程序了。虽然如此，但我们还需要一个系统调用，用来中止当前的状态机(状态机自身只能不停的跳转到下一个状态)。
  Linux为此提供了**\_exit()**系统调用，用来立即销毁当前进程，或者说是状态机。同样的，可以通过**man 2 \_exit**查看该系统调用的接口信息，如下所示
  ```c
#include <unistd.h>

/*
_exit()  terminates  the calling process "immediately".  Any open file descrip‐
       tors belonging to the process are closed.  Any children of the process are  in‐
       herited  by  init(1)  (or by the nearest "subreaper" process as defined through
       the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process's  par‐
       ent is sent a SIGCHLD signal.
*/
noreturn void _exit(int status);


/*

C library/kernel differences
       In  glibc  up  to  version 2.3, the _exit() wrapper function invoked the kernel
       system call of the same name.  Since glibc 2.3, the  wrapper  function  invokes
       exit_group(2), in order to terminate all of the threads in a process.

       The  raw  _exit()  system  call terminates only the calling thread, and actions
       such as reparenting child processes or sending SIGCHLD to  the  parent  process
       are performed only if this is the last thread in the thread group.
*/
```

# M3系统调用Profiler(sperf)

## 实验背景

  **程序就是一个状态机**，而操作系统上的程序又通过**系统调用**和操作系统交互。
  虽然如此，如果不看看实际程序执行的系统调用，对操作系统的理解仍然是很片面的。

  所幸操作系统提供了足够的工具来查看——即追踪工具**trace**。**trace**工具是系统编程时非常常用的问题诊断工具。根据调试理论，**trace**在一定程度上反映了程序执行的流程，因此可以帮助你缩小bug所在的范围;此外，**trace**中额外的信息还能帮助诊断性能等问题。

  如果我们对**trace**进行一定的分析，就可以将其结果更优美的进行展示。在本次实验中，可以借助**strace**实现一个程序的**性能诊断**工具，其可以通过分析**trace**的输出，从而分析系统调用的性能信息


## 实验描述

> 实现命令行工具*sperf*:
> $$sperf \quad \underline{COMMAND} \quad \underline{[ARG]} \quad ...$$
> 其会在系统中执行**COMMAND**命令(如果**COMMAND**是以/开头的绝对路径，则直接执行;否则在**PATH**环境变量中搜索到第一个存在且可执行的文件)，并为**COMMAND**传入ARG参数，然后统计命令执行的系统调用所占用时间，最后在屏幕上显示出耗时最多的若干个系统调用的时间
> 一些假设和约定:
> - 输出的形式不限。对于较短时间运行的程序，可以一次性打印出耗时最多的几个系统调用;对于耗时较长的程序，需要定期(如每秒)打印出系统调用的耗时信息;
> - 假设**COMMAND**是单进程、单线程的，无需处理多进程和多线程的情况
> - 必须使用**execve**系统调用，而非**glibc**对于**execve**的包装(如**execl**、**execlp**、**execle**、**execv**、**execvp**或**execvpe**)


## 实验指南

  在该实验中，其大体上可以分为三个部分
  1. 创建子进程，在子进程中启动**strace**(通过**fork**/**execve**系统调用)
  2. 在父进程中捕获**strace**的输出(通过**pipe**系统调用)
  3. 解析捕获的**strace**输出，并把系统调用的时间信息统计显示


### 显示系统调用序列

  在该实验中，我们只需要通过**strace**，就可以方便的查看整个程序从**头**开始的按顺序的一系列的系统调用
  因此，本质上，该实验就是解析**strace**的输出


### 显示系统调用的时间(strace)

  根据实验要求，我们不仅需要分析程序的系统调用的序列，还需要统计每一个系统调用的时间占比。而这也就是要求**strace**输出中也应该包含每一次系统调用所消耗的时间。
  通过`man strace`可以很轻易的查到如下的信息
  ```plaintext
--syscall-times[=precision]
                   Show the time spent in system calls.  This records the time difference between the
                   beginning  and  the  end of each system call.  precision can be one of s (for sec‐
                   onds), ms (milliseconds), us (microseconds), or ns (nanoseconds), and allows  set‐
                   ting the precision of time value being printed.  Default is us (microseconds).
```

  因此，我们在调用**strace**时，添加相关的参数即可
  ~~实际上在man中可以直接找到输出系统调用及其时间百分比的参数，即`strace -cU time-percent`, 但是有点作弊~~


### spert:设计

  类似于前面的M1实验——其将**pstree**分解成多个更简单的子部分进行解决;这里也将**sperf**分解成几个更为简单的部件进行解决。
  1. 解析出**COMMAND**和**ARG**——就是**main**的相关参数
  2. 使用**fork**创建一个新的进程:
  	1. 子进程使用`execve`调用`strace COMMAND ARG ...`，启动一份**strace**
	- 在`execve`成功返回以后，子进程已经不再受控制了。`strace`会不断输出系统调用的trace，直到程序结束。当然，COMMAND命令不结束，`strace`也不会结束
	2. 父进程想办法不断读取`strace`的输出，直到**strace**程序结束
	- 能读取到输出，就可以解析出每个系统调用的时间，从而把统计信息打印到屏幕上


### 使用execve创建子进程

  实验中已经明确要求了，必须使用`execve`执行程序，因此我们需要通过`man 2 execve`详细了解一下该函数的信息，其内容如下所示
  ```c
       #include <unistd.h>

       int execve(const char *pathname, char *const argv[],
                  char *const envp[]);
```

  这里可能会有几个问题:
  1. **pathname**是相对于进程的当前目录(**current working directory**)而言的，或者是一个绝对路径。如果错误的传入可执行文件路径，则**execve**无法正确执行
  2. 传入正确的**argv**。在课件中实际上有一个非常优美的写法
  3. 传入正确的**envp**。部分程序的运行依赖于正确的环境变量，否则可能导致程序的异常


### 连接父子进程的输入


## 实验环境

  直接按照实验手册上的说明，从github上继续拉取**M3**实验即可
  ```bash
git pull origin M3
```


## 实验实现

  下面是个人的思路及其实现，[实验实现](nju.tar.gz)

### 启动strace

  根据前面的分析，实际上


### 图形化展示

  有时，"面向终端编程"并不是十分的直观，并且十分枯燥。因此可以通过使用[ANSI Escape Code](https://notes.burke.libbey.me/ansi-escape-codes/)，设置字符的颜色和坐标，从而通过在字符终端里绘制系统调用图的方式展示系统调用的耗时(系统调用所花时间与所占面积成正比)，直观地展示系统调用信息
