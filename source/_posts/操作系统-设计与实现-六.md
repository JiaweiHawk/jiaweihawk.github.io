---
title: 操作系统-设计与实现-六
date: 2021-10-04 22:51:14
tags: ['手写','操作系统']
categories: ['手写']
---

# 前言

  最近太忙了，以至于**操作系统-设计与实现**和博客都没怎么更新过了...趁着国庆假期，把其他杂事都干完了，终于有时间来填坑了！

  首先总结一下最近的课程内容，然后实现L2。

## Manual

  对于计算机科学来说，其实际上就是一个由各种手册(标准)组成的学科。因此学习的最好方法就是**RTFM**, *Read The Friendly Manual*。
  如果想要对于Linux下的各种文件格式约定、内存布局等有更深入的了解，可以阅读[System V ABI手册](sysv-abi.pdf)

## 加载

  这里复现一下jyy老师在课程中给出的加载器demo

### 静态链接程序的加载

  对于静态链接的程序，其加载起来非常简单：由于二进制文件中已经包含了程序运行所需要的全部代码和数据，因此理论上，只需要通过**mmap**，将其映射入内存中，然后将执行流转交给程序入口即可。
  虽然如此，静态链接程序的加载器实际上坑也不少
  1. 要进行一些额外的设置(栈的初始化，部分寄存器初始化等)，从而使其符合Linux进程初始化的约定——具体可以查看[System V ABI手册](sysv-abi.pdf)的**Process Initialization**章节。
  2. **Auxiliary Vector**必须初始化，并且其必须包含**AT_RANDOM**类型的数据——因为**glibc**库的**__libc_start_main**会访问`_dl_random`所指向的地址，而这依赖**Auxiliary Vector**的**AT_RANDOM**类型的数据。另一方面，也不要将当前加载器的**Auxiliary Vector**直接当做待加载程序的**Auxiliary Vector**，部分加载器的**Auxiliary Vector**设置的值会导致待加载程序崩溃。具体的**Auxiliary Vector**在[System V ABI手册](sysv-abi.pdf)中有较为详细的说明。~~这个坑藏的太深了~~
  3. 将可执行文件映射入内存时，实际上只需要将**Program Header**的类型为**PT_LOAD**的**segment**载入内存即可
  4. 通过**mmap**将可执行文件映射入内存的时候
    - 如果**flags**参数没有设置**MAP_FIXED**，则**addr**参数仅仅被当做参考
    - **addr**参数、**offset**参数应该对齐到**sysconf(_SC_PAGE_SIZE)**
  5. 将每个**segment**通过**mmap**映射的时候，**mmap**函数的**prot**参数根据**segment**的**p_flags**字段判定；**mmap**函数的**flags**参数设置为`MAP_PRIVATE | MAP_FIXED`，从而确保**mmap**的地址为指定的虚拟地址；**mmap**函数的**addr**参数和**offset**参数，是根据**segment**的**p_vaddr**字段和**p_offset**字段对齐**p_align**字段产生的:这里如果**segment**的**p_vaddr**字段和**p_offset**字段如果对齐**p_align**字段的话，其也自动对齐了**sysconf(_SC_PAGE_SIZE)**
  6. 将**segment**通过**mmap**映射入内存时，映射的长度选择**segment**的**p_memsz**字段，其包含**p_filesz**大小的实际文件内容，以及部分**bss**数据。因此通过**mmap**映射完后，还需要将偏移从**p_filesz**到**p_memsz**的内存空间清零，作为**bss**部分的数据空间
  7. 将进程的栈空间稍微开大点，否则会爆栈~~一开始我以为4KB就足够了，结果还是太年轻~~

  最后，复现的、不那么优雅的静态链接程序的加载器的demo如下所示
  ```c
#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>

#define KB * (1024ll)
#define MB * (1024ll KB)
/*
 * 传入的环境变量数组
 */
extern char **environ;
/*
 * 载入64位的静态链接程序exec，其参数个数为argc，其参数指针数组为argv，环境变量数组为environ */
void static_load_elf(char *exec, int exec_argc, char *exec_argv[], char **exec_environ); /* 载入64位的静态链接程序exec的各个segment */
void static_load_segments(int exec_fd, Elf64_Ehdr *elf64_ehdr);
/*
 * 根据System V api文档
 * 初始化程序的堆栈结构，即设置argc，argv和envp即可
 */
void *static_init_stack(int exec_argc, char *exec_argv[], char **exec_environ);
/*
 * 根据System V api文档
 * 初始化相关的寄存器，自然包括控制流的跳转
 */
void static_init_registers(Elf64_Ehdr *elf64_ehdr, void *stack);





/*
 * 载入64位的静态链接程序exec，其参数个数为argc，其参数指针数组为argv，环境变量数组为environ
 */
void static_load_elf(char *exec, int exec_argc, char *exec_argv[], char **exec_environ) {
	//以只读模式打开exec文件
	int exec_fd = open(exec, O_RDONLY);

	if(exec_fd < 0) { exit(EXIT_FAILURE); }

	/*
	 * 由于这里只展示原理性的东西
	 * 因此不会进行特别多的检查
	 */


	//载入静态链接的起始部分(头部、Program Header)，默认4KB以内
	Elf64_Ehdr *elf64_ehdr = (Elf64_Ehdr*)mmap(
			NULL,		//addr，即映射的虚拟地址
			4 KB, 		//length，映射的字节长度
			PROT_READ,	//prot，映射内存的属性
			MAP_SHARED,	//flags，映射内存的标志
			exec_fd,	//fd，映射内存的文件描述符
			0		//offset，文件描述符的起始偏移
	);
	if(elf64_ehdr == MAP_FAILED) { exit(EXIT_FAILURE); }

#ifdef DEBUG
	printf("elf64_ehdr address => %p\n", elf64_ehdr);
	printf("elf64_ehdr->e_phentsize => %d\n", elf64_ehdr->e_phentsize);
	printf("elf64_ehdr->e_phnum => %d\n", elf64_ehdr->e_phnum);
	printf("elf64_ehdr->e_phoff => %ld\n", elf64_ehdr->e_phoff);
#endif



	// 载入64位的静态链接程序exec的各个segment即可
	static_load_segments(exec_fd, elf64_ehdr);


	// 初始化堆栈结构，即设置argc，argv和envp即可
	void *stack = static_init_stack(exec_argc, exec_argv, exec_environ);


	// 完成寄存器初始化并进行跳转
	static_init_registers(elf64_ehdr, stack);
}




/*
 * 载入64位的静态链接程序exec的各个segment
 */
void static_load_segments(int exec_fd, Elf64_Ehdr *elf64_ehdr) {

	//首先读取segments描述符数组，即Program header数组
	Elf64_Phdr *elf64_phdrs = (Elf64_Phdr*)(((uintptr_t)(elf64_ehdr)) + elf64_ehdr->e_phoff);
#ifdef DEBUG
	printf("elf64_phdrs address => %p\n", elf64_phdrs);
	printf("prot: PROT_READ => %#x PROT_WRITE => %#x PROT_EXEC => %#x\n", PROT_READ, PROT_WRITE, PROT_EXEC);
	printf("Elf64_Phdr->p_flags: PF_R => %#x PF_W => %#x PF_X => %#x\n", PF_R, PF_W, PF_X);
#endif


	//依次遍历segments，将其载入内存
	for(int i = 0; i < elf64_ehdr->e_phnum; ++i) {
		Elf64_Phdr *elf64_phdr = &elf64_phdrs[i];
		//如果对应的p_type字段是PT_LOAD，则直接将其载入至内存中即可
		if(elf64_phdr->p_type == PT_LOAD) {
			uint64_t prot = 0;

			//根据elf64_phdr->p_flags来判断映射权限
			if(elf64_phdr->p_flags & PF_R) { prot |= PROT_READ; }
			if(elf64_phdr->p_flags & PF_W) { prot |= PROT_WRITE; }
			if(elf64_phdr->p_flags & PF_X) { prot |= PROT_EXEC; }


			/*
			 * segments的大小和虚拟地址根据p_align字段进行对齐即可
			 */
			void *elf64_phdr_vaddr_align = (void*)((uintptr_t)elf64_phdr->p_vaddr & (~((uintptr_t)elf64_phdr->p_align - 1)));
			size_t elf64_phdr_length_align = elf64_phdr->p_memsz + ((uintptr_t)elf64_phdr->p_vaddr - (uintptr_t)elf64_phdr_vaddr_align);
			off_t elf64_phdr_offset_align = elf64_phdr->p_offset & (~((uintptr_t)elf64_phdr->p_align - 1));

#ifdef DEBUG
			printf("elf64_phdrs[%d] elf64_phdr_vaddr_align => %p, elf64_phdr_length_align => %#lx, elf64_phdr_offset_align => %#lx prots => %#lx\n", i, elf64_phdr_vaddr_align, elf64_phdr_length_align, elf64_phdr_offset_align, prot);
#endif
			void *address = mmap(
					elf64_phdr_vaddr_align,		//addr，即映射的虚拟地址
					elf64_phdr_length_align, 	//length，映射的字节长度
					prot,				//prot，映射内存的属性
					MAP_PRIVATE | MAP_FIXED,	//flags，映射内存的标志
					exec_fd,			//fd，映射内存的文件描述符
					elf64_phdr_offset_align		//offset，文件描述符的起始偏移
			);

			//由于可能存在bss段等，因此需要将多余的空间置为0，否则执行会错误
			memset(((char*)elf64_phdr->p_vaddr) + elf64_phdr->p_filesz, 0, elf64_phdr->p_memsz - elf64_phdr->p_filesz);

			//测试，用来输出载入的segment的相关地址信息
#ifdef DEBUG
			printf("elf64_phdrs[%d] address => %p p_vaddr => %#lx; p_memsz => %#lx; p_flags => %#x p_filesz => %#lx p_align => %#lx\n\n", i, address, elf64_phdr->p_vaddr, elf64_phdr->p_memsz, elf64_phdr->p_flags, elf64_phdr->p_filesz, elf64_phdr->p_align);
#endif
		}
	}
}


/*
 * 根据System V api文档
 * 初始化程序的堆栈结构，即设置argc，argv和envp即可
 */
void *static_init_stack(int exec_argc, char *exec_argv[], char **exec_environ) {
	/*
	 * 申请堆栈所需要的地址
	 */
	void *stack = mmap(
			NULL,				//addr，即映射的虚拟地址
			1 MB, 				//length，映射的字节长度
			PROT_READ | PROT_WRITE,		//prot，映射内存的属性
			MAP_PRIVATE | MAP_ANONYMOUS,	//flags，映射内存的标志
			-1,				//fd，映射内存的文件描述符
			0				//offset，文件描述符的起始偏移
	);


	//这里栈空间的起始位置
	uintptr_t *sp = (uintptr_t*)((uintptr_t)(stack) + 1 MB - 4 KB);

	//这里设置当前栈帧的顶部
	void *res = (void*)sp;


	//压入exec_argc
	*sp++ = exec_argc;

	//压入exec_argv
	for(int i = 0; exec_argv[i]; ++i) {*sp++ = (uintptr_t)exec_argv[i];}
	//压入exec_argv结束的0
	*sp++ = 0;

	//压入exec_environ
	int environ_idx = 0;
	for(; exec_environ[environ_idx]; ++environ_idx) {
		if(strchr(exec_environ[environ_idx], '_') != exec_environ[environ_idx]) { *sp++ = (uintptr_t)exec_environ[environ_idx]; }
		else {
			char *environ = (char*)malloc(strlen(exec_argv[0] + 3));
			sprintf(environ, "_=%s", exec_argv[0]);
			*sp++ = (uintptr_t)environ;
		}
	}
	//压入exec_environ结束的0
	*sp++ = 0;


	//压入auxiliary vector entries，这些是内核提供给用户空间的一些设置参数，否则glibc无法正常运行。不能直接复制加载器的，否则待加载程序会崩溃
	//for(Elf64_auxv_t *elf64_auxv_t = (Elf64_auxv_t*)&exec_environ[environ_idx + 1]; elf64_auxv_t->a_type != AT_NULL; ++elf64_auxv_t) {
	//	*((Elf64_auxv_t*)sp) = *elf64_auxv_t;
	//	sp = (uintptr_t*)((Elf64_auxv_t*)sp + 1);
	//}
	*((Elf64_auxv_t*)sp) = (Elf64_auxv_t){ .a_type = AT_RANDOM, .a_un.a_val = (uintptr_t)(stack) + 1 MB - 16};
	sp = (uintptr_t*)((Elf64_auxv_t*)sp + 1);
	*((Elf64_auxv_t*)sp) = (Elf64_auxv_t){ .a_type = AT_NULL};
	


#ifdef DEBUG
	printf("stack => %p\n", res);
	int argc = *(int*)res, i;
	printf("argc => %d\n", argc);

	char **argv = ((char**)res) + 1;
	for(i = 0; i < argc; ++i) { printf("argv[%d] = %s\n", i, argv[i]); }

	char **environ = argv + argc + 1;
	for(i = 0; environ[i]; ++i) { printf("environ[%d] = %s\n", i, environ[i]); }

	Elf64_auxv_t *elf64_auxv_t = (Elf64_auxv_t*)(environ + i + 1);
	for(i = 0; elf64_auxv_t[i].a_type != AT_NULL; ++i) { printf("auxiliary[%d].a_type = %#lx, auxiliary[%d].a_un.a_val = %#lx\n", i, elf64_auxv_t[i].a_type, i, elf64_auxv_t[i].a_un.a_val); }

#endif

	return res;
}




/*
 * 根据System V api文档
 * 初始化相关的寄存器，自然包括控制流的跳转
 */
void static_init_registers(Elf64_Ehdr *elf64_ehdr, void *stack){

	//通过内联汇编，初始化寄存器，并完成跳转
	__asm__ volatile(
			"mov %0, %%rsp;"	//将rsp设置为之前初始化的栈的位置
			"xor %%rdx, %%rdx;"	//将rdx设置为atexit部分
			"jmp *%1"		//将待跳转的目标地址存到寄存器中，然后间接跳转
			:
			: "r"(stack), "r"(elf64_ehdr->e_entry)
			: "rdx");
}


int main(int argc, char *argv[]) {

	if(argc == 1) {
		printf("Usage: static-loader file [args...]\n");
		exit(EXIT_SUCCESS);
	}

	/*
	 * argv[0] = "./static-loader"
	 * argv[1] = 待载入程序路径
	 * argv[2 : argc] = 待载入程序参数
	 * argv[argc] = 0
	 */
	static_load_elf(argv[1], argc - 1, argv + 1, environ);


	//理论上，完成跳转后，程序通过hlt退出，永远不会执行到该处
	exit(EXIT_FAILURE);
}
```

  代码的注释已经非常详细了，下面直接给出[静态链接程序的加载器demo](static_loader.tar.gz)


### 动态链接程序的加载

  当前标准下的动态链接程序加载十分繁琐，但是其整体原理还是较为简单的。因此这里保留动态链接程序加载的主要原理，实现一个**自定义**的动态链接的标准，并实现一个基于该**自定义**标准的动态链接程序的加载器，从而帮助理解动态链接程序的加载过程及其原理

#### 为什么需要动态链接

  程序之间往往会包含一部分重复的代码(极端情况就是一个shell程序可能运行多份)。如果程序都采取静态链接，则作为进程加载的时候，需要将整个程序二进制文件都载入到内存中，这是十分浪费的。
  因此，我们希望采用某种技术(实际上就是动态链接)，从而将程序可能重复的部分仅仅加载一次

#### 为什么静态链接不行

  简单来说，是由于程序的编译链接和程序的载入不是同时进行的

  静态链接要求在编译链接时一次性生成程序运行所需要的所有数据，但是其必定无法确定在将来被载入时的重复代码部分的内存地址
  而动态链接在编译时仅仅按照相关标准生成重复代码调用的相关标记，则可以正常完成编译；在载入时再通过编译留下的标记信息和系统调用，载入重复代码或获取已经被载入的重复代码的内存地址，从而正确执行。


#### 如何实现动态链接

  实际上，根据前面的分析，我们知道。采用动态链接的程序，其在载入的时候，会动态的载入重复部分的代码，并执行这部分代码。这部分代码就是动态加载库。

  1. 动态加载库的代码格式
  因此，实际上要实现动态链接，起码需要产生可以不依赖加载地址进行执行的代码形式，从而将其作为动态加载库的代码格式。而这就是位置无关代码格式，其访问变量或代码时，都通过相对**rip**寄存器的偏移进行访问，从而避免了对于载入地址的依赖性。

  2. 程序的编译 
  根据前面的分析，采用动态链接载入的程序，在编译的时候需要按照相关标准生成动态链接库的调用标记。最简单的方式，就是将所有待解析的符号地址及其特征(如符号名)存储在一个数组中。这样，当编译的时候，只需要生成该数组即可,然后调用的地址为该数组中的待解析符号地址即可。这个数组即**GOT**(Global Offset Table)
  而为了方便最终的符号解析，动态链接库中应该包含一个动态链接库的符号导出表，其包含符号在当前动态链接库的相对偏移以及符号的特征。
  载入程序时，根据依赖顺序首先载入所有的动态链接库，然后根据载入符号表中的导出表，从而根据其符号特征重新解析导入表中符号对应的地址即可。


#### 动态链接实现细节

  由于是一个小的演示demo，所以这里定义了自己的一个非常简单的动态链接库标准
  1. 该动态链接库需要程序员自己手动加载，而非类似**ld.so**的自动递归的加载动态链接库。并且动态链接库的查找目录是固定的，和可执行程序处于同一个目录
  2. 动态链接库的符号表必须位于固定位置(这里实现的就是位于动态链接库的起始位置)
  3. 动态链接库需要编译成位置无关代码


  首先，我们规定一个符号的数据结构，从而生成前面分析事提到的符号表，如下所示
  ```c
#define SYMBOL_SIZE (64)
#define SYMBOL_TYPE_TERMINATE	(0)
#define SYMBOL_TYPE_IMPORT	(1)
#define SYMBOL_TYPE_EXPORT	(2)

typedef struct SYMBOL {
	uint64_t offset;
	uint64_t type;
	char name[SYMBOL_SIZE - sizeof(uint64_t) - sizeof(uint64_t)];
} Symbol;
```
  
  实际上，其包括符号的地址以及符号特征(符号名称)等信息。而为了导入符号和导出符号公用一个数据结构，我们添加了**type**字段用来进行区分。
  自定义的标准中要求将符号表放置在动态链接库的起始位置。为了使生成的动态链接库满足上述的标准，我们可以通过汇编代码，以及**objcopy**命令，生成raw文件，而非**ELF**格式的文件。为了方便汇编代码的操作，我们定义了如下的一些宏
  ```c
#ifdef __ASSEMBLER__
/*
 * 这里主要定义一些汇编指令下的宏，方便编写汇编源代码
 */

//定义一个符号表的起始
#define DYNLIB_SYMS	symbols_start:

/*
 * 定义一个符号表的终结
 * .align ALIGN GAP;		按ALIGN对齐下一个符号，中间使用GAP填充
 * .fill REPEAT, SIZE, VALUE;	将SIZE大小的VALUE值拷贝REPEAT次
 */
#define DYNLIB_SYMS_END	.align SYMBOL_SIZE, 0; \
	.fill SYMBOL_SIZE, 1, 0; 

/*
 * 在汇编源代码中，定义导出表
 * 其中包含相对载入基址的相对偏移，以及符号特征
 * .quad VALUE			定义了一个QUAD类型的数据，其值为VALUE
 * .asciz VALUE			使用ASCII字符声明VALUE文本字符串，并在结尾自动添加结束符\0
 * #VAR				将宏参数转换为字符常量
 */
#define EXPORT(name) .align SYMBOL_SIZE, 0; \
	.quad (name - symbols_start); \
	.quad SYMBOL_TYPE_EXPORT; \
	.asciz #name;


/*
 * 在汇编源代码中，定义导入表
 * 其中包含符号待解析地址，以及符号特征
 * .quad VALUE			定义了一个QUAD类型的数据，其值为VALUE
 * .ascii VALUE			使用ASCII字符声明VALUE文本字符串，结尾没有结束符\0
 * str1##str2			将两个token连接为字符常量
 */
#define IMPORT(name) .align SYMBOL_SIZE, 0; \
	name##_dyn: \
	.quad 0; \
	.quad SYMBOL_TYPE_IMPORT; \
	.asciz #name; \

#else
/*
 * 前面汇编源代码中仅仅实现了相关动态链接库的符号标记
 * 这里是上述动态链接库的具体符号标记的含义
 */

#include <stdint.h>
typedef struct SYMBOL {
	uint64_t offset;
	uint64_t type;
	char name[SYMBOL_SIZE - sizeof(uint64_t) - sizeof(uint64_t)];
} Symbol;

#endif		//__ASSEMBLER__


#endif
```

  可以看到，其主要实现了汇编文件中定义**struct SYMBOL**结构体的操作，即**IMPORT(NAME)**和**EXPORT(NAME)**。对于导入符号来说，其最终的符号地址需要在载入的时候进行解析，因此将**offset**字段填充为0即可，在载入的时候，导入的符号已经加载进内存了，则将该符号的地址覆盖到符号的**offset**字段即可，其余按照标准和结构体字段的含义进行填充即可；而对于导出符号来说，其最终的符号地址虽然不知道，但是其相对动态链接库加载地址的偏移始终是不变的，则先将该值填充为相对偏移值即可，等载入的时候，在**offset**字段添加动态链接库的载入地址即可

  下面是一个动态链接库的具体样例，如下所示
  ```x86asm
#include "dynamic.h"

// 将导入导出表放置在最开始
DYNLIB_SYMS

// 导出libb_fun导出
EXPORT(libb_func)

// 导入liba.S中的liba_var导出
IMPORT(liba_func)


// 这里导入导出表结束
DYNLIB_SYMS_END

libb_func:
	call *liba_func_dyn(%rip)
	addq $1, %rax
	ret
```

  这里唯一需要说明的就是动态链接库中，对于导入符号的调用。虽然在编译的时候，并不知道导入符号的最终地址，但是在该动态链接库载入的时候，该动态链接库的导入符号一定已经被载入内存中。则在动态链接库载入的过程中，将导入符号的地址写入导入符号表的**offset**中即可。也就是虽然在编译的时候，并不知道导入符号的最终地址，但是可以确定导入符号的地址是在导入符号表的**offset**字段的，而导入符号表的地址在编译时可以通过相对偏移进行访问，从而也就保证了动态链接库在载入完后可以通过导入符号表正确调用导入的符号。


  最后，则是程序调用动态链接库的相关说明。根据前面的说明，实际上程序在加载动态链接库的时候，唯一的工作就是处理动态链接库的符号表
  1. 对于导出符号类型，将其**struct SYMBOL**的**offset**字段添加上动态链接库的载入地址，从而获得符号的真实地址。除此之外，还需要保存一份**struct SYMBOL**，方便之后动态链接库的导入符号的解析以及程序调用该导入符号
  2. 对于导入符号类型，根据标准，其依赖的动态链接库已经完成加载，则所调用的导入符号也已经完成了解析。则遍历前面1.步骤中保存的符号表，找到该符号，并且覆盖该动态链接库导入符号的**offset**字段，从而确保该动态链接库调用导入符号的正常执行。

  演示代码如下所示
  ```c
#include "dynamic.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <assert.h>


/*
 * 当前程序加载的动态链接库中所有的程序
 */
static Symbol *symbols[128] = {NULL};
static int symbols_size = 0;


/*
 * 处理动态链接库中导入符号类型的符号
 */
void
do_type_import_symol(Symbol *symbol)
{
	assert(symbol->type == SYMBOL_TYPE_IMPORT);
	if(symbol == NULL) { return; }

	printf("[*] try to resolve the import symbol:%s\n", symbol->name);

	// 遍历程序的符号表，如果找到符号特征(符号名称)相同的，则解析符号即可
	for(int i = 0; i < symbols_size; ++i) {
		if(!strcmp(symbol->name, symbols[i]->name)) {
			printf("[*] succeed to resolve the import symbol:%s\n", symbol->name);
			symbol->offset = (uint64_t)symbols[i]->offset;
			return;
		}
	}

	printf("[*] failed to resolve the import symbol:%s\n", symbol->name);
}



/*
 * 处理动态链接库中导出符号类型的符号
 */
void
do_type_export_symbol(Symbol *symbol, void *base_addr)
{
	assert(symbol->type == SYMBOL_TYPE_EXPORT);
	if(symbol == NULL) { return; }

	printf("[*] try to resolve the export symbol:%s\n", symbol->name);

	symbols[symbols_size] = symbol;
	symbols[symbols_size]->offset += (uint64_t)base_addr;
	++symbols_size;
	
	printf("[*] succeed to resolve the export symbol:%s\n", symbol->name);
}



/*
 * 这里根据库的名称
 * 加载当前目录下的.o文件即可
 */
void
load(const char *lib_name)
{
	if(lib_name == NULL) { return; }

	printf("[*] try to load the %s\n", lib_name);

	int lib_name_len = strlen(lib_name);
	char *lib_path = (char*)malloc(sizeof(char) * (lib_name_len + 2 + 7));
	assert(lib_path != NULL);
	sprintf(lib_path, "./%s.dynlib", lib_name);

#ifdef DEBUG
	printf("[*] try to load the %s with path:%s\n", lib_name, lib_path);
#endif

	int fd = -1;
	if((fd = open(lib_path, O_RDONLY)) < 0) {
		printf("[*] fail to open the %s\n", lib_name);
		free(lib_path);
		return;
	}

	//通过mmap映射
	void *base_addr = NULL;
	if((base_addr = mmap(NULL, 4096, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)) == NULL) {
		printf("[*] fail to load the %s\n", lib_name);
		free(lib_path);
		return;
	}


	/*
	 * 由于每一个动态链接的符号表在其首部
	 * 则依次遍历即可
	 *
	 * 如果是导出表，则向全局符号表中添加符号即可
	 * 如果是导入表，则遍历全局符号表，查找对应的符号即可
	 */
	for(Symbol *symbol = (Symbol*)base_addr; symbol->type != SYMBOL_TYPE_TERMINATE; ++symbol) {
#ifdef DEBUG
		printf("[*] symbol address => %p\n", symbol);
		printf("[*] try to load the symbol: %s\n", symbol->name);
#endif
		switch(symbol->type) {
			case SYMBOL_TYPE_IMPORT:
				do_type_import_symol(symbol);
				break;
			case SYMBOL_TYPE_EXPORT:
				do_type_export_symbol(symbol, base_addr);
				break;
		}
	}

	printf("[*] succeed to load the %s\n", lib_name);
	free(lib_path);
}


/*
 * 调用动态链接库中的符号表
 * 即遍历程序所有的符号表，找出给定的符号特征并且执行即可
 */
void
do_execute_symbol(const char *name)
{
	if(name == NULL) { return; }

	printf("[*] try to execute the symbol:%s\n", name);

	// 遍历程序的符号表，如果找到符号特征(符号名称)相同的，则执行符号即可
	for(int i = 0; i < symbols_size; ++i) {
		if(!strcmp(name, symbols[i]->name)) {
#ifdef DEBUG
			printf("[*] the address of the symbol:%s is %lx\n", name, symbols[i]->offset);
#endif
			printf("[*] %s() = %ld\n", name, ((uint64_t (*)())symbols[i]->offset)());
			return;
		}
	}

	printf("[*] failed to execute the symbol:%s\n", name);
}

int main(void) {
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);
	setbuf(stderr, NULL);

	load("liba");
	do_execute_symbol("liba_func");
	load("libb");
	do_execute_symbol("libb_func");
	return 0;
}
```

  这里给出[动态链接程序的加载器demo](dynamic_loader.tar.gz)

# L2多处理器内核上的线程管理(kmt)

## 实验背景

## 实验描述

## 实验指南

## 实验环境

## 实验实现

## 实验结果
