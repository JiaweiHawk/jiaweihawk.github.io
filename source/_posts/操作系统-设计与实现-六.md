---
title: 操作系统-设计与实现-六
date: 2021-10-04 22:51:14
tags: ['手写','操作系统']
categories: ['手写']
---

# 前言

  最近太忙了，以至于**操作系统-设计与实现**和博客都没怎么更新过了...趁着国庆假期，把其他杂事都干完了，终于有时间来填坑了！

  首先总结一下最近的课程内容，然后实现L2。

## Manual

  对于计算机科学来说，其实际上就是一个由各种手册(标准)组成的学科。因此学习的最好方法就是**RTFM**, *Read The Friendly Manual*。
  如果想要对于Linux下的各种文件格式约定、内存布局等有更深入的了解，可以阅读[System V ABI手册](sysv-abi.pdf)

## 加载

  这里复现一下jyy老师在课程中给出的加载器demo

### 静态链接程序的加载

  对于静态链接的程序，其加载起来非常简单：由于二进制文件中已经包含了程序运行所需要的全部代码和数据，因此理论上，只需要通过**mmap**，将其映射入内存中，然后将执行流转交给程序入口即可。
  虽然如此，静态链接程序的加载器实际上坑也不少
  1. 要进行一些额外的设置(栈的初始化，部分寄存器初始化等)，从而使其符合Linux进程初始化的约定——具体可以查看[System V ABI手册](sysv-abi.pdf)的**Process Initialization**章节。
  2. **Auxiliary Vector**必须初始化，并且其必须包含**AT_RANDOM**类型的数据——因为**glibc**库的**__libc_start_main**会访问`_dl_random`所指向的地址，而这依赖**Auxiliary Vector**的**AT_RANDOM**类型的数据。另一方面，也不要将当前加载器的**Auxiliary Vector**直接当做待加载程序的**Auxiliary Vector**，部分加载器的**Auxiliary Vector**设置的值会导致待加载程序崩溃。具体的**Auxiliary Vector**在[System V ABI手册](sysv-abi.pdf)中有较为详细的说明。~~这个坑藏的太深了~~
  3. 将可执行文件映射入内存时，实际上只需要将**Program Header**的类型为**PT_LOAD**的**segment**载入内存即可
  4. 通过**mmap**将可执行文件映射入内存的时候
    - 如果**flags**参数没有设置**MAP_FIXED**，则**addr**参数仅仅被当做参考
    - **addr**参数、**offset**参数应该对齐到**sysconf(_SC_PAGE_SIZE)**
  5. 将每个**segment**通过**mmap**映射的时候，**mmap**函数的**prot**参数根据**segment**的**p_flags**字段判定；**mmap**函数的**flags**参数设置为`MAP_PRIVATE | MAP_FIXED`，从而确保**mmap**的地址为指定的虚拟地址；**mmap**函数的**addr**参数和**offset**参数，是根据**segment**的**p_vaddr**字段和**p_offset**字段对齐**p_align**字段产生的:这里如果**segment**的**p_vaddr**字段和**p_offset**字段如果对齐**p_align**字段的话，其也自动对齐了**sysconf(_SC_PAGE_SIZE)**
  6. 将**segment**通过**mmap**映射入内存时，映射的长度选择**segment**的**p_memsz**字段，其包含**p_filesz**大小的实际文件内容，以及部分**bss**数据。因此通过**mmap**映射完后，还需要将偏移从**p_filesz**到**p_memsz**的内存空间清零，作为**bss**部分的数据空间
  7. 将进程的栈空间稍微开大点，否则会爆栈~~一开始我以为4KB就足够了，结果还是太年轻~~

  最后，复现的、不那么优雅的静态链接程序的加载器的demo如下所示
  ```c
#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>

#define KB * (1024ll)
#define MB * (1024ll KB)
/*
 * 传入的环境变量数组
 */
extern char **environ;
/*
 * 载入64位的静态链接程序exec，其参数个数为argc，其参数指针数组为argv，环境变量数组为environ */
void static_load_elf(char *exec, int exec_argc, char *exec_argv[], char **exec_environ); /* 载入64位的静态链接程序exec的各个segment */
void static_load_segments(int exec_fd, Elf64_Ehdr *elf64_ehdr);
/*
 * 根据System V api文档
 * 初始化程序的堆栈结构，即设置argc，argv和envp即可
 */
void *static_init_stack(int exec_argc, char *exec_argv[], char **exec_environ);
/*
 * 根据System V api文档
 * 初始化相关的寄存器，自然包括控制流的跳转
 */
void static_init_registers(Elf64_Ehdr *elf64_ehdr, void *stack);





/*
 * 载入64位的静态链接程序exec，其参数个数为argc，其参数指针数组为argv，环境变量数组为environ
 */
void static_load_elf(char *exec, int exec_argc, char *exec_argv[], char **exec_environ) {
	//以只读模式打开exec文件
	int exec_fd = open(exec, O_RDONLY);

	if(exec_fd < 0) { exit(EXIT_FAILURE); }

	/*
	 * 由于这里只展示原理性的东西
	 * 因此不会进行特别多的检查
	 */


	//载入静态链接的起始部分(头部、Program Header)，默认4KB以内
	Elf64_Ehdr *elf64_ehdr = (Elf64_Ehdr*)mmap(
			NULL,		//addr，即映射的虚拟地址
			4 KB, 		//length，映射的字节长度
			PROT_READ,	//prot，映射内存的属性
			MAP_SHARED,	//flags，映射内存的标志
			exec_fd,	//fd，映射内存的文件描述符
			0		//offset，文件描述符的起始偏移
	);
	if(elf64_ehdr == MAP_FAILED) { exit(EXIT_FAILURE); }

#ifdef DEBUG
	printf("elf64_ehdr address => %p\n", elf64_ehdr);
	printf("elf64_ehdr->e_phentsize => %d\n", elf64_ehdr->e_phentsize);
	printf("elf64_ehdr->e_phnum => %d\n", elf64_ehdr->e_phnum);
	printf("elf64_ehdr->e_phoff => %ld\n", elf64_ehdr->e_phoff);
#endif



	// 载入64位的静态链接程序exec的各个segment即可
	static_load_segments(exec_fd, elf64_ehdr);


	// 初始化堆栈结构，即设置argc，argv和envp即可
	void *stack = static_init_stack(exec_argc, exec_argv, exec_environ);


	// 完成寄存器初始化并进行跳转
	static_init_registers(elf64_ehdr, stack);
}




/*
 * 载入64位的静态链接程序exec的各个segment
 */
void static_load_segments(int exec_fd, Elf64_Ehdr *elf64_ehdr) {

	//首先读取segments描述符数组，即Program header数组
	Elf64_Phdr *elf64_phdrs = (Elf64_Phdr*)(((uintptr_t)(elf64_ehdr)) + elf64_ehdr->e_phoff);
#ifdef DEBUG
	printf("elf64_phdrs address => %p\n", elf64_phdrs);
	printf("prot: PROT_READ => %#x PROT_WRITE => %#x PROT_EXEC => %#x\n", PROT_READ, PROT_WRITE, PROT_EXEC);
	printf("Elf64_Phdr->p_flags: PF_R => %#x PF_W => %#x PF_X => %#x\n", PF_R, PF_W, PF_X);
#endif


	//依次遍历segments，将其载入内存
	for(int i = 0; i < elf64_ehdr->e_phnum; ++i) {
		Elf64_Phdr *elf64_phdr = &elf64_phdrs[i];
		//如果对应的p_type字段是PT_LOAD，则直接将其载入至内存中即可
		if(elf64_phdr->p_type == PT_LOAD) {
			uint64_t prot = 0;

			//根据elf64_phdr->p_flags来判断映射权限
			if(elf64_phdr->p_flags & PF_R) { prot |= PROT_READ; }
			if(elf64_phdr->p_flags & PF_W) { prot |= PROT_WRITE; }
			if(elf64_phdr->p_flags & PF_X) { prot |= PROT_EXEC; }


			/*
			 * segments的大小和虚拟地址根据p_align字段进行对齐即可
			 */
			void *elf64_phdr_vaddr_align = (void*)((uintptr_t)elf64_phdr->p_vaddr & (~((uintptr_t)elf64_phdr->p_align - 1)));
			size_t elf64_phdr_length_align = elf64_phdr->p_memsz + ((uintptr_t)elf64_phdr->p_vaddr - (uintptr_t)elf64_phdr_vaddr_align);
			off_t elf64_phdr_offset_align = elf64_phdr->p_offset & (~((uintptr_t)elf64_phdr->p_align - 1));

#ifdef DEBUG
			printf("elf64_phdrs[%d] elf64_phdr_vaddr_align => %p, elf64_phdr_length_align => %#lx, elf64_phdr_offset_align => %#lx prots => %#lx\n", i, elf64_phdr_vaddr_align, elf64_phdr_length_align, elf64_phdr_offset_align, prot);
#endif
			void *address = mmap(
					elf64_phdr_vaddr_align,		//addr，即映射的虚拟地址
					elf64_phdr_length_align, 	//length，映射的字节长度
					prot,				//prot，映射内存的属性
					MAP_PRIVATE | MAP_FIXED,	//flags，映射内存的标志
					exec_fd,			//fd，映射内存的文件描述符
					elf64_phdr_offset_align		//offset，文件描述符的起始偏移
			);

			//由于可能存在bss段等，因此需要将多余的空间置为0，否则执行会错误
			memset(((char*)elf64_phdr->p_vaddr) + elf64_phdr->p_filesz, 0, elf64_phdr->p_memsz - elf64_phdr->p_filesz);

			//测试，用来输出载入的segment的相关地址信息
#ifdef DEBUG
			printf("elf64_phdrs[%d] address => %p p_vaddr => %#lx; p_memsz => %#lx; p_flags => %#x p_filesz => %#lx p_align => %#lx\n\n", i, address, elf64_phdr->p_vaddr, elf64_phdr->p_memsz, elf64_phdr->p_flags, elf64_phdr->p_filesz, elf64_phdr->p_align);
#endif
		}
	}
}


/*
 * 根据System V api文档
 * 初始化程序的堆栈结构，即设置argc，argv和envp即可
 */
void *static_init_stack(int exec_argc, char *exec_argv[], char **exec_environ) {
	/*
	 * 申请堆栈所需要的地址
	 */
	void *stack = mmap(
			NULL,				//addr，即映射的虚拟地址
			1 MB, 				//length，映射的字节长度
			PROT_READ | PROT_WRITE,		//prot，映射内存的属性
			MAP_PRIVATE | MAP_ANONYMOUS,	//flags，映射内存的标志
			-1,				//fd，映射内存的文件描述符
			0				//offset，文件描述符的起始偏移
	);


	//这里栈空间的起始位置
	uintptr_t *sp = (uintptr_t*)((uintptr_t)(stack) + 1 MB - 4 KB);

	//这里设置当前栈帧的顶部
	void *res = (void*)sp;


	//压入exec_argc
	*sp++ = exec_argc;

	//压入exec_argv
	for(int i = 0; exec_argv[i]; ++i) {*sp++ = (uintptr_t)exec_argv[i];}
	//压入exec_argv结束的0
	*sp++ = 0;

	//压入exec_environ
	int environ_idx = 0;
	for(; exec_environ[environ_idx]; ++environ_idx) {
		if(strchr(exec_environ[environ_idx], '_') != exec_environ[environ_idx]) { *sp++ = (uintptr_t)exec_environ[environ_idx]; }
		else {
			char *environ = (char*)malloc(strlen(exec_argv[0] + 3));
			sprintf(environ, "_=%s", exec_argv[0]);
			*sp++ = (uintptr_t)environ;
		}
	}
	//压入exec_environ结束的0
	*sp++ = 0;


	//压入auxiliary vector entries，这些是内核提供给用户空间的一些设置参数，否则glibc无法正常运行。不能直接复制加载器的，否则待加载程序会崩溃
	//for(Elf64_auxv_t *elf64_auxv_t = (Elf64_auxv_t*)&exec_environ[environ_idx + 1]; elf64_auxv_t->a_type != AT_NULL; ++elf64_auxv_t) {
	//	*((Elf64_auxv_t*)sp) = *elf64_auxv_t;
	//	sp = (uintptr_t*)((Elf64_auxv_t*)sp + 1);
	//}
	*((Elf64_auxv_t*)sp) = (Elf64_auxv_t){ .a_type = AT_RANDOM, .a_un.a_val = (uintptr_t)(stack) + 1 MB - 16};
	sp = (uintptr_t*)((Elf64_auxv_t*)sp + 1);
	*((Elf64_auxv_t*)sp) = (Elf64_auxv_t){ .a_type = AT_NULL};
	


#ifdef DEBUG
	printf("stack => %p\n", res);
	int argc = *(int*)res, i;
	printf("argc => %d\n", argc);

	char **argv = ((char**)res) + 1;
	for(i = 0; i < argc; ++i) { printf("argv[%d] = %s\n", i, argv[i]); }

	char **environ = argv + argc + 1;
	for(i = 0; environ[i]; ++i) { printf("environ[%d] = %s\n", i, environ[i]); }

	Elf64_auxv_t *elf64_auxv_t = (Elf64_auxv_t*)(environ + i + 1);
	for(i = 0; elf64_auxv_t[i].a_type != AT_NULL; ++i) { printf("auxiliary[%d].a_type = %#lx, auxiliary[%d].a_un.a_val = %#lx\n", i, elf64_auxv_t[i].a_type, i, elf64_auxv_t[i].a_un.a_val); }

#endif

	return res;
}




/*
 * 根据System V api文档
 * 初始化相关的寄存器，自然包括控制流的跳转
 */
void static_init_registers(Elf64_Ehdr *elf64_ehdr, void *stack){

	//通过内联汇编，初始化寄存器，并完成跳转
	__asm__ volatile(
			"mov %0, %%rsp;"	//将rsp设置为之前初始化的栈的位置
			"xor %%rdx, %%rdx;"	//将rdx设置为atexit部分
			"jmp *%1"		//将待跳转的目标地址存到寄存器中，然后间接跳转
			:
			: "r"(stack), "r"(elf64_ehdr->e_entry)
			: "rdx");
}


int main(int argc, char *argv[]) {

	if(argc == 1) {
		printf("Usage: static-loader file [args...]\n");
		exit(EXIT_SUCCESS);
	}

	/*
	 * argv[0] = "./static-loader"
	 * argv[1] = 待载入程序路径
	 * argv[2 : argc] = 待载入程序参数
	 * argv[argc] = 0
	 */
	static_load_elf(argv[1], argc - 1, argv + 1, environ);


	//理论上，完成跳转后，程序通过hlt退出，永远不会执行到该处
	exit(EXIT_FAILURE);
}
```

  代码的注释已经非常详细了，下面直接给出[静态链接程序的加载器demo](static_loader.tar.gz)


### 动态链接程序的加载

  当前标准下的动态链接程序加载十分繁琐，但是其整体原理还是较为简单的。因此这里保留动态链接程序加载的主要原理，实现一个**自定义**的动态链接的标准，并实现一个基于该**自定义**标准的动态链接程序的加载器，从而帮助理解动态链接程序的加载过程及其原理

#### 为什么需要动态链接

  程序之间往往会包含一部分重复的代码(极端情况就是一个shell程序可能运行多份)。如果程序都采取静态链接，则作为进程加载的时候，需要将整个程序二进制文件都载入到内存中，这是十分浪费的。
  因此，我们希望采用某种技术(实际上就是动态链接)，从而将程序可能重复的部分仅仅加载一次

#### 为什么静态链接不行

  简单来说，是由于程序的编译链接和程序的载入不是同时进行的

  静态链接要求在编译链接时一次性生成程序运行所需要的所有数据，但是其必定无法确定在将来被载入时的重复代码部分的内存地址
  而动态链接在编译时仅仅按照相关标准生成重复代码调用的相关标记，则可以正常完成编译；在载入时再通过编译留下的标记信息和系统调用，载入重复代码或获取已经被载入的重复代码的内存地址，从而正确执行。


#### 如何实现动态链接

  实际上，根据前面的分析，我们知道。采用动态链接的程序，其在载入的时候，会动态的载入重复部分的代码，并执行这部分代码。这部分代码就是动态加载库。

  1. 动态加载库的代码格式
  因此，实际上要实现动态链接，起码需要产生可以不依赖加载地址进行执行的代码形式，从而将其作为动态加载库的代码格式。而这就是位置无关代码格式，其访问变量或代码时，都通过相对**rip**寄存器的偏移进行访问，从而避免了对于载入地址的依赖性。

  2. 程序的编译 
  根据前面的分析，采用动态链接载入的程序，在编译的时候需要按照相关标准生成动态链接库的调用标记。最简单的方式，就是将所有待解析的符号地址及其特征(如符号名)存储在一个数组中。这样，当编译的时候，只需要生成该数组即可,然后调用的地址为该数组中的待解析符号地址即可。这个数组即**GOT**(Global Offset Table)
  而为了方便最终的符号解析，动态链接库中应该包含一个动态链接库的符号导出表，其包含符号在当前动态链接库的相对偏移以及符号的特征。
  载入程序时，根据依赖顺序首先载入所有的动态链接库，然后根据载入符号表中的导出表，从而根据其符号特征重新解析导入表中符号对应的地址即可。


#### 动态链接实现细节

  由于是一个小的演示demo，所以这里定义了自己的一个非常简单的动态链接库标准
  1. 该动态链接库需要程序员自己手动加载，而非类似**ld.so**的自动递归的加载动态链接库。并且动态链接库的查找目录是固定的，和可执行程序处于同一个目录
  2. 动态链接库的符号表必须位于固定位置(这里实现的就是位于动态链接库的起始位置)
  3. 动态链接库需要编译成位置无关代码


  首先，我们规定一个符号的数据结构，从而生成前面分析事提到的符号表，如下所示
  ```c
#define SYMBOL_SIZE (64)
#define SYMBOL_TYPE_TERMINATE	(0)
#define SYMBOL_TYPE_IMPORT	(1)
#define SYMBOL_TYPE_EXPORT	(2)

typedef struct SYMBOL {
	uint64_t offset;
	uint64_t type;
	char name[SYMBOL_SIZE - sizeof(uint64_t) - sizeof(uint64_t)];
} Symbol;
```
  
  实际上，其包括符号的地址以及符号特征(符号名称)等信息。而为了导入符号和导出符号公用一个数据结构，我们添加了**type**字段用来进行区分。
  自定义的标准中要求将符号表放置在动态链接库的起始位置。为了使生成的动态链接库满足上述的标准，我们可以通过汇编代码，以及**objcopy**命令，生成raw文件，而非**ELF**格式的文件。为了方便汇编代码的操作，我们定义了如下的一些宏
  ```c
#ifdef __ASSEMBLER__
/*
 * 这里主要定义一些汇编指令下的宏，方便编写汇编源代码
 */

//定义一个符号表的起始
#define DYNLIB_SYMS	symbols_start:

/*
 * 定义一个符号表的终结
 * .align ALIGN GAP;		按ALIGN对齐下一个符号，中间使用GAP填充
 * .fill REPEAT, SIZE, VALUE;	将SIZE大小的VALUE值拷贝REPEAT次
 */
#define DYNLIB_SYMS_END	.align SYMBOL_SIZE, 0; \
	.fill SYMBOL_SIZE, 1, 0; 

/*
 * 在汇编源代码中，定义导出表
 * 其中包含相对载入基址的相对偏移，以及符号特征
 * .quad VALUE			定义了一个QUAD类型的数据，其值为VALUE
 * .asciz VALUE			使用ASCII字符声明VALUE文本字符串，并在结尾自动添加结束符\0
 * #VAR				将宏参数转换为字符常量
 */
#define EXPORT(name) .align SYMBOL_SIZE, 0; \
	.quad (name - symbols_start); \
	.quad SYMBOL_TYPE_EXPORT; \
	.asciz #name;


/*
 * 在汇编源代码中，定义导入表
 * 其中包含符号待解析地址，以及符号特征
 * .quad VALUE			定义了一个QUAD类型的数据，其值为VALUE
 * .ascii VALUE			使用ASCII字符声明VALUE文本字符串，结尾没有结束符\0
 * str1##str2			将两个token连接为字符常量
 */
#define IMPORT(name) .align SYMBOL_SIZE, 0; \
	name##_dyn: \
	.quad 0; \
	.quad SYMBOL_TYPE_IMPORT; \
	.asciz #name; \

#else
/*
 * 前面汇编源代码中仅仅实现了相关动态链接库的符号标记
 * 这里是上述动态链接库的具体符号标记的含义
 */

#include <stdint.h>
typedef struct SYMBOL {
	uint64_t offset;
	uint64_t type;
	char name[SYMBOL_SIZE - sizeof(uint64_t) - sizeof(uint64_t)];
} Symbol;

#endif		//__ASSEMBLER__


#endif
```

  可以看到，其主要实现了汇编文件中定义**struct SYMBOL**结构体的操作，即**IMPORT(NAME)**和**EXPORT(NAME)**。对于导入符号来说，其最终的符号地址需要在载入的时候进行解析，因此将**offset**字段填充为0即可，在载入的时候，导入的符号已经加载进内存了，则将该符号的地址覆盖到符号的**offset**字段即可，其余按照标准和结构体字段的含义进行填充即可；而对于导出符号来说，其最终的符号地址虽然不知道，但是其相对动态链接库加载地址的偏移始终是不变的，则先将该值填充为相对偏移值即可，等载入的时候，在**offset**字段添加动态链接库的载入地址即可

  下面是一个动态链接库的具体样例，如下所示
  ```x86asm
#include "dynamic.h"

// 将导入导出表放置在最开始
DYNLIB_SYMS

// 导出libb_fun导出
EXPORT(libb_func)

// 导入liba.S中的liba_var导出
IMPORT(liba_func)


// 这里导入导出表结束
DYNLIB_SYMS_END

libb_func:
	call *liba_func_dyn(%rip)
	addq $1, %rax
	ret
```

  这里唯一需要说明的就是动态链接库中，对于导入符号的调用。虽然在编译的时候，并不知道导入符号的最终地址，但是在该动态链接库载入的时候，该动态链接库的导入符号一定已经被载入内存中。则在动态链接库载入的过程中，将导入符号的地址写入导入符号表的**offset**中即可。也就是虽然在编译的时候，并不知道导入符号的最终地址，但是可以确定导入符号的地址是在导入符号表的**offset**字段的，而导入符号表的地址在编译时可以通过相对偏移进行访问，从而也就保证了动态链接库在载入完后可以通过导入符号表正确调用导入的符号。


  最后，则是程序调用动态链接库的相关说明。根据前面的说明，实际上程序在加载动态链接库的时候，唯一的工作就是处理动态链接库的符号表
  1. 对于导出符号类型，将其**struct SYMBOL**的**offset**字段添加上动态链接库的载入地址，从而获得符号的真实地址。除此之外，还需要保存一份**struct SYMBOL**，方便之后动态链接库的导入符号的解析以及程序调用该导入符号
  2. 对于导入符号类型，根据标准，其依赖的动态链接库已经完成加载，则所调用的导入符号也已经完成了解析。则遍历前面1.步骤中保存的符号表，找到该符号，并且覆盖该动态链接库导入符号的**offset**字段，从而确保该动态链接库调用导入符号的正常执行。

  演示代码如下所示
  ```c
#include "dynamic.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <assert.h>


/*
 * 当前程序加载的动态链接库中所有的程序
 */
static Symbol *symbols[128] = {NULL};
static int symbols_size = 0;


/*
 * 处理动态链接库中导入符号类型的符号
 */
void
do_type_import_symol(Symbol *symbol)
{
	assert(symbol->type == SYMBOL_TYPE_IMPORT);
	if(symbol == NULL) { return; }

	printf("[*] try to resolve the import symbol:%s\n", symbol->name);

	// 遍历程序的符号表，如果找到符号特征(符号名称)相同的，则解析符号即可
	for(int i = 0; i < symbols_size; ++i) {
		if(!strcmp(symbol->name, symbols[i]->name)) {
			printf("[*] succeed to resolve the import symbol:%s\n", symbol->name);
			symbol->offset = (uint64_t)symbols[i]->offset;
			return;
		}
	}

	printf("[*] failed to resolve the import symbol:%s\n", symbol->name);
}



/*
 * 处理动态链接库中导出符号类型的符号
 */
void
do_type_export_symbol(Symbol *symbol, void *base_addr)
{
	assert(symbol->type == SYMBOL_TYPE_EXPORT);
	if(symbol == NULL) { return; }

	printf("[*] try to resolve the export symbol:%s\n", symbol->name);

	symbols[symbols_size] = symbol;
	symbols[symbols_size]->offset += (uint64_t)base_addr;
	++symbols_size;
	
	printf("[*] succeed to resolve the export symbol:%s\n", symbol->name);
}



/*
 * 这里根据库的名称
 * 加载当前目录下的.o文件即可
 */
void
load(const char *lib_name)
{
	if(lib_name == NULL) { return; }

	printf("[*] try to load the %s\n", lib_name);

	int lib_name_len = strlen(lib_name);
	char *lib_path = (char*)malloc(sizeof(char) * (lib_name_len + 2 + 7));
	assert(lib_path != NULL);
	sprintf(lib_path, "./%s.dynlib", lib_name);

#ifdef DEBUG
	printf("[*] try to load the %s with path:%s\n", lib_name, lib_path);
#endif

	int fd = -1;
	if((fd = open(lib_path, O_RDONLY)) < 0) {
		printf("[*] fail to open the %s\n", lib_name);
		free(lib_path);
		return;
	}

	//通过mmap映射
	void *base_addr = NULL;
	if((base_addr = mmap(NULL, 4096, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)) == NULL) {
		printf("[*] fail to load the %s\n", lib_name);
		free(lib_path);
		return;
	}


	/*
	 * 由于每一个动态链接的符号表在其首部
	 * 则依次遍历即可
	 *
	 * 如果是导出表，则向全局符号表中添加符号即可
	 * 如果是导入表，则遍历全局符号表，查找对应的符号即可
	 */
	for(Symbol *symbol = (Symbol*)base_addr; symbol->type != SYMBOL_TYPE_TERMINATE; ++symbol) {
#ifdef DEBUG
		printf("[*] symbol address => %p\n", symbol);
		printf("[*] try to load the symbol: %s\n", symbol->name);
#endif
		switch(symbol->type) {
			case SYMBOL_TYPE_IMPORT:
				do_type_import_symol(symbol);
				break;
			case SYMBOL_TYPE_EXPORT:
				do_type_export_symbol(symbol, base_addr);
				break;
		}
	}

	printf("[*] succeed to load the %s\n", lib_name);
	free(lib_path);
}


/*
 * 调用动态链接库中的符号表
 * 即遍历程序所有的符号表，找出给定的符号特征并且执行即可
 */
void
do_execute_symbol(const char *name)
{
	if(name == NULL) { return; }

	printf("[*] try to execute the symbol:%s\n", name);

	// 遍历程序的符号表，如果找到符号特征(符号名称)相同的，则执行符号即可
	for(int i = 0; i < symbols_size; ++i) {
		if(!strcmp(name, symbols[i]->name)) {
#ifdef DEBUG
			printf("[*] the address of the symbol:%s is %lx\n", name, symbols[i]->offset);
#endif
			printf("[*] %s() = %ld\n", name, ((uint64_t (*)())symbols[i]->offset)());
			return;
		}
	}

	printf("[*] failed to execute the symbol:%s\n", name);
}

int main(void) {
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);
	setbuf(stderr, NULL);

	load("liba");
	do_execute_symbol("liba_func");
	load("libb");
	do_execute_symbol("libb_func");
	return 0;
}
```

  这里给出[动态链接程序的加载器demo](dynamic_loader.tar.gz)

# L2多处理器内核上的线程管理(kmt)

## 实验背景

  实际上，借助AbstractMachine提供的机制(C Runtime、物理内存、中断/异常等)，可以很容易地实现CPU地虚拟化，并对进程/线程进行模拟。

  目前，我们已经知道操作系统的**虚拟化**是由*中断机制*实现的，在进程/线程执行时，当**中断**到来时，操作系统代码开始执行并保存处理器运行的寄存器现场；在中断返回时，其会选择任何一个进程/线程已经保存的寄存器现场进行恢复，从而实现上下文的切换。

  在此实验中，我们需要实现多处理器操作系统内核中的内核线程API。在完成这个实验后，就可以得到一个真正的嵌入式操作系统。

## 实验描述

  > ### 实验总览
  > 这个实验在L1的基础上，进一步实现内核线程相关的操作系统内核API：
  > - 相比Lab1，os模块中新增了**trap**和**on_irq**两个函数，分别是系统中唯一中断/系统调用的入口和中断处理程序的回调注册；
  > - pmm模块保持不变，可以沿用Lab1的实现，但因为这个实验中多了中断，需要进行一些小的修改；
  > - 新增了kmt模块，需要完成`struct task`、`struct spinlock`和`struct semaphore`的定义，并实现其中全部的API
  > ```c
typedef Context *(*handler_t)(Event, Context *);
MODULE(os) {
  void (*init)();
  void (*run)();
  Context *(*trap)(Event ev, Context *context);
  void (*on_irq)(int seq, int event, handler_t handler);
};

MODULE(pmm) {
  void  (*init)();
  void *(*alloc)(size_t size);
  void  (*free)(void *ptr);
};

typedef struct task task_t;
typedef struct spinlock spinlock_t;
typedef struct semaphore sem_t;
MODULE(kmt) {
  void (*init)();
  int  (*create)(task_t *task, const char *name, void (*entry)(void *arg), void *arg);
  void (*teardown)(task_t *task);
  void (*spin_init)(spinlock_t *lk, const char *name);
  void (*spin_lock)(spinlock_t *lk);
  void (*spin_unlock)(spinlock_t *lk);
  void (*sem_init)(sem_t *sem, const char *name, int value);
  void (*sem_wait)(sem_t *sem);
  void (*sem_signal)(sem_t *sem);
};
```
  > 
  > ### OS(Operating Systems)模块
  > #### 操作系统的主循环
  > os模块是操作系统主循环的代码，主要负责系统的初始化和中断响应。在Lab1的框架代码中，已经包含如下函数：
  > - `os->init()`会在系统启动时被第一个处理器调用，其是在单处理器状态下完成必要的初始化——因此无需担心数据竞争等麻烦；
  > - `os->run()`是操作系统启动后，每一个处理器必须执行的一些代码。在执行`os->run`时，操作系统已经完成了所有的初始化工作，每个处理器都会调用同一个`os->run`

  > 理解os模块，要从程序执行的入口开始，以下是框架代码执行的流程：
  ```c
int main() {
  ioe_init();
  cte_init(os->trap);
  os->init();
  mpe_init(os->run);
  return 1;
}
```
>
>  在每个处理器调用`os->run`执行后，操作系统就成为了中断处理程序。因此，当调用`mpe_init()`之后，所有处理器都开始执行`os->run()`，操作系统即正式启动，而该启动代码就成为了当前处理器上的第一个线程——这个线程是该处理器上的**idle**线程；而当系统中没有任何线程可以被调度时，处理器仍然需要执行点什么，直到下一个中断来临，因此该**idle**中断可以是一个死循环，如下所示
  ```c
  static void os_run() {
	  iset(true);
	  while(1);
  }
```
  >
  > 主循环的另一部分是本次试验新增的中断处理程序的入口
  >
  > - `os->trap(ev, context)`：中断/异常处理程序的唯一入口。中断后，AbstractMachine会将所有寄存器保存到堆栈上，然后调用`os->trap`，并且在函数返回后，将`os->trap`返回的寄存器现场恢复到CPU上
  >
  > 直到`mpe_init()`之前，都只有一个处理器在执行。在上述的代码中，`cte_init(os->trap)`指定了`os->trap()`是唯一的中断处理程序，所有的处理器发生中断都会统一调用`os->trap()`，这也就需要小心并发编程
  >
  > #### 中断处理程序
  > os模块的另一个重要功能是管理系统中的中断处理程序——我们并不希望大家在每当有一个新的功能以后，都直接去更改`os->trap`的代码，因此这里提供了另一个API:
  > - `os->on_irq(seq, event, handler)`：注册一个在中断时调用的callback

  > on_irq的含义是在`os->trap(ev, ctx)`执行时，当**ev.event(事件编号)**和**event**匹配时，调用`handler(event, ctx)`。其中：
  > - **seq**决定了**handler**被调用的顺序，**seq**小的**handler**先被调用。**seq**相同的，按照任意顺序调用
  > - 当**event == EVENT_NULL**时，在任何中断/异常时都调用**handler**
  > - 我们允许一个，且仅允许一个**handler**返回一个**Context**，在中断返回时，恢复到这个**Context**。当多个**handler**都返回**context**时，是**undefined behavior**

  > 通过`os->on_irq`，我们可以注册若干中断处理程序，在适当的时机做适当的事情——这类似于**面向切面编程**的设计。此时，我们的os模块并不知道，也无需知道系统中有多少中断、多少设备驱动程序可能会处理终端。
  >
  > ### PMM(Physical Memory Management)模块
  > pmm与之前行为一致，但因为其被调用的场景增加了，我们需要将`pmm->alloc`和`pmm->free`更改为线程/中断安全的
  >
  > 具体来说，我们要求：
  > 1. 可以再中断里调用`pmm->alloc()`和`pmm->free()`；
  > 2. 内存分配/回收时，简单起见，不允许被中断
  >
  > ### KMT(Kernel Multi-Threading)模块
  > #### 模块初始化
  > `kmt->init()`负责初始化必要的数据，例如分配一些重要的数据结构。一般来说，要在`os->init()`时调用`kmt->init()`。整个系统启动只调用一次`kmt->init()`
  > #### 线程管理
  > ```c
int  (*create)(task_t *task, const char *name, void (*entry)(void *arg), void *arg);
void (*teardown)(task_t *task);
```
  >
  > 其中`create`在系统中创建一个线程，该线程立即就可以被调度执行。这里可以认为通过`create`创建的线程永不返回——但其有可能在永远不会被调度执行的情况下被`kmt->teardown`函数回收
  > `teardown`回收相应的为线程分配的资源——例如为**task_t**动态分配的内存。需要注意的是，线程只有永远不会被调度到处理器上执行的前提下，才能被回收，即可以认为回收的线程不再持有任何自旋锁或在信号量上等待
  > #### 自旋锁
  > ```c
void (*spin_init)(spinlock_t *lk, const char *name);
void (*spin_lock)(spinlock_t *lk);
void (*spin_unlock)(spinlock_t *lk);
```
  >
  > 上述代码用来保护一段强原子性的代码(任何其他线程、中断处理程序、其他处理器都不能同时得到同一把锁)
  > - 允许在中断处理程序中调用自旋锁
  > - 允许任意在任意处理器的任意线程中调用自旋锁
  > - `spin_lock`将会关闭处理器的中断，因此对一个处理器而言，持有任何一个自旋锁之后就不会再发生线程切换
  > - `spin_unlock`在解除最后一个当前处理器持有的自旋锁之后，需要将处理器的中断状态恢复。例如在中断处理程序中，中断是关闭的，则`spin_unlock`不应该打开中断
  > #### 信号量
  > ```c
void (*sem_init)(sem_t *sem, const char *name, int value);
void (*sem_wait)(sem_t *sem);
void (*sem_signal)(sem_t *sem);
```
  >
  > 在信号量初始化时，**value**指定了其初始化的数值。如果**value**==1,可以把信号量当做互斥锁；如果**value**==0，可以把信号量当做生产者-消费者缓冲区管理实现。而`sem_wait`和`sem_signal`分别对应的P/V操作
  > - 允许在线程中执行信号量的`sem_wait`操作。在`P`操作执行没有相应资源时，线程将被阻塞(不再被调度执行)。中断没有对应的线程、不能阻塞，因此不能在中断时调用 `sem_wait`
  > - 允许在任意状态下任意执行`sem_signal`，包括任何处理器中的任何线程和任何处理器的任何中断。
  >
  > ### 正确性标准
  > #### Safety和Liveness
  > 在任意时刻，操作系统中都可能有多个线程，你需要设计调度的策略，在多个处理器中调度这些线程，使操作系统能够被执行的线程尽可能不发生饥饿
  > #### 官方测试用例
  > 官方测试用例使该程序看起来更像一个操作系统，虽然其并不能作为"压力测试"来帮助检查kmt实现的正确性。
  > 其提供了**dev**模块及其实现，并包含了以下设备的驱动：
  > - input，支持读取键盘的输入
  > - fb，支持一个软件模拟的2D显示加速器的写入
  > - tty1，tty2，两个支持读写的虚拟终端，使用Alt-1，Alt-2在虚拟终端之间切换
  > - sda，支持读写的物理磁盘。
  > 在代码合并后，需要在**os->init()**中手工添加设备模块的初始化`dev->init()`。如果实现正确，即可完成中断处理程序和相关线程的初始化。
  > 此后，就可以创建若干访问设备的线程，样例如下所示
  > ```c
static void tty_reader(void *arg) {
  device_t *tty = dev->lookup(arg);
  char cmd[128], resp[128], ps[16];
  snprintf(ps, 16, "(%s) $ ", arg);
  while (1) {
    tty->ops->write(tty, 0, ps, strlen(ps));
    int nread = tty->ops->read(tty, 0, cmd, sizeof(cmd) - 1);
    cmd[nread] = '\0';
    sprintf(resp, "tty reader task: got %d character(s).\n", strlen(cmd));
    tty->ops->write(tty, 0, resp, strlen(resp));
  }
}


static void os_init() {
  ...
  kmt->create(task_alloc(), "tty_reader", tty_reader, "tty1");
  kmt->create(task_alloc(), "tty_reader", tty_reader, "tty2");
}
```

## 实验指南

### 在Bug中活下来

  实际上，Lab2希望可以在多处理器、中断都存在的情况下，仍然能保持正确。或许，只有在做完实验以后，才能对下面这些话产生真正的理解：
  1. 代码可以再多个处理器上被**同时**调用。因此需要小心地保证原子性、顺序性以及可见性。千万小心`kmt->create()`、`kmt->sem_signal()`等所有函数可能同时在多个处理器上被调用
  2. 在中断处理程序中，可以调用自旋锁。实际上，一个CPU的中断处理程序可以和另一个CPU访问同一个共享数据结构。因此自旋锁是保证正确性的重要手段
  3. 小心数据竞争。一切共享的数据都可能产生数据竞争——如果没有保护好的话。有些内存访问悄悄在意向不到的时候发生，例如对堆栈的访问

  为此，实验中反复强调，通过一些手段，可以非常方便的帮助我们调试程序
  - 通过预编译选项，控制log的输出，如下所示
  ```c
#ifdef TRACE_F
  #define TRACE_ENTRY printf("[trace] %s:entry\n", __func__)
  #define TRACE_EXIT printf("[trace] %s:exit\n", __func__)
#else
  #define TRACE_ENTRY ((void)0)
  #define TRACE_EXIT ((void)0)
#endif

void f() {
  TRACE_ENTRY;
  printf("This is f.\n");
  TRACE_EXIT;
}
```
  - 使用gdb进行调试。qemu提供了非常丰富的命令行选项
    - **-gdb**，启动调试模式
	- **-S**，让虚拟机在收到调试命令前不执行
	- 在gdb中使用**target**命令连接远程调试
	- 使用**.gdbinit**/**-x**/**-ex**，实现gdb脚本的预先执行
  - 防御式编程。通过类似于**fences**、**canaries**、**assert**等，帮助我们更快的定义bug

## 实验环境

  切换到**master**分支，然后从github上拉取**L2**实验即可
  ```bash
git checkout master && git pull origin L2
```

## 实验实现

  下面式个人的思路及其实现，[实验实现](nju.tar.gz)

## 实验结果
