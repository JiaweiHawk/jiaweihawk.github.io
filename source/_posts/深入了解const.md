---
title: 深入了解const
date: 2021-07-15 18:03:14
tags: ["c++"]
categories: ["编程"]
---


# 前言

  之前在学习**C++**的时候，对于**const**等相关概念了解的不是很清楚，最后在使用时就很痛苦😖
  这次彻底的总结一下**const**相关的知识点


# 阅读变量声明

  实际上，**const**位于变量声明的不同位置，会产生不同的作用。因此，首先我们需要学会如何阅读变量的声明语句，从而了解变量的具体类型，获取**const**修饰的对象，才能知道其作用。


  这里我们依照[由右至左规则](https://parrt.cs.usfca.edu/doc/how-to-read-C-declarations.html)，可以有效的分解变量的类型。

  整个**由右至左规则**如下所示：

1. 从变量名称开始
2. 向右依次列出所有的关键词，直到遇到不匹配的右括号或者结束停止
3. 向左依次列出所有的关键词，直到遇到不匹配的左括号或者结束停止
4. 如果因为括号停止，则跳出括号，重新执行步骤2.

  这里我们举一个比较有挑战性的例子
```c
char (*(*x())[])();
```

下面给出按照上述分析的步骤

- 根据**步骤1**，找到变量名称`x`，即 `char (*(*`~~`x`~~`())[])();`
- 根据**步骤2**
	1. 找到`()`，即 `char (*(*`~~`x()`~~`)[])();`，因此为**无参函数**
	2. 右边遇到**不匹配右括号**，结束
- 根据**步骤3**
	1. 找到`*`，即 `char (*(`~~`*x()`~~`)[])();`，因此返回值为**指针**
	2. 左边遇到**不匹配左括号**，结束
- 根据**步骤4**，跳出括号，即 `char (*`~~`(*x())`~~`[])();`
- 根据**步骤2**
	1. 找到`[]`，即`char (*`~~`(*x())[]`~~`)();`，因此其指针指向一个数组
	2. 右边遇到**不匹配右括号**，结束
- 根据**步骤3**
	1. 找到`*`，即`char (`~~`*(*x())[]`~~`)();`，因此该数组元素都是指针
	2. 左边遇到**不匹配左括号**，结束
- 根据**步骤4**， 跳出括号，即`char `~~`(*(*x())[])`~~`();`
- 根据**步骤2**
	1. 找到`()`，即`char `~~`(*(*x())[])();`~~，因此该指针是指向**无参函数**的指针
	2. 右边**完结**，结束
- 根据**步骤3**
	1. 找到`*`，即~~`char (*(*x())[])();`~~，因此函数的返回值为**char**类型
	2. 左边遇到**完结**，结束

  综上可知，该变量是一个无参函数，其返回值是一个指针，该指针指向一个数组，数组中的元素都是指针，这些指针指向返回值为`char`的无参函数。

# const性质

  **const**表示修饰的值不能改变，这就是该关键词的性质。
  
  那么实际上，根据上面的规则，我们很容易完全理解**const**的种种特性

1. `const type a;`/`type const a;`
  即**const**用来修饰`type`类型，也就是变量`a`的值不能进行改变

2. `const type *a;`/`const type &a;`
  根据前面的规则，这是一个**指针**/**引用**，其指向/引用一个`const type`类型——也就是其指向/引用的值不能修改，但其本身并没有要求

3. `type * const a;`
  根据前面的规则，这是一个`const`对象，该对象是一个指向`type`的指针——也就是该指针不能重新指向新的对象，但是其指向的值可以进行任意的修改

4. `const type * const a;`
  根据前面的规则，这是一个`const`对象，该对象是`const type *`类型，即该对象是一个指针，指针指向`const type`类型——即该指针既不能重新指向新的对象，也不可以修改其指向的值。

  总的来说，基本就是按照前面的规则解释变量类型，其中`const`修饰的对象的值不能改变

# 顶层const和底层const

## 顶层const

  对于对象本身是一个常量，不可更改对象本身的值，则称为**顶层const**，如`int * const p1;`

## 底层const

  如果对象是指针或引用，其指向或引用的对象的值不可更改，则称为**底层const**，如`const int &r1;`

## 差别

  在使用时，**顶层const**和**底层const**差别十分大，这里简单说一下常见的差别

1. 赋值、初始化
  总体规则是**const**兼容**非const**
  - 对于**顶层const**，对于赋值对象是否为**常量**没有任何关系，如下所示
  ```c++
int val1 = 0;
int const val2 = 0;

int const &r1 = val1, &r2 = val2;		//有效
int const *p1 = &val1, *p2 = &val2;		//有效
```

  - 对于**底层const**，其赋值对象和被赋值对象必须有相同的**底层const**资格，如下所示
  ```c++
int const *p;

int const * const &r1 = 0;	//有效
int const * &r2 = p;		//有效
int * const &r3 = p;		//无效，这里r3是引用指向整型的常指针，但是p是指向常量的指针。r3中其引用指向非常量，而p指向常量，因此不兼容
```

# 注意点

这里需要注意一下`typedef`关键字。即通过`typedef`关键字，其生成新的基本数据类型，并不是简单的宏替换。这点在**const**中特别关键，如下

```c++
typedef char *pstring


const char * p1;
const pstring p2;
```

  如果仅仅将`typedef`当作简单的宏替换，那么`p2`的定义进行展开就是`p1`，其是一个指向**常量char**的指针，即`p1`的值可以进行任意的修改，但是`p1`指向的值不能进行修改
  但实际上，我们需要将`pstring`当作一个基本数据类型看待，即这是一个**常量pstring**类型，即`p2`不能随意更改其值；而由于`pstring`是指针类型，实际上我们仍然可以修改其指向的值。
  可以看到，两种理解方法，得出来的结论完全相反。
  