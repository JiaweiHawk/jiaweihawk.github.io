---
title: 操作系统-设计与实现-二
date: 2021-08-01 21:23:36
tags: ["操作系统", "手写"]
categories: ["手写"]
---

# 前言

  这一章没有新的内容，仅仅是实现课程中的L0实验


# L0直接运行在硬件上的小游戏

## 实验背景
  传统上，操作系统被认为就是"写汇编"、"跟底层打交道"。但实际上，操作系统和硬件之间的关系被夸大了。操作系统实际上不过就是一个直接运行在计算机上的(高级语言)程序而已，只是会在适当的时候调用操作系统提供的**机制**。
  因此，在初始化完成后设置好一个没有标准库的**C**程序运行环境，其中包含栈区、静态数据、堆区;代码从`main`函数开始执行，并允许我们在程序运行过程中直接、独占式地访问操作系统中的物理设备(例如显示器、计时器)和响应中断，即可实现当下主流的操作系统

## 实验描述
> 实验要求1:实现AbstractMachine中klib中缺失的函数
>
>> **AbstractMachine**的项目中包含一个基础运行库的框架klib，其中包含了方便你编写*bare-metal*程序的系列库函数，例如`assert`、`printf`和`memcpy`等。
>
>实验要求2:实现可移植的、直接运行在计算机硬件上的小游戏
>
>> 你需要编写一个直接运行在**AbstractMachine**上(仅仅是用IOE拓展，不使用其他硬件机制如中断/异常/虚拟存储/多处理器)的小游戏;满足:
>> 1. 有肉眼可辨认的图形输出
>> 2. 能使用键盘与游戏交互
>> 3. 游戏使用的内存(代码、静态数据总和不超过1MiB、堆区\_heap使用不超过1MiB)，因此不必考虑复杂的图形;
>> 4. 按ESC键后调用`_halt()`退出;除此之外游戏程序永不调用`_halt()`结束，Game Over后按键重新开始
>>
>> 只要程序不崩溃，哪怕只有几个像素点在屏幕上乱动也可以。虽然不限制实现什么游戏，但仍需要在移植性/通用性上对代码做出一定的保证:
>> - 兼容很简单的处理器:即小游戏运行中只调用**TRM**和**IOE** API，而不使用其他API
>> - 你的游戏应当是可以在多个硬件体系之间移植的，考虑兼容以下情况:
>>   - 适配不同的屏幕大小。不同的体系结构中，屏幕大小可能是320x200、640x480、800x600等，你的游戏最好都能在所有分辨率下都获得不错的体验;
>>   - 同minilabs一样，你的程序可能运行在32/64-bit平台，因此你应当使用`intptr_t`或`uintptr_t`来保存指针数值;
>>   - 兼容大/小端，因此禁止把不同大小的指针类型强制转换

## 实验指南

  根据前面的描述，整个实验由两个小实验构成--实现**klib**库函数;实现小游戏。这里给出这两个小实验需要注意的细节
### 实现库函数

  实际上，实现库函数是普通的**C**语言练习题;但需要注意的是，编写可移植代码时，尽量使用**C**标准提供的机制，而非做一些对硬件的假设


### 访问I/O设备

  没有库函数的C语言程序类似于状态机，仅仅可以完成纯粹的"计算"。我们可以通过**TRM**和**IOE**的API，与外界的I/O设备进行交互，从而完成相关的操作。


### 实现游戏

  **AbstractMachine**中附带的**AMGame**使用了一种框架，这里再提供一个不同的框架，来实现游戏，如下所示
    ```c
next_frame = 0;
while (1) {
  while (uptime() < next_frame) ; // 等待一帧的到来
  while ((key = readkey()) != _KEY_NONE) {
    kbd_event(key);         // 处理键盘事件
  }
  game_progress();          // 处理一帧游戏逻辑，更新物体的位置等
  screen_update();          // 重新绘制屏幕
  next_frame += 1000 / FPS; // 计算下一帧的时间
}
```

  其使用**轮询(polling)**等待下一帧时刻的到来;等到帧时刻到来，就读取键盘按键并处理;然后模拟这一帧中游戏发生的事情即可。

### 小游戏和操作系统

  实际上，游戏和操作系统的工作原理有很多相像的地方，正如前面介绍的，简化的游戏的**主循环**如下所示
  ```c
while (1) {
  // 在每一个时间片，例如每 16.7ms (60 fps)
  wait_for_frame();

  // 做完这一个时间片内需要完成的工作
  int scanlines = 262;
  while (scanlines-- > 0) {
    ppu_cycle();      // 更新游戏图像
    psg_detect_key(); // 读取按键，更新游戏逻辑
  }
}
```

  而如果在程序的**主循环**中，不再是一次执行一帧，而是"每一帧"都执行另一个程序，程序执行完后返回主循环，则可以抽象为批处理系统的流程
  ```c
while (1) {
  // 等待键盘输入需要运行的命令
  Job *job = wait_for_job();

  // 加载并执行命令
  load(job);
}
```

  有了上面的分析，可以简单的**剧透**一下**批处理**系统的工作流程
  1. 批处理系统执行的命令由键盘输入，因此`wait_for_job()`就是从键盘读取按键，并解析成命令，与游戏读取按键类似
  2. 执行的命令(job)是保存在磁盘上的ELF格式的二进制文件，则使用硬件提供的I/O指令，将存储设备中二进制文件加载到内存中，然后在通过跳转，将控制权交给job;等job结束后函数返回，重新回到批处理系统，从而完成一个简易的操作系统，其`load()`部分的简化代码如下
  ```c
copy_from_disk(elf32, 4096, 0); // 从磁盘读取 ELF 文件头
if (elf->e_machine == EM_386) {  // x86 (32-bit)
  load_elf32(elf32); // 从磁盘加载二进制文件到 ELF 文件描述的位置
  ((void(*)())(uint32_t)elf32->e_entry)(); // 跳转到加载的代码执行
}
```
