---
title: 操作系统-设计与实现-三
date: 2021-08-06 15:18:14
tags: ['操作系统','手写']
categories: ['手写']
---


# 前言

  这一章稍微介绍一下多线程程序存在的问题，以及实现课程中的M2实验


# 多线程程序存在的问题

  这里，我们将使用二段代码，说明多线程程序中存在的各种问题。第一段代码如下所示
  ```c
#define n 100000000
long sum = 0;
void do_sum() {
  for (int i = 0; i < n; i++) sum++;
}
void print() {
  printf("sum = %ld\n", sum);
}
int main() {
  create(do_sum);
  create(do_sum);
  join(print);
}
```

  其中，`create`和`join`是包装**pthread**库的函数。
  如果我们采用**O0**优化，即执行`gcc -O0`，则其输出基本一直是介于**100000000**到**200000000**的值;

  如果我们采用**O1**优化，即执行`gcc -O1`，则其输出基本一直是**100000000**;

  如果我们采用**o2**优化，即执行`gcc -O2`，则其输出基本一直是**200000000**。 可以看到，不同优化等级下，多线程输出的值却各部一样。实际上，这些分别表示了多线程变成中的一些问题

## 原子性的丧失

  实际上，最好理解的是采用**O0**优化的程序的输出结果:看似`sum++`是一条原子语句，其执行不可分割。但实际上其仍由包括**取值**、**运算**和**存值**等多个指令构成，并且由于多个线程可以在不同处理器上并行执行，因此这些指令可能随时会在中途被中断，从而导致部分执行自增语句读取的是改变之前的值，从而导致其值变小

## 顺序的丧失

  实际上编译器为了程序性能提升，在进行代码优化的时候，会默认程序只在一个线程(处理器)上执行的顺序语义，这实际上就解释了程序采用**O1**和**O2**优化时的输出
  对于**O1**优化，由于sum变量经过连续的写操作，其中间的值不会被读取(单线程下)，并被最后一次的值覆写，因此可以直接被优化成最后一次覆写;并且由于**O1**下的优化会保留逻辑结构，因此循环仍然被保留，其代码被优化为如下伪代码形式

  ```c
void do_sum() {
	long temp = sum;

	for(int i = 0; i < n; ++i) { ; }

	temp += n;
	sum = temp;
}
```

  由于中间循环实际很长，因此第一个执行程序在完成读取操作后，被中断在中间循环处;然后第二个程序同样会完成读取操作....。这样子也就导致了最终数值总是被覆写。

  而对于**O2**优化，其循环被优化掉了，则被优化的伪代码如下
  ```c
void do_sum() {
	long tmp = sum;

	tmp += n;
	sum = tmp;
}
```
  这样子一个时间片内，基本上可以完整的执行整个函数，因此数值不会被覆写掉


### 可见性的丧失

  下面的代码及其结果，可以非常好的展示多线程编程下，程序可见性的丧失
  ```c
int volatile x = 0, y = 0;
void thread1() {
  [1] x = 1;   // write(x)
  [2] ty = y;  // read(y)
}
void thread2() {
  [3] y = 1;   // write(y)
  [4] tx = x;  // read(x)
}
```

  正常情况下，[2]操作必定在[1]操作之后执行;[4]操作必定在[3]操作之后执行，即最后`x`或`y`中，至少应该有一个为1。但实际上，结果中会出现`x`和`y`都是0的情况。
  其原因在于处理器的**乱序执行**特性上——当正在执行的指令和下一条待执行的指令没有(单线程下)数据依赖关系时，当当前指令处于**Cache Miss**时，其会修改指令的执行顺序，去先执行后面的指令，之后在执行当前的指令。
  在这个案例中，由于`thread1`函数`x`和`y`是不同的变量，因此其可以进行乱序执行;对于`thread2`是同理。因此最终会导致意想不到的输出结果


# M2协程库(libco)

## 实验背景

  总所周知，每个线程(执行流)都有自己独立的寄存器和堆栈。我们实际上可以在用户空间中模拟多线程——对于堆栈，我们可以使用代码为每个线程分别进行分配;对于寄存器，我们可以将"当前不在执行的线程"的寄存器保存在内存中，然后在这些寄存器现场进行切换即可。

  在**Python/Javascript**中，我们可以使用**yield**来定义如下的"死循环"函数

  ```python
def positive_integers():
    i = 0
    while i := i + 1:
        yield i # "output" i
```

  这个函数可以**生成**所有的整数，并被其他函数使用

  ```python
def is_prime(i):
    return i >= 2 and True not in (i % j == 0 for j in range(2, i))

primes = (i for i in positive_integers() if is_prime(i)) # 所有素数的顺序集合
```

  在C语言中，函数调用会从`call`指令开始，执行到`ret`指令结束，结束后所有的对于函数的局部数据的访问都是**undefined behavior**。其会因为无终止的**生成**所有整数，而导致资源消耗殆尽，最终异常中止
  但是对于**python**来说，`positive_integers`不会无限地执行下去。当其执行到`yield`时，`positive_integers`会暂停执行。之后可以通过`next`再一次进入`positive_integers`函数中进行执行，而函数内部的状态`i`被保存下来，再下一次调用时进行递增
  因此，我们希望在`C`中实现类似的代码，其能够
  1. 可以被调用，且从头开始运行
  2. 在运行时，允许被**切换**出去
  3. 之后可以**恢复执行**，即回到被切换时的状态继续执行

  为了能让函数调用被切换，并且之后还可以恢复执行，我们需要在内存中为该函数调用分配**寄存器**和**堆栈**(被称为函数调用的上下文，context)，即主动管理上下文切换的**协程(coroutine)**。
  如果我们允许协程在任意时刻被中断并切换到其他协程执行，我们就得到了**用户态线程(user-level threads)**


## 实验描述

  在该实验中，实现一个轻量级的用户协程(coroutine)，可以在一个不支持线程的操作系统上实现共享内存多任务并发。


### 实验要求

  实验要求实现动态链接库(shared object, .so文件，就像libc，pthread，SDL2等库一样)libc.so，实现以下libco.h中定义的API:
  ```c
struct co *co_start(const char *name, void (*func)(void *), void *arg);
void       co_yield();
void       co_wait(struct co *co);
```

  链接libco.so的程序被赋予使用协程库的能力，它和pthread相当类似:
  1. `co_start(name, func, arg)`创建一个新的协程，并返回一个指向`struct co`的指针(类似于`pthread_create`)
    - 新创建的协程从函数`func`开始执行，并传入参数`arg`。新创建的协程不会立即执行，而是调用`co_start`的协程继续执行
    - 使用协程的应用程序不需要知道`struct co`的具体定义，因此请把该定义留在`co.c`中;框架代码中并没有限定`struct co`结构体的设计，所以可以自由发挥
  2. `co_wait(co)`表示当前协程需要等待，直到`co`协程的执行完成后才能继续执行(类似于`pthread_join`)
    - 在被等待的协程结束后，`co_wait()`返回前，`co_start`分配的`struct co`需要被释放。如果你使用`malloc()`，需要使用`free()`释放即可
    - 因此，每个协程只能被`co_wait()`一次(使用协程库的程序应当保证除了初始协程外，其他协程都必须被`co_wait()`恰好一次，否则会造成内存泄漏)
  3. 协程运行后一直在CPU上执行，直到`func`函数返回或调用`co_yield()`使当前运行的协程暂时放弃执行。调用`co_yield()`会切换到其他协程执行。当系统中有多个可运行的协程时(包括当前协程)，你应当随机选择下一个系统中可运行的协程
  4. `main()`函数的执行也是一个协程，因此可以在`main()`中调用`co_yield()`。`main()`函数返回后，无论有多少协程，进程都将直接终止。


### 协程的使用

  下面是一个协程使用的例子，创建了两个(永不结束的)协程，分别打印`a`和`b`。由于`co_yield()`之后切换到的协程是随机的(可能切换到它自己)，因此可能会看到随机的**ab**交替出现的序列，例如**ababba...**
  ```c
#include <stdio.h>
#include "co.h"

void entry(void *arg) {
  while (1) {
    printf("%s", (const char *)arg);
    co_yield();
  }
}

int main() {
  struct co *co1 = co_start("co1", entry, "a");
  struct co *co2 = co_start("co2", entry, "b");
  co_wait(co1); // never returns
  co_wait(co2);
}
```

  当然，协程有可能会返回，例如在下面的例子(测试程序)中，两个协程会交替执行，共享**counter**变量
  ```c
#include <stdio.h>
#include "co.h"

int count = 1; // 协程之间共享

void entry(void *arg) {
  for (int i = 0; i < 5; i++) {
    printf("%s[%d] ", (const char *)arg, count++);
    co_yield();
  }
}

int main() {
  struct co *co1 = co_start("co1", entry, "a");
  struct co *co2 = co_start("co2", entry, "b");
  co_wait(co1);
  co_wait(co2);
  printf("Done\n");
}
```

  此时协程明显会正常结束，其输出应该是**b[1] a[2] b[3] b[4] a[5] b[6] b[7] a[8] a[9] a[10] Done**

### 协程和线程

  协程和线程的API非常相似。例如**threads.h**中提供的
  ```c
void create(void (*func)(void *));
void join(void (*func)());
```

  刚好对应了`co_start()`和`co_wait()`(join会在main返回后，对每个创建的线程调用`pthread_join()`，依次等待他们结束)。唯一不同的是，线程的调度不是由线程决定的(由操作系统和硬件决定);但协程除非执行`co_yield()`主动切换到另一个协程运行，当前的代码就会一直执行下去。
  协程会在执行`co_yield()`时主动让出处理器，调度到另一个协程执行。因此，如果能保证`co_yield()`的定时执行，我们甚至可以在进程里实现线程。这就是很多操作系统教科书上所讲的**用户态线程**。
  协程与线程的区别在于协程是完全在应用程序内(低特权运行级)实现的，不需要操作系统的支持，占用的资源也比操作系统线程更小一些。协程可以随时切换执行流的特性，用于实现状态机、actor model等。前面提到的**python**语言中的`generator`，也是一种特殊的协程，其每次`co_yield`，都会将控制流返回给其调用者，而非本实验的随机选择。


## 实验环境

  只需要从github上继续拉取**M2**实验即可
  ```bash
git checkout -b M2 origin/M2
```
